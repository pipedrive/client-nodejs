/**
 * PipedriveAPIV1Lib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

'use strict';

const _request = require('../Http/Client/RequestClient');
const _configuration = require('../configuration');
const _apiHelper = require('../APIHelper');
const _baseController = require('./BaseController');
const _oAuthManager = require('../OAuthManager');

class DealsController {
    /**
     * Marks multiple deals as deleted.
     *
     * @param {string} ids Comma-separated IDs that will be deleted
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteMultipleDealsInBulk(ids, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/deals';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            ids,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.deleteMultipleDealsInBulkAction(_queryUrl, _callback, ids);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.deleteMultipleDealsInBulkAction(_queryUrl, _callback, ids),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static deleteMultipleDealsInBulkAction(_queryUrl, _callback, ids) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper().mapObject(parsed, 'DealsResponse');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Returns all deals. For more information on how to get all deals, see <a href="https:
     * //pipedrive.readme.io/docs/getting-all-deals" target="_blank" rel="noopener
     * noreferrer">this tutorial</a>.
     *
     * @param  {array}  input    Array with all options for search
     * @param {int} input['userId'] (optional) If supplied, only deals matching the given user will
     * be returned.
     * @param {int} input['filterId'] (optional) ID of the filter to use
     * @param {int} input['stageId'] (optional) If supplied, only deals within the given stage will
     * be returned.
     * @param {Status2Enum} input['status'] (optional) Only fetch deals with specific status. If
     * omitted, all not deleted deals are fetched.
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {string} input['sort'] (optional) Field names and sorting mode separated by a comma
     * (field_name_1 ASC, field_name_2 DESC). Only first-level field
     * keys are supported (no nested keys).
     * @param {NumberBooleanEnum} input['ownedByYou'] (optional) When supplied, only deals owned by
     * you are returned. However filter_id takes
     * precedence over owned_by_you when both are
     * supplied.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getAllDeals(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/deals';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            user_id: input.userId,
            filter_id: input.filterId,
            stage_id: input.stageId,
            status: (input.status !== null) ? input.status : 'all_not_deleted',
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
            sort: input.sort,
            owned_by_you: (input.ownedByYou !== null) ? input.ownedByYou : null,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.getAllDealsAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.getAllDealsAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static getAllDealsAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper().mapObject(parsed, 'GetDeals');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Adds a new deal. Note that you can supply additional custom fields along with the request
     * that are not described here. These custom fields are different for each Pipedrive account
     * and can be recognized by long hashes as keys. To determine which custom fields exists,
     * fetch the dealFields and look for 'key' values. For more information on how to add a deal,
     * see <a href="https://pipedrive.readme.io/docs/creating-a-deal" target="_blank"
     * rel="noopener noreferrer">this tutorial</a>.
     *
     * @param  {array}  input    Array with all options for search
     * @param {string} input['contentType'] (optional) TODO: type description here
     * @param {object} input['body'] (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static addADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/deals';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.addADealAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.addADealAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static addADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': input.contentType,
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(input.body),
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper().mapObject(parsed, 'GetAddedDeal');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Searches all Deals by title, notes and/or custom fields. This endpoint is a wrapper of /v1/itemSearch with a narrower OAuth scope. Found Deals can be filtered by Person ID and Organization ID.
     *
     * @param  {array} input Array with all options for search.
     * @param {string} input['term'] Search term to look for.
     * @param {string} input['fields'] (optional) A comma-separated string array. The fields to perform the search from.
     * @param {boolean} input['exactMatch'] (optional) When enabled, only full exact matches against the given term are returned.
     * @param {int} input['personId'] (optional) Will filter Deals by the provided Person ID.
     * @param {int} input['organizationId'] (optional) Will filter Deals by the provided Organization ID.
     * @param {string} input['status'] (optional) Will filter Deals by the provided specific status.
     * @param {string} input['includeFields'] (optional) Supports including optional fields in the results which are not provided by default.
     * @param {int} input['start'] (optional) Pagination start.
     * @param {int} input['limit'] (optional) Items shown per page.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static searchDeals(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/deals/search';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            term: input.term,
            fields: input.fields,
            exact_match: input.exactMatch,
            person_id: input.personId,
            organization_id: input.organizationId,
            status: input.status,
            include_fields: input.includeFields,
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.searchDealsAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.searchDealsAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static searchDealsAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
            .then(() =>
                new Promise((_fulfill, _reject) => {
                    _request(_options, (_error, _response, _context) => {
                        let errorResponse;
                        if (_error) {
                            errorResponse = _baseController.validateResponse(_context);
                            _callback(errorResponse.error,
                                errorResponse.response,
                                errorResponse.context);
                            _reject(errorResponse.error);
                        } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                            let parsed = JSON.parse(_response.body);
                            parsed = _baseController.getObjectMapper().mapObject(parsed, 'SearchDeals');
                            _callback(null, parsed, _context);
                            _fulfill(parsed);
                        } else {
                            errorResponse = _baseController.validateResponse(_context);
                            _callback(errorResponse.error,
                                errorResponse.response,
                                errorResponse.context);
                            _reject(errorResponse.error);
                        }
                    });
                }))
            .catch((err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    /**
     * Returns summary of all the deals.
     *
     * @param  {array}  input    Array with all options for search
     * @param {Status3Enum} input['status'] (optional) Only fetch deals with specific status. open
     * = Open, won = Won, lost = Lost
     * @param {int} input['filterId'] (optional) user_id will not be considered. Only deals
     * matching the given filter will be returned.
     * @param {int} input['userId'] (optional) Only deals matching the given user will be returned.
     * user_id will not be considered if you use filter_id.
     * @param {int} input['stageId'] (optional) Only deals within the given stage will be returned.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getDealsSummary(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/deals/summary';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            status: (input.status !== null) ? input.status : null,
            filter_id: input.filterId,
            user_id: input.userId,
            stage_id: input.stageId,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.getDealsSummaryAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.getDealsSummaryAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static getDealsSummaryAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper().mapObject(parsed, 'GetDealsSummary');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Returns open and won deals, grouped by defined interval of time set in a date-type
     * dealField (field_key) — e.g. when month is the chosen interval, and 3 months are asked
     * starting from  January 1st, 2012, deals are returned grouped into 3 groups — January,
     * February and March — based on the value of the given field_key.
     *
     * @param  {array}  input    Array with all options for search
     * @param {date} input['startDate'] Date where first interval starts. Format: YYYY-MM-DD
     * @param {Interval2Enum} input['interval'] Type of interval.<dl class="fields-
     * list"><dt>day</dt><dd>Day</dd><dt>week</dt><dd>A
     * full week (7 days) starting from
     * start_date</dd><dt>month</dt><dd>A full month
     * (depending on the number of days in given month)
     * starting from start_date</dd><dt>quarter</dt><dd>A
     * full quarter (3 months) starting from
     * start_date</dd></dl>
     * @param {double} input['amount'] Number of given intervals, starting from start_date, to
     * fetch. E.g. 3 (months).
     * @param {string} input['fieldKey'] The name of the date field by which to get deals by.
     * @param {int} input['userId'] (optional) If supplied, only deals matching the given user will
     * be returned.
     * @param {int} input['pipelineId'] (optional) If supplied, only deals matching the given
     * pipeline will be returned.
     * @param {int} input['filterId'] (optional) If supplied, only deals matching the given filter
     * will be returned.
     * @param {NumberBooleanEnum} input['excludeDeals'] (optional) Whether to exclude deals list
     * (1) or not (0). Note that when deals are
     * excluded, the timeline summary (counts and
     * values) is still returned.
     * @param {string} input['totalsConvertCurrency'] (optional) 3-letter currency code of any of
     * the supported currencies. When supplied,
     * totals_converted is returned per each
     * interval which contains the currency-
     * converted total amounts in the given currency.
     * You may also set this parameter to
     * 'default_currency' in which case users
     * default currency is used.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getDealsTimeline(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/deals/timeline';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start_date: _apiHelper.stringifyDateTime(input.startDate, 'date'),
            interval: (input.interval !== null) ? input.interval : null,
            amount: input.amount,
            field_key: input.fieldKey,
            user_id: input.userId,
            pipeline_id: input.pipelineId,
            filter_id: input.filterId,
            exclude_deals: (input.excludeDeals !== null) ? input.excludeDeals : null,
            totals_convert_currency: input.totalsConvertCurrency,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.getDealsTimelineAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.getDealsTimelineAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static getDealsTimelineAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper().mapObject(parsed, 'GetDealsTimeline');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Marks a deal as deleted.
     *
     * @param {double} id ID of the deal
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteADeal(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.deleteADealAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.deleteADealAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static deleteADealAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper().mapObject(parsed, 'DeleteDeal');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Returns details of a specific deal. Note that this also returns some additional fields
     * which are not present when asking for all deals – such as deal age and stay in pipeline
     * stages. Also note that custom fields appear as long hashes in the resulting data. These
     * hashes can be mapped against the 'key' value of dealFields. For more information on how to
     * get all details of a deal, see <a href="https://pipedrive.readme.io/docs/getting-details-
     * of-a-deal" target="_blank" rel="noopener noreferrer">this tutorial</a>.
     *
     * @param {double} id ID of the deal
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getDetailsOfADeal(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.getDetailsOfADealAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.getDetailsOfADealAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static getDetailsOfADealAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Updates the properties of a deal. For more information on how to update a deal, see <a
     * href="https://pipedrive.readme.io/docs/updating-a-deal" target="_blank" rel="noopener
     * noreferrer">this tutorial</a>.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {string} input['title'] (optional) Deal title
     * @param {string} input['value'] (optional) Value of the deal. If omitted, value will be set
     * to 0.
     * @param {string} input['currency'] (optional) Currency of the deal. Accepts a 3-character
     * currency code. If omitted, currency will be set to the
     * default currency of the authorized user.
     * @param {int} input['userId'] (optional) ID of the user who will be marked as the owner of
     * this deal. If omitted, the authorized user ID will be used.
     * @param {int} input['personId'] (optional) ID of the person this deal will be associated
     * with
     * @param {int} input['orgId'] (optional) ID of the organization this deal will be associated
     * with
     * @param {int} input['stageId'] (optional) ID of the stage this deal will be placed in a
     * pipeline (note that you can't supply the ID of the pipeline as
     * this will be assigned automatically based on stage_id). If
     * omitted, the deal will be placed in the first stage of the
     * default pipeline.
     * @param {StatusEnum} input['status'] (optional) open = Open, won = Won, lost = Lost, deleted
     * = Deleted. If omitted, status will be set to open.
     * @param {double} input['probability'] (optional) Deal success probability percentage.
     * Used/shown only when deal_probability for the pipeline
     * of the deal is enabled.
     * @param {string} input['lostReason'] (optional) Optional message about why the deal was lost
     * (to be used when status=lost)
     * @param {VisibleToEnum} input['visibleTo'] (optional) Visibility of the deal. If omitted,
     * visibility will be set to the default visibility
     * setting of this item type for the authorized user.
     * <dl class="fields-list"><dt>1</dt><dd>Owner &amp;
     * followers (private)</dd><dt>3</dt><dd>Entire
     * company (shared)</dd></dl>
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.updateADealAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.updateADealAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static updateADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // prepare form data
        const _form = {
            title: input.title,
            value: input.value,
            currency: input.currency,
            user_id: input.userId,
            person_id: input.personId,
            org_id: input.orgId,
            stage_id: input.stageId,
            status: (input.status !== null) ? input.status : null,
            probability: input.probability,
            lost_reason: input.lostReason,
            visible_to: (input.visibleTo !== null) ? input.visibleTo : null,
        };

        input.title = undefined;
        input.value = undefined;
        input.currency = undefined;
        input.userId = undefined;
        input.personId = undefined;
        input.orgId = undefined;
        input.stageId = undefined;
        input.status = undefined;
        input.probability = undefined;
        input.lostReason = undefined;
        input.visibleTo = undefined;

        const _formWithDynamicFields = { ...input, ..._form};

        // remove null values
        _apiHelper.cleanObject(_formWithDynamicFields);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            form: _formWithDynamicFields,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists activities associated with a deal.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {NumberBooleanEnum} input['done'] (optional) Whether the activity is done or not. 0 =
     * Not done, 1 = Done. If omitted returns both Done
     * and Not done activities.
     * @param {string} input['exclude'] (optional) A comma-separated string of activity IDs to
     * exclude from result
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listActivitiesAssociatedWithADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/activities';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
            done: (input.done !== null) ? input.done : null,
            exclude: input.exclude,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.listActivitiesAssociatedWithADealAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.listActivitiesAssociatedWithADealAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listActivitiesAssociatedWithADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Duplicate a deal
     *
     * @param {double} id ID of the deal
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createDuplicateDeal(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/duplicate';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.createDuplicateDealAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.createDuplicateDealAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static createDuplicateDealAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper().mapObject(parsed, 'GetDuplicatedDeal');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists files associated with a deal.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {NumberBooleanEnum} input['includeDeletedFiles'] (optional) When enabled, the list of
     * files will also include deleted
     * files. Please note that trying to
     * download these files will not work.
     * @param {string} input['sort'] (optional) Field names and sorting mode separated by a comma
     * (field_name_1 ASC, field_name_2 DESC). Only first-level field
     * keys are supported (no nested keys). Supported fields: id,
     * user_id, deal_id, person_id, org_id, product_id, add_time,
     * update_time, file_name, file_type, file_size, comment.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listFilesAttachedToADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/files';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
            include_deleted_files: (input.includeDeletedFiles !== null) ? input.includeDeletedFiles : null,
            sort: input.sort,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.listFilesAttachedToADealAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.listFilesAttachedToADealAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listFilesAttachedToADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists updates about a deal.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listUpdatesAboutADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/flow';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.listUpdatesAboutADealAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.listUpdatesAboutADealAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listUpdatesAboutADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists the followers of a deal.
     *
     * @param {double} id ID of the deal
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listFollowersOfADeal(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/followers';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.listFollowersOfADealAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.listFollowersOfADealAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listFollowersOfADealAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Adds a follower to a deal.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {int} input['userId'] ID of the user
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static addAFollowerToADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/followers';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.addAFollowerToADealAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.addAFollowerToADealAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static addAFollowerToADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // prepare form data
        const _form = {
            user_id: input.userId,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper().mapObject(parsed, 'AddedDealFollower');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Deletes a follower from a deal.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {double} input['followerId'] ID of the follower
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteAFollowerFromADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/followers/{follower_id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
            follower_id: input.followerId,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.deleteAFollowerFromADealAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.deleteAFollowerFromADealAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static deleteAFollowerFromADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper().mapObject(parsed, 'DeleteDealFollower');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists mail messages associated with a deal.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listMailMessagesAssociatedWithADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/mailMessages';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.listMailMessagesAssociatedWithADealAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.listMailMessagesAssociatedWithADealAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listMailMessagesAssociatedWithADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Merges a deal with another deal. For more information on how to merge two deals, see <a
     * href="https://pipedrive.readme.io/docs/merging-two-deals" target="_blank" rel="noopener
     * noreferrer">this tutorial</a>.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {int} input['mergeWithId'] ID of the deal that the deal will be merged with
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateMergeTwoDeals(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/merge';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.updateMergeTwoDealsAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.updateMergeTwoDealsAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static updateMergeTwoDealsAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // prepare form data
        const _form = {
            merge_with_id: input.mergeWithId,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            form: _form,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper().mapObject(parsed, 'GetMergedDeal');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists participants associated with a deal.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listParticipantsOfADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/participants';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.listParticipantsOfADealAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.listParticipantsOfADealAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listParticipantsOfADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Adds a participant to a deal.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {int} input['personId'] ID of the person
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static addAParticipantToADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/participants';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.addAParticipantToADealAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.addAParticipantToADealAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static addAParticipantToADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // prepare form data
        const _form = {
            person_id: input.personId,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Deletes a participant from a deal.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {double} input['dealParticipantId'] ID of the deal participant
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteAParticipantFromADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/participants/{deal_participant_id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
            deal_participant_id: input.dealParticipantId,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.deleteAParticipantFromADealAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.deleteAParticipantFromADealAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static deleteAParticipantFromADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper().mapObject(parsed, 'DeleteDealParticipant');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * List users permitted to access a deal
     *
     * @param {double} id ID of the deal
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listPermittedUsers(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/permittedUsers';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.listPermittedUsersAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.listPermittedUsersAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listPermittedUsersAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists all persons associated with a deal, regardless of whether the person is the primary
     * contact of the deal, or added as a participant.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listAllPersonsAssociatedWithADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/persons';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.listAllPersonsAssociatedWithADealAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.listAllPersonsAssociatedWithADealAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listAllPersonsAssociatedWithADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists products attached to a deal.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {NumberBooleanEnum} input['includeProductData'] (optional) Whether to fetch product
     * data along with each attached product
     * (1) or not (0, default).
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listProductsAttachedToADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/products';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
            include_product_data: (input.includeProductData !== null) ? input.includeProductData : null,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.listProductsAttachedToADealAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.listProductsAttachedToADealAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listProductsAttachedToADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Adds a product to the deal.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {string} input['contentType'] (optional) TODO: type description here
     * @param {object} input['body'] (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static addAProductToTheDealEventuallyCreatingANewItemCalledADealProduct(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/products';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.addAProductToTheDealEventuallyCreatingANewItemCalledADealProductAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.addAProductToTheDealEventuallyCreatingANewItemCalledADealProductAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static addAProductToTheDealEventuallyCreatingANewItemCalledADealProductAction(
        _queryUrl,
        _callback,
        input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': input.contentType,
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(input.body),
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper()
                    .mapObject(parsed, 'GetAddProductAttachementDetails');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Updates product attachment details.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {double} input['productAttachmentId'] ID of the deal-product (the ID of the product
     * attached to the deal)
     * @param {double} input['itemPrice'] (optional) Price at which this product will be added to
     * the deal
     * @param {double} input['quantity'] (optional) Quantity – e.g. how many items of this product
     * will be added to the deal
     * @param {double} input['discountPercentage'] (optional) Discount %. If omitted, will be set
     * to 0
     * @param {double} input['duration'] (optional) Duration of the product (when product durations
     * are not enabled for the company or if omitted, defaults to
     * 1)
     * @param {int} input['productVariationId'] (optional) ID of the product variation to use. When
     * omitted, no variation will be used.
     * @param {string} input['comments'] (optional) Any textual comment associated with this
     * product-deal attachment. Visible and editable in the
     * application UI.
     * @param {NumberBooleanEnum} input['enabledFlag'] (optional) Whether the product is enabled on
     * the deal or not. This makes it possible to
     * add products to a deal with specific price
     * and discount criteria - but keep them
     * disabled, which refrains them from being
     * included in deal price calculation. When
     * omitted, the product will be marked as
     * enabled by default.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateProductAttachmentDetailsOfTheDealProductAProductAlreadyAttachedToADeal(input,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/products/{product_attachment_id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
            product_attachment_id: input.productAttachmentId,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.updateProductAttachmentDetailsOfTheDealProductAProductAlreadyAttachedToADealAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.updateProductAttachmentDetailsOfTheDealProductAProductAlreadyAttachedToADealAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static updateProductAttachmentDetailsOfTheDealProductAProductAlreadyAttachedToADealAction(
        _queryUrl,
        _callback,
        input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // prepare form data
        const _form = {
            item_price: input.itemPrice,
            quantity: input.quantity,
            discount_percentage: input.discountPercentage,
            duration: input.duration,
            product_variation_id: input.productVariationId,
            comments: input.comments,
            enabled_flag: (input.enabledFlag !== null) ? input.enabledFlag : null,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            form: _form,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper()
                    .mapObject(parsed, 'GetProductAttachementDetails');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Deletes a product attachment from a deal, using the product_attachment_id.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of the deal
     * @param {double} input['productAttachmentId'] Product attachment ID. This is returned as
     * product_attachment_id after attaching a product
     * to a deal or as id when listing the products
     * attached to a deal.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteAnAttachedProductFromADeal(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/deals/{id}/products/{product_attachment_id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
            product_attachment_id: input.productAttachmentId,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return DealsController.deleteAnAttachedProductFromADealAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => DealsController.deleteAnAttachedProductFromADealAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static deleteAnAttachedProductFromADealAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            accept: 'application/json',
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        let parsed = JSON.parse(_response.body);
                        parsed = _baseController.getObjectMapper().mapObject(parsed, 'DeleteDealProduct');
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
}
module.exports = DealsController;
