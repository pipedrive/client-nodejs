/**
 * PipedriveAPIV1Lib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

'use strict';

const _request = require('../Http/Client/RequestClient');
const _configuration = require('../configuration');
const _apiHelper = require('../APIHelper');
const _baseController = require('./BaseController');
const _fs = require('fs');
const _oAuthManager = require('../OAuthManager');

class PersonsController {
    /**
     * Marks multiple persons as deleted.
     *
     * @param {string} ids (optional) Comma-separated IDs that will be deleted
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteMultiplePersonsInBulk(ids, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/persons';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            ids,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.deleteMultiplePersonsInBulkAction(_queryUrl, _callback, ids);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.deleteMultiplePersonsInBulkAction(_queryUrl, _callback, ids),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static deleteMultiplePersonsInBulkAction(_queryUrl, _callback, ids) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Returns all persons
     *
     * @param  {array}  input    Array with all options for search
     * @param {int} input['userId'] (optional) If supplied, only persons owned by the given user
     * will be returned.
     * @param {int} input['filterId'] (optional) ID of the filter to use.
     * @param {string} input['firstChar'] (optional) If supplied, only persons whose name starts
     * with the specified letter will be returned (case
     * insensitive).
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {string} input['sort'] (optional) Field names and sorting mode separated by a comma
     * (field_name_1 ASC, field_name_2 DESC). Only first-level field
     * keys are supported (no nested keys).
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getAllPersons(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/persons';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            user_id: input.userId,
            filter_id: input.filterId,
            first_char: input.firstChar,
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
            sort: input.sort,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.getAllPersonsAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.getAllPersonsAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static getAllPersonsAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Adds a new person. Note that you can supply additional custom fields along with the
     * request that are not described here. These custom fields are different for each Pipedrive
     * account and can be recognized by long hashes as keys. To determine which custom fields
     * exists, fetch the personFields and look for 'key' values.
     *
     * @param  {array}  input    Array with all options for search
     * @param {object} input['body'] (optional) TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static addAPerson(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/persons';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.addAPersonAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.addAPersonAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static addAPersonAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': input.contentType,
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(input.body),
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Searches all persons by their name.
     *
     * @param  {array}  input    Array with all options for search
     * @param {string} input['term'] Search term to look for
     * @param {int} input['orgId'] (optional) ID of the organization person is associated with.
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {NumberBooleanEnum} input['searchByEmail'] (optional) When enabled, term will only be
     * matched against email addresses of people.
     * Default: false
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static findPersonsByName(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/persons/find';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            term: input.term,
            org_id: input.orgId,
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
            search_by_email: (input.searchByEmail !== null) ? input.searchByEmail : null,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.findPersonsByNameAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.findPersonsByNameAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static findPersonsByNameAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Marks a person as deleted.
     *
     * @param {double} id ID of a person
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteAPerson(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.deleteAPersonAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.deleteAPersonAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static deleteAPersonAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Returns details of a person. Note that this also returns some additional fields which are
     * not present when asking for all persons. Also note that custom fields appear as long
     * hashes in the resulting data. These hashes can be mapped against the 'key' value of
     * personFields.
     *
     * @param {double} id ID of a person
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getDetailsOfAPerson(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.getDetailsOfAPersonAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.getDetailsOfAPersonAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static getDetailsOfAPersonAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Updates the properties of a person. For more information on how to update a person, see <a
     * href="https://pipedrive.readme.io/docs/updating-a-person" target="_blank" rel="noopener
     * noreferrer">this tutorial</a>.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of a person
     * @param {string} input['name'] (optional) Person name
     * @param {int} input['ownerId'] (optional) ID of the user who will be marked as the owner of
     * this person. When omitted, the authorized user ID will be used.
     * @param {int} input['orgId'] (optional) ID of the organization this person will belong to.
     * @param {array} input['email'] (optional) Email addresses (one or more) associated with the
     * person, presented in the same manner as received by GET
     * request of a person.
     * @param {array} input['phone'] (optional) Phone numbers (one or more) associated with the
     * person, presented in the same manner as received by GET
     * request of a person.
     * @param {VisibleToEnum} input['visibleTo'] (optional) Visibility of the person. If omitted,
     * visibility will be set to the default visibility
     * setting of this item type for the authorized user.
     * <dl class="fields-list"><dt>1</dt><dd>Owner &amp;
     * followers (private)</dd><dt>3</dt><dd>Entire
     * company (shared)</dd></dl>
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateAPerson(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.updateAPersonAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.updateAPersonAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static updateAPersonAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // prepare form data
        const _form = {
            name: input.name,
            owner_id: input.ownerId,
            org_id: input.orgId,
            email: input.email,
            phone: input.phone,
            visible_to: (input.visibleTo !== null) ? input.visibleTo : null,
        };

        input.ownerId = undefined;
        input.orgId = undefined;
        input.visibleTo = undefined;

        const _formWithDynamicFields = {...input, ..._form};

        // remove null values
        _apiHelper.cleanObject(_formWithDynamicFields);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            form: _formWithDynamicFields,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists activities associated with a person.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of a person
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {NumberBooleanEnum} input['done'] (optional) Whether the activity is done or not. 0 =
     * Not done, 1 = Done. If omitted returns both Done
     * and Not done activities.
     * @param {string} input['exclude'] (optional) A comma-separated string of activity IDs to
     * exclude from result
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listActivitiesAssociatedWithAPerson(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}/activities';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
            done: (input.done !== null) ? input.done : null,
            exclude: input.exclude,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.listActivitiesAssociatedWithAPersonAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.listActivitiesAssociatedWithAPersonAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listActivitiesAssociatedWithAPersonAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists deals associated with a person.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of a person
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {Status2Enum} input['status'] (optional) Only fetch deals with specific status. If
     * omitted, all not deleted deals are fetched.
     * @param {string} input['sort'] (optional) Field names and sorting mode separated by a comma
     * (field_name_1 ASC, field_name_2 DESC). Only first-level field
     * keys are supported (no nested keys).
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listDealsAssociatedWithAPerson(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}/deals';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
            status: (input.status !== null) ? input.status : 'all_not_deleted',
            sort: input.sort,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.listDealsAssociatedWithAPersonAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.listDealsAssociatedWithAPersonAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listDealsAssociatedWithAPersonAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists files associated with a person.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of a person
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {NumberBooleanEnum} input['includeDeletedFiles'] (optional) When enabled, the list of
     * files will also include deleted
     * files. Please note that trying to
     * download these files will not work.
     * @param {string} input['sort'] (optional) Field names and sorting mode separated by a comma
     * (field_name_1 ASC, field_name_2 DESC). Only first-level field
     * keys are supported (no nested keys). Supported fields: id,
     * user_id, deal_id, person_id, org_id, product_id, add_time,
     * update_time, file_name, file_type, file_size, comment.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listFilesAttachedToAPerson(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}/files';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
            include_deleted_files: (input.includeDeletedFiles !== null) ? input.includeDeletedFiles : null,
            sort: input.sort,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.listFilesAttachedToAPersonAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.listFilesAttachedToAPersonAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listFilesAttachedToAPersonAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists updates about a person.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of a person
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     * @param {NumberBooleanEnum} input['allChanges'] (optional) Whether to show all changes or aggregated ones
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listUpdatesAboutAPerson(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}/flow';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        let parameters = {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
        };

        if (input.allChanges) {
            parameters = { ...parameters, all_changes: input.allChanges };
        }

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, parameters);

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.listUpdatesAboutAPersonAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.listUpdatesAboutAPersonAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listUpdatesAboutAPersonAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists the followers of a person.
     *
     * @param {double} id ID of a person
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listFollowersOfAPerson(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}/followers';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.listFollowersOfAPersonAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.listFollowersOfAPersonAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listFollowersOfAPersonAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Adds a follower to a person.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of a person
     * @param {int} input['userId'] ID of the user
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static addAFollowerToAPerson(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}/followers';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.addAFollowerToAPersonAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.addAFollowerToAPersonAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static addAFollowerToAPersonAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // prepare form data
        const _form = {
            user_id: input.userId,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Delete a follower from a person
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of a person
     * @param {double} input['followerId'] ID of the follower
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deletesAFollowerFromAPerson(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}/followers/{follower_id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
            follower_id: input.followerId,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.deletesAFollowerFromAPersonAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.deletesAFollowerFromAPersonAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static deletesAFollowerFromAPersonAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists mail messages associated with a person.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of a person
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listMailMessagesAssociatedWithAPerson(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}/mailMessages';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.listMailMessagesAssociatedWithAPersonAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.listMailMessagesAssociatedWithAPersonAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listMailMessagesAssociatedWithAPersonAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Merges a person with another person. For more information on how to merge two persons, see
     * <a href="https://pipedrive.readme.io/docs/merging-two-persons" target="_blank"
     * rel="noopener noreferrer">this tutorial</a>.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of a person
     * @param {int} input['mergeWithId'] ID of the person that the person will be merged with
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateMergeTwoPersons(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}/merge';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.updateMergeTwoPersonsAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.updateMergeTwoPersonsAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static updateMergeTwoPersonsAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // prepare form data
        const _form = {
            merge_with_id: input.mergeWithId,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            form: _form,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * List users permitted to access a person
     *
     * @param {double} id ID of a person
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listPermittedUsers(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}/permittedUsers';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.listPermittedUsersAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.listPermittedUsersAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listPermittedUsersAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Delete person picture
     *
     * @param {double} id ID of a person
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deletePersonPicture(id, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}/picture';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.deletePersonPictureAction(_queryUrl, _callback);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.deletePersonPictureAction(_queryUrl, _callback),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static deletePersonPictureAction(_queryUrl, _callback) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Add a picture to a person. If a picture is already set, the old picture will be replaced.
     * Added image (or the cropping parameters supplied with the request) should have an equal
     * width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All
     * added images will be resized to 128 and 512 pixel wide squares.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of a person
     * @param {string} input['file'] One image supplied in the multipart/form-data encoding.
     * @param {double} input['cropX'] (optional) X coordinate to where start cropping form (in
     * pixels)
     * @param {double} input['cropY'] (optional) Y coordinate to where start cropping form (in
     * pixels)
     * @param {double} input['cropWidth'] (optional) Width of cropping area (in pixels)
     * @param {double} input['cropHeight'] (optional) Height of cropping area (in pixels)
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static addPersonPicture(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}/picture';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.addPersonPictureAction(_queryUrl, _callback, input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.addPersonPictureAction(_queryUrl, _callback, input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static addPersonPictureAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // prepare form data
        const _formData = {
            file: _fs.createReadStream(input.file),
            crop_x: input.crop_x,
            crop_y: input.crop_y,
            crop_width: input.crop_width,
            crop_height: input.crop_height,
        };

        // remove null values
        _apiHelper.cleanObject(_formData);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            formData: _formData,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
    /**
     * Lists products associated with a person.
     *
     * @param  {array}  input    Array with all options for search
     * @param {double} input['id'] ID of a person
     * @param {double} input['start'] (optional) Pagination start
     * @param {double} input['limit'] (optional) Items shown per page
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static listProductsAssociatedWithAPerson(input, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        let _pathUrl = '/persons/{id}/products';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id: input.id,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            start: (input.start !== null) ? input.start : 0,
            limit: input.limit,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        if (_oAuthManager.isTokenSet()) {
            return PersonsController.listProductsAssociatedWithAPersonAction(
                _queryUrl,
                _callback,
                input);
        }
        return _oAuthManager.authorize().then(
            () => PersonsController.listProductsAssociatedWithAPersonAction(
                _queryUrl,
                _callback,
                input),
            (err) => {
                _callback(err, null, null);
                return Promise.reject(err);
            });
    }
    static listProductsAssociatedWithAPersonAction(_queryUrl, _callback, input) {
        const oauthTokenPromise = _oAuthManager.checkTokenExpiry();
        // prepare headers
        const _headers = {
            'user-agent': _configuration.getUserAgent(),
        };

        oauthTokenPromise.then(() => {
            _headers.Authorization = `Bearer ${_configuration.oAuthToken.accessToken}`;
        });
        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return oauthTokenPromise
        .then(() =>
            new Promise((_fulfill, _reject) => {
                _request(_options, (_error, _response, _context) => {
                    let errorResponse;
                    if (_error) {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                            errorResponse.response,
                            errorResponse.context);
                        _reject(errorResponse.error);
                    } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                        const parsed = JSON.parse(_response.body);
                        _callback(null, parsed, _context);
                        _fulfill(parsed);
                    } else {
                        errorResponse = _baseController.validateResponse(_context);
                        _callback(errorResponse.error,
                        errorResponse.response,
                        errorResponse.context);
                        _reject(errorResponse.error);
                    }
                });
            }))
        .catch((err) => {
            _callback(err, null, null);
            return Promise.reject(err);
        });
    }
}
module.exports = PersonsController;
