/* tslint:disable */
/* eslint-disable */
/**
 * Pipedrive API v2
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AddActivityRequest } from '../models';
// @ts-ignore
import { AddAdditionalDiscountRequestBody } from '../models';
// @ts-ignore
import { AddAdditionalDiscountResponse } from '../models';
// @ts-ignore
import { AddDealProductRequest } from '../models';
// @ts-ignore
import { AddDealProductResponse } from '../models';
// @ts-ignore
import { AddDealRequest } from '../models';
// @ts-ignore
import { AddOrganizationRequest } from '../models';
// @ts-ignore
import { AddPersonRequest } from '../models';
// @ts-ignore
import { DeleteActivityResponse } from '../models';
// @ts-ignore
import { DeleteAdditionalDiscountResponse } from '../models';
// @ts-ignore
import { DeleteDealProductResponse } from '../models';
// @ts-ignore
import { DeleteDealResponse } from '../models';
// @ts-ignore
import { DeleteOrganizationResponse } from '../models';
// @ts-ignore
import { DeletePersonResponse } from '../models';
// @ts-ignore
import { GetActivitiesResponse } from '../models';
// @ts-ignore
import { GetAdditionalDiscountsResponse } from '../models';
// @ts-ignore
import { GetDealSearchResponse } from '../models';
// @ts-ignore
import { GetDealsProductsResponse } from '../models';
// @ts-ignore
import { GetDealsResponse } from '../models';
// @ts-ignore
import { GetItemSearchFieldResponse } from '../models';
// @ts-ignore
import { GetItemSearchResponse } from '../models';
// @ts-ignore
import { GetLeadSearchResponse } from '../models';
// @ts-ignore
import { GetOrganizationSearchResponse } from '../models';
// @ts-ignore
import { GetOrganizationsResponse } from '../models';
// @ts-ignore
import { GetPersonSearchResponse } from '../models';
// @ts-ignore
import { GetPersonsResponse } from '../models';
// @ts-ignore
import { UpdateAdditionalDiscountRequestBody } from '../models';
// @ts-ignore
import { UpdateAdditionalDiscountResponse } from '../models';
// @ts-ignore
import { UpdateDealProductRequest } from '../models';
// @ts-ignore
import { UpdateDealRequest } from '../models';
// @ts-ignore
import { UpdateOrganizationRequest } from '../models';
// @ts-ignore
import { UpdatePersonRequest } from '../models';
// @ts-ignore
import { UpsertActivityResponse } from '../models';
// @ts-ignore
import { UpsertDealResponse } from '../models';
// @ts-ignore
import { UpsertOrganizationResponse } from '../models';
// @ts-ignore
import { UpsertPersonResponse } from '../models';
/**
 * BetaApi - axios parameter creator
 * @export
 */
export const BetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new activity.
         * @summary Add a new activity
         * @param {AddActivityRequest} [AddActivityRequest] 

         * @throws {RequiredError}
         */
        addActivity: async (AddActivityRequest?: AddActivityRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddActivityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new deal.
         * @summary Add a new deal
         * @param {AddDealRequest} [AddDealRequest] 

         * @throws {RequiredError}
         */
        addDeal: async (AddDealRequest?: AddDealRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/deals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddDealRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a product to a deal, creating a new item called a deal-product.
         * @summary Add a product to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealProductRequest} [AddDealProductRequest] 

         * @throws {RequiredError}
         */
        addDealProduct: async (id: number, AddDealProductRequest?: AddDealProductRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addDealProduct', 'id', id)
            const localVarPath = `/deals/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:full", "deals:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddDealProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new organization.
         * @summary Add a new organization
         * @param {AddOrganizationRequest} [AddOrganizationRequest] 

         * @throws {RequiredError}
         */
        addOrganization: async (AddOrganizationRequest?: AddOrganizationRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddOrganizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new person.
         * @summary Add a new person
         * @param {AddPersonRequest} [AddPersonRequest] 

         * @throws {RequiredError}
         */
        addPerson: async (AddPersonRequest?: AddPersonRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddPersonRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
         * @summary Delete an activity
         * @param {number} id The ID of the activity

         * @throws {RequiredError}
         */
        deleteActivity: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteActivity', 'id', id)
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a discount from a deal, changing the deal value if the deal has one-time products attached.
         * @summary Delete a discount from a deal
         * @param {number} id The ID of the deal
         * @param {number} discount_id The ID of the discount

         * @throws {RequiredError}
         */
        deleteAdditionalDiscount: async (id: number, discount_id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAdditionalDiscount', 'id', id)
            // verify required parameter 'discount_id' is not null or undefined
            assertParamExists('deleteAdditionalDiscount', 'discount_id', discount_id)
            const localVarPath = `/deals/{id}/discounts/{discount_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"discount_id"}}`, encodeURIComponent(String(discount_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
         * @summary Delete a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        deleteDeal: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDeal', 'id', id)
            const localVarPath = `/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a product attachment from a deal, using the `product_attachment_id`.
         * @summary Delete an attached product from a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The product attachment ID

         * @throws {RequiredError}
         */
        deleteDealProduct: async (id: number, product_attachment_id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDealProduct', 'id', id)
            // verify required parameter 'product_attachment_id' is not null or undefined
            assertParamExists('deleteDealProduct', 'product_attachment_id', product_attachment_id)
            const localVarPath = `/deals/{id}/products/{product_attachment_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"product_attachment_id"}}`, encodeURIComponent(String(product_attachment_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "products:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a organization as deleted. After 30 days, the organization will be permanently deleted.
         * @summary Delete a organization
         * @param {number} id The ID of the organization

         * @throws {RequiredError}
         */
        deleteOrganization: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganization', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a person as deleted. After 30 days, the person will be permanently deleted.
         * @summary Delete a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        deletePerson: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePerson', 'id', id)
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all activities.
         * @summary Get all activities
         * @param {number} [filter_id] If supplied, only activities matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only activities owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {number} [deal_id] If supplied, only activities linked to the specified deal are returned. If filter_id is provided, this is ignored.
         * @param {string} [lead_id] If supplied, only activities linked to the specified lead are returned. If filter_id is provided, this is ignored.
         * @param {number} [person_id] If supplied, only activities whose primary participant is the given person are returned. If filter_id is provided, this is ignored.
         * @param {number} [org_id] If supplied, only activities linked to the specified organization are returned. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only activities with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only activities with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'attendees'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        getActivities: async (filter_id?: number, ids?: string, owner_id?: number, deal_id?: number, lead_id?: string, person_id?: number, org_id?: number, updated_since?: string, updated_until?: string, sort_by?: 'id' | 'update_time' | 'add_time', sort_direction?: 'asc' | 'desc', include_fields?: 'attendees', limit?: number, cursor?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:read", "activities:full"], configuration)

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (owner_id !== undefined) {
                localVarQueryParameter['owner_id'] = owner_id;
            }

            if (deal_id !== undefined) {
                localVarQueryParameter['deal_id'] = deal_id;
            }

            if (lead_id !== undefined) {
                localVarQueryParameter['lead_id'] = lead_id;
            }

            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }

            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }

            if (updated_since !== undefined) {
                localVarQueryParameter['updated_since'] = updated_since;
            }

            if (updated_until !== undefined) {
                localVarQueryParameter['updated_until'] = updated_until;
            }

            if (sort_by !== undefined) {
                localVarQueryParameter['sort_by'] = sort_by;
            }

            if (sort_direction !== undefined) {
                localVarQueryParameter['sort_direction'] = sort_direction;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific activity.
         * @summary Get details of an activity
         * @param {number} id The ID of the activity
         * @param {'attendees'} [include_fields] Optional comma separated string array of additional fields to include

         * @throws {RequiredError}
         */
        getActivity: async (id: number, include_fields?: 'attendees', ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getActivity', 'id', id)
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:read", "activities:full"], configuration)

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists discounts attached to a deal.
         * @summary List discounts added to a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        getAdditionalDiscounts: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAdditionalDiscounts', 'id', id)
            const localVarPath = `/deals/{id}/discounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific deal.
         * @summary Get details of a deal
         * @param {number} id The ID of the deal
         * @param {'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.

         * @throws {RequiredError}
         */
        getDeal: async (id: number, include_fields?: 'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time', custom_fields?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeal', 'id', id)
            const localVarPath = `/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (custom_fields !== undefined) {
                localVarQueryParameter['custom_fields'] = custom_fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists products attached to a deal.
         * @summary List products attached to a deal
         * @param {number} id The ID of the deal
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {'id' | 'add_time' | 'update_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.

         * @throws {RequiredError}
         */
        getDealProducts: async (id: number, cursor?: string, limit?: number, sort_by?: 'id' | 'add_time' | 'update_time', sort_direction?: 'asc' | 'desc', ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDealProducts', 'id', id)
            const localVarPath = `/deals/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:read", "products:full", "deals:read", "deals:full"], configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort_by !== undefined) {
                localVarQueryParameter['sort_by'] = sort_by;
            }

            if (sort_direction !== undefined) {
                localVarQueryParameter['sort_direction'] = sort_direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all deals.
         * @summary Get all deals
         * @param {number} [filter_id] If supplied, only deals matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only deals owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {number} [person_id] If supplied, only deals linked to the specified person are returned. If filter_id is provided, this is ignored.
         * @param {number} [org_id] If supplied, only deals linked to the specified organization are returned. If filter_id is provided, this is ignored.
         * @param {number} [pipeline_id] If supplied, only deals in the specified pipeline are returned. If filter_id is provided, this is ignored.
         * @param {number} [stage_id] If supplied, only deals in the specified stage are returned. If filter_id is provided, this is ignored.
         * @param {'open' | 'won' | 'lost' | 'deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. Multiple statuses can be included as a comma separated array. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only deals with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only deals with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        getDeals: async (filter_id?: number, ids?: string, owner_id?: number, person_id?: number, org_id?: number, pipeline_id?: number, stage_id?: number, status?: 'open' | 'won' | 'lost' | 'deleted', updated_since?: string, updated_until?: string, sort_by?: 'id' | 'update_time' | 'add_time', sort_direction?: 'asc' | 'desc', include_fields?: 'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time', custom_fields?: string, limit?: number, cursor?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/deals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (owner_id !== undefined) {
                localVarQueryParameter['owner_id'] = owner_id;
            }

            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }

            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }

            if (pipeline_id !== undefined) {
                localVarQueryParameter['pipeline_id'] = pipeline_id;
            }

            if (stage_id !== undefined) {
                localVarQueryParameter['stage_id'] = stage_id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (updated_since !== undefined) {
                localVarQueryParameter['updated_since'] = updated_since;
            }

            if (updated_until !== undefined) {
                localVarQueryParameter['updated_until'] = updated_until;
            }

            if (sort_by !== undefined) {
                localVarQueryParameter['sort_by'] = sort_by;
            }

            if (sort_direction !== undefined) {
                localVarQueryParameter['sort_direction'] = sort_direction;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (custom_fields !== undefined) {
                localVarQueryParameter['custom_fields'] = custom_fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about products attached to deals
         * @summary Get deal products of several deals
         * @param {Array<number>} deal_ids An array of integers with the IDs of the deals for which the attached products will be returned. A maximum of 100 deal IDs can be provided.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {'id' | 'deal_id' | 'add_time' | 'update_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;deal_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.

         * @throws {RequiredError}
         */
        getDealsProducts: async (deal_ids: Array<number>, cursor?: string, limit?: number, sort_by?: 'id' | 'deal_id' | 'add_time' | 'update_time', sort_direction?: 'asc' | 'desc', ): Promise<RequestArgs> => {
            // verify required parameter 'deal_ids' is not null or undefined
            assertParamExists('getDealsProducts', 'deal_ids', deal_ids)
            const localVarPath = `/deals/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:read", "products:full", "deals:read", "deals:full"], configuration)

            if (deal_ids) {
                localVarQueryParameter['deal_ids'] = deal_ids;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort_by !== undefined) {
                localVarQueryParameter['sort_by'] = sort_by;
            }

            if (sort_direction !== undefined) {
                localVarQueryParameter['sort_direction'] = sort_direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific organization.
         * @summary Get details of a organization
         * @param {number} id The ID of the organization
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.

         * @throws {RequiredError}
         */
        getOrganization: async (id: number, include_fields?: 'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count', custom_fields?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganization', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (custom_fields !== undefined) {
                localVarQueryParameter['custom_fields'] = custom_fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all organizations.
         * @summary Get all organizations
         * @param {number} [filter_id] If supplied, only organizations matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only organization owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only organizations with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only organizations with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        getOrganizations: async (filter_id?: number, ids?: string, owner_id?: number, updated_since?: string, updated_until?: string, sort_by?: 'id' | 'update_time' | 'add_time', sort_direction?: 'asc' | 'desc', include_fields?: 'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count', custom_fields?: string, limit?: number, cursor?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (owner_id !== undefined) {
                localVarQueryParameter['owner_id'] = owner_id;
            }

            if (updated_since !== undefined) {
                localVarQueryParameter['updated_since'] = updated_since;
            }

            if (updated_until !== undefined) {
                localVarQueryParameter['updated_until'] = updated_until;
            }

            if (sort_by !== undefined) {
                localVarQueryParameter['sort_by'] = sort_by;
            }

            if (sort_direction !== undefined) {
                localVarQueryParameter['sort_direction'] = sort_direction;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (custom_fields !== undefined) {
                localVarQueryParameter['custom_fields'] = custom_fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific person. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
         * @summary Get details of a person
         * @param {number} id The ID of the person
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status'} [include_fields] Optional comma separated string array of additional fields to include. &#x60;marketing_status&#x60; and &#x60;doi_status&#x60; can only be included if the company has marketing app enabled.
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.

         * @throws {RequiredError}
         */
        getPerson: async (id: number, include_fields?: 'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status', custom_fields?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPerson', 'id', id)
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (custom_fields !== undefined) {
                localVarQueryParameter['custom_fields'] = custom_fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all persons. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
         * @summary Get all persons
         * @param {number} [filter_id] If supplied, only persons matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only persons owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {number} [org_id] If supplied, only persons linked to the specified organization are returned. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only persons with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only persons with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status'} [include_fields] Optional comma separated string array of additional fields to include. &#x60;marketing_status&#x60; and &#x60;doi_status&#x60; can only be included if the company has marketing app enabled.
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        getPersons: async (filter_id?: number, ids?: string, owner_id?: number, org_id?: number, updated_since?: string, updated_until?: string, sort_by?: 'id' | 'update_time' | 'add_time', sort_direction?: 'asc' | 'desc', include_fields?: 'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status', custom_fields?: string, limit?: number, cursor?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (owner_id !== undefined) {
                localVarQueryParameter['owner_id'] = owner_id;
            }

            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }

            if (updated_since !== undefined) {
                localVarQueryParameter['updated_since'] = updated_since;
            }

            if (updated_until !== undefined) {
                localVarQueryParameter['updated_until'] = updated_until;
            }

            if (sort_by !== undefined) {
                localVarQueryParameter['sort_by'] = sort_by;
            }

            if (sort_direction !== undefined) {
                localVarQueryParameter['sort_direction'] = sort_direction;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (custom_fields !== undefined) {
                localVarQueryParameter['custom_fields'] = custom_fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a discount to a deal changing, the deal value if the deal has one-time products attached.
         * @summary Add a discount to a deal
         * @param {number} id The ID of the deal
         * @param {AddAdditionalDiscountRequestBody} [AddAdditionalDiscountRequestBody] 

         * @throws {RequiredError}
         */
        postAdditionalDiscount: async (id: number, AddAdditionalDiscountRequestBody?: AddAdditionalDiscountRequestBody, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postAdditionalDiscount', 'id', id)
            const localVarPath = `/deals/{id}/discounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddAdditionalDiscountRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
         * @summary Search deals
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'notes' | 'title'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
         * @param {number} [organization_id] Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
         * @param {'open' | 'won' | 'lost'} [status] Will filter deals by the provided specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost. The upper limit of found deals associated with the status is 2000.
         * @param {'deal.cc_email'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchDeals: async (term: string, fields?: 'custom_fields' | 'notes' | 'title', exact_match?: boolean, person_id?: number, organization_id?: number, status?: 'open' | 'won' | 'lost', include_fields?: 'deal.cc_email', limit?: number, cursor?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchDeals', 'term', term)
            const localVarPath = `/deals/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }

            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a search from your choice of item types and fields.
         * @summary Perform a search from multiple item types
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project'} [item_types] A comma-separated string array. The type of items to perform the search from. Defaults to all.
         * @param {'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Project&lt;/td&gt;&lt;td&gt; &#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;, &#x60;description&#x60; &lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.&lt;br/&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
         * @param {boolean} [search_for_related_items] When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {'deal.cc_email' | 'person.picture' | 'product.price'} [include_fields] A comma-separated string array. Supports including optional fields in the results which are not provided by default.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchItem: async (term: string, item_types?: 'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project', fields?: 'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description', search_for_related_items?: boolean, exact_match?: boolean, include_fields?: 'deal.cc_email' | 'person.picture' | 'product.price', limit?: number, cursor?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchItem', 'term', term)
            const localVarPath = `/itemSearch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (item_types !== undefined) {
                localVarQueryParameter['item_types'] = item_types;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (search_for_related_items !== undefined) {
                localVarQueryParameter['search_for_related_items'] = search_for_related_items;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
         * @summary Perform a search using a specific field from an item type
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if &#x60;match&#x60; is &#x60;exact&#x60;). Please note that the search term has to be URL encoded.
         * @param {'deal' | 'lead' | 'person' | 'organization' | 'product' | 'project'} entity_type The type of the field to perform the search from
         * @param {string} field The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields\&#39; API GET methods (dealFields, personFields, etc.). Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {'exact' | 'beginning' | 'middle'} [match] The type of match used against the term. The search &lt;b&gt;is&lt;/b&gt; case sensitive.&lt;br/&gt;&lt;br/&gt; E.g. in case of searching for a value &#x60;monkey&#x60;, &lt;ul&gt; &lt;li&gt;with &#x60;exact&#x60; match, you will only find it if term is &#x60;monkey&#x60;&lt;/li&gt; &lt;li&gt;with &#x60;beginning&#x60; match, you will only find it if the term matches the beginning or the whole string, e.g. &#x60;monk&#x60; and &#x60;monkey&#x60;&lt;/li&gt; &lt;li&gt;with &#x60;middle&#x60; match, you will find the it if the term matches any substring of the value, e.g. &#x60;onk&#x60; and &#x60;ke&#x60;&lt;/li&gt; &lt;/ul&gt;.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchItemByField: async (term: string, entity_type: 'deal' | 'lead' | 'person' | 'organization' | 'product' | 'project', field: string, match?: 'exact' | 'beginning' | 'middle', limit?: number, cursor?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchItemByField', 'term', term)
            // verify required parameter 'entity_type' is not null or undefined
            assertParamExists('searchItemByField', 'entity_type', entity_type)
            // verify required parameter 'field' is not null or undefined
            assertParamExists('searchItemByField', 'field', field)
            const localVarPath = `/itemSearch/field`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (entity_type !== undefined) {
                localVarQueryParameter['entity_type'] = entity_type;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            if (field !== undefined) {
                localVarQueryParameter['field'] = field;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
         * @summary Search leads
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'notes' | 'title'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
         * @param {number} [organization_id] Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
         * @param {'lead.was_seen'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchLeads: async (term: string, fields?: 'custom_fields' | 'notes' | 'title', exact_match?: boolean, person_id?: number, organization_id?: number, include_fields?: 'lead.was_seen', limit?: number, cursor?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchLeads', 'term', term)
            const localVarPath = `/leads/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["leads:read", "leads:full", "search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }

            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search organizations
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'address' | 'custom_fields' | 'notes' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchOrganization: async (term: string, fields?: 'address' | 'custom_fields' | 'notes' | 'name', exact_match?: boolean, limit?: number, cursor?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchOrganization', 'term', term)
            const localVarPath = `/organizations/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full", "search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'email' | 'notes' | 'phone' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [organization_id] Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
         * @param {'person.picture'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchPersons: async (term: string, fields?: 'custom_fields' | 'email' | 'notes' | 'phone' | 'name', exact_match?: boolean, organization_id?: number, include_fields?: 'person.picture', limit?: number, cursor?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchPersons', 'term', term)
            const localVarPath = `/persons/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full", "search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of an activity.
         * @summary Update an activity
         * @param {number} id The ID of the activity
         * @param {AddActivityRequest} [AddActivityRequest] 

         * @throws {RequiredError}
         */
        updateActivity: async (id: number, AddActivityRequest?: AddActivityRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateActivity', 'id', id)
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddActivityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a discount added to a deal, changing the deal value if the deal has one-time products attached.
         * @summary Update a discount added to a deal
         * @param {number} id The ID of the deal
         * @param {number} discount_id The ID of the discount
         * @param {UpdateAdditionalDiscountRequestBody} [UpdateAdditionalDiscountRequestBody] 

         * @throws {RequiredError}
         */
        updateAdditionalDiscount: async (id: number, discount_id: number, UpdateAdditionalDiscountRequestBody?: UpdateAdditionalDiscountRequestBody, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAdditionalDiscount', 'id', id)
            // verify required parameter 'discount_id' is not null or undefined
            assertParamExists('updateAdditionalDiscount', 'discount_id', discount_id)
            const localVarPath = `/deals/{id}/discounts/{discount_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"discount_id"}}`, encodeURIComponent(String(discount_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateAdditionalDiscountRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a deal.
         * @summary Update a deal
         * @param {number} id The ID of the deal
         * @param {UpdateDealRequest} [UpdateDealRequest] 

         * @throws {RequiredError}
         */
        updateDeal: async (id: number, UpdateDealRequest?: UpdateDealRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDeal', 'id', id)
            const localVarPath = `/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateDealRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the details of the product that has been attached to a deal.
         * @summary Update the product attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The ID of the deal-product (the ID of the product attached to the deal)
         * @param {UpdateDealProductRequest} [UpdateDealProductRequest] 

         * @throws {RequiredError}
         */
        updateDealProduct: async (id: number, product_attachment_id: number, UpdateDealProductRequest?: UpdateDealProductRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDealProduct', 'id', id)
            // verify required parameter 'product_attachment_id' is not null or undefined
            assertParamExists('updateDealProduct', 'product_attachment_id', product_attachment_id)
            const localVarPath = `/deals/{id}/products/{product_attachment_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"product_attachment_id"}}`, encodeURIComponent(String(product_attachment_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:full", "deals:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateDealProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a organization.
         * @summary Update a organization
         * @param {number} id The ID of the organization
         * @param {UpdateOrganizationRequest} [UpdateOrganizationRequest] 

         * @throws {RequiredError}
         */
        updateOrganization: async (id: number, UpdateOrganizationRequest?: UpdateOrganizationRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOrganization', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateOrganizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a person.
         * @summary Update a person
         * @param {number} id The ID of the person
         * @param {UpdatePersonRequest} [UpdatePersonRequest] 

         * @throws {RequiredError}
         */
        updatePerson: async (id: number, UpdatePersonRequest?: UpdatePersonRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePerson', 'id', id)
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdatePersonRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};


/**
 * BetaApi - functional programming interface
 * @export
 */
export const BetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new activity.
         * @summary Add a new activity
         * @param {AddActivityRequest} [AddActivityRequest] 

         * @throws {RequiredError}
         */
        async addActivity(AddActivityRequest?: AddActivityRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpsertActivityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addActivity(AddActivityRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new deal.
         * @summary Add a new deal
         * @param {AddDealRequest} [AddDealRequest] 

         * @throws {RequiredError}
         */
        async addDeal(AddDealRequest?: AddDealRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpsertDealResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDeal(AddDealRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a product to a deal, creating a new item called a deal-product.
         * @summary Add a product to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealProductRequest} [AddDealProductRequest] 

         * @throws {RequiredError}
         */
        async addDealProduct(id: number, AddDealProductRequest?: AddDealProductRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddDealProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDealProduct(id, AddDealProductRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new organization.
         * @summary Add a new organization
         * @param {AddOrganizationRequest} [AddOrganizationRequest] 

         * @throws {RequiredError}
         */
        async addOrganization(AddOrganizationRequest?: AddOrganizationRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpsertOrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganization(AddOrganizationRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new person.
         * @summary Add a new person
         * @param {AddPersonRequest} [AddPersonRequest] 

         * @throws {RequiredError}
         */
        async addPerson(AddPersonRequest?: AddPersonRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpsertPersonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPerson(AddPersonRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
         * @summary Delete an activity
         * @param {number} id The ID of the activity

         * @throws {RequiredError}
         */
        async deleteActivity(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteActivityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteActivity(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a discount from a deal, changing the deal value if the deal has one-time products attached.
         * @summary Delete a discount from a deal
         * @param {number} id The ID of the deal
         * @param {number} discount_id The ID of the discount

         * @throws {RequiredError}
         */
        async deleteAdditionalDiscount(id: number, discount_id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteAdditionalDiscountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAdditionalDiscount(id, discount_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
         * @summary Delete a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        async deleteDeal(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteDealResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeal(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a product attachment from a deal, using the `product_attachment_id`.
         * @summary Delete an attached product from a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The product attachment ID

         * @throws {RequiredError}
         */
        async deleteDealProduct(id: number, product_attachment_id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteDealProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDealProduct(id, product_attachment_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a organization as deleted. After 30 days, the organization will be permanently deleted.
         * @summary Delete a organization
         * @param {number} id The ID of the organization

         * @throws {RequiredError}
         */
        async deleteOrganization(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteOrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a person as deleted. After 30 days, the person will be permanently deleted.
         * @summary Delete a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        async deletePerson(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeletePersonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePerson(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all activities.
         * @summary Get all activities
         * @param {number} [filter_id] If supplied, only activities matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only activities owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {number} [deal_id] If supplied, only activities linked to the specified deal are returned. If filter_id is provided, this is ignored.
         * @param {string} [lead_id] If supplied, only activities linked to the specified lead are returned. If filter_id is provided, this is ignored.
         * @param {number} [person_id] If supplied, only activities whose primary participant is the given person are returned. If filter_id is provided, this is ignored.
         * @param {number} [org_id] If supplied, only activities linked to the specified organization are returned. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only activities with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only activities with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'attendees'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        async getActivities(filter_id?: number, ids?: string, owner_id?: number, deal_id?: number, lead_id?: string, person_id?: number, org_id?: number, updated_since?: string, updated_until?: string, sort_by?: 'id' | 'update_time' | 'add_time', sort_direction?: 'asc' | 'desc', include_fields?: 'attendees', limit?: number, cursor?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetActivitiesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(filter_id, ids, owner_id, deal_id, lead_id, person_id, org_id, updated_since, updated_until, sort_by, sort_direction, include_fields, limit, cursor, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a specific activity.
         * @summary Get details of an activity
         * @param {number} id The ID of the activity
         * @param {'attendees'} [include_fields] Optional comma separated string array of additional fields to include

         * @throws {RequiredError}
         */
        async getActivity(id: number, include_fields?: 'attendees', ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpsertActivityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(id, include_fields, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists discounts attached to a deal.
         * @summary List discounts added to a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        async getAdditionalDiscounts(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAdditionalDiscountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdditionalDiscounts(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a specific deal.
         * @summary Get details of a deal
         * @param {number} id The ID of the deal
         * @param {'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.

         * @throws {RequiredError}
         */
        async getDeal(id: number, include_fields?: 'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time', custom_fields?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpsertDealResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeal(id, include_fields, custom_fields, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists products attached to a deal.
         * @summary List products attached to a deal
         * @param {number} id The ID of the deal
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {'id' | 'add_time' | 'update_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.

         * @throws {RequiredError}
         */
        async getDealProducts(id: number, cursor?: string, limit?: number, sort_by?: 'id' | 'add_time' | 'update_time', sort_direction?: 'asc' | 'desc', ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetDealsProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealProducts(id, cursor, limit, sort_by, sort_direction, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all deals.
         * @summary Get all deals
         * @param {number} [filter_id] If supplied, only deals matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only deals owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {number} [person_id] If supplied, only deals linked to the specified person are returned. If filter_id is provided, this is ignored.
         * @param {number} [org_id] If supplied, only deals linked to the specified organization are returned. If filter_id is provided, this is ignored.
         * @param {number} [pipeline_id] If supplied, only deals in the specified pipeline are returned. If filter_id is provided, this is ignored.
         * @param {number} [stage_id] If supplied, only deals in the specified stage are returned. If filter_id is provided, this is ignored.
         * @param {'open' | 'won' | 'lost' | 'deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. Multiple statuses can be included as a comma separated array. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only deals with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only deals with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        async getDeals(filter_id?: number, ids?: string, owner_id?: number, person_id?: number, org_id?: number, pipeline_id?: number, stage_id?: number, status?: 'open' | 'won' | 'lost' | 'deleted', updated_since?: string, updated_until?: string, sort_by?: 'id' | 'update_time' | 'add_time', sort_direction?: 'asc' | 'desc', include_fields?: 'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time', custom_fields?: string, limit?: number, cursor?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetDealsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeals(filter_id, ids, owner_id, person_id, org_id, pipeline_id, stage_id, status, updated_since, updated_until, sort_by, sort_direction, include_fields, custom_fields, limit, cursor, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about products attached to deals
         * @summary Get deal products of several deals
         * @param {Array<number>} deal_ids An array of integers with the IDs of the deals for which the attached products will be returned. A maximum of 100 deal IDs can be provided.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {'id' | 'deal_id' | 'add_time' | 'update_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;deal_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.

         * @throws {RequiredError}
         */
        async getDealsProducts(deal_ids: Array<number>, cursor?: string, limit?: number, sort_by?: 'id' | 'deal_id' | 'add_time' | 'update_time', sort_direction?: 'asc' | 'desc', ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetDealsProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealsProducts(deal_ids, cursor, limit, sort_by, sort_direction, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a specific organization.
         * @summary Get details of a organization
         * @param {number} id The ID of the organization
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.

         * @throws {RequiredError}
         */
        async getOrganization(id: number, include_fields?: 'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count', custom_fields?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpsertOrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(id, include_fields, custom_fields, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all organizations.
         * @summary Get all organizations
         * @param {number} [filter_id] If supplied, only organizations matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only organization owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only organizations with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only organizations with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        async getOrganizations(filter_id?: number, ids?: string, owner_id?: number, updated_since?: string, updated_until?: string, sort_by?: 'id' | 'update_time' | 'add_time', sort_direction?: 'asc' | 'desc', include_fields?: 'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count', custom_fields?: string, limit?: number, cursor?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOrganizationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizations(filter_id, ids, owner_id, updated_since, updated_until, sort_by, sort_direction, include_fields, custom_fields, limit, cursor, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a specific person. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
         * @summary Get details of a person
         * @param {number} id The ID of the person
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status'} [include_fields] Optional comma separated string array of additional fields to include. &#x60;marketing_status&#x60; and &#x60;doi_status&#x60; can only be included if the company has marketing app enabled.
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.

         * @throws {RequiredError}
         */
        async getPerson(id: number, include_fields?: 'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status', custom_fields?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpsertPersonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPerson(id, include_fields, custom_fields, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all persons. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
         * @summary Get all persons
         * @param {number} [filter_id] If supplied, only persons matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only persons owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {number} [org_id] If supplied, only persons linked to the specified organization are returned. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only persons with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only persons with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status'} [include_fields] Optional comma separated string array of additional fields to include. &#x60;marketing_status&#x60; and &#x60;doi_status&#x60; can only be included if the company has marketing app enabled.
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        async getPersons(filter_id?: number, ids?: string, owner_id?: number, org_id?: number, updated_since?: string, updated_until?: string, sort_by?: 'id' | 'update_time' | 'add_time', sort_direction?: 'asc' | 'desc', include_fields?: 'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status', custom_fields?: string, limit?: number, cursor?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPersonsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersons(filter_id, ids, owner_id, org_id, updated_since, updated_until, sort_by, sort_direction, include_fields, custom_fields, limit, cursor, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a discount to a deal changing, the deal value if the deal has one-time products attached.
         * @summary Add a discount to a deal
         * @param {number} id The ID of the deal
         * @param {AddAdditionalDiscountRequestBody} [AddAdditionalDiscountRequestBody] 

         * @throws {RequiredError}
         */
        async postAdditionalDiscount(id: number, AddAdditionalDiscountRequestBody?: AddAdditionalDiscountRequestBody, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddAdditionalDiscountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAdditionalDiscount(id, AddAdditionalDiscountRequestBody, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
         * @summary Search deals
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'notes' | 'title'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
         * @param {number} [organization_id] Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
         * @param {'open' | 'won' | 'lost'} [status] Will filter deals by the provided specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost. The upper limit of found deals associated with the status is 2000.
         * @param {'deal.cc_email'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        async searchDeals(term: string, fields?: 'custom_fields' | 'notes' | 'title', exact_match?: boolean, person_id?: number, organization_id?: number, status?: 'open' | 'won' | 'lost', include_fields?: 'deal.cc_email', limit?: number, cursor?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetDealSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDeals(term, fields, exact_match, person_id, organization_id, status, include_fields, limit, cursor, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performs a search from your choice of item types and fields.
         * @summary Perform a search from multiple item types
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project'} [item_types] A comma-separated string array. The type of items to perform the search from. Defaults to all.
         * @param {'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Project&lt;/td&gt;&lt;td&gt; &#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;, &#x60;description&#x60; &lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.&lt;br/&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
         * @param {boolean} [search_for_related_items] When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {'deal.cc_email' | 'person.picture' | 'product.price'} [include_fields] A comma-separated string array. Supports including optional fields in the results which are not provided by default.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        async searchItem(term: string, item_types?: 'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project', fields?: 'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description', search_for_related_items?: boolean, exact_match?: boolean, include_fields?: 'deal.cc_email' | 'person.picture' | 'product.price', limit?: number, cursor?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetItemSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchItem(term, item_types, fields, search_for_related_items, exact_match, include_fields, limit, cursor, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
         * @summary Perform a search using a specific field from an item type
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if &#x60;match&#x60; is &#x60;exact&#x60;). Please note that the search term has to be URL encoded.
         * @param {'deal' | 'lead' | 'person' | 'organization' | 'product' | 'project'} entity_type The type of the field to perform the search from
         * @param {string} field The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields\&#39; API GET methods (dealFields, personFields, etc.). Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {'exact' | 'beginning' | 'middle'} [match] The type of match used against the term. The search &lt;b&gt;is&lt;/b&gt; case sensitive.&lt;br/&gt;&lt;br/&gt; E.g. in case of searching for a value &#x60;monkey&#x60;, &lt;ul&gt; &lt;li&gt;with &#x60;exact&#x60; match, you will only find it if term is &#x60;monkey&#x60;&lt;/li&gt; &lt;li&gt;with &#x60;beginning&#x60; match, you will only find it if the term matches the beginning or the whole string, e.g. &#x60;monk&#x60; and &#x60;monkey&#x60;&lt;/li&gt; &lt;li&gt;with &#x60;middle&#x60; match, you will find the it if the term matches any substring of the value, e.g. &#x60;onk&#x60; and &#x60;ke&#x60;&lt;/li&gt; &lt;/ul&gt;.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        async searchItemByField(term: string, entity_type: 'deal' | 'lead' | 'person' | 'organization' | 'product' | 'project', field: string, match?: 'exact' | 'beginning' | 'middle', limit?: number, cursor?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetItemSearchFieldResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchItemByField(term, entity_type, field, match, limit, cursor, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
         * @summary Search leads
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'notes' | 'title'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
         * @param {number} [organization_id] Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
         * @param {'lead.was_seen'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        async searchLeads(term: string, fields?: 'custom_fields' | 'notes' | 'title', exact_match?: boolean, person_id?: number, organization_id?: number, include_fields?: 'lead.was_seen', limit?: number, cursor?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLeadSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchLeads(term, fields, exact_match, person_id, organization_id, include_fields, limit, cursor, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search organizations
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'address' | 'custom_fields' | 'notes' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        async searchOrganization(term: string, fields?: 'address' | 'custom_fields' | 'notes' | 'name', exact_match?: boolean, limit?: number, cursor?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOrganizationSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchOrganization(term, fields, exact_match, limit, cursor, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'email' | 'notes' | 'phone' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [organization_id] Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
         * @param {'person.picture'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        async searchPersons(term: string, fields?: 'custom_fields' | 'email' | 'notes' | 'phone' | 'name', exact_match?: boolean, organization_id?: number, include_fields?: 'person.picture', limit?: number, cursor?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPersonSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPersons(term, fields, exact_match, organization_id, include_fields, limit, cursor, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of an activity.
         * @summary Update an activity
         * @param {number} id The ID of the activity
         * @param {AddActivityRequest} [AddActivityRequest] 

         * @throws {RequiredError}
         */
        async updateActivity(id: number, AddActivityRequest?: AddActivityRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpsertActivityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateActivity(id, AddActivityRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a discount added to a deal, changing the deal value if the deal has one-time products attached.
         * @summary Update a discount added to a deal
         * @param {number} id The ID of the deal
         * @param {number} discount_id The ID of the discount
         * @param {UpdateAdditionalDiscountRequestBody} [UpdateAdditionalDiscountRequestBody] 

         * @throws {RequiredError}
         */
        async updateAdditionalDiscount(id: number, discount_id: number, UpdateAdditionalDiscountRequestBody?: UpdateAdditionalDiscountRequestBody, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdateAdditionalDiscountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAdditionalDiscount(id, discount_id, UpdateAdditionalDiscountRequestBody, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of a deal.
         * @summary Update a deal
         * @param {number} id The ID of the deal
         * @param {UpdateDealRequest} [UpdateDealRequest] 

         * @throws {RequiredError}
         */
        async updateDeal(id: number, UpdateDealRequest?: UpdateDealRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpsertDealResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeal(id, UpdateDealRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the details of the product that has been attached to a deal.
         * @summary Update the product attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The ID of the deal-product (the ID of the product attached to the deal)
         * @param {UpdateDealProductRequest} [UpdateDealProductRequest] 

         * @throws {RequiredError}
         */
        async updateDealProduct(id: number, product_attachment_id: number, UpdateDealProductRequest?: UpdateDealProductRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddDealProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDealProduct(id, product_attachment_id, UpdateDealProductRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of a organization.
         * @summary Update a organization
         * @param {number} id The ID of the organization
         * @param {UpdateOrganizationRequest} [UpdateOrganizationRequest] 

         * @throws {RequiredError}
         */
        async updateOrganization(id: number, UpdateOrganizationRequest?: UpdateOrganizationRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpsertOrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(id, UpdateOrganizationRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of a person.
         * @summary Update a person
         * @param {number} id The ID of the person
         * @param {UpdatePersonRequest} [UpdatePersonRequest] 

         * @throws {RequiredError}
         */
        async updatePerson(id: number, UpdatePersonRequest?: UpdatePersonRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpsertPersonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePerson(id, UpdatePersonRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BetaApi - factory interface
 * @export
 */
export const BetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BetaApiFp(configuration)
    return {
        /**
         * Adds a new activity.
         * @summary Add a new activity
         * @param {BetaApiAddActivityRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addActivity(requestParameters: BetaApiAddActivityRequest = {}, ): Promise<UpsertActivityResponse> {
            return localVarFp.addActivity(requestParameters.AddActivityRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new deal.
         * @summary Add a new deal
         * @param {BetaApiAddDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addDeal(requestParameters: BetaApiAddDealRequest = {}, ): Promise<UpsertDealResponse> {
            return localVarFp.addDeal(requestParameters.AddDealRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a product to a deal, creating a new item called a deal-product.
         * @summary Add a product to a deal
         * @param {BetaApiAddDealProductRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addDealProduct(requestParameters: BetaApiAddDealProductRequest, ): Promise<AddDealProductResponse> {
            return localVarFp.addDealProduct(requestParameters.id, requestParameters.AddDealProductRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new organization.
         * @summary Add a new organization
         * @param {BetaApiAddOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addOrganization(requestParameters: BetaApiAddOrganizationRequest = {}, ): Promise<UpsertOrganizationResponse> {
            return localVarFp.addOrganization(requestParameters.AddOrganizationRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new person.
         * @summary Add a new person
         * @param {BetaApiAddPersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addPerson(requestParameters: BetaApiAddPersonRequest = {}, ): Promise<UpsertPersonResponse> {
            return localVarFp.addPerson(requestParameters.AddPersonRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
         * @summary Delete an activity
         * @param {BetaApiDeleteActivityRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteActivity(requestParameters: BetaApiDeleteActivityRequest, ): Promise<DeleteActivityResponse> {
            return localVarFp.deleteActivity(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Removes a discount from a deal, changing the deal value if the deal has one-time products attached.
         * @summary Delete a discount from a deal
         * @param {BetaApiDeleteAdditionalDiscountRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteAdditionalDiscount(requestParameters: BetaApiDeleteAdditionalDiscountRequest, ): Promise<DeleteAdditionalDiscountResponse> {
            return localVarFp.deleteAdditionalDiscount(requestParameters.id, requestParameters.discount_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
         * @summary Delete a deal
         * @param {BetaApiDeleteDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteDeal(requestParameters: BetaApiDeleteDealRequest, ): Promise<DeleteDealResponse> {
            return localVarFp.deleteDeal(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a product attachment from a deal, using the `product_attachment_id`.
         * @summary Delete an attached product from a deal
         * @param {BetaApiDeleteDealProductRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteDealProduct(requestParameters: BetaApiDeleteDealProductRequest, ): Promise<DeleteDealProductResponse> {
            return localVarFp.deleteDealProduct(requestParameters.id, requestParameters.product_attachment_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a organization as deleted. After 30 days, the organization will be permanently deleted.
         * @summary Delete a organization
         * @param {BetaApiDeleteOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteOrganization(requestParameters: BetaApiDeleteOrganizationRequest, ): Promise<DeleteOrganizationResponse> {
            return localVarFp.deleteOrganization(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a person as deleted. After 30 days, the person will be permanently deleted.
         * @summary Delete a person
         * @param {BetaApiDeletePersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deletePerson(requestParameters: BetaApiDeletePersonRequest, ): Promise<DeletePersonResponse> {
            return localVarFp.deletePerson(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all activities.
         * @summary Get all activities
         * @param {BetaApiGetActivitiesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getActivities(requestParameters: BetaApiGetActivitiesRequest = {}, ): Promise<GetActivitiesResponse> {
            return localVarFp.getActivities(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.deal_id, requestParameters.lead_id, requestParameters.person_id, requestParameters.org_id, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific activity.
         * @summary Get details of an activity
         * @param {BetaApiGetActivityRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getActivity(requestParameters: BetaApiGetActivityRequest, ): Promise<UpsertActivityResponse> {
            return localVarFp.getActivity(requestParameters.id, requestParameters.include_fields, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists discounts attached to a deal.
         * @summary List discounts added to a deal
         * @param {BetaApiGetAdditionalDiscountsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getAdditionalDiscounts(requestParameters: BetaApiGetAdditionalDiscountsRequest, ): Promise<GetAdditionalDiscountsResponse> {
            return localVarFp.getAdditionalDiscounts(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific deal.
         * @summary Get details of a deal
         * @param {BetaApiGetDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDeal(requestParameters: BetaApiGetDealRequest, ): Promise<UpsertDealResponse> {
            return localVarFp.getDeal(requestParameters.id, requestParameters.include_fields, requestParameters.custom_fields, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists products attached to a deal.
         * @summary List products attached to a deal
         * @param {BetaApiGetDealProductsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealProducts(requestParameters: BetaApiGetDealProductsRequest, ): Promise<GetDealsProductsResponse> {
            return localVarFp.getDealProducts(requestParameters.id, requestParameters.cursor, requestParameters.limit, requestParameters.sort_by, requestParameters.sort_direction, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all deals.
         * @summary Get all deals
         * @param {BetaApiGetDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDeals(requestParameters: BetaApiGetDealsRequest = {}, ): Promise<GetDealsResponse> {
            return localVarFp.getDeals(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.person_id, requestParameters.org_id, requestParameters.pipeline_id, requestParameters.stage_id, requestParameters.status, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.custom_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about products attached to deals
         * @summary Get deal products of several deals
         * @param {BetaApiGetDealsProductsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealsProducts(requestParameters: BetaApiGetDealsProductsRequest, ): Promise<GetDealsProductsResponse> {
            return localVarFp.getDealsProducts(requestParameters.deal_ids, requestParameters.cursor, requestParameters.limit, requestParameters.sort_by, requestParameters.sort_direction, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific organization.
         * @summary Get details of a organization
         * @param {BetaApiGetOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganization(requestParameters: BetaApiGetOrganizationRequest, ): Promise<UpsertOrganizationResponse> {
            return localVarFp.getOrganization(requestParameters.id, requestParameters.include_fields, requestParameters.custom_fields, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all organizations.
         * @summary Get all organizations
         * @param {BetaApiGetOrganizationsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizations(requestParameters: BetaApiGetOrganizationsRequest = {}, ): Promise<GetOrganizationsResponse> {
            return localVarFp.getOrganizations(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.custom_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific person. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
         * @summary Get details of a person
         * @param {BetaApiGetPersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPerson(requestParameters: BetaApiGetPersonRequest, ): Promise<UpsertPersonResponse> {
            return localVarFp.getPerson(requestParameters.id, requestParameters.include_fields, requestParameters.custom_fields, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all persons. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
         * @summary Get all persons
         * @param {BetaApiGetPersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersons(requestParameters: BetaApiGetPersonsRequest = {}, ): Promise<GetPersonsResponse> {
            return localVarFp.getPersons(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.org_id, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.custom_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a discount to a deal changing, the deal value if the deal has one-time products attached.
         * @summary Add a discount to a deal
         * @param {BetaApiPostAdditionalDiscountRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        postAdditionalDiscount(requestParameters: BetaApiPostAdditionalDiscountRequest, ): Promise<AddAdditionalDiscountResponse> {
            return localVarFp.postAdditionalDiscount(requestParameters.id, requestParameters.AddAdditionalDiscountRequestBody, ).then((request) => request(axios, basePath));
        },
        /**
         * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
         * @summary Search deals
         * @param {BetaApiSearchDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchDeals(requestParameters: BetaApiSearchDealsRequest, ): Promise<GetDealSearchResponse> {
            return localVarFp.searchDeals(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.person_id, requestParameters.organization_id, requestParameters.status, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search from your choice of item types and fields.
         * @summary Perform a search from multiple item types
         * @param {BetaApiSearchItemRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchItem(requestParameters: BetaApiSearchItemRequest, ): Promise<GetItemSearchResponse> {
            return localVarFp.searchItem(requestParameters.term, requestParameters.item_types, requestParameters.fields, requestParameters.search_for_related_items, requestParameters.exact_match, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
         * @summary Perform a search using a specific field from an item type
         * @param {BetaApiSearchItemByFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchItemByField(requestParameters: BetaApiSearchItemByFieldRequest, ): Promise<GetItemSearchFieldResponse> {
            return localVarFp.searchItemByField(requestParameters.term, requestParameters.entity_type, requestParameters.field, requestParameters.match, requestParameters.limit, requestParameters.cursor, ).then((request) => request(axios, basePath));
        },
        /**
         * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
         * @summary Search leads
         * @param {BetaApiSearchLeadsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchLeads(requestParameters: BetaApiSearchLeadsRequest, ): Promise<GetLeadSearchResponse> {
            return localVarFp.searchLeads(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.person_id, requestParameters.organization_id, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(axios, basePath));
        },
        /**
         * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search organizations
         * @param {BetaApiSearchOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchOrganization(requestParameters: BetaApiSearchOrganizationRequest, ): Promise<GetOrganizationSearchResponse> {
            return localVarFp.searchOrganization(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.limit, requestParameters.cursor, ).then((request) => request(axios, basePath));
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {BetaApiSearchPersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchPersons(requestParameters: BetaApiSearchPersonsRequest, ): Promise<GetPersonSearchResponse> {
            return localVarFp.searchPersons(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.organization_id, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of an activity.
         * @summary Update an activity
         * @param {BetaApiUpdateActivityRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateActivity(requestParameters: BetaApiUpdateActivityRequest, ): Promise<UpsertActivityResponse> {
            return localVarFp.updateActivity(requestParameters.id, requestParameters.AddActivityRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Edits a discount added to a deal, changing the deal value if the deal has one-time products attached.
         * @summary Update a discount added to a deal
         * @param {BetaApiUpdateAdditionalDiscountRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateAdditionalDiscount(requestParameters: BetaApiUpdateAdditionalDiscountRequest, ): Promise<UpdateAdditionalDiscountResponse> {
            return localVarFp.updateAdditionalDiscount(requestParameters.id, requestParameters.discount_id, requestParameters.UpdateAdditionalDiscountRequestBody, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a deal.
         * @summary Update a deal
         * @param {BetaApiUpdateDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateDeal(requestParameters: BetaApiUpdateDealRequest, ): Promise<UpsertDealResponse> {
            return localVarFp.updateDeal(requestParameters.id, requestParameters.UpdateDealRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the details of the product that has been attached to a deal.
         * @summary Update the product attached to a deal
         * @param {BetaApiUpdateDealProductRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateDealProduct(requestParameters: BetaApiUpdateDealProductRequest, ): Promise<AddDealProductResponse> {
            return localVarFp.updateDealProduct(requestParameters.id, requestParameters.product_attachment_id, requestParameters.UpdateDealProductRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a organization.
         * @summary Update a organization
         * @param {BetaApiUpdateOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateOrganization(requestParameters: BetaApiUpdateOrganizationRequest, ): Promise<UpsertOrganizationResponse> {
            return localVarFp.updateOrganization(requestParameters.id, requestParameters.UpdateOrganizationRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a person.
         * @summary Update a person
         * @param {BetaApiUpdatePersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updatePerson(requestParameters: BetaApiUpdatePersonRequest, ): Promise<UpsertPersonResponse> {
            return localVarFp.updatePerson(requestParameters.id, requestParameters.UpdatePersonRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addActivity operation in BetaApi.
 * @export
 * @interface BetaApiAddActivityRequest
 */
export interface BetaApiAddActivityRequest {
    /**
     * 
     * @type {AddActivityRequest}
     * @memberof BetaApiAddActivity
     */
    readonly AddActivityRequest?: AddActivityRequest
}

/**
 * Request parameters for addDeal operation in BetaApi.
 * @export
 * @interface BetaApiAddDealRequest
 */
export interface BetaApiAddDealRequest {
    /**
     * 
     * @type {AddDealRequest}
     * @memberof BetaApiAddDeal
     */
    readonly AddDealRequest?: AddDealRequest
}

/**
 * Request parameters for addDealProduct operation in BetaApi.
 * @export
 * @interface BetaApiAddDealProductRequest
 */
export interface BetaApiAddDealProductRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BetaApiAddDealProduct
     */
    readonly id: number

    /**
     * 
     * @type {AddDealProductRequest}
     * @memberof BetaApiAddDealProduct
     */
    readonly AddDealProductRequest?: AddDealProductRequest
}

/**
 * Request parameters for addOrganization operation in BetaApi.
 * @export
 * @interface BetaApiAddOrganizationRequest
 */
export interface BetaApiAddOrganizationRequest {
    /**
     * 
     * @type {AddOrganizationRequest}
     * @memberof BetaApiAddOrganization
     */
    readonly AddOrganizationRequest?: AddOrganizationRequest
}

/**
 * Request parameters for addPerson operation in BetaApi.
 * @export
 * @interface BetaApiAddPersonRequest
 */
export interface BetaApiAddPersonRequest {
    /**
     * 
     * @type {AddPersonRequest}
     * @memberof BetaApiAddPerson
     */
    readonly AddPersonRequest?: AddPersonRequest
}

/**
 * Request parameters for deleteActivity operation in BetaApi.
 * @export
 * @interface BetaApiDeleteActivityRequest
 */
export interface BetaApiDeleteActivityRequest {
    /**
     * The ID of the activity
     * @type {number}
     * @memberof BetaApiDeleteActivity
     */
    readonly id: number
}

/**
 * Request parameters for deleteAdditionalDiscount operation in BetaApi.
 * @export
 * @interface BetaApiDeleteAdditionalDiscountRequest
 */
export interface BetaApiDeleteAdditionalDiscountRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BetaApiDeleteAdditionalDiscount
     */
    readonly id: number

    /**
     * The ID of the discount
     * @type {number}
     * @memberof BetaApiDeleteAdditionalDiscount
     */
    readonly discount_id: number
}

/**
 * Request parameters for deleteDeal operation in BetaApi.
 * @export
 * @interface BetaApiDeleteDealRequest
 */
export interface BetaApiDeleteDealRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BetaApiDeleteDeal
     */
    readonly id: number
}

/**
 * Request parameters for deleteDealProduct operation in BetaApi.
 * @export
 * @interface BetaApiDeleteDealProductRequest
 */
export interface BetaApiDeleteDealProductRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BetaApiDeleteDealProduct
     */
    readonly id: number

    /**
     * The product attachment ID
     * @type {number}
     * @memberof BetaApiDeleteDealProduct
     */
    readonly product_attachment_id: number
}

/**
 * Request parameters for deleteOrganization operation in BetaApi.
 * @export
 * @interface BetaApiDeleteOrganizationRequest
 */
export interface BetaApiDeleteOrganizationRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof BetaApiDeleteOrganization
     */
    readonly id: number
}

/**
 * Request parameters for deletePerson operation in BetaApi.
 * @export
 * @interface BetaApiDeletePersonRequest
 */
export interface BetaApiDeletePersonRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof BetaApiDeletePerson
     */
    readonly id: number
}

/**
 * Request parameters for getActivities operation in BetaApi.
 * @export
 * @interface BetaApiGetActivitiesRequest
 */
export interface BetaApiGetActivitiesRequest {
    /**
     * If supplied, only activities matching the specified filter are returned
     * @type {number}
     * @memberof BetaApiGetActivities
     */
    readonly filter_id?: number

    /**
     * Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
     * @type {string}
     * @memberof BetaApiGetActivities
     */
    readonly ids?: string

    /**
     * If supplied, only activities owned by the specified user are returned. If filter_id is provided, this is ignored.
     * @type {number}
     * @memberof BetaApiGetActivities
     */
    readonly owner_id?: number

    /**
     * If supplied, only activities linked to the specified deal are returned. If filter_id is provided, this is ignored.
     * @type {number}
     * @memberof BetaApiGetActivities
     */
    readonly deal_id?: number

    /**
     * If supplied, only activities linked to the specified lead are returned. If filter_id is provided, this is ignored.
     * @type {string}
     * @memberof BetaApiGetActivities
     */
    readonly lead_id?: string

    /**
     * If supplied, only activities whose primary participant is the given person are returned. If filter_id is provided, this is ignored.
     * @type {number}
     * @memberof BetaApiGetActivities
     */
    readonly person_id?: number

    /**
     * If supplied, only activities linked to the specified organization are returned. If filter_id is provided, this is ignored.
     * @type {number}
     * @memberof BetaApiGetActivities
     */
    readonly org_id?: number

    /**
     * If set, only activities with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
     * @type {string}
     * @memberof BetaApiGetActivities
     */
    readonly updated_since?: string

    /**
     * If set, only activities with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
     * @type {string}
     * @memberof BetaApiGetActivities
     */
    readonly updated_until?: string

    /**
     * The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
     * @type {'id' | 'update_time' | 'add_time'}
     * @memberof BetaApiGetActivities
     */
    readonly sort_by?: 'id' | 'update_time' | 'add_time'

    /**
     * The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
     * @type {'asc' | 'desc'}
     * @memberof BetaApiGetActivities
     */
    readonly sort_direction?: 'asc' | 'desc'

    /**
     * Optional comma separated string array of additional fields to include
     * @type {'attendees'}
     * @memberof BetaApiGetActivities
     */
    readonly include_fields?: 'attendees'

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof BetaApiGetActivities
     */
    readonly limit?: number

    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof BetaApiGetActivities
     */
    readonly cursor?: string
}

/**
 * Request parameters for getActivity operation in BetaApi.
 * @export
 * @interface BetaApiGetActivityRequest
 */
export interface BetaApiGetActivityRequest {
    /**
     * The ID of the activity
     * @type {number}
     * @memberof BetaApiGetActivity
     */
    readonly id: number

    /**
     * Optional comma separated string array of additional fields to include
     * @type {'attendees'}
     * @memberof BetaApiGetActivity
     */
    readonly include_fields?: 'attendees'
}

/**
 * Request parameters for getAdditionalDiscounts operation in BetaApi.
 * @export
 * @interface BetaApiGetAdditionalDiscountsRequest
 */
export interface BetaApiGetAdditionalDiscountsRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BetaApiGetAdditionalDiscounts
     */
    readonly id: number
}

/**
 * Request parameters for getDeal operation in BetaApi.
 * @export
 * @interface BetaApiGetDealRequest
 */
export interface BetaApiGetDealRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BetaApiGetDeal
     */
    readonly id: number

    /**
     * Optional comma separated string array of additional fields to include
     * @type {'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time'}
     * @memberof BetaApiGetDeal
     */
    readonly include_fields?: 'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time'

    /**
     * Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
     * @type {string}
     * @memberof BetaApiGetDeal
     */
    readonly custom_fields?: string
}

/**
 * Request parameters for getDealProducts operation in BetaApi.
 * @export
 * @interface BetaApiGetDealProductsRequest
 */
export interface BetaApiGetDealProductsRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BetaApiGetDealProducts
     */
    readonly id: number

    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof BetaApiGetDealProducts
     */
    readonly cursor?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof BetaApiGetDealProducts
     */
    readonly limit?: number

    /**
     * The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
     * @type {'id' | 'add_time' | 'update_time'}
     * @memberof BetaApiGetDealProducts
     */
    readonly sort_by?: 'id' | 'add_time' | 'update_time'

    /**
     * The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
     * @type {'asc' | 'desc'}
     * @memberof BetaApiGetDealProducts
     */
    readonly sort_direction?: 'asc' | 'desc'
}

/**
 * Request parameters for getDeals operation in BetaApi.
 * @export
 * @interface BetaApiGetDealsRequest
 */
export interface BetaApiGetDealsRequest {
    /**
     * If supplied, only deals matching the specified filter are returned
     * @type {number}
     * @memberof BetaApiGetDeals
     */
    readonly filter_id?: number

    /**
     * Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
     * @type {string}
     * @memberof BetaApiGetDeals
     */
    readonly ids?: string

    /**
     * If supplied, only deals owned by the specified user are returned. If filter_id is provided, this is ignored.
     * @type {number}
     * @memberof BetaApiGetDeals
     */
    readonly owner_id?: number

    /**
     * If supplied, only deals linked to the specified person are returned. If filter_id is provided, this is ignored.
     * @type {number}
     * @memberof BetaApiGetDeals
     */
    readonly person_id?: number

    /**
     * If supplied, only deals linked to the specified organization are returned. If filter_id is provided, this is ignored.
     * @type {number}
     * @memberof BetaApiGetDeals
     */
    readonly org_id?: number

    /**
     * If supplied, only deals in the specified pipeline are returned. If filter_id is provided, this is ignored.
     * @type {number}
     * @memberof BetaApiGetDeals
     */
    readonly pipeline_id?: number

    /**
     * If supplied, only deals in the specified stage are returned. If filter_id is provided, this is ignored.
     * @type {number}
     * @memberof BetaApiGetDeals
     */
    readonly stage_id?: number

    /**
     * Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. Multiple statuses can be included as a comma separated array. If filter_id is provided, this is ignored.
     * @type {'open' | 'won' | 'lost' | 'deleted'}
     * @memberof BetaApiGetDeals
     */
    readonly status?: 'open' | 'won' | 'lost' | 'deleted'

    /**
     * If set, only deals with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
     * @type {string}
     * @memberof BetaApiGetDeals
     */
    readonly updated_since?: string

    /**
     * If set, only deals with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
     * @type {string}
     * @memberof BetaApiGetDeals
     */
    readonly updated_until?: string

    /**
     * The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
     * @type {'id' | 'update_time' | 'add_time'}
     * @memberof BetaApiGetDeals
     */
    readonly sort_by?: 'id' | 'update_time' | 'add_time'

    /**
     * The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
     * @type {'asc' | 'desc'}
     * @memberof BetaApiGetDeals
     */
    readonly sort_direction?: 'asc' | 'desc'

    /**
     * Optional comma separated string array of additional fields to include
     * @type {'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time'}
     * @memberof BetaApiGetDeals
     */
    readonly include_fields?: 'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time'

    /**
     * Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
     * @type {string}
     * @memberof BetaApiGetDeals
     */
    readonly custom_fields?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof BetaApiGetDeals
     */
    readonly limit?: number

    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof BetaApiGetDeals
     */
    readonly cursor?: string
}

/**
 * Request parameters for getDealsProducts operation in BetaApi.
 * @export
 * @interface BetaApiGetDealsProductsRequest
 */
export interface BetaApiGetDealsProductsRequest {
    /**
     * An array of integers with the IDs of the deals for which the attached products will be returned. A maximum of 100 deal IDs can be provided.
     * @type {Array<number>}
     * @memberof BetaApiGetDealsProducts
     */
    readonly deal_ids: Array<number>

    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof BetaApiGetDealsProducts
     */
    readonly cursor?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof BetaApiGetDealsProducts
     */
    readonly limit?: number

    /**
     * The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;deal_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
     * @type {'id' | 'deal_id' | 'add_time' | 'update_time'}
     * @memberof BetaApiGetDealsProducts
     */
    readonly sort_by?: 'id' | 'deal_id' | 'add_time' | 'update_time'

    /**
     * The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
     * @type {'asc' | 'desc'}
     * @memberof BetaApiGetDealsProducts
     */
    readonly sort_direction?: 'asc' | 'desc'
}

/**
 * Request parameters for getOrganization operation in BetaApi.
 * @export
 * @interface BetaApiGetOrganizationRequest
 */
export interface BetaApiGetOrganizationRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof BetaApiGetOrganization
     */
    readonly id: number

    /**
     * Optional comma separated string array of additional fields to include
     * @type {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count'}
     * @memberof BetaApiGetOrganization
     */
    readonly include_fields?: 'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count'

    /**
     * Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
     * @type {string}
     * @memberof BetaApiGetOrganization
     */
    readonly custom_fields?: string
}

/**
 * Request parameters for getOrganizations operation in BetaApi.
 * @export
 * @interface BetaApiGetOrganizationsRequest
 */
export interface BetaApiGetOrganizationsRequest {
    /**
     * If supplied, only organizations matching the specified filter are returned
     * @type {number}
     * @memberof BetaApiGetOrganizations
     */
    readonly filter_id?: number

    /**
     * Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
     * @type {string}
     * @memberof BetaApiGetOrganizations
     */
    readonly ids?: string

    /**
     * If supplied, only organization owned by the specified user are returned. If filter_id is provided, this is ignored.
     * @type {number}
     * @memberof BetaApiGetOrganizations
     */
    readonly owner_id?: number

    /**
     * If set, only organizations with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
     * @type {string}
     * @memberof BetaApiGetOrganizations
     */
    readonly updated_since?: string

    /**
     * If set, only organizations with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
     * @type {string}
     * @memberof BetaApiGetOrganizations
     */
    readonly updated_until?: string

    /**
     * The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
     * @type {'id' | 'update_time' | 'add_time'}
     * @memberof BetaApiGetOrganizations
     */
    readonly sort_by?: 'id' | 'update_time' | 'add_time'

    /**
     * The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
     * @type {'asc' | 'desc'}
     * @memberof BetaApiGetOrganizations
     */
    readonly sort_direction?: 'asc' | 'desc'

    /**
     * Optional comma separated string array of additional fields to include
     * @type {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count'}
     * @memberof BetaApiGetOrganizations
     */
    readonly include_fields?: 'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count'

    /**
     * Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
     * @type {string}
     * @memberof BetaApiGetOrganizations
     */
    readonly custom_fields?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof BetaApiGetOrganizations
     */
    readonly limit?: number

    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof BetaApiGetOrganizations
     */
    readonly cursor?: string
}

/**
 * Request parameters for getPerson operation in BetaApi.
 * @export
 * @interface BetaApiGetPersonRequest
 */
export interface BetaApiGetPersonRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof BetaApiGetPerson
     */
    readonly id: number

    /**
     * Optional comma separated string array of additional fields to include. &#x60;marketing_status&#x60; and &#x60;doi_status&#x60; can only be included if the company has marketing app enabled.
     * @type {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status'}
     * @memberof BetaApiGetPerson
     */
    readonly include_fields?: 'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status'

    /**
     * Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
     * @type {string}
     * @memberof BetaApiGetPerson
     */
    readonly custom_fields?: string
}

/**
 * Request parameters for getPersons operation in BetaApi.
 * @export
 * @interface BetaApiGetPersonsRequest
 */
export interface BetaApiGetPersonsRequest {
    /**
     * If supplied, only persons matching the specified filter are returned
     * @type {number}
     * @memberof BetaApiGetPersons
     */
    readonly filter_id?: number

    /**
     * Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
     * @type {string}
     * @memberof BetaApiGetPersons
     */
    readonly ids?: string

    /**
     * If supplied, only persons owned by the specified user are returned. If filter_id is provided, this is ignored.
     * @type {number}
     * @memberof BetaApiGetPersons
     */
    readonly owner_id?: number

    /**
     * If supplied, only persons linked to the specified organization are returned. If filter_id is provided, this is ignored.
     * @type {number}
     * @memberof BetaApiGetPersons
     */
    readonly org_id?: number

    /**
     * If set, only persons with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
     * @type {string}
     * @memberof BetaApiGetPersons
     */
    readonly updated_since?: string

    /**
     * If set, only persons with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
     * @type {string}
     * @memberof BetaApiGetPersons
     */
    readonly updated_until?: string

    /**
     * The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
     * @type {'id' | 'update_time' | 'add_time'}
     * @memberof BetaApiGetPersons
     */
    readonly sort_by?: 'id' | 'update_time' | 'add_time'

    /**
     * The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
     * @type {'asc' | 'desc'}
     * @memberof BetaApiGetPersons
     */
    readonly sort_direction?: 'asc' | 'desc'

    /**
     * Optional comma separated string array of additional fields to include. &#x60;marketing_status&#x60; and &#x60;doi_status&#x60; can only be included if the company has marketing app enabled.
     * @type {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status'}
     * @memberof BetaApiGetPersons
     */
    readonly include_fields?: 'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status'

    /**
     * Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
     * @type {string}
     * @memberof BetaApiGetPersons
     */
    readonly custom_fields?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof BetaApiGetPersons
     */
    readonly limit?: number

    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof BetaApiGetPersons
     */
    readonly cursor?: string
}

/**
 * Request parameters for postAdditionalDiscount operation in BetaApi.
 * @export
 * @interface BetaApiPostAdditionalDiscountRequest
 */
export interface BetaApiPostAdditionalDiscountRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BetaApiPostAdditionalDiscount
     */
    readonly id: number

    /**
     * 
     * @type {AddAdditionalDiscountRequestBody}
     * @memberof BetaApiPostAdditionalDiscount
     */
    readonly AddAdditionalDiscountRequestBody?: AddAdditionalDiscountRequestBody
}

/**
 * Request parameters for searchDeals operation in BetaApi.
 * @export
 * @interface BetaApiSearchDealsRequest
 */
export interface BetaApiSearchDealsRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof BetaApiSearchDeals
     */
    readonly term: string

    /**
     * A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
     * @type {'custom_fields' | 'notes' | 'title'}
     * @memberof BetaApiSearchDeals
     */
    readonly fields?: 'custom_fields' | 'notes' | 'title'

    /**
     * When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @type {boolean}
     * @memberof BetaApiSearchDeals
     */
    readonly exact_match?: boolean

    /**
     * Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
     * @type {number}
     * @memberof BetaApiSearchDeals
     */
    readonly person_id?: number

    /**
     * Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
     * @type {number}
     * @memberof BetaApiSearchDeals
     */
    readonly organization_id?: number

    /**
     * Will filter deals by the provided specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost. The upper limit of found deals associated with the status is 2000.
     * @type {'open' | 'won' | 'lost'}
     * @memberof BetaApiSearchDeals
     */
    readonly status?: 'open' | 'won' | 'lost'

    /**
     * Supports including optional fields in the results which are not provided by default
     * @type {'deal.cc_email'}
     * @memberof BetaApiSearchDeals
     */
    readonly include_fields?: 'deal.cc_email'

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof BetaApiSearchDeals
     */
    readonly limit?: number

    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof BetaApiSearchDeals
     */
    readonly cursor?: string
}

/**
 * Request parameters for searchItem operation in BetaApi.
 * @export
 * @interface BetaApiSearchItemRequest
 */
export interface BetaApiSearchItemRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof BetaApiSearchItem
     */
    readonly term: string

    /**
     * A comma-separated string array. The type of items to perform the search from. Defaults to all.
     * @type {'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project'}
     * @memberof BetaApiSearchItem
     */
    readonly item_types?: 'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project'

    /**
     * A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Project&lt;/td&gt;&lt;td&gt; &#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;, &#x60;description&#x60; &lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.&lt;br/&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
     * @type {'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description'}
     * @memberof BetaApiSearchItem
     */
    readonly fields?: 'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description'

    /**
     * When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization
     * @type {boolean}
     * @memberof BetaApiSearchItem
     */
    readonly search_for_related_items?: boolean

    /**
     * When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @type {boolean}
     * @memberof BetaApiSearchItem
     */
    readonly exact_match?: boolean

    /**
     * A comma-separated string array. Supports including optional fields in the results which are not provided by default.
     * @type {'deal.cc_email' | 'person.picture' | 'product.price'}
     * @memberof BetaApiSearchItem
     */
    readonly include_fields?: 'deal.cc_email' | 'person.picture' | 'product.price'

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof BetaApiSearchItem
     */
    readonly limit?: number

    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof BetaApiSearchItem
     */
    readonly cursor?: string
}

/**
 * Request parameters for searchItemByField operation in BetaApi.
 * @export
 * @interface BetaApiSearchItemByFieldRequest
 */
export interface BetaApiSearchItemByFieldRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if &#x60;match&#x60; is &#x60;exact&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof BetaApiSearchItemByField
     */
    readonly term: string

    /**
     * The type of the field to perform the search from
     * @type {'deal' | 'lead' | 'person' | 'organization' | 'product' | 'project'}
     * @memberof BetaApiSearchItemByField
     */
    readonly entity_type: 'deal' | 'lead' | 'person' | 'organization' | 'product' | 'project'

    /**
     * The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields\&#39; API GET methods (dealFields, personFields, etc.). Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
     * @type {string}
     * @memberof BetaApiSearchItemByField
     */
    readonly field: string

    /**
     * The type of match used against the term. The search &lt;b&gt;is&lt;/b&gt; case sensitive.&lt;br/&gt;&lt;br/&gt; E.g. in case of searching for a value &#x60;monkey&#x60;, &lt;ul&gt; &lt;li&gt;with &#x60;exact&#x60; match, you will only find it if term is &#x60;monkey&#x60;&lt;/li&gt; &lt;li&gt;with &#x60;beginning&#x60; match, you will only find it if the term matches the beginning or the whole string, e.g. &#x60;monk&#x60; and &#x60;monkey&#x60;&lt;/li&gt; &lt;li&gt;with &#x60;middle&#x60; match, you will find the it if the term matches any substring of the value, e.g. &#x60;onk&#x60; and &#x60;ke&#x60;&lt;/li&gt; &lt;/ul&gt;.
     * @type {'exact' | 'beginning' | 'middle'}
     * @memberof BetaApiSearchItemByField
     */
    readonly match?: 'exact' | 'beginning' | 'middle'

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof BetaApiSearchItemByField
     */
    readonly limit?: number

    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof BetaApiSearchItemByField
     */
    readonly cursor?: string
}

/**
 * Request parameters for searchLeads operation in BetaApi.
 * @export
 * @interface BetaApiSearchLeadsRequest
 */
export interface BetaApiSearchLeadsRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof BetaApiSearchLeads
     */
    readonly term: string

    /**
     * A comma-separated string array. The fields to perform the search from. Defaults to all of them.
     * @type {'custom_fields' | 'notes' | 'title'}
     * @memberof BetaApiSearchLeads
     */
    readonly fields?: 'custom_fields' | 'notes' | 'title'

    /**
     * When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @type {boolean}
     * @memberof BetaApiSearchLeads
     */
    readonly exact_match?: boolean

    /**
     * Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
     * @type {number}
     * @memberof BetaApiSearchLeads
     */
    readonly person_id?: number

    /**
     * Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
     * @type {number}
     * @memberof BetaApiSearchLeads
     */
    readonly organization_id?: number

    /**
     * Supports including optional fields in the results which are not provided by default
     * @type {'lead.was_seen'}
     * @memberof BetaApiSearchLeads
     */
    readonly include_fields?: 'lead.was_seen'

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof BetaApiSearchLeads
     */
    readonly limit?: number

    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof BetaApiSearchLeads
     */
    readonly cursor?: string
}

/**
 * Request parameters for searchOrganization operation in BetaApi.
 * @export
 * @interface BetaApiSearchOrganizationRequest
 */
export interface BetaApiSearchOrganizationRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof BetaApiSearchOrganization
     */
    readonly term: string

    /**
     * A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
     * @type {'address' | 'custom_fields' | 'notes' | 'name'}
     * @memberof BetaApiSearchOrganization
     */
    readonly fields?: 'address' | 'custom_fields' | 'notes' | 'name'

    /**
     * When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @type {boolean}
     * @memberof BetaApiSearchOrganization
     */
    readonly exact_match?: boolean

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof BetaApiSearchOrganization
     */
    readonly limit?: number

    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof BetaApiSearchOrganization
     */
    readonly cursor?: string
}

/**
 * Request parameters for searchPersons operation in BetaApi.
 * @export
 * @interface BetaApiSearchPersonsRequest
 */
export interface BetaApiSearchPersonsRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof BetaApiSearchPersons
     */
    readonly term: string

    /**
     * A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
     * @type {'custom_fields' | 'email' | 'notes' | 'phone' | 'name'}
     * @memberof BetaApiSearchPersons
     */
    readonly fields?: 'custom_fields' | 'email' | 'notes' | 'phone' | 'name'

    /**
     * When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @type {boolean}
     * @memberof BetaApiSearchPersons
     */
    readonly exact_match?: boolean

    /**
     * Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
     * @type {number}
     * @memberof BetaApiSearchPersons
     */
    readonly organization_id?: number

    /**
     * Supports including optional fields in the results which are not provided by default
     * @type {'person.picture'}
     * @memberof BetaApiSearchPersons
     */
    readonly include_fields?: 'person.picture'

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof BetaApiSearchPersons
     */
    readonly limit?: number

    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof BetaApiSearchPersons
     */
    readonly cursor?: string
}

/**
 * Request parameters for updateActivity operation in BetaApi.
 * @export
 * @interface BetaApiUpdateActivityRequest
 */
export interface BetaApiUpdateActivityRequest {
    /**
     * The ID of the activity
     * @type {number}
     * @memberof BetaApiUpdateActivity
     */
    readonly id: number

    /**
     * 
     * @type {AddActivityRequest}
     * @memberof BetaApiUpdateActivity
     */
    readonly AddActivityRequest?: AddActivityRequest
}

/**
 * Request parameters for updateAdditionalDiscount operation in BetaApi.
 * @export
 * @interface BetaApiUpdateAdditionalDiscountRequest
 */
export interface BetaApiUpdateAdditionalDiscountRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BetaApiUpdateAdditionalDiscount
     */
    readonly id: number

    /**
     * The ID of the discount
     * @type {number}
     * @memberof BetaApiUpdateAdditionalDiscount
     */
    readonly discount_id: number

    /**
     * 
     * @type {UpdateAdditionalDiscountRequestBody}
     * @memberof BetaApiUpdateAdditionalDiscount
     */
    readonly UpdateAdditionalDiscountRequestBody?: UpdateAdditionalDiscountRequestBody
}

/**
 * Request parameters for updateDeal operation in BetaApi.
 * @export
 * @interface BetaApiUpdateDealRequest
 */
export interface BetaApiUpdateDealRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BetaApiUpdateDeal
     */
    readonly id: number

    /**
     * 
     * @type {UpdateDealRequest}
     * @memberof BetaApiUpdateDeal
     */
    readonly UpdateDealRequest?: UpdateDealRequest
}

/**
 * Request parameters for updateDealProduct operation in BetaApi.
 * @export
 * @interface BetaApiUpdateDealProductRequest
 */
export interface BetaApiUpdateDealProductRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BetaApiUpdateDealProduct
     */
    readonly id: number

    /**
     * The ID of the deal-product (the ID of the product attached to the deal)
     * @type {number}
     * @memberof BetaApiUpdateDealProduct
     */
    readonly product_attachment_id: number

    /**
     * 
     * @type {UpdateDealProductRequest}
     * @memberof BetaApiUpdateDealProduct
     */
    readonly UpdateDealProductRequest?: UpdateDealProductRequest
}

/**
 * Request parameters for updateOrganization operation in BetaApi.
 * @export
 * @interface BetaApiUpdateOrganizationRequest
 */
export interface BetaApiUpdateOrganizationRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof BetaApiUpdateOrganization
     */
    readonly id: number

    /**
     * 
     * @type {UpdateOrganizationRequest}
     * @memberof BetaApiUpdateOrganization
     */
    readonly UpdateOrganizationRequest?: UpdateOrganizationRequest
}

/**
 * Request parameters for updatePerson operation in BetaApi.
 * @export
 * @interface BetaApiUpdatePersonRequest
 */
export interface BetaApiUpdatePersonRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof BetaApiUpdatePerson
     */
    readonly id: number

    /**
     * 
     * @type {UpdatePersonRequest}
     * @memberof BetaApiUpdatePerson
     */
    readonly UpdatePersonRequest?: UpdatePersonRequest
}

/**
 * BetaApi - object-oriented interface
 * @export
 * @class BetaApi
 * @extends {BaseAPI}
 */
export class BetaApi extends BaseAPI {
    /**
     * Adds a new activity.
     * @summary Add a new activity
     * @param {BetaApiAddActivityRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public addActivity(requestParameters: BetaApiAddActivityRequest = {}, ) {
        return BetaApiFp(this.configuration).addActivity(requestParameters.AddActivityRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new deal.
     * @summary Add a new deal
     * @param {BetaApiAddDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public addDeal(requestParameters: BetaApiAddDealRequest = {}, ) {
        return BetaApiFp(this.configuration).addDeal(requestParameters.AddDealRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a product to a deal, creating a new item called a deal-product.
     * @summary Add a product to a deal
     * @param {BetaApiAddDealProductRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public addDealProduct(requestParameters: BetaApiAddDealProductRequest, ) {
        return BetaApiFp(this.configuration).addDealProduct(requestParameters.id, requestParameters.AddDealProductRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new organization.
     * @summary Add a new organization
     * @param {BetaApiAddOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public addOrganization(requestParameters: BetaApiAddOrganizationRequest = {}, ) {
        return BetaApiFp(this.configuration).addOrganization(requestParameters.AddOrganizationRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new person.
     * @summary Add a new person
     * @param {BetaApiAddPersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public addPerson(requestParameters: BetaApiAddPersonRequest = {}, ) {
        return BetaApiFp(this.configuration).addPerson(requestParameters.AddPersonRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
     * @summary Delete an activity
     * @param {BetaApiDeleteActivityRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public deleteActivity(requestParameters: BetaApiDeleteActivityRequest, ) {
        return BetaApiFp(this.configuration).deleteActivity(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a discount from a deal, changing the deal value if the deal has one-time products attached.
     * @summary Delete a discount from a deal
     * @param {BetaApiDeleteAdditionalDiscountRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public deleteAdditionalDiscount(requestParameters: BetaApiDeleteAdditionalDiscountRequest, ) {
        return BetaApiFp(this.configuration).deleteAdditionalDiscount(requestParameters.id, requestParameters.discount_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
     * @summary Delete a deal
     * @param {BetaApiDeleteDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public deleteDeal(requestParameters: BetaApiDeleteDealRequest, ) {
        return BetaApiFp(this.configuration).deleteDeal(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a product attachment from a deal, using the `product_attachment_id`.
     * @summary Delete an attached product from a deal
     * @param {BetaApiDeleteDealProductRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public deleteDealProduct(requestParameters: BetaApiDeleteDealProductRequest, ) {
        return BetaApiFp(this.configuration).deleteDealProduct(requestParameters.id, requestParameters.product_attachment_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a organization as deleted. After 30 days, the organization will be permanently deleted.
     * @summary Delete a organization
     * @param {BetaApiDeleteOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public deleteOrganization(requestParameters: BetaApiDeleteOrganizationRequest, ) {
        return BetaApiFp(this.configuration).deleteOrganization(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a person as deleted. After 30 days, the person will be permanently deleted.
     * @summary Delete a person
     * @param {BetaApiDeletePersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public deletePerson(requestParameters: BetaApiDeletePersonRequest, ) {
        return BetaApiFp(this.configuration).deletePerson(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all activities.
     * @summary Get all activities
     * @param {BetaApiGetActivitiesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public getActivities(requestParameters: BetaApiGetActivitiesRequest = {}, ) {
        return BetaApiFp(this.configuration).getActivities(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.deal_id, requestParameters.lead_id, requestParameters.person_id, requestParameters.org_id, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a specific activity.
     * @summary Get details of an activity
     * @param {BetaApiGetActivityRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public getActivity(requestParameters: BetaApiGetActivityRequest, ) {
        return BetaApiFp(this.configuration).getActivity(requestParameters.id, requestParameters.include_fields, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists discounts attached to a deal.
     * @summary List discounts added to a deal
     * @param {BetaApiGetAdditionalDiscountsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public getAdditionalDiscounts(requestParameters: BetaApiGetAdditionalDiscountsRequest, ) {
        return BetaApiFp(this.configuration).getAdditionalDiscounts(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a specific deal.
     * @summary Get details of a deal
     * @param {BetaApiGetDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public getDeal(requestParameters: BetaApiGetDealRequest, ) {
        return BetaApiFp(this.configuration).getDeal(requestParameters.id, requestParameters.include_fields, requestParameters.custom_fields, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists products attached to a deal.
     * @summary List products attached to a deal
     * @param {BetaApiGetDealProductsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public getDealProducts(requestParameters: BetaApiGetDealProductsRequest, ) {
        return BetaApiFp(this.configuration).getDealProducts(requestParameters.id, requestParameters.cursor, requestParameters.limit, requestParameters.sort_by, requestParameters.sort_direction, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all deals.
     * @summary Get all deals
     * @param {BetaApiGetDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public getDeals(requestParameters: BetaApiGetDealsRequest = {}, ) {
        return BetaApiFp(this.configuration).getDeals(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.person_id, requestParameters.org_id, requestParameters.pipeline_id, requestParameters.stage_id, requestParameters.status, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.custom_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about products attached to deals
     * @summary Get deal products of several deals
     * @param {BetaApiGetDealsProductsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public getDealsProducts(requestParameters: BetaApiGetDealsProductsRequest, ) {
        return BetaApiFp(this.configuration).getDealsProducts(requestParameters.deal_ids, requestParameters.cursor, requestParameters.limit, requestParameters.sort_by, requestParameters.sort_direction, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a specific organization.
     * @summary Get details of a organization
     * @param {BetaApiGetOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public getOrganization(requestParameters: BetaApiGetOrganizationRequest, ) {
        return BetaApiFp(this.configuration).getOrganization(requestParameters.id, requestParameters.include_fields, requestParameters.custom_fields, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all organizations.
     * @summary Get all organizations
     * @param {BetaApiGetOrganizationsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public getOrganizations(requestParameters: BetaApiGetOrganizationsRequest = {}, ) {
        return BetaApiFp(this.configuration).getOrganizations(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.custom_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a specific person. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
     * @summary Get details of a person
     * @param {BetaApiGetPersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public getPerson(requestParameters: BetaApiGetPersonRequest, ) {
        return BetaApiFp(this.configuration).getPerson(requestParameters.id, requestParameters.include_fields, requestParameters.custom_fields, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all persons. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
     * @summary Get all persons
     * @param {BetaApiGetPersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public getPersons(requestParameters: BetaApiGetPersonsRequest = {}, ) {
        return BetaApiFp(this.configuration).getPersons(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.org_id, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.custom_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a discount to a deal changing, the deal value if the deal has one-time products attached.
     * @summary Add a discount to a deal
     * @param {BetaApiPostAdditionalDiscountRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public postAdditionalDiscount(requestParameters: BetaApiPostAdditionalDiscountRequest, ) {
        return BetaApiFp(this.configuration).postAdditionalDiscount(requestParameters.id, requestParameters.AddAdditionalDiscountRequestBody, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
     * @summary Search deals
     * @param {BetaApiSearchDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public searchDeals(requestParameters: BetaApiSearchDealsRequest, ) {
        return BetaApiFp(this.configuration).searchDeals(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.person_id, requestParameters.organization_id, requestParameters.status, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a search from your choice of item types and fields.
     * @summary Perform a search from multiple item types
     * @param {BetaApiSearchItemRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public searchItem(requestParameters: BetaApiSearchItemRequest, ) {
        return BetaApiFp(this.configuration).searchItem(requestParameters.term, requestParameters.item_types, requestParameters.fields, requestParameters.search_for_related_items, requestParameters.exact_match, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
     * @summary Perform a search using a specific field from an item type
     * @param {BetaApiSearchItemByFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public searchItemByField(requestParameters: BetaApiSearchItemByFieldRequest, ) {
        return BetaApiFp(this.configuration).searchItemByField(requestParameters.term, requestParameters.entity_type, requestParameters.field, requestParameters.match, requestParameters.limit, requestParameters.cursor, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
     * @summary Search leads
     * @param {BetaApiSearchLeadsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public searchLeads(requestParameters: BetaApiSearchLeadsRequest, ) {
        return BetaApiFp(this.configuration).searchLeads(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.person_id, requestParameters.organization_id, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
     * @summary Search organizations
     * @param {BetaApiSearchOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public searchOrganization(requestParameters: BetaApiSearchOrganizationRequest, ) {
        return BetaApiFp(this.configuration).searchOrganization(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.limit, requestParameters.cursor, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
     * @summary Search persons
     * @param {BetaApiSearchPersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public searchPersons(requestParameters: BetaApiSearchPersonsRequest, ) {
        return BetaApiFp(this.configuration).searchPersons(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.organization_id, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of an activity.
     * @summary Update an activity
     * @param {BetaApiUpdateActivityRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public updateActivity(requestParameters: BetaApiUpdateActivityRequest, ) {
        return BetaApiFp(this.configuration).updateActivity(requestParameters.id, requestParameters.AddActivityRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a discount added to a deal, changing the deal value if the deal has one-time products attached.
     * @summary Update a discount added to a deal
     * @param {BetaApiUpdateAdditionalDiscountRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public updateAdditionalDiscount(requestParameters: BetaApiUpdateAdditionalDiscountRequest, ) {
        return BetaApiFp(this.configuration).updateAdditionalDiscount(requestParameters.id, requestParameters.discount_id, requestParameters.UpdateAdditionalDiscountRequestBody, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of a deal.
     * @summary Update a deal
     * @param {BetaApiUpdateDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public updateDeal(requestParameters: BetaApiUpdateDealRequest, ) {
        return BetaApiFp(this.configuration).updateDeal(requestParameters.id, requestParameters.UpdateDealRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the details of the product that has been attached to a deal.
     * @summary Update the product attached to a deal
     * @param {BetaApiUpdateDealProductRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public updateDealProduct(requestParameters: BetaApiUpdateDealProductRequest, ) {
        return BetaApiFp(this.configuration).updateDealProduct(requestParameters.id, requestParameters.product_attachment_id, requestParameters.UpdateDealProductRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of a organization.
     * @summary Update a organization
     * @param {BetaApiUpdateOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public updateOrganization(requestParameters: BetaApiUpdateOrganizationRequest, ) {
        return BetaApiFp(this.configuration).updateOrganization(requestParameters.id, requestParameters.UpdateOrganizationRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of a person.
     * @summary Update a person
     * @param {BetaApiUpdatePersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    public updatePerson(requestParameters: BetaApiUpdatePersonRequest, ) {
        return BetaApiFp(this.configuration).updatePerson(requestParameters.id, requestParameters.UpdatePersonRequest, ).then((request) => request(this.axios, this.basePath));
    }
}
