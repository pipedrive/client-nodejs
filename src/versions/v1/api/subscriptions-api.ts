/* tslint:disable */
/* eslint-disable */
/**
 * Pipedrive API v1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AddRecurringSubscriptionRequest } from '../models';
// @ts-ignore
import { AddSubscriptionInstallmentRequest } from '../models';
// @ts-ignore
import { CancelRecurringSubscriptionRequest } from '../models';
// @ts-ignore
import { GetPaymentsResponse } from '../models';
// @ts-ignore
import { GetSubscriptionsIdResponse } from '../models';
// @ts-ignore
import { UpdateRecurringSubscriptionRequest } from '../models';
// @ts-ignore
import { UpdateSubscriptionInstallmentRequest } from '../models';
/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new recurring subscription.
         * @summary Add a recurring subscription
         * @param {AddRecurringSubscriptionRequest} [AddRecurringSubscriptionRequest] 

         * @throws {RequiredError}
         */
        addRecurringSubscription: async (AddRecurringSubscriptionRequest?: AddRecurringSubscriptionRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions/recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddRecurringSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new installment subscription.
         * @summary Add an installment subscription
         * @param {AddSubscriptionInstallmentRequest} [AddSubscriptionInstallmentRequest] 

         * @throws {RequiredError}
         */
        addSubscriptionInstallment: async (AddSubscriptionInstallmentRequest?: AddSubscriptionInstallmentRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions/installment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddSubscriptionInstallmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a recurring subscription.
         * @summary Cancel a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {CancelRecurringSubscriptionRequest} [CancelRecurringSubscriptionRequest] 

         * @throws {RequiredError}
         */
        cancelRecurringSubscription: async (id: number, CancelRecurringSubscriptionRequest?: CancelRecurringSubscriptionRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelRecurringSubscription', 'id', id)
            const localVarPath = `/subscriptions/recurring/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(CancelRecurringSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an installment or a recurring subscription as deleted.
         * @summary Delete a subscription
         * @param {number} id The ID of the subscription

         * @throws {RequiredError}
         */
        deleteSubscription: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSubscription', 'id', id)
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of an installment or a recurring subscription by the deal ID.
         * @summary Find subscription by deal
         * @param {number} dealId The ID of the deal

         * @throws {RequiredError}
         */
        findSubscriptionByDeal: async (dealId: number, ): Promise<RequestArgs> => {
            // verify required parameter 'dealId' is not null or undefined
            assertParamExists('findSubscriptionByDeal', 'dealId', dealId)
            const localVarPath = `/subscriptions/find/{dealId}`
                .replace(`{${"dealId"}}`, encodeURIComponent(String(dealId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of an installment or a recurring subscription.
         * @summary Get details of a subscription
         * @param {number} id The ID of the subscription

         * @throws {RequiredError}
         */
        getSubscription: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubscription', 'id', id)
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payments of an installment or recurring subscription.
         * @summary Get all payments of a subscription
         * @param {number} id The ID of the subscription

         * @throws {RequiredError}
         */
        getSubscriptionPayments: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubscriptionPayments', 'id', id)
            const localVarPath = `/subscriptions/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a recurring subscription.
         * @summary Update a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateRecurringSubscriptionRequest} [UpdateRecurringSubscriptionRequest] 

         * @throws {RequiredError}
         */
        updateRecurringSubscription: async (id: number, UpdateRecurringSubscriptionRequest?: UpdateRecurringSubscriptionRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecurringSubscription', 'id', id)
            const localVarPath = `/subscriptions/recurring/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateRecurringSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an installment subscription.
         * @summary Update an installment subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateSubscriptionInstallmentRequest} [UpdateSubscriptionInstallmentRequest] 

         * @throws {RequiredError}
         */
        updateSubscriptionInstallment: async (id: number, UpdateSubscriptionInstallmentRequest?: UpdateSubscriptionInstallmentRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSubscriptionInstallment', 'id', id)
            const localVarPath = `/subscriptions/installment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateSubscriptionInstallmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};


/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new recurring subscription.
         * @summary Add a recurring subscription
         * @param {AddRecurringSubscriptionRequest} [AddRecurringSubscriptionRequest] 

         * @throws {RequiredError}
         */
        async addRecurringSubscription(AddRecurringSubscriptionRequest?: AddRecurringSubscriptionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetSubscriptionsIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRecurringSubscription(AddRecurringSubscriptionRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new installment subscription.
         * @summary Add an installment subscription
         * @param {AddSubscriptionInstallmentRequest} [AddSubscriptionInstallmentRequest] 

         * @throws {RequiredError}
         */
        async addSubscriptionInstallment(AddSubscriptionInstallmentRequest?: AddSubscriptionInstallmentRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetSubscriptionsIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSubscriptionInstallment(AddSubscriptionInstallmentRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels a recurring subscription.
         * @summary Cancel a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {CancelRecurringSubscriptionRequest} [CancelRecurringSubscriptionRequest] 

         * @throws {RequiredError}
         */
        async cancelRecurringSubscription(id: number, CancelRecurringSubscriptionRequest?: CancelRecurringSubscriptionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetSubscriptionsIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelRecurringSubscription(id, CancelRecurringSubscriptionRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks an installment or a recurring subscription as deleted.
         * @summary Delete a subscription
         * @param {number} id The ID of the subscription

         * @throws {RequiredError}
         */
        async deleteSubscription(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetSubscriptionsIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscription(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns details of an installment or a recurring subscription by the deal ID.
         * @summary Find subscription by deal
         * @param {number} dealId The ID of the deal

         * @throws {RequiredError}
         */
        async findSubscriptionByDeal(dealId: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetSubscriptionsIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSubscriptionByDeal(dealId, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns details of an installment or a recurring subscription.
         * @summary Get details of a subscription
         * @param {number} id The ID of the subscription

         * @throws {RequiredError}
         */
        async getSubscription(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetSubscriptionsIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all payments of an installment or recurring subscription.
         * @summary Get all payments of a subscription
         * @param {number} id The ID of the subscription

         * @throws {RequiredError}
         */
        async getSubscriptionPayments(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPaymentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionPayments(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a recurring subscription.
         * @summary Update a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateRecurringSubscriptionRequest} [UpdateRecurringSubscriptionRequest] 

         * @throws {RequiredError}
         */
        async updateRecurringSubscription(id: number, UpdateRecurringSubscriptionRequest?: UpdateRecurringSubscriptionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetSubscriptionsIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecurringSubscription(id, UpdateRecurringSubscriptionRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an installment subscription.
         * @summary Update an installment subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateSubscriptionInstallmentRequest} [UpdateSubscriptionInstallmentRequest] 

         * @throws {RequiredError}
         */
        async updateSubscriptionInstallment(id: number, UpdateSubscriptionInstallmentRequest?: UpdateSubscriptionInstallmentRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetSubscriptionsIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionInstallment(id, UpdateSubscriptionInstallmentRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * Adds a new recurring subscription.
         * @summary Add a recurring subscription
         * @param {SubscriptionsApiAddRecurringSubscriptionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addRecurringSubscription(requestParameters: SubscriptionsApiAddRecurringSubscriptionRequest = {}, ): Promise<GetSubscriptionsIdResponse> {
            return localVarFp.addRecurringSubscription(requestParameters.AddRecurringSubscriptionRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new installment subscription.
         * @summary Add an installment subscription
         * @param {SubscriptionsApiAddSubscriptionInstallmentRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addSubscriptionInstallment(requestParameters: SubscriptionsApiAddSubscriptionInstallmentRequest = {}, ): Promise<GetSubscriptionsIdResponse> {
            return localVarFp.addSubscriptionInstallment(requestParameters.AddSubscriptionInstallmentRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a recurring subscription.
         * @summary Cancel a recurring subscription
         * @param {SubscriptionsApiCancelRecurringSubscriptionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        cancelRecurringSubscription(requestParameters: SubscriptionsApiCancelRecurringSubscriptionRequest, ): Promise<GetSubscriptionsIdResponse> {
            return localVarFp.cancelRecurringSubscription(requestParameters.id, requestParameters.CancelRecurringSubscriptionRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks an installment or a recurring subscription as deleted.
         * @summary Delete a subscription
         * @param {SubscriptionsApiDeleteSubscriptionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteSubscription(requestParameters: SubscriptionsApiDeleteSubscriptionRequest, ): Promise<GetSubscriptionsIdResponse> {
            return localVarFp.deleteSubscription(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of an installment or a recurring subscription by the deal ID.
         * @summary Find subscription by deal
         * @param {SubscriptionsApiFindSubscriptionByDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        findSubscriptionByDeal(requestParameters: SubscriptionsApiFindSubscriptionByDealRequest, ): Promise<GetSubscriptionsIdResponse> {
            return localVarFp.findSubscriptionByDeal(requestParameters.dealId, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of an installment or a recurring subscription.
         * @summary Get details of a subscription
         * @param {SubscriptionsApiGetSubscriptionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getSubscription(requestParameters: SubscriptionsApiGetSubscriptionRequest, ): Promise<GetSubscriptionsIdResponse> {
            return localVarFp.getSubscription(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all payments of an installment or recurring subscription.
         * @summary Get all payments of a subscription
         * @param {SubscriptionsApiGetSubscriptionPaymentsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getSubscriptionPayments(requestParameters: SubscriptionsApiGetSubscriptionPaymentsRequest, ): Promise<GetPaymentsResponse> {
            return localVarFp.getSubscriptionPayments(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates a recurring subscription.
         * @summary Update a recurring subscription
         * @param {SubscriptionsApiUpdateRecurringSubscriptionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateRecurringSubscription(requestParameters: SubscriptionsApiUpdateRecurringSubscriptionRequest, ): Promise<GetSubscriptionsIdResponse> {
            return localVarFp.updateRecurringSubscription(requestParameters.id, requestParameters.UpdateRecurringSubscriptionRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates an installment subscription.
         * @summary Update an installment subscription
         * @param {SubscriptionsApiUpdateSubscriptionInstallmentRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateSubscriptionInstallment(requestParameters: SubscriptionsApiUpdateSubscriptionInstallmentRequest, ): Promise<GetSubscriptionsIdResponse> {
            return localVarFp.updateSubscriptionInstallment(requestParameters.id, requestParameters.UpdateSubscriptionInstallmentRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addRecurringSubscription operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiAddRecurringSubscriptionRequest
 */
export interface SubscriptionsApiAddRecurringSubscriptionRequest {
    /**
     * 
     * @type {AddRecurringSubscriptionRequest}
     * @memberof SubscriptionsApiAddRecurringSubscription
     */
    readonly AddRecurringSubscriptionRequest?: AddRecurringSubscriptionRequest
}

/**
 * Request parameters for addSubscriptionInstallment operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiAddSubscriptionInstallmentRequest
 */
export interface SubscriptionsApiAddSubscriptionInstallmentRequest {
    /**
     * 
     * @type {AddSubscriptionInstallmentRequest}
     * @memberof SubscriptionsApiAddSubscriptionInstallment
     */
    readonly AddSubscriptionInstallmentRequest?: AddSubscriptionInstallmentRequest
}

/**
 * Request parameters for cancelRecurringSubscription operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiCancelRecurringSubscriptionRequest
 */
export interface SubscriptionsApiCancelRecurringSubscriptionRequest {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsApiCancelRecurringSubscription
     */
    readonly id: number

    /**
     * 
     * @type {CancelRecurringSubscriptionRequest}
     * @memberof SubscriptionsApiCancelRecurringSubscription
     */
    readonly CancelRecurringSubscriptionRequest?: CancelRecurringSubscriptionRequest
}

/**
 * Request parameters for deleteSubscription operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiDeleteSubscriptionRequest
 */
export interface SubscriptionsApiDeleteSubscriptionRequest {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsApiDeleteSubscription
     */
    readonly id: number
}

/**
 * Request parameters for findSubscriptionByDeal operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiFindSubscriptionByDealRequest
 */
export interface SubscriptionsApiFindSubscriptionByDealRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof SubscriptionsApiFindSubscriptionByDeal
     */
    readonly dealId: number
}

/**
 * Request parameters for getSubscription operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiGetSubscriptionRequest
 */
export interface SubscriptionsApiGetSubscriptionRequest {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsApiGetSubscription
     */
    readonly id: number
}

/**
 * Request parameters for getSubscriptionPayments operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiGetSubscriptionPaymentsRequest
 */
export interface SubscriptionsApiGetSubscriptionPaymentsRequest {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsApiGetSubscriptionPayments
     */
    readonly id: number
}

/**
 * Request parameters for updateRecurringSubscription operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiUpdateRecurringSubscriptionRequest
 */
export interface SubscriptionsApiUpdateRecurringSubscriptionRequest {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsApiUpdateRecurringSubscription
     */
    readonly id: number

    /**
     * 
     * @type {UpdateRecurringSubscriptionRequest}
     * @memberof SubscriptionsApiUpdateRecurringSubscription
     */
    readonly UpdateRecurringSubscriptionRequest?: UpdateRecurringSubscriptionRequest
}

/**
 * Request parameters for updateSubscriptionInstallment operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiUpdateSubscriptionInstallmentRequest
 */
export interface SubscriptionsApiUpdateSubscriptionInstallmentRequest {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsApiUpdateSubscriptionInstallment
     */
    readonly id: number

    /**
     * 
     * @type {UpdateSubscriptionInstallmentRequest}
     * @memberof SubscriptionsApiUpdateSubscriptionInstallment
     */
    readonly UpdateSubscriptionInstallmentRequest?: UpdateSubscriptionInstallmentRequest
}

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * Adds a new recurring subscription.
     * @summary Add a recurring subscription
     * @param {SubscriptionsApiAddRecurringSubscriptionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public addRecurringSubscription(requestParameters: SubscriptionsApiAddRecurringSubscriptionRequest = {}, ) {
        return SubscriptionsApiFp(this.configuration).addRecurringSubscription(requestParameters.AddRecurringSubscriptionRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new installment subscription.
     * @summary Add an installment subscription
     * @param {SubscriptionsApiAddSubscriptionInstallmentRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public addSubscriptionInstallment(requestParameters: SubscriptionsApiAddSubscriptionInstallmentRequest = {}, ) {
        return SubscriptionsApiFp(this.configuration).addSubscriptionInstallment(requestParameters.AddSubscriptionInstallmentRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a recurring subscription.
     * @summary Cancel a recurring subscription
     * @param {SubscriptionsApiCancelRecurringSubscriptionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public cancelRecurringSubscription(requestParameters: SubscriptionsApiCancelRecurringSubscriptionRequest, ) {
        return SubscriptionsApiFp(this.configuration).cancelRecurringSubscription(requestParameters.id, requestParameters.CancelRecurringSubscriptionRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks an installment or a recurring subscription as deleted.
     * @summary Delete a subscription
     * @param {SubscriptionsApiDeleteSubscriptionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public deleteSubscription(requestParameters: SubscriptionsApiDeleteSubscriptionRequest, ) {
        return SubscriptionsApiFp(this.configuration).deleteSubscription(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details of an installment or a recurring subscription by the deal ID.
     * @summary Find subscription by deal
     * @param {SubscriptionsApiFindSubscriptionByDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public findSubscriptionByDeal(requestParameters: SubscriptionsApiFindSubscriptionByDealRequest, ) {
        return SubscriptionsApiFp(this.configuration).findSubscriptionByDeal(requestParameters.dealId, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details of an installment or a recurring subscription.
     * @summary Get details of a subscription
     * @param {SubscriptionsApiGetSubscriptionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscription(requestParameters: SubscriptionsApiGetSubscriptionRequest, ) {
        return SubscriptionsApiFp(this.configuration).getSubscription(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all payments of an installment or recurring subscription.
     * @summary Get all payments of a subscription
     * @param {SubscriptionsApiGetSubscriptionPaymentsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscriptionPayments(requestParameters: SubscriptionsApiGetSubscriptionPaymentsRequest, ) {
        return SubscriptionsApiFp(this.configuration).getSubscriptionPayments(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a recurring subscription.
     * @summary Update a recurring subscription
     * @param {SubscriptionsApiUpdateRecurringSubscriptionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public updateRecurringSubscription(requestParameters: SubscriptionsApiUpdateRecurringSubscriptionRequest, ) {
        return SubscriptionsApiFp(this.configuration).updateRecurringSubscription(requestParameters.id, requestParameters.UpdateRecurringSubscriptionRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an installment subscription.
     * @summary Update an installment subscription
     * @param {SubscriptionsApiUpdateSubscriptionInstallmentRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public updateSubscriptionInstallment(requestParameters: SubscriptionsApiUpdateSubscriptionInstallmentRequest, ) {
        return SubscriptionsApiFp(this.configuration).updateSubscriptionInstallment(requestParameters.id, requestParameters.UpdateSubscriptionInstallmentRequest, ).then((request) => request(this.axios, this.basePath));
    }
}
