/* tslint:disable */
/* eslint-disable */
/**
 * Pipedrive API v1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
	assertParamExists,
	createRequestFunction,
	DUMMY_BASE_URL,
	serializeDataIfNeeded,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	toPathString
} from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequestArgs, RequiredError } from './base';

/**
 *
 * @export
 * @interface ActivityCollectionResponseObject
 */
export interface ActivityCollectionResponseObject {
    /**
     * The due date of the activity. Format: YYYY-MM-DD
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'due_date'?: string;
    /**
     * The due time of the activity in UTC. Format: HH:MM
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'due_time'?: string;
    /**
     * The duration of the activity. Format: HH:MM
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'duration'?: string;
    /**
     * The ID of the deal this activity is associated with
     * @type {number}
     * @memberof ActivityCollectionResponseObject
     */
    'deal_id'?: number;
    /**
     * The ID of the lead in the UUID format this activity is associated with
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'lead_id'?: string | null;
    /**
     * The ID of the person this activity is associated with
     * @type {number}
     * @memberof ActivityCollectionResponseObject
     */
    'person_id'?: number;
    /**
     * The ID of the project this activity is associated with
     * @type {number}
     * @memberof ActivityCollectionResponseObject
     */
    'project_id'?: number | null;
    /**
     * The ID of the organization this activity is associated with
     * @type {number}
     * @memberof ActivityCollectionResponseObject
     */
    'org_id'?: number;
    /**
     * The address of the activity. Pipedrive will automatically check if the location matches a geo-location on Google maps.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'location'?: string;
    /**
     * Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'public_description'?: string;
    /**
     * The ID of the activity, generated when the activity was created
     * @type {number}
     * @memberof ActivityCollectionResponseObject
     */
    'id'?: number;
    /**
     * Whether the activity is done or not
     * @type {boolean}
     * @memberof ActivityCollectionResponseObject
     */
    'done'?: boolean;
    /**
     * The subject of the activity
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'subject'?: string;
    /**
     * The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'type'?: string;
    /**
     * The ID of the user whom the activity is assigned to
     * @type {number}
     * @memberof ActivityCollectionResponseObject
     */
    'user_id'?: number;
    /**
     * Marks if the activity is set as \'Busy\' or \'Free\'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to \'Busy\' if it has a time set, and \'Free\' if it is an all-day event without specified time.
     * @type {boolean}
     * @memberof ActivityCollectionResponseObject
     */
    'busy_flag'?: boolean;
    /**
     * The user\'s company ID
     * @type {number}
     * @memberof ActivityCollectionResponseObject
     */
    'company_id'?: number;
    /**
     * The ID of the Marketplace app, which is connected to this activity
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'conference_meeting_client'?: string;
    /**
     * The link to join the meeting which is associated with this activity
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'conference_meeting_url'?: string;
    /**
     * The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'conference_meeting_id'?: string;
    /**
     * The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'add_time'?: string;
    /**
     * The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'marked_as_done_time'?: string;
    /**
     * Whether the activity is active or not
     * @type {boolean}
     * @memberof ActivityCollectionResponseObject
     */
    'active_flag'?: boolean;
    /**
     * The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'update_time'?: string;
    /**
     * The ID of the user who was the last to update this activity
     * @type {number}
     * @memberof ActivityCollectionResponseObject
     */
    'update_user_id'?: number;
    /**
     * The timezone the activity was created in an external calendar
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'source_timezone'?: string;
    /**
     * A subfield of the location field. Indicates apartment/suite number.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'location_subpremise'?: string;
    /**
     * A subfield of the location field. Indicates house number.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'location_street_number'?: string;
    /**
     * A subfield of the location field. Indicates street name.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'location_route'?: string;
    /**
     * A subfield of the location field. Indicates district/sublocality.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'location_sublocality'?: string;
    /**
     * A subfield of the location field. Indicates city/town/village/locality.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'location_locality'?: string;
    /**
     * A subfield of the location field. Indicates state/county.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'location_admin_area_level_1'?: string;
    /**
     * A subfield of the location field. Indicates region.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'location_admin_area_level_2'?: string;
    /**
     * A subfield of the location field. Indicates country.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'location_country'?: string;
    /**
     * A subfield of the location field. Indicates ZIP/postal code.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'location_postal_code'?: string;
    /**
     * A subfield of the location field. Indicates full/combined address.
     * @type {string}
     * @memberof ActivityCollectionResponseObject
     */
    'location_formatted_address'?: string;
}
/**
 *
 * @export
 * @interface ActivityCollectionResponseObjectAllOf
 */
export interface ActivityCollectionResponseObjectAllOf {
    /**
     * The ID of the activity, generated when the activity was created
     * @type {number}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'id'?: number;
    /**
     * Whether the activity is done or not
     * @type {boolean}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'done'?: boolean;
    /**
     * The subject of the activity
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'subject'?: string;
    /**
     * The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'type'?: string;
    /**
     * The ID of the user whom the activity is assigned to
     * @type {number}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'user_id'?: number;
    /**
     * Marks if the activity is set as \'Busy\' or \'Free\'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to \'Busy\' if it has a time set, and \'Free\' if it is an all-day event without specified time.
     * @type {boolean}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'busy_flag'?: boolean;
    /**
     * The user\'s company ID
     * @type {number}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'company_id'?: number;
    /**
     * The ID of the Marketplace app, which is connected to this activity
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'conference_meeting_client'?: string;
    /**
     * The link to join the meeting which is associated with this activity
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'conference_meeting_url'?: string;
    /**
     * The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'conference_meeting_id'?: string;
    /**
     * The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'add_time'?: string;
    /**
     * The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'marked_as_done_time'?: string;
    /**
     * Whether the activity is active or not
     * @type {boolean}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'active_flag'?: boolean;
    /**
     * The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'update_time'?: string;
    /**
     * The ID of the user who was the last to update this activity
     * @type {number}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'update_user_id'?: number;
    /**
     * The timezone the activity was created in an external calendar
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'source_timezone'?: string;
    /**
     * A subfield of the location field. Indicates apartment/suite number.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'location_subpremise'?: string;
    /**
     * A subfield of the location field. Indicates house number.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'location_street_number'?: string;
    /**
     * A subfield of the location field. Indicates street name.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'location_route'?: string;
    /**
     * A subfield of the location field. Indicates district/sublocality.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'location_sublocality'?: string;
    /**
     * A subfield of the location field. Indicates city/town/village/locality.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'location_locality'?: string;
    /**
     * A subfield of the location field. Indicates state/county.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'location_admin_area_level_1'?: string;
    /**
     * A subfield of the location field. Indicates region.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'location_admin_area_level_2'?: string;
    /**
     * A subfield of the location field. Indicates country.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'location_country'?: string;
    /**
     * A subfield of the location field. Indicates ZIP/postal code.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'location_postal_code'?: string;
    /**
     * A subfield of the location field. Indicates full/combined address.
     * @type {string}
     * @memberof ActivityCollectionResponseObjectAllOf
     */
    'location_formatted_address'?: string;
}
/**
 *
 * @export
 * @interface ActivityDistributionDataWithAdditionalData
 */
export interface ActivityDistributionDataWithAdditionalData {
    /**
     *
     * @type {ActivityDistributionDataWithAdditionalDataAllOfActivityDistribution}
     * @memberof ActivityDistributionDataWithAdditionalData
     */
    'activity_distribution'?: ActivityDistributionDataWithAdditionalDataAllOfActivityDistribution;
    /**
     * Pagination start
     * @type {number}
     * @memberof ActivityDistributionDataWithAdditionalData
     */
    'start'?: number;
    /**
     * Items shown per page
     * @type {number}
     * @memberof ActivityDistributionDataWithAdditionalData
     */
    'limit'?: number;
    /**
     * If there are more list items in the collection than displayed or not
     * @type {boolean}
     * @memberof ActivityDistributionDataWithAdditionalData
     */
    'more_items_in_collection'?: boolean;
}
/**
 *
 * @export
 * @interface ActivityDistributionDataWithAdditionalDataAllOf
 */
export interface ActivityDistributionDataWithAdditionalDataAllOf {
    /**
     *
     * @type {ActivityDistributionDataWithAdditionalDataAllOfActivityDistribution}
     * @memberof ActivityDistributionDataWithAdditionalDataAllOf
     */
    'activity_distribution'?: ActivityDistributionDataWithAdditionalDataAllOfActivityDistribution;
}
/**
 * The distribution of activities related to the organization grouped by the user ID
 * @export
 * @interface ActivityDistributionDataWithAdditionalDataAllOfActivityDistribution
 */
export interface ActivityDistributionDataWithAdditionalDataAllOfActivityDistribution {
    /**
     *
     * @type {ActivityDistributionDataWithAdditionalDataAllOfActivityDistributionASSIGNEDTOUSERID}
     * @memberof ActivityDistributionDataWithAdditionalDataAllOfActivityDistribution
     */
    'ASSIGNED_TO_USER_ID'?: ActivityDistributionDataWithAdditionalDataAllOfActivityDistributionASSIGNEDTOUSERID;
}
/**
 * The ID of the user
 * @export
 * @interface ActivityDistributionDataWithAdditionalDataAllOfActivityDistributionASSIGNEDTOUSERID
 */
export interface ActivityDistributionDataWithAdditionalDataAllOfActivityDistributionASSIGNEDTOUSERID {
    /**
     *
     * @type {ActivityDistributionDataWithAdditionalDataAllOfActivityDistributionASSIGNEDTOUSERIDActivities}
     * @memberof ActivityDistributionDataWithAdditionalDataAllOfActivityDistributionASSIGNEDTOUSERID
     */
    'activities'?: ActivityDistributionDataWithAdditionalDataAllOfActivityDistributionASSIGNEDTOUSERIDActivities;
    /**
     * The name of the user
     * @type {string}
     * @memberof ActivityDistributionDataWithAdditionalDataAllOfActivityDistributionASSIGNEDTOUSERID
     */
    'name'?: string;
    /**
     * The overall count of activities for the user
     * @type {number}
     * @memberof ActivityDistributionDataWithAdditionalDataAllOfActivityDistributionASSIGNEDTOUSERID
     */
    'activity_count'?: number;
    /**
     * The percentage of activities belongs to the user
     * @type {number}
     * @memberof ActivityDistributionDataWithAdditionalDataAllOfActivityDistributionASSIGNEDTOUSERID
     */
    'share'?: number;
}
/**
 * The count of activities related to the user grouped by activity type
 * @export
 * @interface ActivityDistributionDataWithAdditionalDataAllOfActivityDistributionASSIGNEDTOUSERIDActivities
 */
export interface ActivityDistributionDataWithAdditionalDataAllOfActivityDistributionASSIGNEDTOUSERIDActivities {
    /**
     * The count of activities related to a specific type
     * @type {number}
     * @memberof ActivityDistributionDataWithAdditionalDataAllOfActivityDistributionASSIGNEDTOUSERIDActivities
     */
    'ACTIVITY_TYPE_NAME'?: number;
}
/**
 *
 * @export
 * @interface ActivityResponseObject
 */
export interface ActivityResponseObject {
    /**
     * The due date of the activity. Format: YYYY-MM-DD
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'due_date'?: string;
    /**
     * The due time of the activity in UTC. Format: HH:MM
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'due_time'?: string;
    /**
     * The duration of the activity. Format: HH:MM
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'duration'?: string;
    /**
     * The ID of the deal this activity is associated with
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'deal_id'?: number;
    /**
     * The ID of the lead in the UUID format this activity is associated with
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'lead_id'?: string | null;
    /**
     * The ID of the person this activity is associated with
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'person_id'?: number;
    /**
     * The ID of the project this activity is associated with
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'project_id'?: number | null;
    /**
     * The ID of the organization this activity is associated with
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'org_id'?: number;
    /**
     * The address of the activity. Pipedrive will automatically check if the location matches a geo-location on Google maps.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'location'?: string;
    /**
     * Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'public_description'?: string;
    /**
     * The ID of the activity, generated when the activity was created
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'id'?: number;
    /**
     * The note of the activity (HTML format)
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'note'?: string;
    /**
     * Whether the activity is done or not
     * @type {boolean}
     * @memberof ActivityResponseObject
     */
    'done'?: boolean;
    /**
     * The subject of the activity
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'subject'?: string;
    /**
     * The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'type'?: string;
    /**
     * The ID of the user whom the activity is assigned to
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'user_id'?: number;
    /**
     * List of multiple persons (participants) this activity is associated with
     * @type {Array<object>}
     * @memberof ActivityResponseObject
     */
    'participants'?: Array<object> | null;
    /**
     * Marks if the activity is set as \'Busy\' or \'Free\'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to \'Busy\' if it has a time set, and \'Free\' if it is an all-day event without specified time.
     * @type {boolean}
     * @memberof ActivityResponseObject
     */
    'busy_flag'?: boolean;
    /**
     * The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address.
     * @type {Array<object>}
     * @memberof ActivityResponseObject
     */
    'attendees'?: Array<object> | null;
    /**
     * The user\'s company ID
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'company_id'?: number;
    /**
     * If the activity references some other object, it is indicated here. For example, value `Salesphone` refers to activities created with Caller.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'reference_type'?: string;
    /**
     * Together with the `reference_type`, gives the ID of the other object
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'reference_id'?: number;
    /**
     * The ID of the Marketplace app, which is connected to this activity
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'conference_meeting_client'?: string;
    /**
     * The link to join the meeting which is associated with this activity
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'conference_meeting_url'?: string;
    /**
     * The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'conference_meeting_id'?: string;
    /**
     * The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'add_time'?: string;
    /**
     * The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'marked_as_done_time'?: string;
    /**
     * The date and time of latest notifications sent about this activity to the participants or the attendees of this activity
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'last_notification_time'?: string;
    /**
     * The ID of the user who triggered the sending of the latest notifications about this activity to the participants or the attendees of this activity
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'last_notification_user_id'?: number;
    /**
     * The ID of the language the notifications are sent in
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'notification_language_id'?: number;
    /**
     * Whether the activity is active or not
     * @type {boolean}
     * @memberof ActivityResponseObject
     */
    'active_flag'?: boolean;
    /**
     * The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'update_time'?: string;
    /**
     * The ID of the user who was the last to update this activity
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'update_user_id'?: number;
    /**
     * For the activity which syncs to Google calendar, this is the Google event ID. NB! This field is related to old Google calendar sync and will be deprecated soon.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'gcal_event_id'?: string;
    /**
     * The Google calendar ID that this activity syncs to. NB! This field is related to old Google calendar sync and will be deprecated soon.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'google_calendar_id'?: string;
    /**
     * The Google calendar API etag (version) that is used for syncing this activity. NB! This field is related to old Google calendar sync and will be deprecated soon.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'google_calendar_etag'?: string;
    /**
     * For activities that sync to an external calendar, this setting indicates if the activity syncs with context (what are the deals, persons, organizations this activity is related to)
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'calendar_sync_include_context'?: string;
    /**
     * The timezone the activity was created in an external calendar
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'source_timezone'?: string;
    /**
     * The rule for the recurrence of the activity. Is important for activities synced into Pipedrive from an external calendar. Example: \"RRULE:FREQ=WEEKLY;BYDAY=WE\"
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'rec_rule'?: string;
    /**
     * Additional rules for the recurrence of the activity, extend the `rec_rule`. Is important for activities synced into Pipedrive from an external calendar.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'rec_rule_extension'?: string;
    /**
     * The ID of parent activity for a recurrent activity if the current activity is an exception to recurrence rules
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'rec_master_activity_id'?: number;
    /**
     * The list of recurring activity instances. It is in a structure as follows: `[{due_date: \"2020-06-24\", due_time: \"10:00:00\"}]`
     * @type {Array<object>}
     * @memberof ActivityResponseObject
     */
    'series'?: Array<object>;
    /**
     * The ID of the user who created the activity
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'created_by_user_id'?: number;
    /**
     * A subfield of the location field. Indicates apartment/suite number.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'location_subpremise'?: string;
    /**
     * A subfield of the location field. Indicates house number.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'location_street_number'?: string;
    /**
     * A subfield of the location field. Indicates street name.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'location_route'?: string;
    /**
     * A subfield of the location field. Indicates district/sublocality.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'location_sublocality'?: string;
    /**
     * A subfield of the location field. Indicates city/town/village/locality.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'location_locality'?: string;
    /**
     * A subfield of the location field. Indicates state/county.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'location_admin_area_level_1'?: string;
    /**
     * A subfield of the location field. Indicates region.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'location_admin_area_level_2'?: string;
    /**
     * A subfield of the location field. Indicates country.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'location_country'?: string;
    /**
     * A subfield of the location field. Indicates ZIP/postal code.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'location_postal_code'?: string;
    /**
     * A subfield of the location field. Indicates full/combined address.
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'location_formatted_address'?: string;
    /**
     * The name of the organization this activity is associated with
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'org_name'?: string;
    /**
     * The name of the person this activity is associated with
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'person_name'?: string;
    /**
     * The name of the deal this activity is associated with
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'deal_title'?: string;
    /**
     * The name of the user this activity is owned by
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'owner_name'?: string;
    /**
     * The BCC email address of the person
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'person_dropbox_bcc'?: string;
    /**
     * The BCC email address of the deal
     * @type {string}
     * @memberof ActivityResponseObject
     */
    'deal_dropbox_bcc'?: string;
    /**
     * The ID of the user to whom the activity is assigned to. Equal to `user_id`.
     * @type {number}
     * @memberof ActivityResponseObject
     */
    'assigned_to_user_id'?: number;
    /**
     * The file that is attached to this activity. For example, this can be a reference to an audio note file generated with Pipedrive mobile app.
     * @type {object}
     * @memberof ActivityResponseObject
     */
    'file'?: object;
}
/**
 *
 * @export
 * @interface ActivityResponseObjectAllOf
 */
export interface ActivityResponseObjectAllOf {
    /**
     * The due date of the activity. Format: YYYY-MM-DD
     * @type {string}
     * @memberof ActivityResponseObjectAllOf
     */
    'due_date'?: string;
    /**
     * The due time of the activity in UTC. Format: HH:MM
     * @type {string}
     * @memberof ActivityResponseObjectAllOf
     */
    'due_time'?: string;
    /**
     * The duration of the activity. Format: HH:MM
     * @type {string}
     * @memberof ActivityResponseObjectAllOf
     */
    'duration'?: string;
    /**
     * The ID of the deal this activity is associated with
     * @type {number}
     * @memberof ActivityResponseObjectAllOf
     */
    'deal_id'?: number;
    /**
     * The ID of the lead in the UUID format this activity is associated with
     * @type {string}
     * @memberof ActivityResponseObjectAllOf
     */
    'lead_id'?: string | null;
    /**
     * The ID of the person this activity is associated with
     * @type {number}
     * @memberof ActivityResponseObjectAllOf
     */
    'person_id'?: number;
    /**
     * The ID of the project this activity is associated with
     * @type {number}
     * @memberof ActivityResponseObjectAllOf
     */
    'project_id'?: number | null;
    /**
     * The ID of the organization this activity is associated with
     * @type {number}
     * @memberof ActivityResponseObjectAllOf
     */
    'org_id'?: number;
    /**
     * The address of the activity. Pipedrive will automatically check if the location matches a geo-location on Google maps.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf
     */
    'location'?: string;
    /**
     * Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf
     */
    'public_description'?: string;
}
/**
 *
 * @export
 * @interface ActivityResponseObjectAllOf1
 */
export interface ActivityResponseObjectAllOf1 {
    /**
     * The ID of the activity, generated when the activity was created
     * @type {number}
     * @memberof ActivityResponseObjectAllOf1
     */
    'id'?: number;
    /**
     * The note of the activity (HTML format)
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'note'?: string;
    /**
     * Whether the activity is done or not
     * @type {boolean}
     * @memberof ActivityResponseObjectAllOf1
     */
    'done'?: boolean;
    /**
     * The subject of the activity
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'subject'?: string;
    /**
     * The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'type'?: string;
    /**
     * The ID of the user whom the activity is assigned to
     * @type {number}
     * @memberof ActivityResponseObjectAllOf1
     */
    'user_id'?: number;
    /**
     * List of multiple persons (participants) this activity is associated with
     * @type {Array<object>}
     * @memberof ActivityResponseObjectAllOf1
     */
    'participants'?: Array<object> | null;
    /**
     * Marks if the activity is set as \'Busy\' or \'Free\'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset. When the value of the flag is unset (`null`), the flag defaults to \'Busy\' if it has a time set, and \'Free\' if it is an all-day event without specified time.
     * @type {boolean}
     * @memberof ActivityResponseObjectAllOf1
     */
    'busy_flag'?: boolean;
    /**
     * The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address.
     * @type {Array<object>}
     * @memberof ActivityResponseObjectAllOf1
     */
    'attendees'?: Array<object> | null;
    /**
     * The user\'s company ID
     * @type {number}
     * @memberof ActivityResponseObjectAllOf1
     */
    'company_id'?: number;
    /**
     * If the activity references some other object, it is indicated here. For example, value `Salesphone` refers to activities created with Caller.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'reference_type'?: string;
    /**
     * Together with the `reference_type`, gives the ID of the other object
     * @type {number}
     * @memberof ActivityResponseObjectAllOf1
     */
    'reference_id'?: number;
    /**
     * The ID of the Marketplace app, which is connected to this activity
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'conference_meeting_client'?: string;
    /**
     * The link to join the meeting which is associated with this activity
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'conference_meeting_url'?: string;
    /**
     * The meeting ID of the meeting provider (Zoom, MS Teams etc.) that is associated with this activity
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'conference_meeting_id'?: string;
    /**
     * The creation date and time of the activity in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'add_time'?: string;
    /**
     * The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'marked_as_done_time'?: string;
    /**
     * The date and time of latest notifications sent about this activity to the participants or the attendees of this activity
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'last_notification_time'?: string;
    /**
     * The ID of the user who triggered the sending of the latest notifications about this activity to the participants or the attendees of this activity
     * @type {number}
     * @memberof ActivityResponseObjectAllOf1
     */
    'last_notification_user_id'?: number;
    /**
     * The ID of the language the notifications are sent in
     * @type {number}
     * @memberof ActivityResponseObjectAllOf1
     */
    'notification_language_id'?: number;
    /**
     * Whether the activity is active or not
     * @type {boolean}
     * @memberof ActivityResponseObjectAllOf1
     */
    'active_flag'?: boolean;
    /**
     * The last update date and time of the activity. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'update_time'?: string;
    /**
     * The ID of the user who was the last to update this activity
     * @type {number}
     * @memberof ActivityResponseObjectAllOf1
     */
    'update_user_id'?: number;
    /**
     * For the activity which syncs to Google calendar, this is the Google event ID. NB! This field is related to old Google calendar sync and will be deprecated soon.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'gcal_event_id'?: string;
    /**
     * The Google calendar ID that this activity syncs to. NB! This field is related to old Google calendar sync and will be deprecated soon.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'google_calendar_id'?: string;
    /**
     * The Google calendar API etag (version) that is used for syncing this activity. NB! This field is related to old Google calendar sync and will be deprecated soon.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'google_calendar_etag'?: string;
    /**
     * For activities that sync to an external calendar, this setting indicates if the activity syncs with context (what are the deals, persons, organizations this activity is related to)
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'calendar_sync_include_context'?: string;
    /**
     * The timezone the activity was created in an external calendar
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'source_timezone'?: string;
    /**
     * The rule for the recurrence of the activity. Is important for activities synced into Pipedrive from an external calendar. Example: \"RRULE:FREQ=WEEKLY;BYDAY=WE\"
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'rec_rule'?: string;
    /**
     * Additional rules for the recurrence of the activity, extend the `rec_rule`. Is important for activities synced into Pipedrive from an external calendar.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'rec_rule_extension'?: string;
    /**
     * The ID of parent activity for a recurrent activity if the current activity is an exception to recurrence rules
     * @type {number}
     * @memberof ActivityResponseObjectAllOf1
     */
    'rec_master_activity_id'?: number;
    /**
     * The list of recurring activity instances. It is in a structure as follows: `[{due_date: \"2020-06-24\", due_time: \"10:00:00\"}]`
     * @type {Array<object>}
     * @memberof ActivityResponseObjectAllOf1
     */
    'series'?: Array<object>;
    /**
     * The ID of the user who created the activity
     * @type {number}
     * @memberof ActivityResponseObjectAllOf1
     */
    'created_by_user_id'?: number;
    /**
     * A subfield of the location field. Indicates apartment/suite number.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'location_subpremise'?: string;
    /**
     * A subfield of the location field. Indicates house number.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'location_street_number'?: string;
    /**
     * A subfield of the location field. Indicates street name.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'location_route'?: string;
    /**
     * A subfield of the location field. Indicates district/sublocality.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'location_sublocality'?: string;
    /**
     * A subfield of the location field. Indicates city/town/village/locality.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'location_locality'?: string;
    /**
     * A subfield of the location field. Indicates state/county.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'location_admin_area_level_1'?: string;
    /**
     * A subfield of the location field. Indicates region.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'location_admin_area_level_2'?: string;
    /**
     * A subfield of the location field. Indicates country.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'location_country'?: string;
    /**
     * A subfield of the location field. Indicates ZIP/postal code.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'location_postal_code'?: string;
    /**
     * A subfield of the location field. Indicates full/combined address.
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'location_formatted_address'?: string;
    /**
     * The name of the organization this activity is associated with
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'org_name'?: string;
    /**
     * The name of the person this activity is associated with
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'person_name'?: string;
    /**
     * The name of the deal this activity is associated with
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'deal_title'?: string;
    /**
     * The name of the user this activity is owned by
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'owner_name'?: string;
    /**
     * The BCC email address of the person
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'person_dropbox_bcc'?: string;
    /**
     * The BCC email address of the deal
     * @type {string}
     * @memberof ActivityResponseObjectAllOf1
     */
    'deal_dropbox_bcc'?: string;
    /**
     * The ID of the user to whom the activity is assigned to. Equal to `user_id`.
     * @type {number}
     * @memberof ActivityResponseObjectAllOf1
     */
    'assigned_to_user_id'?: number;
    /**
     * The file that is attached to this activity. For example, this can be a reference to an audio note file generated with Pipedrive mobile app.
     * @type {object}
     * @memberof ActivityResponseObjectAllOf1
     */
    'file'?: object;
}
/**
 *
 * @export
 * @interface AddActivityRequest
 */
export interface AddActivityRequest {
    /**
     * The due date of the activity. Format: YYYY-MM-DD
     * @type {string}
     * @memberof AddActivityRequest
     */
    'due_date'?: string;
    /**
     * The due time of the activity in UTC. Format: HH:MM
     * @type {string}
     * @memberof AddActivityRequest
     */
    'due_time'?: string;
    /**
     * The duration of the activity. Format: HH:MM
     * @type {string}
     * @memberof AddActivityRequest
     */
    'duration'?: string;
    /**
     * The ID of the deal this activity is associated with
     * @type {number}
     * @memberof AddActivityRequest
     */
    'deal_id'?: number;
    /**
     * The ID of the lead in the UUID format this activity is associated with
     * @type {string}
     * @memberof AddActivityRequest
     */
    'lead_id'?: string | null;
    /**
     * The ID of the person this activity is associated with
     * @type {number}
     * @memberof AddActivityRequest
     */
    'person_id'?: number;
    /**
     * The ID of the project this activity is associated with
     * @type {number}
     * @memberof AddActivityRequest
     */
    'project_id'?: number | null;
    /**
     * The ID of the organization this activity is associated with
     * @type {number}
     * @memberof AddActivityRequest
     */
    'org_id'?: number;
    /**
     * The address of the activity. Pipedrive will automatically check if the location matches a geo-location on Google maps.
     * @type {string}
     * @memberof AddActivityRequest
     */
    'location'?: string;
    /**
     * Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
     * @type {string}
     * @memberof AddActivityRequest
     */
    'public_description'?: string;
    /**
     * The note of the activity (HTML format)
     * @type {string}
     * @memberof AddActivityRequest
     */
    'note'?: string;
    /**
     * The subject of the activity. When value for subject is not set, it will be given a default value `Call`.
     * @type {string}
     * @memberof AddActivityRequest
     */
    'subject'?: string;
    /**
     * The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes. When value for type is not set, it will be given a default value `Call`.
     * @type {string}
     * @memberof AddActivityRequest
     */
    'type'?: string;
    /**
     * The ID of the user whom the activity is assigned to. If omitted, the activity is assigned to the authorized user.
     * @type {number}
     * @memberof AddActivityRequest
     */
    'user_id'?: number;
    /**
     * List of multiple persons (participants) this activity is associated with. If omitted, single participant from `person_id` field is used. It requires a structure as follows: `[{\"person_id\":1,\"primary_flag\":true}]`
     * @type {Array<object>}
     * @memberof AddActivityRequest
     */
    'participants'?: Array<object>;
    /**
     * Set the activity as \'Busy\' or \'Free\'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset by never setting it or overriding it with `null`. When the value of the flag is unset (`null`), the flag defaults to \'Busy\' if it has a time set, and \'Free\' if it is an all-day event without specified time.
     * @type {boolean}
     * @memberof AddActivityRequest
     */
    'busy_flag'?: boolean;
    /**
     * The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address. It requires a structure as follows: `[{\"email_address\":\"mail@example.org\"}]` or `[{\"person_id\":1, \"email_address\":\"mail@example.org\"}]`
     * @type {Array<object>}
     * @memberof AddActivityRequest
     */
    'attendees'?: Array<object>;
    /**
     *
     * @type {number}
     * @memberof AddActivityRequest
     */
    'done'?: AddActivityRequestDoneConst;
}

export const AddActivityRequestDoneConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type AddActivityRequestDoneConst = typeof AddActivityRequestDoneConst[keyof typeof AddActivityRequestDoneConst];

/**
 *
 * @export
 * @interface AddActivityRequestAllOf
 */
export interface AddActivityRequestAllOf {
    /**
     * The note of the activity (HTML format)
     * @type {string}
     * @memberof AddActivityRequestAllOf
     */
    'note'?: string;
    /**
     * The subject of the activity. When value for subject is not set, it will be given a default value `Call`.
     * @type {string}
     * @memberof AddActivityRequestAllOf
     */
    'subject'?: string;
    /**
     * The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes. When value for type is not set, it will be given a default value `Call`.
     * @type {string}
     * @memberof AddActivityRequestAllOf
     */
    'type'?: string;
    /**
     * The ID of the user whom the activity is assigned to. If omitted, the activity is assigned to the authorized user.
     * @type {number}
     * @memberof AddActivityRequestAllOf
     */
    'user_id'?: number;
    /**
     * List of multiple persons (participants) this activity is associated with. If omitted, single participant from `person_id` field is used. It requires a structure as follows: `[{\"person_id\":1,\"primary_flag\":true}]`
     * @type {Array<object>}
     * @memberof AddActivityRequestAllOf
     */
    'participants'?: Array<object>;
    /**
     * Set the activity as \'Busy\' or \'Free\'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset by never setting it or overriding it with `null`. When the value of the flag is unset (`null`), the flag defaults to \'Busy\' if it has a time set, and \'Free\' if it is an all-day event without specified time.
     * @type {boolean}
     * @memberof AddActivityRequestAllOf
     */
    'busy_flag'?: boolean;
    /**
     * The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address. It requires a structure as follows: `[{\"email_address\":\"mail@example.org\"}]` or `[{\"person_id\":1, \"email_address\":\"mail@example.org\"}]`
     * @type {Array<object>}
     * @memberof AddActivityRequestAllOf
     */
    'attendees'?: Array<object>;
    /**
     *
     * @type {number}
     * @memberof AddActivityRequestAllOf
     */
    'done'?: AddActivityRequestAllOfDoneConst;
}

export const AddActivityRequestAllOfDoneConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type AddActivityRequestAllOfDoneConst = typeof AddActivityRequestAllOfDoneConst[keyof typeof AddActivityRequestAllOfDoneConst];

/**
 *
 * @export
 * @interface AddActivityResponse200
 */
export interface AddActivityResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof AddActivityResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {ActivityResponseObject}
     * @memberof AddActivityResponse200
     */
    'data'?: ActivityResponseObject;
    /**
     *
     * @type {AddActivityResponse200AdditionalData}
     * @memberof AddActivityResponse200
     */
    'additional_data'?: AddActivityResponse200AdditionalData;
    /**
     *
     * @type {AddActivityResponse200RelatedObjects}
     * @memberof AddActivityResponse200
     */
    'related_objects'?: AddActivityResponse200RelatedObjects;
}
/**
 *
 * @export
 * @interface AddActivityResponse200AdditionalData
 */
export interface AddActivityResponse200AdditionalData {
    /**
     * This field will be deprecated
     * @type {number}
     * @memberof AddActivityResponse200AdditionalData
     */
    'updates_story_id'?: number;
}
/**
 *
 * @export
 * @interface AddActivityResponse200RelatedObjects
 */
export interface AddActivityResponse200RelatedObjects {
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsUser}
     * @memberof AddActivityResponse200RelatedObjects
     */
    'user'?: GetActivitiesResponse200RelatedObjectsUser;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsDeal}
     * @memberof AddActivityResponse200RelatedObjects
     */
    'deal'?: GetActivitiesResponse200RelatedObjectsDeal;
    /**
     *
     * @type {AddActivityResponse200RelatedObjectsPerson}
     * @memberof AddActivityResponse200RelatedObjects
     */
    'person'?: AddActivityResponse200RelatedObjectsPerson;
    /**
     *
     * @type {AddActivityResponse200RelatedObjectsOrganization}
     * @memberof AddActivityResponse200RelatedObjects
     */
    'organization'?: AddActivityResponse200RelatedObjectsOrganization;
}
/**
 *
 * @export
 * @interface AddActivityResponse200RelatedObjectsOrganization
 */
export interface AddActivityResponse200RelatedObjectsOrganization {
    /**
     *
     * @type {AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONID}
     * @memberof AddActivityResponse200RelatedObjectsOrganization
     */
    'ORGANIZATION_ID'?: AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONID;
}
/**
 * The ID of the organization associated with the item
 * @export
 * @interface AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONID
 */
export interface AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONID {
    /**
     * Whether the associated organization is active or not
     * @type {boolean}
     * @memberof AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONID
     */
    'active_flag'?: boolean;
    /**
     * The ID of the organization associated with the item
     * @type {number}
     * @memberof AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONID
     */
    'id'?: number;
    /**
     * The name of the organization associated with the item
     * @type {string}
     * @memberof AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONID
     */
    'name'?: string;
    /**
     * The number of people connected with the organization that is associated with the item
     * @type {number}
     * @memberof AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONID
     */
    'people_count'?: number;
    /**
     * The ID of the owner of the organization that is associated with the item
     * @type {number}
     * @memberof AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONID
     */
    'owner_id'?: number;
    /**
     * The address of the organization
     * @type {string}
     * @memberof AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONID
     */
    'address'?: string;
    /**
     * The BCC email of the organization associated with the item
     * @type {string}
     * @memberof AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONID
     */
    'cc_email'?: string;
}
/**
 *
 * @export
 * @interface AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONIDAllOf
 */
export interface AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONIDAllOf {
    /**
     * Whether the associated organization is active or not
     * @type {boolean}
     * @memberof AddActivityResponse200RelatedObjectsOrganizationORGANIZATIONIDAllOf
     */
    'active_flag'?: boolean;
}
/**
 *
 * @export
 * @interface AddActivityResponse200RelatedObjectsPerson
 */
export interface AddActivityResponse200RelatedObjectsPerson {
    /**
     *
     * @type {AddActivityResponse200RelatedObjectsPersonPERSONID}
     * @memberof AddActivityResponse200RelatedObjectsPerson
     */
    'PERSON_ID'?: AddActivityResponse200RelatedObjectsPersonPERSONID;
}
/**
 * The ID of the person associated with the item
 * @export
 * @interface AddActivityResponse200RelatedObjectsPersonPERSONID
 */
export interface AddActivityResponse200RelatedObjectsPersonPERSONID {
    /**
     * Whether the associated person is active or not
     * @type {boolean}
     * @memberof AddActivityResponse200RelatedObjectsPersonPERSONID
     */
    'active_flag'?: boolean;
    /**
     * The ID of the person associated with the item
     * @type {number}
     * @memberof AddActivityResponse200RelatedObjectsPersonPERSONID
     */
    'id'?: number;
    /**
     * The name of the person associated with the item
     * @type {string}
     * @memberof AddActivityResponse200RelatedObjectsPersonPERSONID
     */
    'name'?: string;
    /**
     * The emails of the person associated with the item
     * @type {Array<GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfEmailInner>}
     * @memberof AddActivityResponse200RelatedObjectsPersonPERSONID
     */
    'email'?: Array<GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfEmailInner>;
    /**
     * The phone numbers of the person associated with the item
     * @type {Array<GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfPhoneInner>}
     * @memberof AddActivityResponse200RelatedObjectsPersonPERSONID
     */
    'phone'?: Array<GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfPhoneInner>;
    /**
     * The ID of the owner of the person that is associated with the item
     * @type {number}
     * @memberof AddActivityResponse200RelatedObjectsPersonPERSONID
     */
    'owner_id'?: number;
}
/**
 *
 * @export
 * @interface AddActivityResponse200RelatedObjectsPersonPERSONIDAllOf
 */
export interface AddActivityResponse200RelatedObjectsPersonPERSONIDAllOf {
    /**
     * Whether the associated person is active or not
     * @type {boolean}
     * @memberof AddActivityResponse200RelatedObjectsPersonPERSONIDAllOf
     */
    'active_flag'?: boolean;
}
/**
 *
 * @export
 * @interface AddActivityTypeRequest
 */
export interface AddActivityTypeRequest {
    /**
     * The name of the activity type
     * @type {string}
     * @memberof AddActivityTypeRequest
     */
    'name': string;
    /**
     * Icon graphic to use for representing this activity type
     * @type {string}
     * @memberof AddActivityTypeRequest
     */
    'icon_key': AddActivityTypeRequestIconKeyConst;
    /**
     * A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
     * @type {string}
     * @memberof AddActivityTypeRequest
     */
    'color'?: string;
}

export const AddActivityTypeRequestIconKeyConst = {
    task: 'task',
    email: 'email',
    meeting: 'meeting',
    deadline: 'deadline',
    call: 'call',
    lunch: 'lunch',
    calendar: 'calendar',
    downarrow: 'downarrow',
    document: 'document',
    smartphone: 'smartphone',
    camera: 'camera',
    scissors: 'scissors',
    cogs: 'cogs',
    bubble: 'bubble',
    uparrow: 'uparrow',
    checkbox: 'checkbox',
    signpost: 'signpost',
    shuffle: 'shuffle',
    addressbook: 'addressbook',
    linegraph: 'linegraph',
    picture: 'picture',
    car: 'car',
    world: 'world',
    search: 'search',
    clip: 'clip',
    sound: 'sound',
    brush: 'brush',
    key: 'key',
    padlock: 'padlock',
    pricetag: 'pricetag',
    suitcase: 'suitcase',
    finish: 'finish',
    plane: 'plane',
    loop: 'loop',
    wifi: 'wifi',
    truck: 'truck',
    cart: 'cart',
    bulb: 'bulb',
    bell: 'bell',
    presentation: 'presentation'
} as const;

export type AddActivityTypeRequestIconKeyConst = typeof AddActivityTypeRequestIconKeyConst[keyof typeof AddActivityTypeRequestIconKeyConst];

/**
 *
 * @export
 * @interface AddCallLogRequest
 */
export interface AddCallLogRequest {
    /**
     * The ID of the owner of the call log. Please note that a user without account settings access cannot create call logs for other users.
     * @type {number}
     * @memberof AddCallLogRequest
     */
    'user_id'?: number;
    /**
     * If specified, this activity will be converted into a call log, with the information provided. When this field is used, you don\'t need to specify `deal_id`, `person_id` or `org_id`, as they will be ignored in favor of the values already available in the activity. The `activity_id` must refer to a `call` type activity.
     * @type {number}
     * @memberof AddCallLogRequest
     */
    'activity_id'?: number;
    /**
     * The name of the activity this call is attached to
     * @type {string}
     * @memberof AddCallLogRequest
     */
    'subject'?: string;
    /**
     * The duration of the call in seconds
     * @type {string}
     * @memberof AddCallLogRequest
     */
    'duration'?: string;
    /**
     * Describes the outcome of the call
     * @type {string}
     * @memberof AddCallLogRequest
     */
    'outcome': AddCallLogRequestOutcomeConst;
    /**
     * The number that made the call
     * @type {string}
     * @memberof AddCallLogRequest
     */
    'from_phone_number'?: string;
    /**
     * The number called
     * @type {string}
     * @memberof AddCallLogRequest
     */
    'to_phone_number': string;
    /**
     * The date and time of the start of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof AddCallLogRequest
     */
    'start_time': string;
    /**
     * The date and time of the end of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof AddCallLogRequest
     */
    'end_time': string;
    /**
     * The ID of the person this call is associated with
     * @type {number}
     * @memberof AddCallLogRequest
     */
    'person_id'?: number;
    /**
     * The ID of the organization this call is associated with
     * @type {number}
     * @memberof AddCallLogRequest
     */
    'org_id'?: number;
    /**
     * The ID of the deal this call is associated with
     * @type {number}
     * @memberof AddCallLogRequest
     */
    'deal_id'?: number;
    /**
     * The note for the call log in HTML format
     * @type {string}
     * @memberof AddCallLogRequest
     */
    'note'?: string;
}

export const AddCallLogRequestOutcomeConst = {
    connected: 'connected',
    no_answer: 'no_answer',
    left_message: 'left_message',
    left_voicemail: 'left_voicemail',
    wrong_number: 'wrong_number',
    busy: 'busy'
} as const;

export type AddCallLogRequestOutcomeConst = typeof AddCallLogRequestOutcomeConst[keyof typeof AddCallLogRequestOutcomeConst];

/**
 *
 * @export
 * @interface AddChannel200Response
 */
export interface AddChannel200Response {
    /**
     *
     * @type {boolean}
     * @memberof AddChannel200Response
     */
    'success'?: boolean;
    /**
     *
     * @type {AddChannel200ResponseData}
     * @memberof AddChannel200Response
     */
    'data'?: AddChannel200ResponseData;
}
/**
 *
 * @export
 * @interface AddChannel200ResponseData
 */
export interface AddChannel200ResponseData {
    /**
     * The unique channel ID used internally in omnichannel-api and the frontend of the extension
     * @type {string}
     * @memberof AddChannel200ResponseData
     */
    'id'?: string;
    /**
     * The name of the channel
     * @type {string}
     * @memberof AddChannel200ResponseData
     */
    'name'?: string;
    /**
     * The URL for an icon that represents your channel
     * @type {string}
     * @memberof AddChannel200ResponseData
     */
    'avatar_url'?: string;
    /**
     * The channel ID you specified while creating the channel
     * @type {string}
     * @memberof AddChannel200ResponseData
     */
    'provider_channel_id'?: string;
    /**
     * The client_id of your app in Pipedrive marketplace
     * @type {string}
     * @memberof AddChannel200ResponseData
     */
    'marketplace_client_id'?: string;
    /**
     * The ID of the user\'s company in Pipedrive
     * @type {number}
     * @memberof AddChannel200ResponseData
     */
    'pd_company_id'?: number;
    /**
     * The ID of the user in Pipedrive
     * @type {number}
     * @memberof AddChannel200ResponseData
     */
    'pd_user_id'?: number;
    /**
     * The date and time when your channel was created in the API
     * @type {string}
     * @memberof AddChannel200ResponseData
     */
    'created_at'?: string;
    /**
     * Value of the provider_type sent to this endpoint
     * @type {string}
     * @memberof AddChannel200ResponseData
     */
    'provider_type'?: AddChannel200ResponseDataProviderTypeConst;
    /**
     * Value of the template_support sent to this endpoint
     * @type {boolean}
     * @memberof AddChannel200ResponseData
     */
    'template_support'?: boolean;
}

export const AddChannel200ResponseDataProviderTypeConst = {
    facebook: 'facebook',
    whatsapp: 'whatsapp',
    other: 'other'
} as const;

export type AddChannel200ResponseDataProviderTypeConst = typeof AddChannel200ResponseDataProviderTypeConst[keyof typeof AddChannel200ResponseDataProviderTypeConst];

/**
 *
 * @export
 * @interface AddChannel400Response
 */
export interface AddChannel400Response {
    /**
     *
     * @type {boolean}
     * @memberof AddChannel400Response
     */
    'success'?: boolean;
    /**
     * The error description
     * @type {string}
     * @memberof AddChannel400Response
     */
    'error'?: string;
    /**
     *
     * @type {string}
     * @memberof AddChannel400Response
     */
    'error_info'?: string;
    /**
     *
     * @type {AddChannel400ResponseAdditionalData}
     * @memberof AddChannel400Response
     */
    'additional_data'?: AddChannel400ResponseAdditionalData;
}
/**
 *
 * @export
 * @interface AddChannel400ResponseAdditionalData
 */
export interface AddChannel400ResponseAdditionalData {
    /**
     * An error code sent by the API
     * @type {string}
     * @memberof AddChannel400ResponseAdditionalData
     */
    'code'?: string;
}
/**
 *
 * @export
 * @interface AddChannel403Response
 */
export interface AddChannel403Response {
    /**
     *
     * @type {boolean}
     * @memberof AddChannel403Response
     */
    'success'?: boolean;
    /**
     * The error description
     * @type {string}
     * @memberof AddChannel403Response
     */
    'error'?: string;
    /**
     *
     * @type {string}
     * @memberof AddChannel403Response
     */
    'error_info'?: string;
    /**
     *
     * @type {AddChannel403ResponseAdditionalData}
     * @memberof AddChannel403Response
     */
    'additional_data'?: AddChannel403ResponseAdditionalData;
}
/**
 *
 * @export
 * @interface AddChannel403ResponseAdditionalData
 */
export interface AddChannel403ResponseAdditionalData {
    /**
     * An error code sent by the API
     * @type {string}
     * @memberof AddChannel403ResponseAdditionalData
     */
    'code'?: string;
}
/**
 *
 * @export
 * @interface AddChannelRequest
 */
export interface AddChannelRequest {
    /**
     * The name of the channel
     * @type {string}
     * @memberof AddChannelRequest
     */
    'name': string;
    /**
     * The channel ID
     * @type {string}
     * @memberof AddChannelRequest
     */
    'provider_channel_id': string;
    /**
     * The URL for an icon that represents your channel
     * @type {string}
     * @memberof AddChannelRequest
     */
    'avatar_url'?: string;
    /**
     * If true, enables templates logic on UI. Requires getTemplates endpoint implemented. Find out more [here](https://pipedrive.readme.io/docs/implementing-messaging-app-extension).
     * @type {boolean}
     * @memberof AddChannelRequest
     */
    'template_support'?: boolean;
    /**
     * It controls the icons (like the icon next to the conversation)
     * @type {string}
     * @memberof AddChannelRequest
     */
    'provider_type'?: AddChannelRequestProviderTypeConst;
}

export const AddChannelRequestProviderTypeConst = {
    facebook: 'facebook',
    whatsapp: 'whatsapp',
    other: 'other'
} as const;

export type AddChannelRequestProviderTypeConst = typeof AddChannelRequestProviderTypeConst[keyof typeof AddChannelRequestProviderTypeConst];

/**
 *
 * @export
 * @interface AddDealFollowerRequest
 */
export interface AddDealFollowerRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof AddDealFollowerRequest
     */
    'user_id': number;
}
/**
 *
 * @export
 * @interface AddDealFollowerResponse200
 */
export interface AddDealFollowerResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof AddDealFollowerResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {AddDealFollowerResponse200Data}
     * @memberof AddDealFollowerResponse200
     */
    'data'?: AddDealFollowerResponse200Data;
}
/**
 *
 * @export
 * @interface AddDealFollowerResponse200Data
 */
export interface AddDealFollowerResponse200Data {
    /**
     * The user ID who added the follower
     * @type {number}
     * @memberof AddDealFollowerResponse200Data
     */
    'user_id'?: number;
    /**
     * The follower ID
     * @type {number}
     * @memberof AddDealFollowerResponse200Data
     */
    'id'?: number;
    /**
     * The ID of the deal which the follower was added to
     * @type {number}
     * @memberof AddDealFollowerResponse200Data
     */
    'deal_id'?: number;
    /**
     * The date and time when the deal follower was added
     * @type {string}
     * @memberof AddDealFollowerResponse200Data
     */
    'add_time'?: string;
}
/**
 *
 * @export
 * @interface AddDealParticipantRequest
 */
export interface AddDealParticipantRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof AddDealParticipantRequest
     */
    'person_id': number;
}
/**
 *
 * @export
 * @interface AddDealParticipantResponse200
 */
export interface AddDealParticipantResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof AddDealParticipantResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {AddDealParticipantResponse200Data}
     * @memberof AddDealParticipantResponse200
     */
    'data'?: AddDealParticipantResponse200Data;
    /**
     *
     * @type {GetDealsResponse200RelatedObjects}
     * @memberof AddDealParticipantResponse200
     */
    'related_objects'?: GetDealsResponse200RelatedObjects;
}
/**
 * The object of participant
 * @export
 * @interface AddDealParticipantResponse200Data
 */
export interface AddDealParticipantResponse200Data {
    /**
     * The ID of the person
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'id'?: number;
    /**
     * The ID of the company related to the person
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'company_id'?: number;
    /**
     * Whether the person is active or not
     * @type {boolean}
     * @memberof AddDealParticipantResponse200Data
     */
    'active_flag'?: boolean;
    /**
     * A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ \"value\": \"12345\", \"primary\": \"true\", \"label\": \"mobile\" }]`. Please note that only `value` is required.
     * @type {Array<PersonItemAllOfPhoneInner>}
     * @memberof AddDealParticipantResponse200Data
     */
    'phone'?: Array<PersonItemAllOfPhoneInner>;
    /**
     * An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ \"value\": \"mail@example.com\", \"primary\": \"true\", \"label\": \"main\" } ]`. Please note that only `value` is required.
     * @type {Array<PersonItemAllOfEmailInner>}
     * @memberof AddDealParticipantResponse200Data
     */
    'email'?: Array<PersonItemAllOfEmailInner>;
    /**
     * The first letter of the name of the person
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'first_char'?: string;
    /**
     * The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'update_time'?: string;
    /**
     * The visibility group ID of who can see the person
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'visible_to'?: string;
    /**
     *
     * @type {PersonItemAllOfPictureId}
     * @memberof AddDealParticipantResponse200Data
     */
    'picture_id'?: PersonItemAllOfPictureId;
    /**
     * The label assigned to the person
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'label'?: number;
    /**
     * The name of the organization associated with the person
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'org_name'?: string;
    /**
     * The name of the owner associated with the person
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'owner_name'?: string;
    /**
     * The BCC email associated with the person
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'cc_email'?: string;
    /**
     *
     * @type {Owner}
     * @memberof AddDealParticipantResponse200Data
     */
    'owner_id'?: Owner;
    /**
     *
     * @type {RelationshipOrganizationInfoItemWithActiveFlag}
     * @memberof AddDealParticipantResponse200Data
     */
    'org_id'?: RelationshipOrganizationInfoItemWithActiveFlag;
    /**
     * The name of the person
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'name'?: string;
    /**
     * The first name of the person
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'first_name'?: string;
    /**
     * The last name of the person
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'last_name'?: string;
    /**
     * The count of email messages related to the person
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'email_messages_count'?: number;
    /**
     * The count of activities related to the person
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the person
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the person
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the person
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'files_count'?: number;
    /**
     * The count of notes related to the person
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the person
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'followers_count'?: number;
    /**
     * The date and time of the last incoming email associated with the person
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the person
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'last_outgoing_mail_time'?: string;
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'related_lost_deals_count'?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof AddDealParticipantResponse200Data
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof AddDealParticipantResponse200Data
     */
    'last_activity_date'?: string | null;
}
/**
 *
 * @export
 * @interface AddDealProductRequest
 */
export interface AddDealProductRequest {
    /**
     * The ID of the product to use
     * @type {number}
     * @memberof AddDealProductRequest
     */
    'product_id': number;
    /**
     * The price at which this product will be added to the deal
     * @type {number}
     * @memberof AddDealProductRequest
     */
    'item_price': number;
    /**
     * Quantity – e.g. how many items of this product will be added to the deal
     * @type {number}
     * @memberof AddDealProductRequest
     */
    'quantity': number;
    /**
     * The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage.
     * @type {number}
     * @memberof AddDealProductRequest
     */
    'discount'?: number;
    /**
     * The type of the discount\'s value.
     * @type {string}
     * @memberof AddDealProductRequest
     */
    'discount_type'?: AddDealProductRequestDiscountTypeConst;
    /**
     * The duration of the product. If omitted, will be set to 1.
     * @type {number}
     * @memberof AddDealProductRequest
     */
    'duration'?: number;
    /**
     *
     * @type {string}
     * @memberof AddDealProductRequest
     */
    'duration_unit'?: AddDealProductRequestDurationUnitConst;
    /**
     * The ID of the product variation to use. When omitted, no variation will be used.
     * @type {number}
     * @memberof AddDealProductRequest
     */
    'product_variation_id'?: number | null;
    /**
     * A textual comment associated with this product-deal attachment
     * @type {string}
     * @memberof AddDealProductRequest
     */
    'comments'?: string;
    /**
     * The tax percentage
     * @type {number}
     * @memberof AddDealProductRequest
     */
    'tax'?: number;
    /**
     * The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal.
     * @type {string}
     * @memberof AddDealProductRequest
     */
    'tax_method'?: AddDealProductRequestTaxMethodConst;
    /**
     * Whether the product is enabled for a deal or not. This makes it possible to add products to a deal with a specific price and discount criteria, but keep them disabled, which refrains them from being included in the deal value calculation. When omitted, the product will be marked as enabled by default.
     * @type {boolean}
     * @memberof AddDealProductRequest
     */
    'enabled_flag'?: boolean;
}

export const AddDealProductRequestDiscountTypeConst = {
    percentage: 'percentage',
    amount: 'amount'
} as const;

export type AddDealProductRequestDiscountTypeConst = typeof AddDealProductRequestDiscountTypeConst[keyof typeof AddDealProductRequestDiscountTypeConst];
export const AddDealProductRequestDurationUnitConst = {
    hourly: 'hourly',
    daily: 'daily',
    weekly: 'weekly',
    monthly: 'monthly',
    yearly: 'yearly'
} as const;

export type AddDealProductRequestDurationUnitConst = typeof AddDealProductRequestDurationUnitConst[keyof typeof AddDealProductRequestDurationUnitConst];
export const AddDealProductRequestTaxMethodConst = {
    exclusive: 'exclusive',
    inclusive: 'inclusive',
    none: 'none'
} as const;

export type AddDealProductRequestTaxMethodConst = typeof AddDealProductRequestTaxMethodConst[keyof typeof AddDealProductRequestTaxMethodConst];

/**
 *
 * @export
 * @interface AddDealRequest
 */
export interface AddDealRequest {
    /**
     * The title of the deal
     * @type {string}
     * @memberof AddDealRequest
     */
    'title': string;
    /**
     * The value of the deal. If omitted, value will be set to 0.
     * @type {string}
     * @memberof AddDealRequest
     */
    'value'?: string;
    /**
     * The array of the labels IDs.
     * @type {Array<number>}
     * @memberof AddDealRequest
     */
    'label'?: Array<number>;
    /**
     * The currency of the deal. Accepts a 3-character currency code. If omitted, currency will be set to the default currency of the authorized user.
     * @type {string}
     * @memberof AddDealRequest
     */
    'currency'?: string;
    /**
     * The ID of the user which will be the owner of the created deal. If not provided, the user making the request will be used.
     * @type {number}
     * @memberof AddDealRequest
     */
    'user_id'?: number;
    /**
     * The ID of a person which this deal will be linked to. If the person does not exist yet, it needs to be created first. This property is required unless `org_id` is specified.
     * @type {number}
     * @memberof AddDealRequest
     */
    'person_id'?: number;
    /**
     * The ID of an organization which this deal will be linked to. If the organization does not exist yet, it needs to be created first. This property is required unless `person_id` is specified.
     * @type {number}
     * @memberof AddDealRequest
     */
    'org_id'?: number;
    /**
     * The ID of the pipeline this deal will be added to. By default, the deal will be added to the first stage of the specified pipeline. Please note that `pipeline_id` and `stage_id` should not be used together as `pipeline_id` will be ignored.
     * @type {number}
     * @memberof AddDealRequest
     */
    'pipeline_id'?: number;
    /**
     * The ID of the stage this deal will be added to. Please note that a pipeline will be assigned automatically based on the `stage_id`. If omitted, the deal will be placed in the first stage of the default pipeline.
     * @type {number}
     * @memberof AddDealRequest
     */
    'stage_id'?: number;
    /**
     * open = Open, won = Won, lost = Lost, deleted = Deleted. If omitted, status will be set to open.
     * @type {string}
     * @memberof AddDealRequest
     */
    'status'?: AddDealRequestStatusConst;
    /**
     * The optional creation date & time of the deal in UTC. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof AddDealRequest
     */
    'add_time'?: string;
    /**
     * The expected close date of the deal. In ISO 8601 format: YYYY-MM-DD.
     * @type {string}
     * @memberof AddDealRequest
     */
    'expected_close_date'?: string;
    /**
     * The success probability percentage of the deal. Used/shown only when `deal_probability` for the pipeline of the deal is enabled.
     * @type {number}
     * @memberof AddDealRequest
     */
    'probability'?: number;
    /**
     * The optional message about why the deal was lost (to be used when status = lost)
     * @type {string}
     * @memberof AddDealRequest
     */
    'lost_reason'?: string;
    /**
     *
     * @type {string}
     * @memberof AddDealRequest
     */
    'visible_to'?: AddDealRequestVisibleToConst;
}

export const AddDealRequestStatusConst = {
    open: 'open',
    won: 'won',
    lost: 'lost',
    deleted: 'deleted'
} as const;

export type AddDealRequestStatusConst = typeof AddDealRequestStatusConst[keyof typeof AddDealRequestStatusConst];
export const AddDealRequestVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type AddDealRequestVisibleToConst = typeof AddDealRequestVisibleToConst[keyof typeof AddDealRequestVisibleToConst];

/**
 *
 * @export
 * @interface AddFileAndLinkItResponse200
 */
export interface AddFileAndLinkItResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof AddFileAndLinkItResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetFilesResponse200DataInner}
     * @memberof AddFileAndLinkItResponse200
     */
    'data'?: GetFilesResponse200DataInner;
}
/**
 *
 * @export
 * @interface AddFileResponse200
 */
export interface AddFileResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof AddFileResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetFilesResponse200DataInner}
     * @memberof AddFileResponse200
     */
    'data'?: GetFilesResponse200DataInner;
}
/**
 *
 * @export
 * @interface AddFilterRequest
 */
export interface AddFilterRequest {
    /**
     * The name of the filter
     * @type {string}
     * @memberof AddFilterRequest
     */
    'name': string;
    /**
     * The conditions of the filter as a JSON object. Please note that a maximum of 16 conditions is allowed per filter and `date` values must be supplied in the `YYYY-MM-DD` format. It requires a minimum structure as follows: `{\"glue\":\"and\",\"conditions\":[{\"glue\":\"and\",\"conditions\": [CONDITION_OBJECTS]},{\"glue\":\"or\",\"conditions\":[CONDITION_OBJECTS]}]}`. Replace `CONDITION_OBJECTS` with JSON objects of the following structure: `{\"object\":\"\",\"field_id\":\"\", \"operator\":\"\",\"value\":\"\", \"extra_value\":\"\"}` or leave the array empty. Depending on the object type you should use another API endpoint to get `field_id`. There are five types of objects you can choose from: `\"person\"`, `\"deal\"`, `\"organization\"`, `\"product\"`, `\"activity\"` and you can use these types of operators depending on what type of a field you have: `\"IS NOT NULL\"`, `\"IS NULL\"`, `\"<=\"`, `\">=\"`, `\"<\"`, `\">\"`, `\"!=\"`, `\"=\"`, `\"LIKE \'$%\'\"`, `\"LIKE \'%$%\'\"`, `\"NOT LIKE \'$%\'\"`. To get a better understanding of how filters work try creating them directly from the Pipedrive application.
     * @type {object}
     * @memberof AddFilterRequest
     */
    'conditions': object;
    /**
     *
     * @type {string}
     * @memberof AddFilterRequest
     */
    'type': AddFilterRequestTypeConst;
}

export const AddFilterRequestTypeConst = {
    deals: 'deals',
    leads: 'leads',
    org: 'org',
    people: 'people',
    products: 'products',
    activity: 'activity',
    projects: 'projects'
} as const;

export type AddFilterRequestTypeConst = typeof AddFilterRequestTypeConst[keyof typeof AddFilterRequestTypeConst];

/**
 *
 * @export
 * @interface AddGoalRequest
 */
export interface AddGoalRequest {
    /**
     * The title of the goal
     * @type {string}
     * @memberof AddGoalRequest
     */
    'title'?: string;
    /**
     * Who this goal is assigned to. It requires the following JSON structure: `{ \"id\": \"1\", \"type\": \"person\" }`. `type` can be either `person`, `company` or `team`. ID of the assignee person, company or team.
     * @type {object}
     * @memberof AddGoalRequest
     */
    'assignee': object;
    /**
     * The type of the goal. It requires the following JSON structure: `{ \"name\": \"deals_started\", \"params\": { \"pipeline_id\": [1, 2], \"activity_type_id\": [9] } }`. Type can be one of: `deals_won`, `deals_progressed`, `activities_completed`, `activities_added`, `deals_started` or `revenue_forecast`. `params` can include `pipeline_id`, `stage_id` or `activity_type_id`. `stage_id` is related to only `deals_progressed` type of goals and `activity_type_id` to `activities_completed` or `activities_added` types of goals. The `pipeline_id` and `activity_type_id` need to be given as an array of integers. To track the goal in all pipelines, set `pipeline_id` as `null` and similarly, to track the goal for all activities, set `activity_type_id` as `null`.”
     * @type {object}
     * @memberof AddGoalRequest
     */
    'type': object;
    /**
     * The expected outcome of the goal. Expected outcome can be tracked either by `quantity` or by `sum`. It requires the following JSON structure: `{ \"target\": \"50\", \"tracking_metric\": \"quantity\" }` or `{ \"target\": \"50\", \"tracking_metric\": \"sum\", \"currency_id\": 1 }`. `currency_id` should only be added to `sum` type of goals.
     * @type {object}
     * @memberof AddGoalRequest
     */
    'expected_outcome': object;
    /**
     * The date when the goal starts and ends. It requires the following JSON structure: `{ \"start\": \"2019-01-01\", \"end\": \"2022-12-31\" }`. Date in format of YYYY-MM-DD. \"end\" can be set to `null` for an infinite, open-ended goal.
     * @type {object}
     * @memberof AddGoalRequest
     */
    'duration': object;
    /**
     * The interval of the goal
     * @type {string}
     * @memberof AddGoalRequest
     */
    'interval': AddGoalRequestIntervalConst;
}

export const AddGoalRequestIntervalConst = {
    weekly: 'weekly',
    monthly: 'monthly',
    quarterly: 'quarterly',
    yearly: 'yearly'
} as const;

export type AddGoalRequestIntervalConst = typeof AddGoalRequestIntervalConst[keyof typeof AddGoalRequestIntervalConst];

/**
 *
 * @export
 * @interface AddLeadLabelRequest
 */
export interface AddLeadLabelRequest {
    /**
     * The name of the lead label
     * @type {string}
     * @memberof AddLeadLabelRequest
     */
    'name': string;
    /**
     * The color of the label. Only a subset of colors can be used.
     * @type {string}
     * @memberof AddLeadLabelRequest
     */
    'color': AddLeadLabelRequestColorConst;
}

export const AddLeadLabelRequestColorConst = {
    green: 'green',
    blue: 'blue',
    red: 'red',
    yellow: 'yellow',
    purple: 'purple',
    gray: 'gray'
} as const;

export type AddLeadLabelRequestColorConst = typeof AddLeadLabelRequestColorConst[keyof typeof AddLeadLabelRequestColorConst];

/**
 *
 * @export
 * @interface AddLeadRequest
 */
export interface AddLeadRequest {
    /**
     * The name of the lead
     * @type {string}
     * @memberof AddLeadRequest
     */
    'title': string;
    /**
     * The ID of the user which will be the owner of the created lead. If not provided, the user making the request will be used.
     * @type {number}
     * @memberof AddLeadRequest
     */
    'owner_id'?: number;
    /**
     * The IDs of the lead labels which will be associated with the lead
     * @type {Array<string>}
     * @memberof AddLeadRequest
     */
    'label_ids'?: Array<string>;
    /**
     * The ID of a person which this lead will be linked to. If the person does not exist yet, it needs to be created first. This property is required unless `organization_id` is specified.
     * @type {number}
     * @memberof AddLeadRequest
     */
    'person_id'?: number;
    /**
     * The ID of an organization which this lead will be linked to. If the organization does not exist yet, it needs to be created first. This property is required unless `person_id` is specified.
     * @type {number}
     * @memberof AddLeadRequest
     */
    'organization_id'?: number;
    /**
     *
     * @type {AddLeadRequestValue}
     * @memberof AddLeadRequest
     */
    'value'?: AddLeadRequestValue;
    /**
     * The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
     * @type {string}
     * @memberof AddLeadRequest
     */
    'expected_close_date'?: string;
    /**
     *
     * @type {string}
     * @memberof AddLeadRequest
     */
    'visible_to'?: AddLeadRequestVisibleToConst;
    /**
     * A flag indicating whether the lead was seen by someone in the Pipedrive UI
     * @type {boolean}
     * @memberof AddLeadRequest
     */
    'was_seen'?: boolean;
}

export const AddLeadRequestVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type AddLeadRequestVisibleToConst = typeof AddLeadRequestVisibleToConst[keyof typeof AddLeadRequestVisibleToConst];

/**
 * The potential value of the lead as a JSON object. It requires the following JSON structure: `{ \"amount\": 200, \"currency\": \"EUR\" }`. Both amount and currency are required.
 * @export
 * @interface AddLeadRequestValue
 */
export interface AddLeadRequestValue {
    /**
     *
     * @type {number}
     * @memberof AddLeadRequestValue
     */
    'amount': number;
    /**
     *
     * @type {string}
     * @memberof AddLeadRequestValue
     */
    'currency': string;
}
/**
 *
 * @export
 * @interface AddNoteRequest
 */
export interface AddNoteRequest {
    /**
     * The content of the note in HTML format. Subject to sanitization on the back-end.
     * @type {string}
     * @memberof AddNoteRequest
     */
    'content': string;
    /**
     * The ID of the lead the note will be attached to. This property is required unless one of (`deal_id/person_id/org_id`) is specified.
     * @type {string}
     * @memberof AddNoteRequest
     */
    'lead_id'?: string;
    /**
     * The ID of the deal the note will be attached to. This property is required unless one of (`lead_id/person_id/org_id`) is specified.
     * @type {number}
     * @memberof AddNoteRequest
     */
    'deal_id'?: number;
    /**
     * The ID of the person this note will be attached to. This property is required unless one of (`deal_id/lead_id/org_id`) is specified.
     * @type {number}
     * @memberof AddNoteRequest
     */
    'person_id'?: number;
    /**
     * The ID of the organization this note will be attached to. This property is required unless one of (`deal_id/lead_id/person_id`) is specified.
     * @type {number}
     * @memberof AddNoteRequest
     */
    'org_id'?: number;
    /**
     * The ID of the user who will be marked as the author of the note. Only an admin can change the author.
     * @type {number}
     * @memberof AddNoteRequest
     */
    'user_id'?: number;
    /**
     * The optional creation date & time of the note in UTC. Can be set in the past or in the future. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof AddNoteRequest
     */
    'add_time'?: string;
    /**
     *
     * @type {number}
     * @memberof AddNoteRequest
     */
    'pinned_to_lead_flag'?: AddNoteRequestPinnedToLeadFlagConst;
    /**
     *
     * @type {number}
     * @memberof AddNoteRequest
     */
    'pinned_to_deal_flag'?: AddNoteRequestPinnedToDealFlagConst;
    /**
     *
     * @type {number}
     * @memberof AddNoteRequest
     */
    'pinned_to_organization_flag'?: AddNoteRequestPinnedToOrganizationFlagConst;
    /**
     *
     * @type {number}
     * @memberof AddNoteRequest
     */
    'pinned_to_person_flag'?: AddNoteRequestPinnedToPersonFlagConst;
}

export const AddNoteRequestPinnedToLeadFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type AddNoteRequestPinnedToLeadFlagConst = typeof AddNoteRequestPinnedToLeadFlagConst[keyof typeof AddNoteRequestPinnedToLeadFlagConst];
export const AddNoteRequestPinnedToDealFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type AddNoteRequestPinnedToDealFlagConst = typeof AddNoteRequestPinnedToDealFlagConst[keyof typeof AddNoteRequestPinnedToDealFlagConst];
export const AddNoteRequestPinnedToOrganizationFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type AddNoteRequestPinnedToOrganizationFlagConst = typeof AddNoteRequestPinnedToOrganizationFlagConst[keyof typeof AddNoteRequestPinnedToOrganizationFlagConst];
export const AddNoteRequestPinnedToPersonFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type AddNoteRequestPinnedToPersonFlagConst = typeof AddNoteRequestPinnedToPersonFlagConst[keyof typeof AddNoteRequestPinnedToPersonFlagConst];

/**
 *
 * @export
 * @interface AddNoteRequestAllOf
 */
export interface AddNoteRequestAllOf {
    /**
     * The content of the note in HTML format. Subject to sanitization on the back-end.
     * @type {string}
     * @memberof AddNoteRequestAllOf
     */
    'content': string;
    /**
     * The ID of the lead the note will be attached to. This property is required unless one of (`deal_id/person_id/org_id`) is specified.
     * @type {string}
     * @memberof AddNoteRequestAllOf
     */
    'lead_id'?: string;
    /**
     * The ID of the deal the note will be attached to. This property is required unless one of (`lead_id/person_id/org_id`) is specified.
     * @type {number}
     * @memberof AddNoteRequestAllOf
     */
    'deal_id'?: number;
    /**
     * The ID of the person this note will be attached to. This property is required unless one of (`deal_id/lead_id/org_id`) is specified.
     * @type {number}
     * @memberof AddNoteRequestAllOf
     */
    'person_id'?: number;
    /**
     * The ID of the organization this note will be attached to. This property is required unless one of (`deal_id/lead_id/person_id`) is specified.
     * @type {number}
     * @memberof AddNoteRequestAllOf
     */
    'org_id'?: number;
}
/**
 *
 * @export
 * @interface AddNoteRequestAllOf1
 */
export interface AddNoteRequestAllOf1 {
    /**
     * The ID of the user who will be marked as the author of the note. Only an admin can change the author.
     * @type {number}
     * @memberof AddNoteRequestAllOf1
     */
    'user_id'?: number;
    /**
     * The optional creation date & time of the note in UTC. Can be set in the past or in the future. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof AddNoteRequestAllOf1
     */
    'add_time'?: string;
    /**
     *
     * @type {number}
     * @memberof AddNoteRequestAllOf1
     */
    'pinned_to_lead_flag'?: AddNoteRequestAllOf1PinnedToLeadFlagConst;
    /**
     *
     * @type {number}
     * @memberof AddNoteRequestAllOf1
     */
    'pinned_to_deal_flag'?: AddNoteRequestAllOf1PinnedToDealFlagConst;
    /**
     *
     * @type {number}
     * @memberof AddNoteRequestAllOf1
     */
    'pinned_to_organization_flag'?: AddNoteRequestAllOf1PinnedToOrganizationFlagConst;
    /**
     *
     * @type {number}
     * @memberof AddNoteRequestAllOf1
     */
    'pinned_to_person_flag'?: AddNoteRequestAllOf1PinnedToPersonFlagConst;
}

export const AddNoteRequestAllOf1PinnedToLeadFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type AddNoteRequestAllOf1PinnedToLeadFlagConst = typeof AddNoteRequestAllOf1PinnedToLeadFlagConst[keyof typeof AddNoteRequestAllOf1PinnedToLeadFlagConst];
export const AddNoteRequestAllOf1PinnedToDealFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type AddNoteRequestAllOf1PinnedToDealFlagConst = typeof AddNoteRequestAllOf1PinnedToDealFlagConst[keyof typeof AddNoteRequestAllOf1PinnedToDealFlagConst];
export const AddNoteRequestAllOf1PinnedToOrganizationFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type AddNoteRequestAllOf1PinnedToOrganizationFlagConst = typeof AddNoteRequestAllOf1PinnedToOrganizationFlagConst[keyof typeof AddNoteRequestAllOf1PinnedToOrganizationFlagConst];
export const AddNoteRequestAllOf1PinnedToPersonFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type AddNoteRequestAllOf1PinnedToPersonFlagConst = typeof AddNoteRequestAllOf1PinnedToPersonFlagConst[keyof typeof AddNoteRequestAllOf1PinnedToPersonFlagConst];

/**
 *
 * @export
 * @interface AddOrUpdateGoalResponse200
 */
export interface AddOrUpdateGoalResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof AddOrUpdateGoalResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {AddOrUpdateGoalResponse200Data}
     * @memberof AddOrUpdateGoalResponse200
     */
    'data'?: AddOrUpdateGoalResponse200Data;
}
/**
 *
 * @export
 * @interface AddOrUpdateGoalResponse200Data
 */
export interface AddOrUpdateGoalResponse200Data {
    /**
     *
     * @type {AddOrUpdateGoalResponse200DataGoal}
     * @memberof AddOrUpdateGoalResponse200Data
     */
    'goal'?: AddOrUpdateGoalResponse200DataGoal;
}
/**
 *
 * @export
 * @interface AddOrUpdateGoalResponse200DataGoal
 */
export interface AddOrUpdateGoalResponse200DataGoal {
    /**
     * The ID of the goal
     * @type {string}
     * @memberof AddOrUpdateGoalResponse200DataGoal
     */
    'id'?: string;
    /**
     * The ID of the creator of the goal
     * @type {number}
     * @memberof AddOrUpdateGoalResponse200DataGoal
     */
    'owner_id'?: number;
    /**
     * The title of the goal
     * @type {string}
     * @memberof AddOrUpdateGoalResponse200DataGoal
     */
    'title'?: string;
    /**
     *
     * @type {AddOrUpdateGoalResponse200DataGoalType}
     * @memberof AddOrUpdateGoalResponse200DataGoal
     */
    'type'?: AddOrUpdateGoalResponse200DataGoalType;
    /**
     *
     * @type {AddOrUpdateGoalResponse200DataGoalAssignee}
     * @memberof AddOrUpdateGoalResponse200DataGoal
     */
    'assignee'?: AddOrUpdateGoalResponse200DataGoalAssignee;
    /**
     * The interval of the goal
     * @type {string}
     * @memberof AddOrUpdateGoalResponse200DataGoal
     */
    'interval'?: string;
    /**
     *
     * @type {AddOrUpdateGoalResponse200DataGoalDuration}
     * @memberof AddOrUpdateGoalResponse200DataGoal
     */
    'duration'?: AddOrUpdateGoalResponse200DataGoalDuration;
    /**
     *
     * @type {AddOrUpdateGoalResponse200DataGoalExpectedOutcome}
     * @memberof AddOrUpdateGoalResponse200DataGoal
     */
    'expected_outcome'?: AddOrUpdateGoalResponse200DataGoalExpectedOutcome;
    /**
     * Whether the goal is currently active or not
     * @type {boolean}
     * @memberof AddOrUpdateGoalResponse200DataGoal
     */
    'is_active'?: boolean;
    /**
     * The IDs of the reports that belong to the goal
     * @type {Array<string>}
     * @memberof AddOrUpdateGoalResponse200DataGoal
     */
    'report_ids'?: Array<string>;
}
/**
 * Who the goal is assigned to
 * @export
 * @interface AddOrUpdateGoalResponse200DataGoalAssignee
 */
export interface AddOrUpdateGoalResponse200DataGoalAssignee {
    /**
     * The ID of the goal assignee
     * @type {number}
     * @memberof AddOrUpdateGoalResponse200DataGoalAssignee
     */
    'id'?: number;
    /**
     * The type of the assignee
     * @type {string}
     * @memberof AddOrUpdateGoalResponse200DataGoalAssignee
     */
    'type'?: string;
}
/**
 * The duration of the goal
 * @export
 * @interface AddOrUpdateGoalResponse200DataGoalDuration
 */
export interface AddOrUpdateGoalResponse200DataGoalDuration {
    /**
     * The start date of the goal
     * @type {string}
     * @memberof AddOrUpdateGoalResponse200DataGoalDuration
     */
    'start'?: string;
    /**
     * The end date of the goal
     * @type {string}
     * @memberof AddOrUpdateGoalResponse200DataGoalDuration
     */
    'end'?: string;
}
/**
 * The expected outcome of the goal
 * @export
 * @interface AddOrUpdateGoalResponse200DataGoalExpectedOutcome
 */
export interface AddOrUpdateGoalResponse200DataGoalExpectedOutcome {
    /**
     * The numeric target of the goal
     * @type {number}
     * @memberof AddOrUpdateGoalResponse200DataGoalExpectedOutcome
     */
    'target'?: number;
    /**
     * The tracking metric of the goal
     * @type {string}
     * @memberof AddOrUpdateGoalResponse200DataGoalExpectedOutcome
     */
    'tracking_metric'?: string;
}
/**
 * The type of the goal
 * @export
 * @interface AddOrUpdateGoalResponse200DataGoalType
 */
export interface AddOrUpdateGoalResponse200DataGoalType {
    /**
     * The name of the goal type
     * @type {string}
     * @memberof AddOrUpdateGoalResponse200DataGoalType
     */
    'name'?: string;
    /**
     *
     * @type {AddOrUpdateGoalResponse200DataGoalTypeParams}
     * @memberof AddOrUpdateGoalResponse200DataGoalType
     */
    'params'?: AddOrUpdateGoalResponse200DataGoalTypeParams;
}
/**
 * The parameters that accompany the goal type
 * @export
 * @interface AddOrUpdateGoalResponse200DataGoalTypeParams
 */
export interface AddOrUpdateGoalResponse200DataGoalTypeParams {
    /**
     * The IDs of pipelines of the goal
     * @type {Array<number>}
     * @memberof AddOrUpdateGoalResponse200DataGoalTypeParams
     */
    'pipeline_id'?: Array<number>;
    /**
     * The IDs of activity types of the goal
     * @type {Array<number>}
     * @memberof AddOrUpdateGoalResponse200DataGoalTypeParams
     */
    'activity_type_id'?: Array<number>;
}
/**
 *
 * @export
 * @interface AddOrUpdateLeadLabelResponse200
 */
export interface AddOrUpdateLeadLabelResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof AddOrUpdateLeadLabelResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetLeadLabelsResponse200DataInner}
     * @memberof AddOrUpdateLeadLabelResponse200
     */
    'data'?: GetLeadLabelsResponse200DataInner;
}
/**
 *
 * @export
 * @interface AddOrUpdateRoleSettingRequest
 */
export interface AddOrUpdateRoleSettingRequest {
    /**
     *
     * @type {string}
     * @memberof AddOrUpdateRoleSettingRequest
     */
    'setting_key': AddOrUpdateRoleSettingRequestSettingKeyConst;
    /**
     * Possible values for the `default_visibility` setting depending on the subscription plan:<br> <table class=\'role-setting\'> <caption><b>Essential / Advanced plan</b></caption> <tr><th><b>Value</b></th><th><b>Description</b></th></tr> <tr><td>`1`</td><td>Owner & Followers</td></tr> <tr><td>`3`</td><td>Entire company</td></tr> </table> <br> <table class=\'role-setting\'> <caption><b>Professional / Enterprise plan</b></caption> <tr><th><b>Value</b></th><th><b>Description</b></th></tr> <tr><td>`1`</td><td>Owner only</td></tr> <tr><td>`3`</td><td>Owner&#39;s visibility group</td></tr> <tr><td>`5`</td><td>Owner&#39;s visibility group and sub-groups</td></tr> <tr><td>`7`</td><td>Entire company</td></tr> </table> <br> Read more about visibility groups <a href=\'https://support.pipedrive.com/en/article/visibility-groups\'>here</a>.
     * @type {number}
     * @memberof AddOrUpdateRoleSettingRequest
     */
    'value': AddOrUpdateRoleSettingRequestValueConst;
}

export const AddOrUpdateRoleSettingRequestSettingKeyConst = {
    deal_default_visibility: 'deal_default_visibility',
    lead_default_visibility: 'lead_default_visibility',
    org_default_visibility: 'org_default_visibility',
    person_default_visibility: 'person_default_visibility',
    product_default_visibility: 'product_default_visibility'
} as const;

export type AddOrUpdateRoleSettingRequestSettingKeyConst = typeof AddOrUpdateRoleSettingRequestSettingKeyConst[keyof typeof AddOrUpdateRoleSettingRequestSettingKeyConst];
export const AddOrUpdateRoleSettingRequestValueConst = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type AddOrUpdateRoleSettingRequestValueConst = typeof AddOrUpdateRoleSettingRequestValueConst[keyof typeof AddOrUpdateRoleSettingRequestValueConst];

/**
 *
 * @export
 * @interface AddOrUpdateRoleSettingResponse200
 */
export interface AddOrUpdateRoleSettingResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof AddOrUpdateRoleSettingResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {AddOrUpdateRoleSettingResponse200AllOfData}
     * @memberof AddOrUpdateRoleSettingResponse200
     */
    'data'?: AddOrUpdateRoleSettingResponse200AllOfData;
}
/**
 *
 * @export
 * @interface AddOrUpdateRoleSettingResponse200AllOf
 */
export interface AddOrUpdateRoleSettingResponse200AllOf {
    /**
     *
     * @type {AddOrUpdateRoleSettingResponse200AllOfData}
     * @memberof AddOrUpdateRoleSettingResponse200AllOf
     */
    'data'?: AddOrUpdateRoleSettingResponse200AllOfData;
}
/**
 * The response data
 * @export
 * @interface AddOrUpdateRoleSettingResponse200AllOfData
 */
export interface AddOrUpdateRoleSettingResponse200AllOfData {
    /**
     * The ID of the role
     * @type {number}
     * @memberof AddOrUpdateRoleSettingResponse200AllOfData
     */
    'id'?: number;
    /**
     * The setting
     * @type {number}
     * @memberof AddOrUpdateRoleSettingResponse200AllOfData
     */
    'deal_default_visibility'?: AddOrUpdateRoleSettingResponse200AllOfDataDealDefaultVisibilityConst;
}

export const AddOrUpdateRoleSettingResponse200AllOfDataDealDefaultVisibilityConst = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type AddOrUpdateRoleSettingResponse200AllOfDataDealDefaultVisibilityConst = typeof AddOrUpdateRoleSettingResponse200AllOfDataDealDefaultVisibilityConst[keyof typeof AddOrUpdateRoleSettingResponse200AllOfDataDealDefaultVisibilityConst];

/**
 *
 * @export
 * @interface AddOrganizationFollowerRequest
 */
export interface AddOrganizationFollowerRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof AddOrganizationFollowerRequest
     */
    'user_id': number;
}
/**
 *
 * @export
 * @interface AddOrganizationFollowerResponse200
 */
export interface AddOrganizationFollowerResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof AddOrganizationFollowerResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetAssociatedFollowersResponse2001DataInner}
     * @memberof AddOrganizationFollowerResponse200
     */
    'data'?: GetAssociatedFollowersResponse2001DataInner;
}
/**
 *
 * @export
 * @interface AddOrganizationRelationshipRequest
 */
export interface AddOrganizationRelationshipRequest {
    /**
     * The ID of the base organization for the returned calculated values
     * @type {number}
     * @memberof AddOrganizationRelationshipRequest
     */
    'org_id'?: number;
    /**
     * The type of organization relationship
     * @type {string}
     * @memberof AddOrganizationRelationshipRequest
     */
    'type': AddOrganizationRelationshipRequestTypeConst;
    /**
     * The owner of the relationship. If type is `parent`, then the owner is the parent and the linked organization is the daughter.
     * @type {number}
     * @memberof AddOrganizationRelationshipRequest
     */
    'rel_owner_org_id': number;
    /**
     * The linked organization in the relationship. If type is `parent`, then the linked organization is the daughter.
     * @type {number}
     * @memberof AddOrganizationRelationshipRequest
     */
    'rel_linked_org_id': number;
}

export const AddOrganizationRelationshipRequestTypeConst = {
    parent: 'parent',
    related: 'related'
} as const;

export type AddOrganizationRelationshipRequestTypeConst = typeof AddOrganizationRelationshipRequestTypeConst[keyof typeof AddOrganizationRelationshipRequestTypeConst];

/**
 *
 * @export
 * @interface AddOrganizationRelationshipResponse200
 */
export interface AddOrganizationRelationshipResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof AddOrganizationRelationshipResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {OrganizationRelationshipWithCalculatedFieldsAllOf}
     * @memberof AddOrganizationRelationshipResponse200
     */
    'data'?: OrganizationRelationshipWithCalculatedFieldsAllOf;
    /**
     *
     * @type {GetOrganizationRelationshipsResponse200AllOfRelatedObjects}
     * @memberof AddOrganizationRelationshipResponse200
     */
    'related_objects'?: GetOrganizationRelationshipsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface AddOrganizationRelationshipResponse200AllOf
 */
export interface AddOrganizationRelationshipResponse200AllOf {
    /**
     *
     * @type {OrganizationRelationshipWithCalculatedFieldsAllOf}
     * @memberof AddOrganizationRelationshipResponse200AllOf
     */
    'data'?: OrganizationRelationshipWithCalculatedFieldsAllOf;
    /**
     *
     * @type {GetOrganizationRelationshipsResponse200AllOfRelatedObjects}
     * @memberof AddOrganizationRelationshipResponse200AllOf
     */
    'related_objects'?: GetOrganizationRelationshipsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface AddOrganizationRequest
 */
export interface AddOrganizationRequest {
    /**
     * The name of the organization
     * @type {string}
     * @memberof AddOrganizationRequest
     */
    'name': string;
    /**
     * The optional creation date & time of the organization in UTC. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof AddOrganizationRequest
     */
    'add_time'?: string;
    /**
     * The ID of the user who will be marked as the owner of this organization. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof AddOrganizationRequest
     */
    'owner_id'?: number;
    /**
     * The ID of the label.
     * @type {number}
     * @memberof AddOrganizationRequest
     */
    'label'?: number;
    /**
     *
     * @type {string}
     * @memberof AddOrganizationRequest
     */
    'visible_to'?: AddOrganizationRequestVisibleToConst;
}

export const AddOrganizationRequestVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type AddOrganizationRequestVisibleToConst = typeof AddOrganizationRequestVisibleToConst[keyof typeof AddOrganizationRequestVisibleToConst];

/**
 *
 * @export
 * @interface AddOrganizationRequestAllOf
 */
export interface AddOrganizationRequestAllOf {
    /**
     * The name of the organization
     * @type {string}
     * @memberof AddOrganizationRequestAllOf
     */
    'name': string;
    /**
     * The optional creation date & time of the organization in UTC. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof AddOrganizationRequestAllOf
     */
    'add_time'?: string;
}
/**
 *
 * @export
 * @interface AddOrganizationResponse200
 */
export interface AddOrganizationResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof AddOrganizationResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {BaseOrganizationItemWithEditNameFlag}
     * @memberof AddOrganizationResponse200
     */
    'data'?: BaseOrganizationItemWithEditNameFlag;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjects}
     * @memberof AddOrganizationResponse200
     */
    'related_objects'?: GetOrganizationsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface AddOrganizationResponse200AllOf
 */
export interface AddOrganizationResponse200AllOf {
    /**
     *
     * @type {BaseOrganizationItemWithEditNameFlag}
     * @memberof AddOrganizationResponse200AllOf
     */
    'data'?: BaseOrganizationItemWithEditNameFlag;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjects}
     * @memberof AddOrganizationResponse200AllOf
     */
    'related_objects'?: GetOrganizationsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface AddPersonFollowerRequest
 */
export interface AddPersonFollowerRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof AddPersonFollowerRequest
     */
    'user_id': number;
}
/**
 *
 * @export
 * @interface AddPersonFollowerResponse200
 */
export interface AddPersonFollowerResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof AddPersonFollowerResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {AddPersonFollowerResponse200AllOfData}
     * @memberof AddPersonFollowerResponse200
     */
    'data'?: AddPersonFollowerResponse200AllOfData;
}
/**
 *
 * @export
 * @interface AddPersonFollowerResponse200AllOf
 */
export interface AddPersonFollowerResponse200AllOf {
    /**
     *
     * @type {AddPersonFollowerResponse200AllOfData}
     * @memberof AddPersonFollowerResponse200AllOf
     */
    'data'?: AddPersonFollowerResponse200AllOfData;
}
/**
 *
 * @export
 * @interface AddPersonFollowerResponse200AllOfData
 */
export interface AddPersonFollowerResponse200AllOfData {
    /**
     * The ID of the user who was added as a follower to a person
     * @type {number}
     * @memberof AddPersonFollowerResponse200AllOfData
     */
    'user_id'?: number;
    /**
     * The ID of the follower
     * @type {number}
     * @memberof AddPersonFollowerResponse200AllOfData
     */
    'id'?: number;
    /**
     * The ID of the person to whom the follower was added
     * @type {number}
     * @memberof AddPersonFollowerResponse200AllOfData
     */
    'person_id'?: number;
    /**
     * The date and time when the follower was added to a person. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof AddPersonFollowerResponse200AllOfData
     */
    'add_time'?: string;
}
/**
 *
 * @export
 * @interface AddPersonPictureResponse200
 */
export interface AddPersonPictureResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof AddPersonPictureResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjectsPicture}
     * @memberof AddPersonPictureResponse200
     */
    'data'?: GetOrganizationsResponse200AllOfRelatedObjectsPicture;
}
/**
 *
 * @export
 * @interface AddPersonPictureResponse200AllOf
 */
export interface AddPersonPictureResponse200AllOf {
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjectsPicture}
     * @memberof AddPersonPictureResponse200AllOf
     */
    'data'?: GetOrganizationsResponse200AllOfRelatedObjectsPicture;
}
/**
 *
 * @export
 * @interface AddPersonRequest
 */
export interface AddPersonRequest {
    /**
     * The name of the person
     * @type {string}
     * @memberof AddPersonRequest
     */
    'name': string;
    /**
     * The ID of the user who will be marked as the owner of this person. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof AddPersonRequest
     */
    'owner_id'?: number;
    /**
     * The ID of the organization this person will belong to
     * @type {number}
     * @memberof AddPersonRequest
     */
    'org_id'?: number;
    /**
     * An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ \"value\": \"mail@example.com\", \"primary\": \"true\", \"label\": \"main\" }]`. Please note that only `value` is required.
     * @type {Array<BasicPersonRequestEmailInner>}
     * @memberof AddPersonRequest
     */
    'email'?: Array<BasicPersonRequestEmailInner>;
    /**
     * A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ \"value\": \"12345\", \"primary\": \"true\", \"label\": \"mobile\" }]`. Please note that only `value` is required.
     * @type {Array<PersonItemAllOfPhoneInner>}
     * @memberof AddPersonRequest
     */
    'phone'?: Array<PersonItemAllOfPhoneInner>;
    /**
     * The ID of the label.
     * @type {number}
     * @memberof AddPersonRequest
     */
    'label'?: number;
    /**
     *
     * @type {string}
     * @memberof AddPersonRequest
     */
    'visible_to'?: AddPersonRequestVisibleToConst;
    /**
     *
     * @type {string}
     * @memberof AddPersonRequest
     */
    'marketing_status'?: AddPersonRequestMarketingStatusConst;
    /**
     * The optional creation date & time of the person in UTC. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof AddPersonRequest
     */
    'add_time'?: string;
}

export const AddPersonRequestVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type AddPersonRequestVisibleToConst = typeof AddPersonRequestVisibleToConst[keyof typeof AddPersonRequestVisibleToConst];
export const AddPersonRequestMarketingStatusConst = {
    no_consent: 'no_consent',
    unsubscribed: 'unsubscribed',
    subscribed: 'subscribed',
    archived: 'archived'
} as const;

export type AddPersonRequestMarketingStatusConst = typeof AddPersonRequestMarketingStatusConst[keyof typeof AddPersonRequestMarketingStatusConst];

/**
 *
 * @export
 * @interface AddPersonRequestAllOf
 */
export interface AddPersonRequestAllOf {
    /**
     * The name of the person
     * @type {string}
     * @memberof AddPersonRequestAllOf
     */
    'name': string;
}
/**
 *
 * @export
 * @interface AddPersonResponse200
 */
export interface AddPersonResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof AddPersonResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {PersonItem}
     * @memberof AddPersonResponse200
     */
    'data'?: PersonItem;
    /**
     *
     * @type {ListProductsResponse200AllOfRelatedObjects}
     * @memberof AddPersonResponse200
     */
    'related_objects'?: ListProductsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface AddPersonResponse200AllOf
 */
export interface AddPersonResponse200AllOf {
    /**
     *
     * @type {PersonItem}
     * @memberof AddPersonResponse200AllOf
     */
    'data'?: PersonItem;
    /**
     *
     * @type {ListProductsResponse200AllOfRelatedObjects}
     * @memberof AddPersonResponse200AllOf
     */
    'related_objects'?: ListProductsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface AddPipelineResponse200
 */
export interface AddPipelineResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof AddPipelineResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {AddPipelineResponse200AllOfData}
     * @memberof AddPipelineResponse200
     */
    'data'?: AddPipelineResponse200AllOfData;
}
/**
 *
 * @export
 * @interface AddPipelineResponse200AllOf
 */
export interface AddPipelineResponse200AllOf {
    /**
     *
     * @type {AddPipelineResponse200AllOfData}
     * @memberof AddPipelineResponse200AllOf
     */
    'data'?: AddPipelineResponse200AllOfData;
}
/**
 * The pipeline object
 * @export
 * @interface AddPipelineResponse200AllOfData
 */
export interface AddPipelineResponse200AllOfData {
    /**
     * The ID of the pipeline
     * @type {number}
     * @memberof AddPipelineResponse200AllOfData
     */
    'id'?: number;
    /**
     * The name of the pipeline
     * @type {string}
     * @memberof AddPipelineResponse200AllOfData
     */
    'name'?: string;
    /**
     * The pipeline title displayed in the URL
     * @type {string}
     * @memberof AddPipelineResponse200AllOfData
     */
    'url_title'?: string;
    /**
     * Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
     * @type {number}
     * @memberof AddPipelineResponse200AllOfData
     */
    'order_nr'?: number;
    /**
     * Whether this pipeline will be made inactive (hidden) or active
     * @type {boolean}
     * @memberof AddPipelineResponse200AllOfData
     */
    'active'?: boolean;
    /**
     * Whether deal probability is disabled or enabled for this pipeline
     * @type {boolean}
     * @memberof AddPipelineResponse200AllOfData
     */
    'deal_probability'?: boolean;
    /**
     * The pipeline creation time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof AddPipelineResponse200AllOfData
     */
    'add_time'?: string;
    /**
     * The pipeline update time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof AddPipelineResponse200AllOfData
     */
    'update_time'?: string;
}
/**
 *
 * @export
 * @interface AddProductFollowerRequest
 */
export interface AddProductFollowerRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof AddProductFollowerRequest
     */
    'user_id': number;
}
/**
 *
 * @export
 * @interface AddProductRequest
 */
export interface AddProductRequest {
    /**
     * The name of the product
     * @type {string}
     * @memberof AddProductRequest
     */
    'name': string;
    /**
     * The product code
     * @type {string}
     * @memberof AddProductRequest
     */
    'code'?: string;
    /**
     * The unit in which this product is sold
     * @type {string}
     * @memberof AddProductRequest
     */
    'unit'?: string;
    /**
     * The tax percentage
     * @type {number}
     * @memberof AddProductRequest
     */
    'tax'?: number;
    /**
     * Whether this product will be made active or not
     * @type {boolean}
     * @memberof AddProductRequest
     */
    'active_flag'?: boolean;
    /**
     * Whether this product can be selected in deals or not
     * @type {boolean}
     * @memberof AddProductRequest
     */
    'selectable'?: boolean;
    /**
     *
     * @type {string}
     * @memberof AddProductRequest
     */
    'visible_to'?: AddProductRequestVisibleToConst;
    /**
     * The ID of the user who will be marked as the owner of this product. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof AddProductRequest
     */
    'owner_id'?: number;
    /**
     * An array of objects, each containing: `currency` (string), `price` (number), `cost` (number, optional), `overhead_cost` (number, optional). Note that there can only be one price per product per currency. When `prices` is omitted altogether, a default price of 0 and a default currency based on the company\'s currency will be assigned.
     * @type {Array<object>}
     * @memberof AddProductRequest
     */
    'prices'?: Array<object>;
}

export const AddProductRequestVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type AddProductRequestVisibleToConst = typeof AddProductRequestVisibleToConst[keyof typeof AddProductRequestVisibleToConst];

/**
 *
 * @export
 * @interface AddProductRequest1
 */
export interface AddProductRequest1 {
    /**
     * The name of the product
     * @type {string}
     * @memberof AddProductRequest1
     */
    'name': string;
    /**
     * The product code
     * @type {string}
     * @memberof AddProductRequest1
     */
    'code'?: string;
    /**
     * The unit in which this product is sold
     * @type {string}
     * @memberof AddProductRequest1
     */
    'unit'?: string;
    /**
     * The tax percentage
     * @type {number}
     * @memberof AddProductRequest1
     */
    'tax'?: number;
    /**
     * Whether this product will be made active or not
     * @type {boolean}
     * @memberof AddProductRequest1
     */
    'active_flag'?: boolean;
    /**
     * Whether this product can be selected in deals or not
     * @type {boolean}
     * @memberof AddProductRequest1
     */
    'selectable'?: boolean;
    /**
     *
     * @type {string}
     * @memberof AddProductRequest1
     */
    'visible_to'?: AddProductRequest1VisibleToConst;
    /**
     * The ID of the user who will be marked as the owner of this product. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof AddProductRequest1
     */
    'owner_id'?: number;
    /**
     * An array of objects, each containing: `currency` (string), `price` (number), `cost` (number, optional), `overhead_cost` (number, optional). Note that there can only be one price per product per currency. When `prices` is omitted altogether, a default price of 0 and a default currency based on the company\'s currency will be assigned.
     * @type {Array<object>}
     * @memberof AddProductRequest1
     */
    'prices'?: Array<object>;
}

export const AddProductRequest1VisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type AddProductRequest1VisibleToConst = typeof AddProductRequest1VisibleToConst[keyof typeof AddProductRequest1VisibleToConst];

/**
 *
 * @export
 * @interface AddProductRequest1AllOf
 */
export interface AddProductRequest1AllOf {
    /**
     * The name of the product
     * @type {string}
     * @memberof AddProductRequest1AllOf
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface AddProductRequestAllOf
 */
export interface AddProductRequestAllOf {
    /**
     * The name of the product
     * @type {string}
     * @memberof AddProductRequestAllOf
     */
    'name': string;
}
/**
 *
 * @export
 * @interface AddProjectRequest
 */
export interface AddProjectRequest {
    /**
     * The title of the project
     * @type {string}
     * @memberof AddProjectRequest
     */
    'title': string;
    /**
     * The ID of a project board
     * @type {number}
     * @memberof AddProjectRequest
     */
    'board_id': number;
    /**
     * The ID of a phase on a project board
     * @type {number}
     * @memberof AddProjectRequest
     */
    'phase_id': number;
    /**
     * The description of the project
     * @type {string}
     * @memberof AddProjectRequest
     */
    'description'?: string;
    /**
     * The status of the project
     * @type {string}
     * @memberof AddProjectRequest
     */
    'status'?: string;
    /**
     * The ID of a project owner
     * @type {number}
     * @memberof AddProjectRequest
     */
    'owner_id'?: number;
    /**
     * The start date of the project. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof AddProjectRequest
     */
    'start_date'?: string;
    /**
     * The end date of the project. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof AddProjectRequest
     */
    'end_date'?: string;
    /**
     * An array of IDs of the deals this project is associated with
     * @type {Array<number>}
     * @memberof AddProjectRequest
     */
    'deal_ids'?: Array<number>;
    /**
     * The ID of the organization this project is associated with
     * @type {number}
     * @memberof AddProjectRequest
     */
    'org_id'?: number;
    /**
     * The ID of the person this project is associated with
     * @type {number}
     * @memberof AddProjectRequest
     */
    'person_id'?: number;
    /**
     * An array of IDs of the labels this project has
     * @type {Array<number>}
     * @memberof AddProjectRequest
     */
    'labels'?: Array<number>;
    /**
     * The ID of the template the project will be based on
     * @type {number}
     * @memberof AddProjectRequest
     */
    'template_id'?: number;
}
/**
 *
 * @export
 * @interface AddProjectRequestAllOf
 */
export interface AddProjectRequestAllOf {
    /**
     * The ID of the template the project will be based on
     * @type {number}
     * @memberof AddProjectRequestAllOf
     */
    'template_id'?: number;
}
/**
 *
 * @export
 * @interface AddProjectResponse201
 */
export interface AddProjectResponse201 {
    /**
     *
     * @type {boolean}
     * @memberof AddProjectResponse201
     */
    'success'?: boolean;
    /**
     *
     * @type {ProjectResponseObject}
     * @memberof AddProjectResponse201
     */
    'data'?: ProjectResponseObject;
    /**
     *
     * @type {object}
     * @memberof AddProjectResponse201
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface AddRecurringSubscriptionRequest
 */
export interface AddRecurringSubscriptionRequest {
    /**
     * The ID of the deal this recurring subscription is associated with
     * @type {number}
     * @memberof AddRecurringSubscriptionRequest
     */
    'deal_id': number;
    /**
     * The currency of the recurring subscription. Accepts a 3-character currency code.
     * @type {string}
     * @memberof AddRecurringSubscriptionRequest
     */
    'currency': string;
    /**
     * The description of the recurring subscription
     * @type {string}
     * @memberof AddRecurringSubscriptionRequest
     */
    'description'?: string;
    /**
     * The interval between payments
     * @type {string}
     * @memberof AddRecurringSubscriptionRequest
     */
    'cadence_type': AddRecurringSubscriptionRequestCadenceTypeConst;
    /**
     * Shows how many payments the subscription has. Note that one field must be set: `cycles_count` or `infinite`. If `cycles_count` is set, then `cycle_amount` and `start_date` are also required.
     * @type {number}
     * @memberof AddRecurringSubscriptionRequest
     */
    'cycles_count'?: number;
    /**
     * The amount of each payment
     * @type {number}
     * @memberof AddRecurringSubscriptionRequest
     */
    'cycle_amount': number;
    /**
     * The start date of the recurring subscription. Format: YYYY-MM-DD
     * @type {string}
     * @memberof AddRecurringSubscriptionRequest
     */
    'start_date': string;
    /**
     * This indicates that the recurring subscription will last until it\'s manually canceled or deleted. Note that only one field must be set: `cycles_count` or `infinite`.
     * @type {boolean}
     * @memberof AddRecurringSubscriptionRequest
     */
    'infinite'?: boolean;
    /**
     * Array of additional payments. It requires a minimum structure as follows: [{ amount:SUM, description:DESCRIPTION, due_at:PAYMENT_DATE }]. Replace SUM with a payment amount, DESCRIPTION with an explanation string, PAYMENT_DATE with a date (format YYYY-MM-DD).
     * @type {Array<object>}
     * @memberof AddRecurringSubscriptionRequest
     */
    'payments'?: Array<object>;
    /**
     * Indicates that the deal value must be set to recurring subscription\'s MRR value
     * @type {boolean}
     * @memberof AddRecurringSubscriptionRequest
     */
    'update_deal_value'?: boolean;
}

export const AddRecurringSubscriptionRequestCadenceTypeConst = {
    weekly: 'weekly',
    monthly: 'monthly',
    quarterly: 'quarterly',
    yearly: 'yearly'
} as const;

export type AddRecurringSubscriptionRequestCadenceTypeConst = typeof AddRecurringSubscriptionRequestCadenceTypeConst[keyof typeof AddRecurringSubscriptionRequestCadenceTypeConst];

/**
 *
 * @export
 * @interface AddRoleAssignmentRequest
 */
export interface AddRoleAssignmentRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof AddRoleAssignmentRequest
     */
    'user_id': number;
}
/**
 *
 * @export
 * @interface AddRoleAssignmentResponse200
 */
export interface AddRoleAssignmentResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof AddRoleAssignmentResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {AddRoleAssignmentResponse200AllOfData}
     * @memberof AddRoleAssignmentResponse200
     */
    'data'?: AddRoleAssignmentResponse200AllOfData;
}
/**
 *
 * @export
 * @interface AddRoleAssignmentResponse200AllOf
 */
export interface AddRoleAssignmentResponse200AllOf {
    /**
     *
     * @type {AddRoleAssignmentResponse200AllOfData}
     * @memberof AddRoleAssignmentResponse200AllOf
     */
    'data'?: AddRoleAssignmentResponse200AllOfData;
}
/**
 * The response data
 * @export
 * @interface AddRoleAssignmentResponse200AllOfData
 */
export interface AddRoleAssignmentResponse200AllOfData {
    /**
     * The ID of the user that was added to the role
     * @type {number}
     * @memberof AddRoleAssignmentResponse200AllOfData
     */
    'user_id'?: number;
    /**
     * The ID of the role the user was added to
     * @type {number}
     * @memberof AddRoleAssignmentResponse200AllOfData
     */
    'role_id'?: number;
}
/**
 * The details of the role
 * @export
 * @interface AddRoleRequest
 */
export interface AddRoleRequest {
    /**
     * The name of the role
     * @type {string}
     * @memberof AddRoleRequest
     */
    'name': string;
    /**
     * The ID of the parent role
     * @type {number}
     * @memberof AddRoleRequest
     */
    'parent_role_id'?: number;
}
/**
 *
 * @export
 * @interface AddRoleResponse200
 */
export interface AddRoleResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof AddRoleResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {AddRoleResponse200AllOfData}
     * @memberof AddRoleResponse200
     */
    'data'?: AddRoleResponse200AllOfData;
}
/**
 *
 * @export
 * @interface AddRoleResponse200AllOf
 */
export interface AddRoleResponse200AllOf {
    /**
     *
     * @type {AddRoleResponse200AllOfData}
     * @memberof AddRoleResponse200AllOf
     */
    'data'?: AddRoleResponse200AllOfData;
}
/**
 * The response data
 * @export
 * @interface AddRoleResponse200AllOfData
 */
export interface AddRoleResponse200AllOfData {
    /**
     *
     * @type {number}
     * @memberof AddRoleResponse200AllOfData
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface AddStageRequest
 */
export interface AddStageRequest {
    /**
     * The name of the stage
     * @type {string}
     * @memberof AddStageRequest
     */
    'name': string;
    /**
     * The ID of the pipeline to add stage to
     * @type {number}
     * @memberof AddStageRequest
     */
    'pipeline_id': number;
    /**
     * The success probability percentage of the deal. Used/shown when deal weighted values are used.
     * @type {number}
     * @memberof AddStageRequest
     */
    'deal_probability'?: number;
    /**
     * Whether deals in this stage can become rotten
     * @type {boolean}
     * @memberof AddStageRequest
     */
    'rotten_flag'?: boolean;
    /**
     * The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
     * @type {number}
     * @memberof AddStageRequest
     */
    'rotten_days'?: number;
}
/**
 *
 * @export
 * @interface AddSubscriptionInstallmentRequest
 */
export interface AddSubscriptionInstallmentRequest {
    /**
     * The ID of the deal this installment subscription is associated with
     * @type {number}
     * @memberof AddSubscriptionInstallmentRequest
     */
    'deal_id': number;
    /**
     * The currency of the installment subscription. Accepts a 3-character currency code.
     * @type {string}
     * @memberof AddSubscriptionInstallmentRequest
     */
    'currency': string;
    /**
     * Array of payments. It requires a minimum structure as follows: [{ amount:SUM, description:DESCRIPTION, due_at:PAYMENT_DATE }]. Replace SUM with a payment amount, DESCRIPTION with an explanation string, PAYMENT_DATE with a date (format YYYY-MM-DD).
     * @type {Array<object>}
     * @memberof AddSubscriptionInstallmentRequest
     */
    'payments': Array<object>;
    /**
     * Indicates that the deal value must be set to the installment subscription\'s total value
     * @type {boolean}
     * @memberof AddSubscriptionInstallmentRequest
     */
    'update_deal_value'?: boolean;
}
/**
 *
 * @export
 * @interface AddTaskRequest
 */
export interface AddTaskRequest {
    /**
     * The title of the task
     * @type {string}
     * @memberof AddTaskRequest
     */
    'title': string;
    /**
     * The ID of a project
     * @type {number}
     * @memberof AddTaskRequest
     */
    'project_id': number;
    /**
     * The description of the task
     * @type {string}
     * @memberof AddTaskRequest
     */
    'description'?: string;
    /**
     * The ID of a parent task. Can not be ID of a task which is already a subtask.
     * @type {number}
     * @memberof AddTaskRequest
     */
    'parent_task_id'?: number;
    /**
     * The ID of the user who will be the assignee of the task
     * @type {number}
     * @memberof AddTaskRequest
     */
    'assignee_id'?: number;
    /**
     *
     * @type {number}
     * @memberof AddTaskRequest
     */
    'done'?: AddTaskRequestDoneConst;
    /**
     * The due date of the task. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof AddTaskRequest
     */
    'due_date'?: string;
}

export const AddTaskRequestDoneConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type AddTaskRequestDoneConst = typeof AddTaskRequestDoneConst[keyof typeof AddTaskRequestDoneConst];

/**
 *
 * @export
 * @interface AddTaskResponse201
 */
export interface AddTaskResponse201 {
    /**
     *
     * @type {boolean}
     * @memberof AddTaskResponse201
     */
    'success'?: boolean;
    /**
     *
     * @type {TaskResponseObject}
     * @memberof AddTaskResponse201
     */
    'data'?: TaskResponseObject;
    /**
     *
     * @type {object}
     * @memberof AddTaskResponse201
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface AddTeamRequest
 */
export interface AddTeamRequest {
    /**
     * The team name
     * @type {string}
     * @memberof AddTeamRequest
     */
    'name'?: string;
    /**
     * The team description
     * @type {string}
     * @memberof AddTeamRequest
     */
    'description'?: string;
    /**
     * The team manager ID
     * @type {number}
     * @memberof AddTeamRequest
     */
    'manager_id'?: number;
    /**
     * The IDs of the users that belong to the team
     * @type {Array<number>}
     * @memberof AddTeamRequest
     */
    'users'?: Array<number>;
}
/**
 *
 * @export
 * @interface AddTeamRequest1
 */
export interface AddTeamRequest1 {
    /**
     * The team name
     * @type {string}
     * @memberof AddTeamRequest1
     */
    'name': string;
    /**
     * The team description
     * @type {string}
     * @memberof AddTeamRequest1
     */
    'description'?: string;
    /**
     * The team manager ID
     * @type {number}
     * @memberof AddTeamRequest1
     */
    'manager_id': number;
    /**
     * The IDs of the users that belong to the team
     * @type {Array<number>}
     * @memberof AddTeamRequest1
     */
    'users'?: Array<number>;
}
/**
 *
 * @export
 * @interface AddTeamUserRequest
 */
export interface AddTeamUserRequest {
    /**
     * The list of user IDs
     * @type {Array<number>}
     * @memberof AddTeamUserRequest
     */
    'users': Array<number>;
}
/**
 *
 * @export
 * @interface AddUserRequest
 */
export interface AddUserRequest {
    /**
     * The email of the user
     * @type {string}
     * @memberof AddUserRequest
     */
    'email': string;
    /**
     * The access given to the user. Each item in the array represents access to a specific app. Optionally may include either admin flag or permission set ID to specify which access to give within the app. If both are omitted, the default access for the corresponding app will be used. It requires structure as follows: `[{ app: \'sales\', permission_set_id: \'62cc4d7f-4038-4352-abf3-a8c1c822b631\' }, { app: \'global\', admin: true }, { app: \'account_settings\' }]`
     * @type {Array<AddUserRequestAccessInner>}
     * @memberof AddUserRequest
     */
    'access'?: Array<AddUserRequestAccessInner>;
    /**
     * Whether the user is active or not. `false` = Not activated, `true` = Activated
     * @type {boolean}
     * @memberof AddUserRequest
     */
    'active_flag'?: boolean;
}
/**
 *
 * @export
 * @interface AddUserRequestAccessInner
 */
export interface AddUserRequestAccessInner {
    /**
     *
     * @type {string}
     * @memberof AddUserRequestAccessInner
     */
    'app': AddUserRequestAccessInnerAppConst;
    /**
     *
     * @type {boolean}
     * @memberof AddUserRequestAccessInner
     */
    'admin'?: boolean;
    /**
     *
     * @type {string}
     * @memberof AddUserRequestAccessInner
     */
    'permission_set_id'?: string;
}

export const AddUserRequestAccessInnerAppConst = {
    sales: 'sales',
    projects: 'projects',
    campaigns: 'campaigns',
    global: 'global',
    account_settings: 'account_settings'
} as const;

export type AddUserRequestAccessInnerAppConst = typeof AddUserRequestAccessInnerAppConst[keyof typeof AddUserRequestAccessInnerAppConst];

/**
 *
 * @export
 * @interface AddWebhookRequest
 */
export interface AddWebhookRequest {
    /**
     * A full, valid, publicly accessible URL which determines where to send the notifications. Please note that you cannot use Pipedrive API endpoints as the `subscription_url` and the chosen URL must not redirect to another link.
     * @type {string}
     * @memberof AddWebhookRequest
     */
    'subscription_url': string;
    /**
     * The type of action to receive notifications about. Wildcard will match all supported actions.
     * @type {string}
     * @memberof AddWebhookRequest
     */
    'event_action': AddWebhookRequestEventActionConst;
    /**
     * The type of object to receive notifications about. Wildcard will match all supported objects.
     * @type {string}
     * @memberof AddWebhookRequest
     */
    'event_object': AddWebhookRequestEventObjectConst;
    /**
     * The ID of the user that this webhook will be authorized with. You have the option to use a different user\'s `user_id`. If it is not set, the current user\'s `user_id` will be used. As each webhook event is checked against a user’s permissions, the webhook will only be sent if the user has access to the specified object(s). If you want to receive notifications for all events, please use a top-level admin user’s `user_id`.
     * @type {number}
     * @memberof AddWebhookRequest
     */
    'user_id'?: number;
    /**
     * The HTTP basic auth username of the subscription URL endpoint (if required)
     * @type {string}
     * @memberof AddWebhookRequest
     */
    'http_auth_user'?: string;
    /**
     * The HTTP basic auth password of the subscription URL endpoint (if required)
     * @type {string}
     * @memberof AddWebhookRequest
     */
    'http_auth_password'?: string;
    /**
     * The webhook\'s version
     * @type {string}
     * @memberof AddWebhookRequest
     */
    'version'?: AddWebhookRequestVersionConst;
}

export const AddWebhookRequestEventActionConst = {
    added: 'added',
    updated: 'updated',
    merged: 'merged',
    deleted: 'deleted',
    Star: '*'
} as const;

export type AddWebhookRequestEventActionConst = typeof AddWebhookRequestEventActionConst[keyof typeof AddWebhookRequestEventActionConst];
export const AddWebhookRequestEventObjectConst = {
    activity: 'activity',
    activityType: 'activityType',
    deal: 'deal',
    note: 'note',
    organization: 'organization',
    person: 'person',
    pipeline: 'pipeline',
    product: 'product',
    stage: 'stage',
    user: 'user',
    Star: '*'
} as const;

export type AddWebhookRequestEventObjectConst = typeof AddWebhookRequestEventObjectConst[keyof typeof AddWebhookRequestEventObjectConst];
export const AddWebhookRequestVersionConst = {
    _1_0: '1.0',
    _2_0: '2.0'
} as const;

export type AddWebhookRequestVersionConst = typeof AddWebhookRequestVersionConst[keyof typeof AddWebhookRequestVersionConst];

/**
 *
 * @export
 * @interface AdditionalBaseOrganizationItemInfo
 */
export interface AdditionalBaseOrganizationItemInfo {
    /**
     * The count of email messages related to the organization
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'email_messages_count'?: number;
    /**
     * The count of persons related to the organization
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'people_count'?: number;
    /**
     * The count of activities related to the organization
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the organization
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the organization
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the organization
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'files_count'?: number;
    /**
     * The count of notes related to the organization
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the organization
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'followers_count'?: number;
    /**
     * The full address of the organization
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'address'?: string;
    /**
     * The sub-premise of the organization location
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'address_subpremise'?: string;
    /**
     * The street number of the organization location
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'address_street_number'?: string;
    /**
     * The route of the organization location
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'address_route'?: string;
    /**
     * The sub-locality of the organization location
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'address_sublocality'?: string;
    /**
     * The locality of the organization location
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'address_locality'?: string;
    /**
     * The level 1 admin area of the organization location
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'address_admin_area_level_1'?: string;
    /**
     * The level 2 admin area of the organization location
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'address_admin_area_level_2'?: string;
    /**
     * The country of the organization location
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'address_country'?: string;
    /**
     * The postal code of the organization location
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'address_postal_code'?: string;
    /**
     * The formatted organization location
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'address_formatted_address'?: string;
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'related_lost_deals_count'?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof AdditionalBaseOrganizationItemInfo
     */
    'last_activity_date'?: string | null;
}
/**
 *
 * @export
 * @interface AdditionalMergePersonInfo
 */
export interface AdditionalMergePersonInfo {
    /**
     * The ID of the owner related to the person
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'owner_id'?: number;
    /**
     * The ID of the organization related to the person
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'org_id'?: number;
    /**
     * The ID of the person with what the main person was merged
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'merge_what_id'?: number;
    /**
     * The name of the person
     * @type {string}
     * @memberof AdditionalMergePersonInfo
     */
    'name'?: string;
    /**
     * The first name of the person
     * @type {string}
     * @memberof AdditionalMergePersonInfo
     */
    'first_name'?: string;
    /**
     * The last name of the person
     * @type {string}
     * @memberof AdditionalMergePersonInfo
     */
    'last_name'?: string;
    /**
     * The count of email messages related to the person
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'email_messages_count'?: number;
    /**
     * The count of activities related to the person
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the person
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the person
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the person
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'files_count'?: number;
    /**
     * The count of notes related to the person
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the person
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'followers_count'?: number;
    /**
     * The date and time of the last incoming email associated with the person
     * @type {string}
     * @memberof AdditionalMergePersonInfo
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the person
     * @type {string}
     * @memberof AdditionalMergePersonInfo
     */
    'last_outgoing_mail_time'?: string;
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'related_lost_deals_count'?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof AdditionalMergePersonInfo
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof AdditionalMergePersonInfo
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof AdditionalMergePersonInfo
     */
    'last_activity_date'?: string | null;
    /**
     * The count of open participant deals related with the item
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'participant_open_deals_count'?: number;
    /**
     * The count of closed participant deals related with the item
     * @type {number}
     * @memberof AdditionalMergePersonInfo
     */
    'participant_closed_deals_count'?: number;
}
/**
 *
 * @export
 * @interface AdditionalPersonInfo
 */
export interface AdditionalPersonInfo {
    /**
     *
     * @type {Owner}
     * @memberof AdditionalPersonInfo
     */
    'owner_id'?: Owner;
    /**
     *
     * @type {RelationshipOrganizationInfoItemWithActiveFlag}
     * @memberof AdditionalPersonInfo
     */
    'org_id'?: RelationshipOrganizationInfoItemWithActiveFlag;
    /**
     * The name of the person
     * @type {string}
     * @memberof AdditionalPersonInfo
     */
    'name'?: string;
    /**
     * The first name of the person
     * @type {string}
     * @memberof AdditionalPersonInfo
     */
    'first_name'?: string;
    /**
     * The last name of the person
     * @type {string}
     * @memberof AdditionalPersonInfo
     */
    'last_name'?: string;
    /**
     * The count of email messages related to the person
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'email_messages_count'?: number;
    /**
     * The count of activities related to the person
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the person
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the person
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the person
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'files_count'?: number;
    /**
     * The count of notes related to the person
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the person
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'followers_count'?: number;
    /**
     * The date and time of the last incoming email associated with the person
     * @type {string}
     * @memberof AdditionalPersonInfo
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the person
     * @type {string}
     * @memberof AdditionalPersonInfo
     */
    'last_outgoing_mail_time'?: string;
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'related_lost_deals_count'?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof AdditionalPersonInfo
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof AdditionalPersonInfo
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof AdditionalPersonInfo
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof AdditionalPersonInfo
     */
    'last_activity_date'?: string | null;
}
/**
 *
 * @export
 * @interface BaseDeal
 */
export interface BaseDeal {
    /**
     * The ID of the deal stage
     * @type {number}
     * @memberof BaseDeal
     */
    'stage_id'?: number;
    /**
     * The title of the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'title'?: string;
    /**
     * The value of the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'value'?: number;
    /**
     * The currency associated with the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'currency'?: string;
    /**
     * The creation date and time of the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'update_time'?: string;
    /**
     * The last updated date and time of the deal stage
     * @type {string}
     * @memberof BaseDeal
     */
    'stage_change_time'?: string;
    /**
     * Whether the deal is active or not
     * @type {boolean}
     * @memberof BaseDeal
     */
    'active'?: boolean;
    /**
     * Whether the deal is deleted or not
     * @type {boolean}
     * @memberof BaseDeal
     */
    'deleted'?: boolean;
    /**
     * The status of the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'status'?: string;
    /**
     * The success probability percentage of the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'probability'?: number | null;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'next_activity_date'?: string;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'next_activity_time'?: string;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'last_activity_date'?: string | null;
    /**
     * The reason for losing the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'lost_reason'?: string | null;
    /**
     * The visibility of the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'visible_to'?: string;
    /**
     * The date and time of closing the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'close_time'?: string | null;
    /**
     * The ID of the pipeline associated with the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'pipeline_id'?: number;
    /**
     * The date and time of changing the deal status as won
     * @type {string}
     * @memberof BaseDeal
     */
    'won_time'?: string;
    /**
     * The date and time of the first time changing the deal status as won
     * @type {string}
     * @memberof BaseDeal
     */
    'first_won_time'?: string;
    /**
     * The date and time of changing the deal status as lost
     * @type {string}
     * @memberof BaseDeal
     */
    'lost_time'?: string;
    /**
     * The number of products associated with the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'products_count'?: number;
    /**
     * The number of files associated with the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'files_count'?: number;
    /**
     * The number of notes associated with the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'notes_count'?: number;
    /**
     * The number of followers associated with the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'followers_count'?: number;
    /**
     * The number of emails associated with the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'email_messages_count'?: number;
    /**
     * The number of activities associated with the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'activities_count'?: number;
    /**
     * The number of completed activities associated with the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'done_activities_count'?: number;
    /**
     * The number of incomplete activities associated with the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'undone_activities_count'?: number;
    /**
     * The number of participants associated with the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'participants_count'?: number;
    /**
     * The expected close date of the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'expected_close_date'?: string;
    /**
     * The date and time of the last incoming email associated with the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'last_outgoing_mail_time'?: string;
    /**
     * The label or multiple labels assigned to the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'label'?: string;
    /**
     * The order number of the deal stage associated with the deal
     * @type {number}
     * @memberof BaseDeal
     */
    'stage_order_nr'?: number;
    /**
     * The name of the person associated with the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'person_name'?: string;
    /**
     * The name of the organization associated with the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'org_name'?: string;
    /**
     * The subject of the next activity associated with the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'next_activity_subject'?: string;
    /**
     * The type of the next activity associated with the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'next_activity_type'?: string;
    /**
     * The duration of the next activity associated with the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'next_activity_duration'?: string;
    /**
     * The note of the next activity associated with the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'next_activity_note'?: string;
    /**
     * The deal value formatted with selected currency. E.g. US$500
     * @type {string}
     * @memberof BaseDeal
     */
    'formatted_value'?: string;
    /**
     * Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
     * @type {number}
     * @memberof BaseDeal
     */
    'weighted_value'?: number;
    /**
     * The weighted_value formatted with selected currency. E.g. US$500
     * @type {string}
     * @memberof BaseDeal
     */
    'formatted_weighted_value'?: string;
    /**
     * The currency associated with the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'weighted_value_currency'?: string;
    /**
     * The date and time of changing the deal status as rotten
     * @type {string}
     * @memberof BaseDeal
     */
    'rotten_time'?: string | null;
    /**
     * The name of the deal owner
     * @type {string}
     * @memberof BaseDeal
     */
    'owner_name'?: string;
    /**
     * The BCC email of the deal
     * @type {string}
     * @memberof BaseDeal
     */
    'cc_email'?: string;
    /**
     * If the organization that is associated with the deal is hidden or not
     * @type {boolean}
     * @memberof BaseDeal
     */
    'org_hidden'?: boolean;
    /**
     * If the person that is associated with the deal is hidden or not
     * @type {boolean}
     * @memberof BaseDeal
     */
    'person_hidden'?: boolean;
}
/**
 *
 * @export
 * @interface BaseMailThread
 */
export interface BaseMailThread {
    /**
     * ID of the mail thread
     * @type {number}
     * @memberof BaseMailThread
     */
    'id'?: number;
    /**
     * The connection account ID
     * @type {string}
     * @memberof BaseMailThread
     */
    'account_id'?: string;
    /**
     * ID of the user whom mail message will be assigned to
     * @type {number}
     * @memberof BaseMailThread
     */
    'user_id'?: number;
    /**
     * The subject
     * @type {string}
     * @memberof BaseMailThread
     */
    'subject'?: string;
    /**
     * A snippet
     * @type {string}
     * @memberof BaseMailThread
     */
    'snippet'?: string;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'read_flag'?: BaseMailThreadReadFlagConst;
    /**
     * Mail tracking status
     * @type {string}
     * @memberof BaseMailThread
     */
    'mail_tracking_status'?: string | null;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'has_attachments_flag'?: BaseMailThreadHasAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'has_inline_attachments_flag'?: BaseMailThreadHasInlineAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'has_real_attachments_flag'?: BaseMailThreadHasRealAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'deleted_flag'?: BaseMailThreadDeletedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'synced_flag'?: BaseMailThreadSyncedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'smart_bcc_flag'?: BaseMailThreadSmartBccFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'mail_link_tracking_enabled_flag'?: BaseMailThreadMailLinkTrackingEnabledFlagConst;
    /**
     *
     * @type {BaseMailThreadAllOf1Parties}
     * @memberof BaseMailThread
     */
    'parties'?: BaseMailThreadAllOf1Parties;
    /**
     * Parties of the drafted mail thread
     * @type {Array<object>}
     * @memberof BaseMailThread
     */
    'drafts_parties'?: Array<object>;
    /**
     * Folders in which messages from thread are being stored
     * @type {Array<string>}
     * @memberof BaseMailThread
     */
    'folders'?: Array<string>;
    /**
     * Version
     * @type {number}
     * @memberof BaseMailThread
     */
    'version'?: number;
    /**
     * A snippet from a draft
     * @type {string}
     * @memberof BaseMailThread
     */
    'snippet_draft'?: string | null;
    /**
     * A snippet from a message sent
     * @type {string}
     * @memberof BaseMailThread
     */
    'snippet_sent'?: string;
    /**
     * An amount of messages
     * @type {number}
     * @memberof BaseMailThread
     */
    'message_count'?: number;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'has_draft_flag'?: BaseMailThreadHasDraftFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'has_sent_flag'?: BaseMailThreadHasSentFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'archived_flag'?: BaseMailThreadArchivedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'shared_flag'?: BaseMailThreadSharedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'external_deleted_flag'?: BaseMailThreadExternalDeletedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'first_message_to_me_flag'?: BaseMailThreadFirstMessageToMeFlagConst;
    /**
     * Last message timestamp
     * @type {string}
     * @memberof BaseMailThread
     */
    'last_message_timestamp'?: string;
    /**
     * The time when the mail thread has had the first message received or created
     * @type {string}
     * @memberof BaseMailThread
     */
    'first_message_timestamp'?: string;
    /**
     * The last time when the mail thread has had a message sent
     * @type {string}
     * @memberof BaseMailThread
     */
    'last_message_sent_timestamp'?: string | null;
    /**
     * The last time when the mail thread has had a message received
     * @type {string}
     * @memberof BaseMailThread
     */
    'last_message_received_timestamp'?: string;
    /**
     * The time when the mail thread was inserted to database
     * @type {string}
     * @memberof BaseMailThread
     */
    'add_time'?: string;
    /**
     * The time when the mail thread was updated in database received
     * @type {string}
     * @memberof BaseMailThread
     */
    'update_time'?: string;
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BaseMailThread
     */
    'deal_id'?: number | null;
    /**
     * Status of the deal
     * @type {string}
     * @memberof BaseMailThread
     */
    'deal_status'?: string | null;
    /**
     * The ID of the lead
     * @type {string}
     * @memberof BaseMailThread
     */
    'lead_id'?: string | null;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread
     */
    'all_messages_sent_flag'?: BaseMailThreadAllMessagesSentFlagConst;
}

export const BaseMailThreadReadFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadReadFlagConst = typeof BaseMailThreadReadFlagConst[keyof typeof BaseMailThreadReadFlagConst];
export const BaseMailThreadHasAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadHasAttachmentsFlagConst = typeof BaseMailThreadHasAttachmentsFlagConst[keyof typeof BaseMailThreadHasAttachmentsFlagConst];
export const BaseMailThreadHasInlineAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadHasInlineAttachmentsFlagConst = typeof BaseMailThreadHasInlineAttachmentsFlagConst[keyof typeof BaseMailThreadHasInlineAttachmentsFlagConst];
export const BaseMailThreadHasRealAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadHasRealAttachmentsFlagConst = typeof BaseMailThreadHasRealAttachmentsFlagConst[keyof typeof BaseMailThreadHasRealAttachmentsFlagConst];
export const BaseMailThreadDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadDeletedFlagConst = typeof BaseMailThreadDeletedFlagConst[keyof typeof BaseMailThreadDeletedFlagConst];
export const BaseMailThreadSyncedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadSyncedFlagConst = typeof BaseMailThreadSyncedFlagConst[keyof typeof BaseMailThreadSyncedFlagConst];
export const BaseMailThreadSmartBccFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadSmartBccFlagConst = typeof BaseMailThreadSmartBccFlagConst[keyof typeof BaseMailThreadSmartBccFlagConst];
export const BaseMailThreadMailLinkTrackingEnabledFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadMailLinkTrackingEnabledFlagConst = typeof BaseMailThreadMailLinkTrackingEnabledFlagConst[keyof typeof BaseMailThreadMailLinkTrackingEnabledFlagConst];
export const BaseMailThreadHasDraftFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadHasDraftFlagConst = typeof BaseMailThreadHasDraftFlagConst[keyof typeof BaseMailThreadHasDraftFlagConst];
export const BaseMailThreadHasSentFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadHasSentFlagConst = typeof BaseMailThreadHasSentFlagConst[keyof typeof BaseMailThreadHasSentFlagConst];
export const BaseMailThreadArchivedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadArchivedFlagConst = typeof BaseMailThreadArchivedFlagConst[keyof typeof BaseMailThreadArchivedFlagConst];
export const BaseMailThreadSharedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadSharedFlagConst = typeof BaseMailThreadSharedFlagConst[keyof typeof BaseMailThreadSharedFlagConst];
export const BaseMailThreadExternalDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadExternalDeletedFlagConst = typeof BaseMailThreadExternalDeletedFlagConst[keyof typeof BaseMailThreadExternalDeletedFlagConst];
export const BaseMailThreadFirstMessageToMeFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadFirstMessageToMeFlagConst = typeof BaseMailThreadFirstMessageToMeFlagConst[keyof typeof BaseMailThreadFirstMessageToMeFlagConst];
export const BaseMailThreadAllMessagesSentFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllMessagesSentFlagConst = typeof BaseMailThreadAllMessagesSentFlagConst[keyof typeof BaseMailThreadAllMessagesSentFlagConst];

/**
 * The mail thread object
 * @export
 * @interface BaseMailThread1
 */
export interface BaseMailThread1 {
    /**
     * ID of the mail thread
     * @type {number}
     * @memberof BaseMailThread1
     */
    'id'?: number;
    /**
     * The connection account ID
     * @type {string}
     * @memberof BaseMailThread1
     */
    'account_id'?: string;
    /**
     * ID of the user whom mail message will be assigned to
     * @type {number}
     * @memberof BaseMailThread1
     */
    'user_id'?: number;
    /**
     * The subject
     * @type {string}
     * @memberof BaseMailThread1
     */
    'subject'?: string;
    /**
     * A snippet
     * @type {string}
     * @memberof BaseMailThread1
     */
    'snippet'?: string;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'read_flag'?: BaseMailThread1ReadFlagConst;
    /**
     * Mail tracking status
     * @type {string}
     * @memberof BaseMailThread1
     */
    'mail_tracking_status'?: string | null;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'has_attachments_flag'?: BaseMailThread1HasAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'has_inline_attachments_flag'?: BaseMailThread1HasInlineAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'has_real_attachments_flag'?: BaseMailThread1HasRealAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'deleted_flag'?: BaseMailThread1DeletedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'synced_flag'?: BaseMailThread1SyncedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'smart_bcc_flag'?: BaseMailThread1SmartBccFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'mail_link_tracking_enabled_flag'?: BaseMailThread1MailLinkTrackingEnabledFlagConst;
    /**
     *
     * @type {BaseMailThreadAllOf1Parties}
     * @memberof BaseMailThread1
     */
    'parties'?: BaseMailThreadAllOf1Parties;
    /**
     * Parties of the drafted mail thread
     * @type {Array<object>}
     * @memberof BaseMailThread1
     */
    'drafts_parties'?: Array<object>;
    /**
     * Folders in which messages from thread are being stored
     * @type {Array<string>}
     * @memberof BaseMailThread1
     */
    'folders'?: Array<string>;
    /**
     * Version
     * @type {number}
     * @memberof BaseMailThread1
     */
    'version'?: number;
    /**
     * A snippet from a draft
     * @type {string}
     * @memberof BaseMailThread1
     */
    'snippet_draft'?: string | null;
    /**
     * A snippet from a message sent
     * @type {string}
     * @memberof BaseMailThread1
     */
    'snippet_sent'?: string;
    /**
     * An amount of messages
     * @type {number}
     * @memberof BaseMailThread1
     */
    'message_count'?: number;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'has_draft_flag'?: BaseMailThread1HasDraftFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'has_sent_flag'?: BaseMailThread1HasSentFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'archived_flag'?: BaseMailThread1ArchivedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'shared_flag'?: BaseMailThread1SharedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'external_deleted_flag'?: BaseMailThread1ExternalDeletedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'first_message_to_me_flag'?: BaseMailThread1FirstMessageToMeFlagConst;
    /**
     * Last message timestamp
     * @type {string}
     * @memberof BaseMailThread1
     */
    'last_message_timestamp'?: string;
    /**
     * The time when the mail thread has had the first message received or created
     * @type {string}
     * @memberof BaseMailThread1
     */
    'first_message_timestamp'?: string;
    /**
     * The last time when the mail thread has had a message sent
     * @type {string}
     * @memberof BaseMailThread1
     */
    'last_message_sent_timestamp'?: string | null;
    /**
     * The last time when the mail thread has had a message received
     * @type {string}
     * @memberof BaseMailThread1
     */
    'last_message_received_timestamp'?: string;
    /**
     * The time when the mail thread was inserted to database
     * @type {string}
     * @memberof BaseMailThread1
     */
    'add_time'?: string;
    /**
     * The time when the mail thread was updated in database received
     * @type {string}
     * @memberof BaseMailThread1
     */
    'update_time'?: string;
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BaseMailThread1
     */
    'deal_id'?: number | null;
    /**
     * Status of the deal
     * @type {string}
     * @memberof BaseMailThread1
     */
    'deal_status'?: string | null;
    /**
     * The ID of the lead
     * @type {string}
     * @memberof BaseMailThread1
     */
    'lead_id'?: string | null;
    /**
     *
     * @type {number}
     * @memberof BaseMailThread1
     */
    'all_messages_sent_flag'?: BaseMailThread1AllMessagesSentFlagConst;
}

export const BaseMailThread1ReadFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1ReadFlagConst = typeof BaseMailThread1ReadFlagConst[keyof typeof BaseMailThread1ReadFlagConst];
export const BaseMailThread1HasAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1HasAttachmentsFlagConst = typeof BaseMailThread1HasAttachmentsFlagConst[keyof typeof BaseMailThread1HasAttachmentsFlagConst];
export const BaseMailThread1HasInlineAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1HasInlineAttachmentsFlagConst = typeof BaseMailThread1HasInlineAttachmentsFlagConst[keyof typeof BaseMailThread1HasInlineAttachmentsFlagConst];
export const BaseMailThread1HasRealAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1HasRealAttachmentsFlagConst = typeof BaseMailThread1HasRealAttachmentsFlagConst[keyof typeof BaseMailThread1HasRealAttachmentsFlagConst];
export const BaseMailThread1DeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1DeletedFlagConst = typeof BaseMailThread1DeletedFlagConst[keyof typeof BaseMailThread1DeletedFlagConst];
export const BaseMailThread1SyncedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1SyncedFlagConst = typeof BaseMailThread1SyncedFlagConst[keyof typeof BaseMailThread1SyncedFlagConst];
export const BaseMailThread1SmartBccFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1SmartBccFlagConst = typeof BaseMailThread1SmartBccFlagConst[keyof typeof BaseMailThread1SmartBccFlagConst];
export const BaseMailThread1MailLinkTrackingEnabledFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1MailLinkTrackingEnabledFlagConst = typeof BaseMailThread1MailLinkTrackingEnabledFlagConst[keyof typeof BaseMailThread1MailLinkTrackingEnabledFlagConst];
export const BaseMailThread1HasDraftFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1HasDraftFlagConst = typeof BaseMailThread1HasDraftFlagConst[keyof typeof BaseMailThread1HasDraftFlagConst];
export const BaseMailThread1HasSentFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1HasSentFlagConst = typeof BaseMailThread1HasSentFlagConst[keyof typeof BaseMailThread1HasSentFlagConst];
export const BaseMailThread1ArchivedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1ArchivedFlagConst = typeof BaseMailThread1ArchivedFlagConst[keyof typeof BaseMailThread1ArchivedFlagConst];
export const BaseMailThread1SharedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1SharedFlagConst = typeof BaseMailThread1SharedFlagConst[keyof typeof BaseMailThread1SharedFlagConst];
export const BaseMailThread1ExternalDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1ExternalDeletedFlagConst = typeof BaseMailThread1ExternalDeletedFlagConst[keyof typeof BaseMailThread1ExternalDeletedFlagConst];
export const BaseMailThread1FirstMessageToMeFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1FirstMessageToMeFlagConst = typeof BaseMailThread1FirstMessageToMeFlagConst[keyof typeof BaseMailThread1FirstMessageToMeFlagConst];
export const BaseMailThread1AllMessagesSentFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThread1AllMessagesSentFlagConst = typeof BaseMailThread1AllMessagesSentFlagConst[keyof typeof BaseMailThread1AllMessagesSentFlagConst];

/**
 *
 * @export
 * @interface BaseMailThreadAllOf
 */
export interface BaseMailThreadAllOf {
    /**
     * ID of the mail thread
     * @type {number}
     * @memberof BaseMailThreadAllOf
     */
    'id'?: number;
    /**
     * The connection account ID
     * @type {string}
     * @memberof BaseMailThreadAllOf
     */
    'account_id'?: string;
    /**
     * ID of the user whom mail message will be assigned to
     * @type {number}
     * @memberof BaseMailThreadAllOf
     */
    'user_id'?: number;
    /**
     * The subject
     * @type {string}
     * @memberof BaseMailThreadAllOf
     */
    'subject'?: string;
    /**
     * A snippet
     * @type {string}
     * @memberof BaseMailThreadAllOf
     */
    'snippet'?: string;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf
     */
    'read_flag'?: BaseMailThreadAllOfReadFlagConst;
    /**
     * Mail tracking status
     * @type {string}
     * @memberof BaseMailThreadAllOf
     */
    'mail_tracking_status'?: string | null;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf
     */
    'has_attachments_flag'?: BaseMailThreadAllOfHasAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf
     */
    'has_inline_attachments_flag'?: BaseMailThreadAllOfHasInlineAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf
     */
    'has_real_attachments_flag'?: BaseMailThreadAllOfHasRealAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf
     */
    'deleted_flag'?: BaseMailThreadAllOfDeletedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf
     */
    'synced_flag'?: BaseMailThreadAllOfSyncedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf
     */
    'smart_bcc_flag'?: BaseMailThreadAllOfSmartBccFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf
     */
    'mail_link_tracking_enabled_flag'?: BaseMailThreadAllOfMailLinkTrackingEnabledFlagConst;
}

export const BaseMailThreadAllOfReadFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOfReadFlagConst = typeof BaseMailThreadAllOfReadFlagConst[keyof typeof BaseMailThreadAllOfReadFlagConst];
export const BaseMailThreadAllOfHasAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOfHasAttachmentsFlagConst = typeof BaseMailThreadAllOfHasAttachmentsFlagConst[keyof typeof BaseMailThreadAllOfHasAttachmentsFlagConst];
export const BaseMailThreadAllOfHasInlineAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOfHasInlineAttachmentsFlagConst = typeof BaseMailThreadAllOfHasInlineAttachmentsFlagConst[keyof typeof BaseMailThreadAllOfHasInlineAttachmentsFlagConst];
export const BaseMailThreadAllOfHasRealAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOfHasRealAttachmentsFlagConst = typeof BaseMailThreadAllOfHasRealAttachmentsFlagConst[keyof typeof BaseMailThreadAllOfHasRealAttachmentsFlagConst];
export const BaseMailThreadAllOfDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOfDeletedFlagConst = typeof BaseMailThreadAllOfDeletedFlagConst[keyof typeof BaseMailThreadAllOfDeletedFlagConst];
export const BaseMailThreadAllOfSyncedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOfSyncedFlagConst = typeof BaseMailThreadAllOfSyncedFlagConst[keyof typeof BaseMailThreadAllOfSyncedFlagConst];
export const BaseMailThreadAllOfSmartBccFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOfSmartBccFlagConst = typeof BaseMailThreadAllOfSmartBccFlagConst[keyof typeof BaseMailThreadAllOfSmartBccFlagConst];
export const BaseMailThreadAllOfMailLinkTrackingEnabledFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOfMailLinkTrackingEnabledFlagConst = typeof BaseMailThreadAllOfMailLinkTrackingEnabledFlagConst[keyof typeof BaseMailThreadAllOfMailLinkTrackingEnabledFlagConst];

/**
 *
 * @export
 * @interface BaseMailThreadAllOf1
 */
export interface BaseMailThreadAllOf1 {
    /**
     *
     * @type {BaseMailThreadAllOf1Parties}
     * @memberof BaseMailThreadAllOf1
     */
    'parties'?: BaseMailThreadAllOf1Parties;
    /**
     * Parties of the drafted mail thread
     * @type {Array<object>}
     * @memberof BaseMailThreadAllOf1
     */
    'drafts_parties'?: Array<object>;
    /**
     * Folders in which messages from thread are being stored
     * @type {Array<string>}
     * @memberof BaseMailThreadAllOf1
     */
    'folders'?: Array<string>;
    /**
     * Version
     * @type {number}
     * @memberof BaseMailThreadAllOf1
     */
    'version'?: number;
    /**
     * A snippet from a draft
     * @type {string}
     * @memberof BaseMailThreadAllOf1
     */
    'snippet_draft'?: string | null;
    /**
     * A snippet from a message sent
     * @type {string}
     * @memberof BaseMailThreadAllOf1
     */
    'snippet_sent'?: string;
    /**
     * An amount of messages
     * @type {number}
     * @memberof BaseMailThreadAllOf1
     */
    'message_count'?: number;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf1
     */
    'has_draft_flag'?: BaseMailThreadAllOf1HasDraftFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf1
     */
    'has_sent_flag'?: BaseMailThreadAllOf1HasSentFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf1
     */
    'archived_flag'?: BaseMailThreadAllOf1ArchivedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf1
     */
    'shared_flag'?: BaseMailThreadAllOf1SharedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf1
     */
    'external_deleted_flag'?: BaseMailThreadAllOf1ExternalDeletedFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf1
     */
    'first_message_to_me_flag'?: BaseMailThreadAllOf1FirstMessageToMeFlagConst;
    /**
     * Last message timestamp
     * @type {string}
     * @memberof BaseMailThreadAllOf1
     */
    'last_message_timestamp'?: string;
    /**
     * The time when the mail thread has had the first message received or created
     * @type {string}
     * @memberof BaseMailThreadAllOf1
     */
    'first_message_timestamp'?: string;
    /**
     * The last time when the mail thread has had a message sent
     * @type {string}
     * @memberof BaseMailThreadAllOf1
     */
    'last_message_sent_timestamp'?: string | null;
    /**
     * The last time when the mail thread has had a message received
     * @type {string}
     * @memberof BaseMailThreadAllOf1
     */
    'last_message_received_timestamp'?: string;
    /**
     * The time when the mail thread was inserted to database
     * @type {string}
     * @memberof BaseMailThreadAllOf1
     */
    'add_time'?: string;
    /**
     * The time when the mail thread was updated in database received
     * @type {string}
     * @memberof BaseMailThreadAllOf1
     */
    'update_time'?: string;
    /**
     * The ID of the deal
     * @type {number}
     * @memberof BaseMailThreadAllOf1
     */
    'deal_id'?: number | null;
    /**
     * Status of the deal
     * @type {string}
     * @memberof BaseMailThreadAllOf1
     */
    'deal_status'?: string | null;
    /**
     * The ID of the lead
     * @type {string}
     * @memberof BaseMailThreadAllOf1
     */
    'lead_id'?: string | null;
    /**
     *
     * @type {number}
     * @memberof BaseMailThreadAllOf1
     */
    'all_messages_sent_flag'?: BaseMailThreadAllOf1AllMessagesSentFlagConst;
}

export const BaseMailThreadAllOf1HasDraftFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOf1HasDraftFlagConst = typeof BaseMailThreadAllOf1HasDraftFlagConst[keyof typeof BaseMailThreadAllOf1HasDraftFlagConst];
export const BaseMailThreadAllOf1HasSentFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOf1HasSentFlagConst = typeof BaseMailThreadAllOf1HasSentFlagConst[keyof typeof BaseMailThreadAllOf1HasSentFlagConst];
export const BaseMailThreadAllOf1ArchivedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOf1ArchivedFlagConst = typeof BaseMailThreadAllOf1ArchivedFlagConst[keyof typeof BaseMailThreadAllOf1ArchivedFlagConst];
export const BaseMailThreadAllOf1SharedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOf1SharedFlagConst = typeof BaseMailThreadAllOf1SharedFlagConst[keyof typeof BaseMailThreadAllOf1SharedFlagConst];
export const BaseMailThreadAllOf1ExternalDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOf1ExternalDeletedFlagConst = typeof BaseMailThreadAllOf1ExternalDeletedFlagConst[keyof typeof BaseMailThreadAllOf1ExternalDeletedFlagConst];
export const BaseMailThreadAllOf1FirstMessageToMeFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOf1FirstMessageToMeFlagConst = typeof BaseMailThreadAllOf1FirstMessageToMeFlagConst[keyof typeof BaseMailThreadAllOf1FirstMessageToMeFlagConst];
export const BaseMailThreadAllOf1AllMessagesSentFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseMailThreadAllOf1AllMessagesSentFlagConst = typeof BaseMailThreadAllOf1AllMessagesSentFlagConst[keyof typeof BaseMailThreadAllOf1AllMessagesSentFlagConst];

/**
 * Parties of the mail thread
 * @export
 * @interface BaseMailThreadAllOf1Parties
 */
export interface BaseMailThreadAllOf1Parties {
    /**
     * Recipients of the mail thread
     * @type {Array<BaseMailThreadAllOf1PartiesToInner>}
     * @memberof BaseMailThreadAllOf1Parties
     */
    'to'?: Array<BaseMailThreadAllOf1PartiesToInner>;
    /**
     * Senders of the mail thread
     * @type {Array<BaseMailThreadAllOf1PartiesToInner>}
     * @memberof BaseMailThreadAllOf1Parties
     */
    'from'?: Array<BaseMailThreadAllOf1PartiesToInner>;
}
/**
 * Member of a thread
 * @export
 * @interface BaseMailThreadAllOf1PartiesToInner
 */
export interface BaseMailThreadAllOf1PartiesToInner {
    /**
     * ID of the mail thread participant
     * @type {number}
     * @memberof BaseMailThreadAllOf1PartiesToInner
     */
    'id'?: number;
    /**
     * Name of the mail thread participant
     * @type {string}
     * @memberof BaseMailThreadAllOf1PartiesToInner
     */
    'name'?: string;
    /**
     * Whether the mail thread participant was last to send an email
     * @type {boolean}
     * @memberof BaseMailThreadAllOf1PartiesToInner
     */
    'latest_sent'?: boolean;
    /**
     * Email address of the mail thread participant
     * @type {string}
     * @memberof BaseMailThreadAllOf1PartiesToInner
     */
    'email_address'?: string;
    /**
     * Message time
     * @type {number}
     * @memberof BaseMailThreadAllOf1PartiesToInner
     */
    'message_time'?: number;
    /**
     * ID of the linked person
     * @type {number}
     * @memberof BaseMailThreadAllOf1PartiesToInner
     */
    'linked_person_id'?: number;
    /**
     * Email of the linked person
     * @type {string}
     * @memberof BaseMailThreadAllOf1PartiesToInner
     */
    'linked_person_name'?: string;
    /**
     * ID of the mail message party
     * @type {number}
     * @memberof BaseMailThreadAllOf1PartiesToInner
     */
    'mail_message_party_id'?: number;
    /**
     * Linked Organization ID
     * @type {number}
     * @memberof BaseMailThreadAllOf1PartiesToInner
     */
    'linked_organization_id'?: number | null;
}
/**
 *
 * @export
 * @interface BaseOrganizationItem
 */
export interface BaseOrganizationItem {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'id'?: number;
    /**
     * The ID of the company related to the organization
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'company_id'?: number;
    /**
     *
     * @type {Owner}
     * @memberof BaseOrganizationItem
     */
    'owner_id'?: Owner;
    /**
     * The name of the organization
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'name'?: string;
    /**
     * Whether the organization is active or not
     * @type {boolean}
     * @memberof BaseOrganizationItem
     */
    'active_flag'?: boolean;
    /**
     *
     * @type {BaseOrganizationItemAllOfPictureId}
     * @memberof BaseOrganizationItem
     */
    'picture_id'?: BaseOrganizationItemAllOfPictureId;
    /**
     * The country code of the organization
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'country_code'?: string;
    /**
     * The first character of the organization name
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'first_char'?: string;
    /**
     * The creation date and time of the organization
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the organization
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'update_time'?: string;
    /**
     * The visibility group ID of who can see the organization
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'visible_to'?: string;
    /**
     * The label assigned to the organization
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'label'?: number;
    /**
     * The name of the organization owner
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'owner_name'?: string;
    /**
     * The BCC email associated with the organization
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'cc_email'?: string;
    /**
     * The count of email messages related to the organization
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'email_messages_count'?: number;
    /**
     * The count of persons related to the organization
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'people_count'?: number;
    /**
     * The count of activities related to the organization
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the organization
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the organization
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the organization
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'files_count'?: number;
    /**
     * The count of notes related to the organization
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the organization
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'followers_count'?: number;
    /**
     * The full address of the organization
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'address'?: string;
    /**
     * The sub-premise of the organization location
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'address_subpremise'?: string;
    /**
     * The street number of the organization location
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'address_street_number'?: string;
    /**
     * The route of the organization location
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'address_route'?: string;
    /**
     * The sub-locality of the organization location
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'address_sublocality'?: string;
    /**
     * The locality of the organization location
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'address_locality'?: string;
    /**
     * The level 1 admin area of the organization location
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'address_admin_area_level_1'?: string;
    /**
     * The level 2 admin area of the organization location
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'address_admin_area_level_2'?: string;
    /**
     * The country of the organization location
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'address_country'?: string;
    /**
     * The postal code of the organization location
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'address_postal_code'?: string;
    /**
     * The formatted organization location
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'address_formatted_address'?: string;
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'related_lost_deals_count'?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof BaseOrganizationItem
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof BaseOrganizationItem
     */
    'last_activity_date'?: string | null;
}
/**
 *
 * @export
 * @interface BaseOrganizationItemAllOf
 */
export interface BaseOrganizationItemAllOf {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof BaseOrganizationItemAllOf
     */
    'id'?: number;
    /**
     * The ID of the company related to the organization
     * @type {number}
     * @memberof BaseOrganizationItemAllOf
     */
    'company_id'?: number;
    /**
     *
     * @type {Owner}
     * @memberof BaseOrganizationItemAllOf
     */
    'owner_id'?: Owner;
    /**
     * The name of the organization
     * @type {string}
     * @memberof BaseOrganizationItemAllOf
     */
    'name'?: string;
    /**
     * Whether the organization is active or not
     * @type {boolean}
     * @memberof BaseOrganizationItemAllOf
     */
    'active_flag'?: boolean;
    /**
     *
     * @type {BaseOrganizationItemAllOfPictureId}
     * @memberof BaseOrganizationItemAllOf
     */
    'picture_id'?: BaseOrganizationItemAllOfPictureId;
    /**
     * The country code of the organization
     * @type {string}
     * @memberof BaseOrganizationItemAllOf
     */
    'country_code'?: string;
    /**
     * The first character of the organization name
     * @type {string}
     * @memberof BaseOrganizationItemAllOf
     */
    'first_char'?: string;
    /**
     * The creation date and time of the organization
     * @type {string}
     * @memberof BaseOrganizationItemAllOf
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the organization
     * @type {string}
     * @memberof BaseOrganizationItemAllOf
     */
    'update_time'?: string;
    /**
     * The visibility group ID of who can see the organization
     * @type {string}
     * @memberof BaseOrganizationItemAllOf
     */
    'visible_to'?: string;
    /**
     * The label assigned to the organization
     * @type {number}
     * @memberof BaseOrganizationItemAllOf
     */
    'label'?: number;
    /**
     * The name of the organization owner
     * @type {string}
     * @memberof BaseOrganizationItemAllOf
     */
    'owner_name'?: string;
    /**
     * The BCC email associated with the organization
     * @type {string}
     * @memberof BaseOrganizationItemAllOf
     */
    'cc_email'?: string;
}
/**
 *
 * @export
 * @interface BaseOrganizationItemAllOfPictureId
 */
export interface BaseOrganizationItemAllOfPictureId {
    /**
     * The ID of the picture associated with the item
     * @type {number}
     * @memberof BaseOrganizationItemAllOfPictureId
     */
    'value'?: number;
    /**
     * The type of item the picture is related to
     * @type {string}
     * @memberof BaseOrganizationItemAllOfPictureId
     */
    'item_type'?: string;
    /**
     * The ID of related item
     * @type {number}
     * @memberof BaseOrganizationItemAllOfPictureId
     */
    'item_id'?: number;
    /**
     * Whether the associated picture is active or not
     * @type {boolean}
     * @memberof BaseOrganizationItemAllOfPictureId
     */
    'active_flag'?: boolean;
    /**
     * The add time of the picture
     * @type {string}
     * @memberof BaseOrganizationItemAllOfPictureId
     */
    'add_time'?: string;
    /**
     * The update time of the picture
     * @type {string}
     * @memberof BaseOrganizationItemAllOfPictureId
     */
    'update_time'?: string;
    /**
     * The ID of the user who added the picture
     * @type {number}
     * @memberof BaseOrganizationItemAllOfPictureId
     */
    'added_by_user_id'?: number;
    /**
     *
     * @type {PersonItemAllOfPictureIdAllOf1Pictures}
     * @memberof BaseOrganizationItemAllOfPictureId
     */
    'pictures'?: PersonItemAllOfPictureIdAllOf1Pictures;
}
/**
 *
 * @export
 * @interface BaseOrganizationItemAllOfPictureIdAllOf
 */
export interface BaseOrganizationItemAllOfPictureIdAllOf {
    /**
     * The ID of the picture associated with the item
     * @type {number}
     * @memberof BaseOrganizationItemAllOfPictureIdAllOf
     */
    'value'?: number;
}
/**
 *
 * @export
 * @interface BaseOrganizationItemWithEditNameFlag
 */
export interface BaseOrganizationItemWithEditNameFlag {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'id'?: number;
    /**
     * The ID of the company related to the organization
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'company_id'?: number;
    /**
     *
     * @type {Owner}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'owner_id'?: Owner;
    /**
     * The name of the organization
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'name'?: string;
    /**
     * Whether the organization is active or not
     * @type {boolean}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'active_flag'?: boolean;
    /**
     *
     * @type {BaseOrganizationItemAllOfPictureId}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'picture_id'?: BaseOrganizationItemAllOfPictureId;
    /**
     * The country code of the organization
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'country_code'?: string;
    /**
     * The first character of the organization name
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'first_char'?: string;
    /**
     * The creation date and time of the organization
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the organization
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'update_time'?: string;
    /**
     * The visibility group ID of who can see the organization
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'visible_to'?: string;
    /**
     * The label assigned to the organization
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'label'?: number;
    /**
     * The name of the organization owner
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'owner_name'?: string;
    /**
     * The BCC email associated with the organization
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'cc_email'?: string;
    /**
     * The count of email messages related to the organization
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'email_messages_count'?: number;
    /**
     * The count of persons related to the organization
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'people_count'?: number;
    /**
     * The count of activities related to the organization
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the organization
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the organization
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the organization
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'files_count'?: number;
    /**
     * The count of notes related to the organization
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the organization
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'followers_count'?: number;
    /**
     * The full address of the organization
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'address'?: string;
    /**
     * The sub-premise of the organization location
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'address_subpremise'?: string;
    /**
     * The street number of the organization location
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'address_street_number'?: string;
    /**
     * The route of the organization location
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'address_route'?: string;
    /**
     * The sub-locality of the organization location
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'address_sublocality'?: string;
    /**
     * The locality of the organization location
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'address_locality'?: string;
    /**
     * The level 1 admin area of the organization location
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'address_admin_area_level_1'?: string;
    /**
     * The level 2 admin area of the organization location
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'address_admin_area_level_2'?: string;
    /**
     * The country of the organization location
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'address_country'?: string;
    /**
     * The postal code of the organization location
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'address_postal_code'?: string;
    /**
     * The formatted organization location
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'address_formatted_address'?: string;
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'related_lost_deals_count'?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'last_activity_date'?: string | null;
    /**
     * If the company ID of the organization and company ID of the request is same or not
     * @type {boolean}
     * @memberof BaseOrganizationItemWithEditNameFlag
     */
    'edit_name'?: boolean;
}
/**
 *
 * @export
 * @interface BaseOrganizationItemWithEditNameFlagAllOf
 */
export interface BaseOrganizationItemWithEditNameFlagAllOf {
    /**
     * If the company ID of the organization and company ID of the request is same or not
     * @type {boolean}
     * @memberof BaseOrganizationItemWithEditNameFlagAllOf
     */
    'edit_name'?: boolean;
}
/**
 *
 * @export
 * @interface BasePipelineWithSelectedFlag
 */
export interface BasePipelineWithSelectedFlag {
    /**
     * The ID of the pipeline
     * @type {number}
     * @memberof BasePipelineWithSelectedFlag
     */
    'id'?: number;
    /**
     * The name of the pipeline
     * @type {string}
     * @memberof BasePipelineWithSelectedFlag
     */
    'name'?: string;
    /**
     * The pipeline title displayed in the URL
     * @type {string}
     * @memberof BasePipelineWithSelectedFlag
     */
    'url_title'?: string;
    /**
     * Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
     * @type {number}
     * @memberof BasePipelineWithSelectedFlag
     */
    'order_nr'?: number;
    /**
     * Whether this pipeline will be made inactive (hidden) or active
     * @type {boolean}
     * @memberof BasePipelineWithSelectedFlag
     */
    'active'?: boolean;
    /**
     * Whether deal probability is disabled or enabled for this pipeline
     * @type {boolean}
     * @memberof BasePipelineWithSelectedFlag
     */
    'deal_probability'?: boolean;
    /**
     * The pipeline creation time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof BasePipelineWithSelectedFlag
     */
    'add_time'?: string;
    /**
     * The pipeline update time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof BasePipelineWithSelectedFlag
     */
    'update_time'?: string;
    /**
     * A boolean that shows if the pipeline is selected from a filter or not
     * @type {boolean}
     * @memberof BasePipelineWithSelectedFlag
     */
    'selected'?: boolean;
}
/**
 *
 * @export
 * @interface BasePipelineWithSelectedFlagAllOf
 */
export interface BasePipelineWithSelectedFlagAllOf {
    /**
     * A boolean that shows if the pipeline is selected from a filter or not
     * @type {boolean}
     * @memberof BasePipelineWithSelectedFlagAllOf
     */
    'selected'?: boolean;
}
/**
 *
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof BaseResponse
     */
    'success'?: boolean;
}
/**
 *
 * @export
 * @interface BaseResponse200
 */
export interface BaseResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof BaseResponse200
     */
    'success'?: boolean;
    /**
     * The status of the response
     * @type {string}
     * @memberof BaseResponse200
     */
    'status'?: string;
}
/**
 *
 * @export
 * @interface BaseResponse200AllOf
 */
export interface BaseResponse200AllOf {
    /**
     * The status of the response
     * @type {string}
     * @memberof BaseResponse200AllOf
     */
    'status'?: string;
}
/**
 * The details of the role
 * @export
 * @interface BaseRoleRequest
 */
export interface BaseRoleRequest {
    /**
     * The ID of the parent role
     * @type {number}
     * @memberof BaseRoleRequest
     */
    'parent_role_id'?: number;
    /**
     * The name of the role
     * @type {string}
     * @memberof BaseRoleRequest
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface BaseTeam
 */
export interface BaseTeam {
    /**
     * The team ID
     * @type {number}
     * @memberof BaseTeam
     */
    'id'?: number;
    /**
     * The team name
     * @type {string}
     * @memberof BaseTeam
     */
    'name'?: string;
    /**
     * The team description
     * @type {string}
     * @memberof BaseTeam
     */
    'description'?: string;
    /**
     * The team manager ID
     * @type {number}
     * @memberof BaseTeam
     */
    'manager_id'?: number;
    /**
     * The IDs of the users that belong to the team
     * @type {Array<number>}
     * @memberof BaseTeam
     */
    'users'?: Array<number>;
    /**
     *
     * @type {number}
     * @memberof BaseTeam
     */
    'active_flag'?: BaseTeamActiveFlagConst;
    /**
     *
     * @type {number}
     * @memberof BaseTeam
     */
    'deleted_flag'?: BaseTeamDeletedFlagConst;
    /**
     * The team creation time. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof BaseTeam
     */
    'add_time'?: string;
    /**
     * The ID of the user who created the team
     * @type {number}
     * @memberof BaseTeam
     */
    'created_by_user_id'?: number;
}

export const BaseTeamActiveFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseTeamActiveFlagConst = typeof BaseTeamActiveFlagConst[keyof typeof BaseTeamActiveFlagConst];
export const BaseTeamDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseTeamDeletedFlagConst = typeof BaseTeamDeletedFlagConst[keyof typeof BaseTeamDeletedFlagConst];

/**
 *
 * @export
 * @interface BaseTeamAdditionalProperties
 */
export interface BaseTeamAdditionalProperties {
    /**
     * The team creation time. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof BaseTeamAdditionalProperties
     */
    'add_time'?: string;
    /**
     * The ID of the user who created the team
     * @type {number}
     * @memberof BaseTeamAdditionalProperties
     */
    'created_by_user_id'?: number;
}
/**
 *
 * @export
 * @interface BasicDeal
 */
export interface BasicDeal {
    /**
     * The expected close date of the deal. In ISO 8601 format: YYYY-MM-DD.
     * @type {string}
     * @memberof BasicDeal
     */
    'expected_close_date'?: string;
    /**
     * The success probability percentage of the deal. Used/shown only when `deal_probability` for the pipeline of the deal is enabled.
     * @type {number}
     * @memberof BasicDeal
     */
    'probability'?: number;
    /**
     * The optional message about why the deal was lost (to be used when status = lost)
     * @type {string}
     * @memberof BasicDeal
     */
    'lost_reason'?: string;
    /**
     *
     * @type {string}
     * @memberof BasicDeal
     */
    'visible_to'?: BasicDealVisibleToConst;
}

export const BasicDealVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type BasicDealVisibleToConst = typeof BasicDealVisibleToConst[keyof typeof BasicDealVisibleToConst];

/**
 *
 * @export
 * @interface BasicDealProductRequest
 */
export interface BasicDealProductRequest {
    /**
     * The ID of the product to use
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    'product_id': number;
    /**
     * The price at which this product will be added to the deal
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    'item_price': number;
    /**
     * Quantity – e.g. how many items of this product will be added to the deal
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    'quantity': number;
    /**
     * The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage.
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    'discount'?: number;
    /**
     * The type of the discount\'s value.
     * @type {string}
     * @memberof BasicDealProductRequest
     */
    'discount_type'?: BasicDealProductRequestDiscountTypeConst;
    /**
     * The duration of the product. If omitted, will be set to 1.
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    'duration'?: number;
    /**
     *
     * @type {string}
     * @memberof BasicDealProductRequest
     */
    'duration_unit'?: BasicDealProductRequestDurationUnitConst;
    /**
     * The ID of the product variation to use. When omitted, no variation will be used.
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    'product_variation_id'?: number | null;
    /**
     * A textual comment associated with this product-deal attachment
     * @type {string}
     * @memberof BasicDealProductRequest
     */
    'comments'?: string;
    /**
     * The tax percentage
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    'tax'?: number;
    /**
     * The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal.
     * @type {string}
     * @memberof BasicDealProductRequest
     */
    'tax_method'?: BasicDealProductRequestTaxMethodConst;
    /**
     * Whether the product is enabled for a deal or not. This makes it possible to add products to a deal with a specific price and discount criteria, but keep them disabled, which refrains them from being included in the deal value calculation. When omitted, the product will be marked as enabled by default.
     * @type {boolean}
     * @memberof BasicDealProductRequest
     */
    'enabled_flag'?: boolean;
}

export const BasicDealProductRequestDiscountTypeConst = {
    percentage: 'percentage',
    amount: 'amount'
} as const;

export type BasicDealProductRequestDiscountTypeConst = typeof BasicDealProductRequestDiscountTypeConst[keyof typeof BasicDealProductRequestDiscountTypeConst];
export const BasicDealProductRequestDurationUnitConst = {
    hourly: 'hourly',
    daily: 'daily',
    weekly: 'weekly',
    monthly: 'monthly',
    yearly: 'yearly'
} as const;

export type BasicDealProductRequestDurationUnitConst = typeof BasicDealProductRequestDurationUnitConst[keyof typeof BasicDealProductRequestDurationUnitConst];
export const BasicDealProductRequestTaxMethodConst = {
    exclusive: 'exclusive',
    inclusive: 'inclusive',
    none: 'none'
} as const;

export type BasicDealProductRequestTaxMethodConst = typeof BasicDealProductRequestTaxMethodConst[keyof typeof BasicDealProductRequestTaxMethodConst];

/**
 *
 * @export
 * @interface BasicGoalRequest
 */
export interface BasicGoalRequest {
    /**
     * The title of the goal
     * @type {string}
     * @memberof BasicGoalRequest
     */
    'title'?: string;
    /**
     * Who this goal is assigned to. It requires the following JSON structure: `{ \"id\": \"1\", \"type\": \"person\" }`. `type` can be either `person`, `company` or `team`. ID of the assignee person, company or team.
     * @type {object}
     * @memberof BasicGoalRequest
     */
    'assignee'?: object;
    /**
     * The type of the goal. It requires the following JSON structure: `{ \"name\": \"deals_started\", \"params\": { \"pipeline_id\": [1, 2], \"activity_type_id\": [9] } }`. Type can be one of: `deals_won`, `deals_progressed`, `activities_completed`, `activities_added`, `deals_started` or `revenue_forecast`. `params` can include `pipeline_id`, `stage_id` or `activity_type_id`. `stage_id` is related to only `deals_progressed` type of goals and `activity_type_id` to `activities_completed` or `activities_added` types of goals. The `pipeline_id` and `activity_type_id` need to be given as an array of integers. To track the goal in all pipelines, set `pipeline_id` as `null` and similarly, to track the goal for all activities, set `activity_type_id` as `null`.”
     * @type {object}
     * @memberof BasicGoalRequest
     */
    'type'?: object;
    /**
     * The expected outcome of the goal. Expected outcome can be tracked either by `quantity` or by `sum`. It requires the following JSON structure: `{ \"target\": \"50\", \"tracking_metric\": \"quantity\" }` or `{ \"target\": \"50\", \"tracking_metric\": \"sum\", \"currency_id\": 1 }`. `currency_id` should only be added to `sum` type of goals.
     * @type {object}
     * @memberof BasicGoalRequest
     */
    'expected_outcome'?: object;
    /**
     * The date when the goal starts and ends. It requires the following JSON structure: `{ \"start\": \"2019-01-01\", \"end\": \"2022-12-31\" }`. Date in format of YYYY-MM-DD. \"end\" can be set to `null` for an infinite, open-ended goal.
     * @type {object}
     * @memberof BasicGoalRequest
     */
    'duration'?: object;
    /**
     * The interval of the goal
     * @type {string}
     * @memberof BasicGoalRequest
     */
    'interval'?: BasicGoalRequestIntervalConst;
}

export const BasicGoalRequestIntervalConst = {
    weekly: 'weekly',
    monthly: 'monthly',
    quarterly: 'quarterly',
    yearly: 'yearly'
} as const;

export type BasicGoalRequestIntervalConst = typeof BasicGoalRequestIntervalConst[keyof typeof BasicGoalRequestIntervalConst];

/**
 *
 * @export
 * @interface BasicOrganization
 */
export interface BasicOrganization {
    /**
     * The ID of the user who will be marked as the owner of this organization. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof BasicOrganization
     */
    'owner_id'?: number;
    /**
     * The ID of the label.
     * @type {number}
     * @memberof BasicOrganization
     */
    'label'?: number;
    /**
     *
     * @type {string}
     * @memberof BasicOrganization
     */
    'visible_to'?: BasicOrganizationVisibleToConst;
}

export const BasicOrganizationVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type BasicOrganizationVisibleToConst = typeof BasicOrganizationVisibleToConst[keyof typeof BasicOrganizationVisibleToConst];

/**
 *
 * @export
 * @interface BasicPersonRequest
 */
export interface BasicPersonRequest {
    /**
     * The ID of the user who will be marked as the owner of this person. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof BasicPersonRequest
     */
    'owner_id'?: number;
    /**
     * The ID of the organization this person will belong to
     * @type {number}
     * @memberof BasicPersonRequest
     */
    'org_id'?: number;
    /**
     * An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ \"value\": \"mail@example.com\", \"primary\": \"true\", \"label\": \"main\" }]`. Please note that only `value` is required.
     * @type {Array<BasicPersonRequestEmailInner>}
     * @memberof BasicPersonRequest
     */
    'email'?: Array<BasicPersonRequestEmailInner>;
    /**
     * A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ \"value\": \"12345\", \"primary\": \"true\", \"label\": \"mobile\" }]`. Please note that only `value` is required.
     * @type {Array<PersonItemAllOfPhoneInner>}
     * @memberof BasicPersonRequest
     */
    'phone'?: Array<PersonItemAllOfPhoneInner>;
    /**
     * The ID of the label.
     * @type {number}
     * @memberof BasicPersonRequest
     */
    'label'?: number;
    /**
     *
     * @type {string}
     * @memberof BasicPersonRequest
     */
    'visible_to'?: BasicPersonRequestVisibleToConst;
    /**
     *
     * @type {string}
     * @memberof BasicPersonRequest
     */
    'marketing_status'?: BasicPersonRequestMarketingStatusConst;
    /**
     * The optional creation date & time of the person in UTC. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof BasicPersonRequest
     */
    'add_time'?: string;
}

export const BasicPersonRequestVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type BasicPersonRequestVisibleToConst = typeof BasicPersonRequestVisibleToConst[keyof typeof BasicPersonRequestVisibleToConst];
export const BasicPersonRequestMarketingStatusConst = {
    no_consent: 'no_consent',
    unsubscribed: 'unsubscribed',
    subscribed: 'subscribed',
    archived: 'archived'
} as const;

export type BasicPersonRequestMarketingStatusConst = typeof BasicPersonRequestMarketingStatusConst[keyof typeof BasicPersonRequestMarketingStatusConst];

/**
 *
 * @export
 * @interface BasicPersonRequestEmailInner
 */
export interface BasicPersonRequestEmailInner {
    /**
     * The email
     * @type {string}
     * @memberof BasicPersonRequestEmailInner
     */
    'value'?: string;
    /**
     * Boolean that indicates if email is primary for the person or not
     * @type {boolean}
     * @memberof BasicPersonRequestEmailInner
     */
    'primary'?: boolean;
    /**
     * The label that indicates the type of the email. (Possible values - work, home or other)
     * @type {string}
     * @memberof BasicPersonRequestEmailInner
     */
    'label'?: string;
}
/**
 *
 * @export
 * @interface CallLogResponse200
 */
export interface CallLogResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof CallLogResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {ResponseCallLogObject}
     * @memberof CallLogResponse200
     */
    'data'?: ResponseCallLogObject;
}
/**
 *
 * @export
 * @interface CallLogResponse400
 */
export interface CallLogResponse400 {
    /**
     *
     * @type {boolean}
     * @memberof CallLogResponse400
     */
    'success'?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof CallLogResponse400
     */
    'error'?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof CallLogResponse400
     */
    'error_info'?: string;
    /**
     *
     * @type {object}
     * @memberof CallLogResponse400
     */
    'data'?: object | null;
    /**
     *
     * @type {object}
     * @memberof CallLogResponse400
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface CallLogResponse403
 */
export interface CallLogResponse403 {
    /**
     *
     * @type {boolean}
     * @memberof CallLogResponse403
     */
    'success'?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof CallLogResponse403
     */
    'error'?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof CallLogResponse403
     */
    'error_info'?: string;
    /**
     *
     * @type {object}
     * @memberof CallLogResponse403
     */
    'data'?: object | null;
    /**
     *
     * @type {object}
     * @memberof CallLogResponse403
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface CallLogResponse404
 */
export interface CallLogResponse404 {
    /**
     *
     * @type {boolean}
     * @memberof CallLogResponse404
     */
    'success'?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof CallLogResponse404
     */
    'error'?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof CallLogResponse404
     */
    'error_info'?: string;
    /**
     *
     * @type {object}
     * @memberof CallLogResponse404
     */
    'data'?: object | null;
    /**
     *
     * @type {object}
     * @memberof CallLogResponse404
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface CallLogResponse409
 */
export interface CallLogResponse409 {
    /**
     *
     * @type {boolean}
     * @memberof CallLogResponse409
     */
    'success'?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof CallLogResponse409
     */
    'error'?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof CallLogResponse409
     */
    'error_info'?: string;
    /**
     *
     * @type {object}
     * @memberof CallLogResponse409
     */
    'data'?: object | null;
    /**
     *
     * @type {object}
     * @memberof CallLogResponse409
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface CallLogResponse410
 */
export interface CallLogResponse410 {
    /**
     *
     * @type {boolean}
     * @memberof CallLogResponse410
     */
    'success'?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof CallLogResponse410
     */
    'error'?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof CallLogResponse410
     */
    'error_info'?: string;
    /**
     *
     * @type {object}
     * @memberof CallLogResponse410
     */
    'data'?: object | null;
    /**
     *
     * @type {object}
     * @memberof CallLogResponse410
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface CallLogResponse500
 */
export interface CallLogResponse500 {
    /**
     *
     * @type {boolean}
     * @memberof CallLogResponse500
     */
    'success'?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof CallLogResponse500
     */
    'error'?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof CallLogResponse500
     */
    'error_info'?: string;
    /**
     *
     * @type {object}
     * @memberof CallLogResponse500
     */
    'data'?: object | null;
    /**
     *
     * @type {object}
     * @memberof CallLogResponse500
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface CallLogsResponse
 */
export interface CallLogsResponse {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof CallLogsResponse
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<ResponseCallLogObject>}
     * @memberof CallLogsResponse
     */
    'data'?: Array<ResponseCallLogObject>;
    /**
     *
     * @type {CallLogsResponseAdditionalData}
     * @memberof CallLogsResponse
     */
    'additional_data'?: CallLogsResponseAdditionalData;
}
/**
 *
 * @export
 * @interface CallLogsResponseAdditionalData
 */
export interface CallLogsResponseAdditionalData {
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof CallLogsResponseAdditionalData
     */
    'pagination'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface CancelRecurringSubscriptionRequest
 */
export interface CancelRecurringSubscriptionRequest {
    /**
     * The subscription termination date. All payments after the specified date will be deleted. The end_date of the subscription will be set to the due date of the payment to follow the specified date. Default value is the current date.
     * @type {string}
     * @memberof CancelRecurringSubscriptionRequest
     */
    'end_date'?: string;
}
/**
 *
 * @export
 * @interface CommentPostPutObject
 */
export interface CommentPostPutObject {
    /**
     * The content of the comment in HTML format. Subject to sanitization on the back-end.
     * @type {string}
     * @memberof CommentPostPutObject
     */
    'content': string;
}
/**
 *
 * @export
 * @interface CreateFieldRequest
 */
export interface CreateFieldRequest {
    /**
     * The name of the field
     * @type {string}
     * @memberof CreateFieldRequest
     */
    'name': string;
    /**
     * When `field_type` is either set or enum, possible options must be supplied as a JSON-encoded sequential array of objects. Example: `[{\"label\":\"New Item\"}]`
     * @type {Array<object>}
     * @memberof CreateFieldRequest
     */
    'options'?: Array<object>;
    /**
     * Whether the field is available in the \'add new\' modal or not (both in the web and mobile app)
     * @type {boolean}
     * @memberof CreateFieldRequest
     */
    'add_visible_flag'?: boolean;
    /**
     * The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`address`</td><td>Address field (has multiple subfields, autocompleted by Google Maps)</td></tr><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td></tr><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td></tr><tr><td>`double`</td><td>Numeric value</td></tr><tr><td>`enum`</td><td>Options field with a single possible chosen option</td></tr><tr></tr><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td></tr><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td></tr><tr><td>`people`</td><td>Person field (contains a person ID which is stored on the same account)</td></tr><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td></tr><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td></tr><tr><td>`text`</td><td>Long text (up to 65k characters)</td></tr><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td></tr><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td></tr><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td></tr><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td></tr><tr><td>`visible_to`</td><td>System field that keeps item\'s visibility setting</td></tr></table>
     * @type {string}
     * @memberof CreateFieldRequest
     */
    'field_type': CreateFieldRequestFieldTypeConst;
}

export const CreateFieldRequestFieldTypeConst = {
    address: 'address',
    date: 'date',
    daterange: 'daterange',
    double: 'double',
    enum: 'enum',
    monetary: 'monetary',
    org: 'org',
    people: 'people',
    phone: 'phone',
    set: 'set',
    text: 'text',
    time: 'time',
    timerange: 'timerange',
    user: 'user',
    varchar: 'varchar',
    varchar_auto: 'varchar_auto',
    visible_to: 'visible_to'
} as const;

export type CreateFieldRequestFieldTypeConst = typeof CreateFieldRequestFieldTypeConst[keyof typeof CreateFieldRequestFieldTypeConst];

/**
 *
 * @export
 * @interface CreateFieldRequestAllOf
 */
export interface CreateFieldRequestAllOf {
    /**
     * The name of the field
     * @type {string}
     * @memberof CreateFieldRequestAllOf
     */
    'name': string;
    /**
     * When `field_type` is either set or enum, possible options must be supplied as a JSON-encoded sequential array of objects. Example: `[{\"label\":\"New Item\"}]`
     * @type {Array<object>}
     * @memberof CreateFieldRequestAllOf
     */
    'options'?: Array<object>;
    /**
     * Whether the field is available in the \'add new\' modal or not (both in the web and mobile app)
     * @type {boolean}
     * @memberof CreateFieldRequestAllOf
     */
    'add_visible_flag'?: boolean;
}
/**
 *
 * @export
 * @interface CreateFieldRequestAllOf1
 */
export interface CreateFieldRequestAllOf1 {
    /**
     * The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`address`</td><td>Address field (has multiple subfields, autocompleted by Google Maps)</td></tr><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td></tr><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td></tr><tr><td>`double`</td><td>Numeric value</td></tr><tr><td>`enum`</td><td>Options field with a single possible chosen option</td></tr><tr></tr><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td></tr><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td></tr><tr><td>`people`</td><td>Person field (contains a person ID which is stored on the same account)</td></tr><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td></tr><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td></tr><tr><td>`text`</td><td>Long text (up to 65k characters)</td></tr><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td></tr><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td></tr><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td></tr><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td></tr><tr><td>`visible_to`</td><td>System field that keeps item\'s visibility setting</td></tr></table>
     * @type {string}
     * @memberof CreateFieldRequestAllOf1
     */
    'field_type': CreateFieldRequestAllOf1FieldTypeConst;
}

export const CreateFieldRequestAllOf1FieldTypeConst = {
    address: 'address',
    date: 'date',
    daterange: 'daterange',
    double: 'double',
    enum: 'enum',
    monetary: 'monetary',
    org: 'org',
    people: 'people',
    phone: 'phone',
    set: 'set',
    text: 'text',
    time: 'time',
    timerange: 'timerange',
    user: 'user',
    varchar: 'varchar',
    varchar_auto: 'varchar_auto',
    visible_to: 'visible_to'
} as const;

export type CreateFieldRequestAllOf1FieldTypeConst = typeof CreateFieldRequestAllOf1FieldTypeConst[keyof typeof CreateFieldRequestAllOf1FieldTypeConst];

/**
 *
 * @export
 * @interface CreateUpdateDeleteActivityTypeResponse200
 */
export interface CreateUpdateDeleteActivityTypeResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof CreateUpdateDeleteActivityTypeResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetActivityTypesResponse200AllOfDataInner}
     * @memberof CreateUpdateDeleteActivityTypeResponse200
     */
    'data'?: GetActivityTypesResponse200AllOfDataInner;
}
/**
 *
 * @export
 * @interface CreateUpdateDeleteActivityTypeResponse200AllOf
 */
export interface CreateUpdateDeleteActivityTypeResponse200AllOf {
    /**
     *
     * @type {GetActivityTypesResponse200AllOfDataInner}
     * @memberof CreateUpdateDeleteActivityTypeResponse200AllOf
     */
    'data'?: GetActivityTypesResponse200AllOfDataInner;
}
/**
 *
 * @export
 * @interface DealCollectionResponseObject
 */
export interface DealCollectionResponseObject {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealCollectionResponseObject
     */
    'id'?: number;
    /**
     * The ID of the deal creator
     * @type {number}
     * @memberof DealCollectionResponseObject
     */
    'creator_user_id'?: number;
    /**
     * The ID of the user
     * @type {number}
     * @memberof DealCollectionResponseObject
     */
    'user_id'?: number;
    /**
     * The ID of the person associated with the deal
     * @type {number}
     * @memberof DealCollectionResponseObject
     */
    'person_id'?: number;
    /**
     * The ID of the organization associated with the deal
     * @type {number}
     * @memberof DealCollectionResponseObject
     */
    'org_id'?: number;
    /**
     * The ID of the deal stage
     * @type {number}
     * @memberof DealCollectionResponseObject
     */
    'stage_id'?: number;
    /**
     * The title of the deal
     * @type {string}
     * @memberof DealCollectionResponseObject
     */
    'title'?: string;
    /**
     * The value of the deal
     * @type {number}
     * @memberof DealCollectionResponseObject
     */
    'value'?: number;
    /**
     * The currency associated with the deal
     * @type {string}
     * @memberof DealCollectionResponseObject
     */
    'currency'?: string;
    /**
     * The creation date and time of the deal in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof DealCollectionResponseObject
     */
    'add_time'?: string;
    /**
     * The last update date and time of the deal in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof DealCollectionResponseObject
     */
    'update_time'?: string;
    /**
     * The status of the deal
     * @type {string}
     * @memberof DealCollectionResponseObject
     */
    'status'?: string;
    /**
     * The success probability percentage of the deal
     * @type {number}
     * @memberof DealCollectionResponseObject
     */
    'probability'?: number | null;
    /**
     * The reason for losing the deal
     * @type {string}
     * @memberof DealCollectionResponseObject
     */
    'lost_reason'?: string | null;
    /**
     * The visibility of the deal
     * @type {string}
     * @memberof DealCollectionResponseObject
     */
    'visible_to'?: string;
    /**
     * The date and time of closing the deal in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof DealCollectionResponseObject
     */
    'close_time'?: string | null;
    /**
     * The ID of the pipeline associated with the deal
     * @type {number}
     * @memberof DealCollectionResponseObject
     */
    'pipeline_id'?: number;
    /**
     * The date and time of changing the deal status to won in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof DealCollectionResponseObject
     */
    'won_time'?: string;
    /**
     * The date and time of changing the deal status to lost in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof DealCollectionResponseObject
     */
    'lost_time'?: string;
    /**
     * The expected close date of the deal
     * @type {string}
     * @memberof DealCollectionResponseObject
     */
    'expected_close_date'?: string;
    /**
     * The label or multiple labels assigned to the deal
     * @type {string}
     * @memberof DealCollectionResponseObject
     */
    'label'?: string;
}
/**
 *
 * @export
 * @interface DealCountAndActivityInfo
 */
export interface DealCountAndActivityInfo {
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfo
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfo
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfo
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfo
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfo
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfo
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfo
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfo
     */
    'related_lost_deals_count'?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof DealCountAndActivityInfo
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof DealCountAndActivityInfo
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof DealCountAndActivityInfo
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof DealCountAndActivityInfo
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof DealCountAndActivityInfo
     */
    'last_activity_date'?: string | null;
}
/**
 *
 * @export
 * @interface DealCountAndActivityInfoAllOf
 */
export interface DealCountAndActivityInfoAllOf {
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfoAllOf
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfoAllOf
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfoAllOf
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfoAllOf
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfoAllOf
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfoAllOf
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfoAllOf
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof DealCountAndActivityInfoAllOf
     */
    'related_lost_deals_count'?: number;
}
/**
 *
 * @export
 * @interface DealCountAndActivityInfoAllOf1
 */
export interface DealCountAndActivityInfoAllOf1 {
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof DealCountAndActivityInfoAllOf1
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof DealCountAndActivityInfoAllOf1
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof DealCountAndActivityInfoAllOf1
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof DealCountAndActivityInfoAllOf1
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof DealCountAndActivityInfoAllOf1
     */
    'last_activity_date'?: string | null;
}
/**
 *
 * @export
 * @interface DealNonStrict
 */
export interface DealNonStrict {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'id'?: number;
    /**
     *
     * @type {DealNonStrictAllOfCreatorUserId}
     * @memberof DealNonStrict
     */
    'creator_user_id'?: DealNonStrictAllOfCreatorUserId;
    /**
     *
     * @type {DealUserDataWithId}
     * @memberof DealNonStrict
     */
    'user_id'?: DealUserDataWithId;
    /**
     *
     * @type {DealPersonDataWithId}
     * @memberof DealNonStrict
     */
    'person_id'?: DealPersonDataWithId;
    /**
     *
     * @type {DealOrganizationDataWithId}
     * @memberof DealNonStrict
     */
    'org_id'?: DealOrganizationDataWithId;
    /**
     * The ID of the deal stage
     * @type {number}
     * @memberof DealNonStrict
     */
    'stage_id'?: number;
    /**
     * The title of the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'title'?: string;
    /**
     * The value of the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'value'?: number;
    /**
     * The currency associated with the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'currency'?: string;
    /**
     * The creation date and time of the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'update_time'?: string;
    /**
     * The last updated date and time of the deal stage
     * @type {string}
     * @memberof DealNonStrict
     */
    'stage_change_time'?: string;
    /**
     * Whether the deal is active or not
     * @type {boolean}
     * @memberof DealNonStrict
     */
    'active'?: boolean;
    /**
     * Whether the deal is deleted or not
     * @type {boolean}
     * @memberof DealNonStrict
     */
    'deleted'?: boolean;
    /**
     * The status of the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'status'?: string;
    /**
     * The success probability percentage of the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'probability'?: number | null;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'next_activity_date'?: string;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'next_activity_time'?: string;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'last_activity_date'?: string | null;
    /**
     * The reason for losing the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'lost_reason'?: string | null;
    /**
     * The visibility of the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'visible_to'?: string;
    /**
     * The date and time of closing the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'close_time'?: string | null;
    /**
     * The ID of the pipeline associated with the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'pipeline_id'?: number;
    /**
     * The date and time of changing the deal status as won
     * @type {string}
     * @memberof DealNonStrict
     */
    'won_time'?: string;
    /**
     * The date and time of the first time changing the deal status as won
     * @type {string}
     * @memberof DealNonStrict
     */
    'first_won_time'?: string;
    /**
     * The date and time of changing the deal status as lost
     * @type {string}
     * @memberof DealNonStrict
     */
    'lost_time'?: string;
    /**
     * The number of products associated with the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'products_count'?: number;
    /**
     * The number of files associated with the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'files_count'?: number;
    /**
     * The number of notes associated with the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'notes_count'?: number;
    /**
     * The number of followers associated with the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'followers_count'?: number;
    /**
     * The number of emails associated with the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'email_messages_count'?: number;
    /**
     * The number of activities associated with the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'activities_count'?: number;
    /**
     * The number of completed activities associated with the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'done_activities_count'?: number;
    /**
     * The number of incomplete activities associated with the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'undone_activities_count'?: number;
    /**
     * The number of participants associated with the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'participants_count'?: number;
    /**
     * The expected close date of the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'expected_close_date'?: string;
    /**
     * The date and time of the last incoming email associated with the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'last_outgoing_mail_time'?: string;
    /**
     * The label or multiple labels assigned to the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'label'?: string;
    /**
     * The order number of the deal stage associated with the deal
     * @type {number}
     * @memberof DealNonStrict
     */
    'stage_order_nr'?: number;
    /**
     * The name of the person associated with the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'person_name'?: string;
    /**
     * The name of the organization associated with the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'org_name'?: string;
    /**
     * The subject of the next activity associated with the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'next_activity_subject'?: string;
    /**
     * The type of the next activity associated with the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'next_activity_type'?: string;
    /**
     * The duration of the next activity associated with the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'next_activity_duration'?: string;
    /**
     * The note of the next activity associated with the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'next_activity_note'?: string;
    /**
     * The deal value formatted with selected currency. E.g. US$500
     * @type {string}
     * @memberof DealNonStrict
     */
    'formatted_value'?: string;
    /**
     * Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
     * @type {number}
     * @memberof DealNonStrict
     */
    'weighted_value'?: number;
    /**
     * The weighted_value formatted with selected currency. E.g. US$500
     * @type {string}
     * @memberof DealNonStrict
     */
    'formatted_weighted_value'?: string;
    /**
     * The currency associated with the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'weighted_value_currency'?: string;
    /**
     * The date and time of changing the deal status as rotten
     * @type {string}
     * @memberof DealNonStrict
     */
    'rotten_time'?: string | null;
    /**
     * The name of the deal owner
     * @type {string}
     * @memberof DealNonStrict
     */
    'owner_name'?: string;
    /**
     * The BCC email of the deal
     * @type {string}
     * @memberof DealNonStrict
     */
    'cc_email'?: string;
    /**
     * If the organization that is associated with the deal is hidden or not
     * @type {boolean}
     * @memberof DealNonStrict
     */
    'org_hidden'?: boolean;
    /**
     * If the person that is associated with the deal is hidden or not
     * @type {boolean}
     * @memberof DealNonStrict
     */
    'person_hidden'?: boolean;
}
/**
 *
 * @export
 * @interface DealNonStrictAllOf
 */
export interface DealNonStrictAllOf {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealNonStrictAllOf
     */
    'id'?: number;
    /**
     *
     * @type {DealNonStrictAllOfCreatorUserId}
     * @memberof DealNonStrictAllOf
     */
    'creator_user_id'?: DealNonStrictAllOfCreatorUserId;
    /**
     *
     * @type {DealUserDataWithId}
     * @memberof DealNonStrictAllOf
     */
    'user_id'?: DealUserDataWithId;
    /**
     *
     * @type {DealPersonDataWithId}
     * @memberof DealNonStrictAllOf
     */
    'person_id'?: DealPersonDataWithId;
    /**
     *
     * @type {DealOrganizationDataWithId}
     * @memberof DealNonStrictAllOf
     */
    'org_id'?: DealOrganizationDataWithId;
}
/**
 * The creator of the deal
 * @export
 * @interface DealNonStrictAllOfCreatorUserId
 */
export interface DealNonStrictAllOfCreatorUserId {
    /**
     * The ID of the deal creator
     * @type {number}
     * @memberof DealNonStrictAllOfCreatorUserId
     */
    'id'?: number;
    /**
     * The name of the deal creator
     * @type {string}
     * @memberof DealNonStrictAllOfCreatorUserId
     */
    'name'?: string;
    /**
     * The email of the deal creator
     * @type {string}
     * @memberof DealNonStrictAllOfCreatorUserId
     */
    'email'?: string;
    /**
     * If the creator has a picture or not
     * @type {boolean}
     * @memberof DealNonStrictAllOfCreatorUserId
     */
    'has_pic'?: boolean;
    /**
     * The creator picture hash
     * @type {string}
     * @memberof DealNonStrictAllOfCreatorUserId
     */
    'pic_hash'?: string | null;
    /**
     * Whether the creator is active or not
     * @type {boolean}
     * @memberof DealNonStrictAllOfCreatorUserId
     */
    'active_flag'?: boolean;
    /**
     * The ID of the deal creator
     * @type {number}
     * @memberof DealNonStrictAllOfCreatorUserId
     */
    'value'?: number;
}
/**
 *
 * @export
 * @interface DealNonStrictWithDetails
 */
export interface DealNonStrictWithDetails {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'id'?: number;
    /**
     *
     * @type {DealNonStrictAllOfCreatorUserId}
     * @memberof DealNonStrictWithDetails
     */
    'creator_user_id'?: DealNonStrictAllOfCreatorUserId;
    /**
     *
     * @type {DealUserDataWithId}
     * @memberof DealNonStrictWithDetails
     */
    'user_id'?: DealUserDataWithId;
    /**
     *
     * @type {DealPersonDataWithId}
     * @memberof DealNonStrictWithDetails
     */
    'person_id'?: DealPersonDataWithId;
    /**
     *
     * @type {DealOrganizationDataWithId}
     * @memberof DealNonStrictWithDetails
     */
    'org_id'?: DealOrganizationDataWithId;
    /**
     * The ID of the deal stage
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'stage_id'?: number;
    /**
     * The title of the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'title'?: string;
    /**
     * The value of the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'value'?: number;
    /**
     * The currency associated with the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'currency'?: string;
    /**
     * The creation date and time of the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'update_time'?: string;
    /**
     * The last updated date and time of the deal stage
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'stage_change_time'?: string;
    /**
     * Whether the deal is active or not
     * @type {boolean}
     * @memberof DealNonStrictWithDetails
     */
    'active'?: boolean;
    /**
     * Whether the deal is deleted or not
     * @type {boolean}
     * @memberof DealNonStrictWithDetails
     */
    'deleted'?: boolean;
    /**
     * The status of the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'status'?: string;
    /**
     * The success probability percentage of the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'probability'?: number | null;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'next_activity_date'?: string;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'next_activity_time'?: string;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'last_activity_date'?: string | null;
    /**
     * The reason for losing the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'lost_reason'?: string | null;
    /**
     * The visibility of the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'visible_to'?: string;
    /**
     * The date and time of closing the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'close_time'?: string | null;
    /**
     * The ID of the pipeline associated with the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'pipeline_id'?: number;
    /**
     * The date and time of changing the deal status as won
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'won_time'?: string;
    /**
     * The date and time of the first time changing the deal status as won
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'first_won_time'?: string;
    /**
     * The date and time of changing the deal status as lost
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'lost_time'?: string;
    /**
     * The number of products associated with the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'products_count'?: number;
    /**
     * The number of files associated with the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'files_count'?: number;
    /**
     * The number of notes associated with the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'notes_count'?: number;
    /**
     * The number of followers associated with the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'followers_count'?: number;
    /**
     * The number of emails associated with the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'email_messages_count'?: number;
    /**
     * The number of activities associated with the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'activities_count'?: number;
    /**
     * The number of completed activities associated with the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'done_activities_count'?: number;
    /**
     * The number of incomplete activities associated with the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'undone_activities_count'?: number;
    /**
     * The number of participants associated with the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'participants_count'?: number;
    /**
     * The expected close date of the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'expected_close_date'?: string;
    /**
     * The date and time of the last incoming email associated with the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'last_outgoing_mail_time'?: string;
    /**
     * The label or multiple labels assigned to the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'label'?: string;
    /**
     * The order number of the deal stage associated with the deal
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'stage_order_nr'?: number;
    /**
     * The name of the person associated with the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'person_name'?: string;
    /**
     * The name of the organization associated with the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'org_name'?: string;
    /**
     * The subject of the next activity associated with the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'next_activity_subject'?: string;
    /**
     * The type of the next activity associated with the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'next_activity_type'?: string;
    /**
     * The duration of the next activity associated with the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'next_activity_duration'?: string;
    /**
     * The note of the next activity associated with the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'next_activity_note'?: string;
    /**
     * The deal value formatted with selected currency. E.g. US$500
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'formatted_value'?: string;
    /**
     * Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'weighted_value'?: number;
    /**
     * The weighted_value formatted with selected currency. E.g. US$500
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'formatted_weighted_value'?: string;
    /**
     * The currency associated with the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'weighted_value_currency'?: string;
    /**
     * The date and time of changing the deal status as rotten
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'rotten_time'?: string | null;
    /**
     * The name of the deal owner
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'owner_name'?: string;
    /**
     * The BCC email of the deal
     * @type {string}
     * @memberof DealNonStrictWithDetails
     */
    'cc_email'?: string;
    /**
     * If the organization that is associated with the deal is hidden or not
     * @type {boolean}
     * @memberof DealNonStrictWithDetails
     */
    'org_hidden'?: boolean;
    /**
     * If the person that is associated with the deal is hidden or not
     * @type {boolean}
     * @memberof DealNonStrictWithDetails
     */
    'person_hidden'?: boolean;
    /**
     *
     * @type {DealNonStrictWithDetailsAllOfAverageTimeToWon}
     * @memberof DealNonStrictWithDetails
     */
    'average_time_to_won'?: DealNonStrictWithDetailsAllOfAverageTimeToWon;
    /**
     * The average of the deal stage progression
     * @type {number}
     * @memberof DealNonStrictWithDetails
     */
    'average_stage_progress'?: number;
    /**
     *
     * @type {DealNonStrictWithDetailsAllOfAge}
     * @memberof DealNonStrictWithDetails
     */
    'age'?: DealNonStrictWithDetailsAllOfAge;
    /**
     *
     * @type {DealNonStrictWithDetailsAllOfStayInPipelineStages}
     * @memberof DealNonStrictWithDetails
     */
    'stay_in_pipeline_stages'?: DealNonStrictWithDetailsAllOfStayInPipelineStages;
    /**
     * The details of the last activity associated with the deal
     * @type {object}
     * @memberof DealNonStrictWithDetails
     */
    'last_activity'?: object | null;
    /**
     * The details of the next activity associated with the deal
     * @type {object}
     * @memberof DealNonStrictWithDetails
     */
    'next_activity'?: object | null;
}
/**
 *
 * @export
 * @interface DealNonStrictWithDetailsAllOf
 */
export interface DealNonStrictWithDetailsAllOf {
    /**
     *
     * @type {DealNonStrictWithDetailsAllOfAverageTimeToWon}
     * @memberof DealNonStrictWithDetailsAllOf
     */
    'average_time_to_won'?: DealNonStrictWithDetailsAllOfAverageTimeToWon;
    /**
     * The average of the deal stage progression
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOf
     */
    'average_stage_progress'?: number;
    /**
     *
     * @type {DealNonStrictWithDetailsAllOfAge}
     * @memberof DealNonStrictWithDetailsAllOf
     */
    'age'?: DealNonStrictWithDetailsAllOfAge;
    /**
     *
     * @type {DealNonStrictWithDetailsAllOfStayInPipelineStages}
     * @memberof DealNonStrictWithDetailsAllOf
     */
    'stay_in_pipeline_stages'?: DealNonStrictWithDetailsAllOfStayInPipelineStages;
    /**
     * The details of the last activity associated with the deal
     * @type {object}
     * @memberof DealNonStrictWithDetailsAllOf
     */
    'last_activity'?: object | null;
    /**
     * The details of the next activity associated with the deal
     * @type {object}
     * @memberof DealNonStrictWithDetailsAllOf
     */
    'next_activity'?: object | null;
}
/**
 * The lifetime of the deal
 * @export
 * @interface DealNonStrictWithDetailsAllOfAge
 */
export interface DealNonStrictWithDetailsAllOfAge {
    /**
     * Years
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAge
     */
    'y'?: number;
    /**
     * Months
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAge
     */
    'm'?: number;
    /**
     * Days
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAge
     */
    'd'?: number;
    /**
     * Hours
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAge
     */
    'h'?: number;
    /**
     * Minutes
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAge
     */
    'i'?: number;
    /**
     * Seconds
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAge
     */
    's'?: number;
    /**
     * The total time in seconds
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAge
     */
    'total_seconds'?: number;
}
/**
 * The average time to win the deal
 * @export
 * @interface DealNonStrictWithDetailsAllOfAverageTimeToWon
 */
export interface DealNonStrictWithDetailsAllOfAverageTimeToWon {
    /**
     * Years
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAverageTimeToWon
     */
    'y'?: number;
    /**
     * Months
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAverageTimeToWon
     */
    'm'?: number;
    /**
     * Days
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAverageTimeToWon
     */
    'd'?: number;
    /**
     * Hours
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAverageTimeToWon
     */
    'h'?: number;
    /**
     * Minutes
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAverageTimeToWon
     */
    'i'?: number;
    /**
     * Seconds
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAverageTimeToWon
     */
    's'?: number;
    /**
     * The total time in seconds
     * @type {number}
     * @memberof DealNonStrictWithDetailsAllOfAverageTimeToWon
     */
    'total_seconds'?: number;
}
/**
 * The details of the duration of the deal being in each stage of the pipeline
 * @export
 * @interface DealNonStrictWithDetailsAllOfStayInPipelineStages
 */
export interface DealNonStrictWithDetailsAllOfStayInPipelineStages {
    /**
     * The number of seconds a deal has been in each stage of the pipeline
     * @type {object}
     * @memberof DealNonStrictWithDetailsAllOfStayInPipelineStages
     */
    'times_in_stages'?: object;
    /**
     * The order of the deal progression through the pipeline stages
     * @type {Array<number>}
     * @memberof DealNonStrictWithDetailsAllOfStayInPipelineStages
     */
    'order_of_stages'?: Array<number>;
}
/**
 *
 * @export
 * @interface DealOrganizationDataWithId
 */
export interface DealOrganizationDataWithId {
    /**
     * The name of the organization associated with the deal
     * @type {string}
     * @memberof DealOrganizationDataWithId
     */
    'name'?: string;
    /**
     * The number of people connected with the organization that is associated with the deal
     * @type {number}
     * @memberof DealOrganizationDataWithId
     */
    'people_count'?: number;
    /**
     * The ID of the owner of the organization that is associated with the deal
     * @type {number}
     * @memberof DealOrganizationDataWithId
     */
    'owner_id'?: number;
    /**
     * The address of the organization that is associated with the deal
     * @type {string}
     * @memberof DealOrganizationDataWithId
     */
    'address'?: string;
    /**
     * Whether the associated organization is active or not
     * @type {boolean}
     * @memberof DealOrganizationDataWithId
     */
    'active_flag'?: boolean;
    /**
     * The BCC email of the organization associated with the deal
     * @type {string}
     * @memberof DealOrganizationDataWithId
     */
    'cc_email'?: string;
    /**
     * The ID of the organization associated with the deal
     * @type {number}
     * @memberof DealOrganizationDataWithId
     */
    'value'?: number;
}
/**
 * The organization which is associated with the deal
 * @export
 * @interface DealOrganizationDataWithIdAllOf
 */
export interface DealOrganizationDataWithIdAllOf {
    /**
     * The name of the organization associated with the deal
     * @type {string}
     * @memberof DealOrganizationDataWithIdAllOf
     */
    'name'?: string;
    /**
     * The number of people connected with the organization that is associated with the deal
     * @type {number}
     * @memberof DealOrganizationDataWithIdAllOf
     */
    'people_count'?: number;
    /**
     * The ID of the owner of the organization that is associated with the deal
     * @type {number}
     * @memberof DealOrganizationDataWithIdAllOf
     */
    'owner_id'?: number;
    /**
     * The address of the organization that is associated with the deal
     * @type {string}
     * @memberof DealOrganizationDataWithIdAllOf
     */
    'address'?: string;
    /**
     * Whether the associated organization is active or not
     * @type {boolean}
     * @memberof DealOrganizationDataWithIdAllOf
     */
    'active_flag'?: boolean;
    /**
     * The BCC email of the organization associated with the deal
     * @type {string}
     * @memberof DealOrganizationDataWithIdAllOf
     */
    'cc_email'?: string;
}
/**
 *
 * @export
 * @interface DealOrganizationDataWithIdAllOf1
 */
export interface DealOrganizationDataWithIdAllOf1 {
    /**
     * The ID of the organization associated with the deal
     * @type {number}
     * @memberof DealOrganizationDataWithIdAllOf1
     */
    'value'?: number;
}
/**
 *
 * @export
 * @interface DealPersonDataWithId
 */
export interface DealPersonDataWithId {
    /**
     * Whether the associated person is active or not
     * @type {boolean}
     * @memberof DealPersonDataWithId
     */
    'active_flag'?: boolean;
    /**
     * The name of the person associated with the deal
     * @type {string}
     * @memberof DealPersonDataWithId
     */
    'name'?: string;
    /**
     * The emails of the person associated with the deal
     * @type {Array<DealPersonDataWithIdAllOfEmailInner>}
     * @memberof DealPersonDataWithId
     */
    'email'?: Array<DealPersonDataWithIdAllOfEmailInner>;
    /**
     * The phone numbers of the person associated with the deal
     * @type {Array<DealPersonDataWithIdAllOfPhoneInner>}
     * @memberof DealPersonDataWithId
     */
    'phone'?: Array<DealPersonDataWithIdAllOfPhoneInner>;
    /**
     * The ID of the owner of the person that is associated with the deal
     * @type {number}
     * @memberof DealPersonDataWithId
     */
    'owner_id'?: number;
    /**
     * The ID of the person associated with the deal
     * @type {number}
     * @memberof DealPersonDataWithId
     */
    'value'?: number;
}
/**
 * The person who is associated with the deal
 * @export
 * @interface DealPersonDataWithIdAllOf
 */
export interface DealPersonDataWithIdAllOf {
    /**
     * Whether the associated person is active or not
     * @type {boolean}
     * @memberof DealPersonDataWithIdAllOf
     */
    'active_flag'?: boolean;
    /**
     * The name of the person associated with the deal
     * @type {string}
     * @memberof DealPersonDataWithIdAllOf
     */
    'name'?: string;
    /**
     * The emails of the person associated with the deal
     * @type {Array<DealPersonDataWithIdAllOfEmailInner>}
     * @memberof DealPersonDataWithIdAllOf
     */
    'email'?: Array<DealPersonDataWithIdAllOfEmailInner>;
    /**
     * The phone numbers of the person associated with the deal
     * @type {Array<DealPersonDataWithIdAllOfPhoneInner>}
     * @memberof DealPersonDataWithIdAllOf
     */
    'phone'?: Array<DealPersonDataWithIdAllOfPhoneInner>;
    /**
     * The ID of the owner of the person that is associated with the deal
     * @type {number}
     * @memberof DealPersonDataWithIdAllOf
     */
    'owner_id'?: number;
}
/**
 *
 * @export
 * @interface DealPersonDataWithIdAllOf1
 */
export interface DealPersonDataWithIdAllOf1 {
    /**
     * The ID of the person associated with the deal
     * @type {number}
     * @memberof DealPersonDataWithIdAllOf1
     */
    'value'?: number;
}
/**
 *
 * @export
 * @interface DealPersonDataWithIdAllOfEmailInner
 */
export interface DealPersonDataWithIdAllOfEmailInner {
    /**
     * The type of the email
     * @type {string}
     * @memberof DealPersonDataWithIdAllOfEmailInner
     */
    'label'?: string;
    /**
     * The email of the associated person
     * @type {string}
     * @memberof DealPersonDataWithIdAllOfEmailInner
     */
    'value'?: string;
    /**
     * If this is the primary email or not
     * @type {boolean}
     * @memberof DealPersonDataWithIdAllOfEmailInner
     */
    'primary'?: boolean;
}
/**
 *
 * @export
 * @interface DealPersonDataWithIdAllOfPhoneInner
 */
export interface DealPersonDataWithIdAllOfPhoneInner {
    /**
     * The type of the phone number
     * @type {string}
     * @memberof DealPersonDataWithIdAllOfPhoneInner
     */
    'label'?: string;
    /**
     * The phone number of the person associated with the deal
     * @type {string}
     * @memberof DealPersonDataWithIdAllOfPhoneInner
     */
    'value'?: string;
    /**
     * If this is the primary phone number or not
     * @type {boolean}
     * @memberof DealPersonDataWithIdAllOfPhoneInner
     */
    'primary'?: boolean;
}
/**
 *
 * @export
 * @interface DealResponse200
 */
export interface DealResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DealResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DealNonStrict}
     * @memberof DealResponse200
     */
    'data'?: DealNonStrict;
    /**
     *
     * @type {GetDealsResponse200RelatedObjects}
     * @memberof DealResponse200
     */
    'related_objects'?: GetDealsResponse200RelatedObjects;
}
/**
 *
 * @export
 * @interface DealStrict
 */
export interface DealStrict {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealStrict
     */
    'id'?: number;
    /**
     * The ID of the deal creator
     * @type {number}
     * @memberof DealStrict
     */
    'creator_user_id'?: number;
    /**
     * The ID of the user
     * @type {number}
     * @memberof DealStrict
     */
    'user_id'?: number;
    /**
     * The ID of the person associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'person_id'?: number;
    /**
     * The ID of the organization associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'org_id'?: number;
    /**
     * The ID of the deal stage
     * @type {number}
     * @memberof DealStrict
     */
    'stage_id'?: number;
    /**
     * The title of the deal
     * @type {string}
     * @memberof DealStrict
     */
    'title'?: string;
    /**
     * The value of the deal
     * @type {number}
     * @memberof DealStrict
     */
    'value'?: number;
    /**
     * The currency associated with the deal
     * @type {string}
     * @memberof DealStrict
     */
    'currency'?: string;
    /**
     * The creation date and time of the deal
     * @type {string}
     * @memberof DealStrict
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the deal
     * @type {string}
     * @memberof DealStrict
     */
    'update_time'?: string;
    /**
     * The last updated date and time of the deal stage
     * @type {string}
     * @memberof DealStrict
     */
    'stage_change_time'?: string;
    /**
     * Whether the deal is active or not
     * @type {boolean}
     * @memberof DealStrict
     */
    'active'?: boolean;
    /**
     * Whether the deal is deleted or not
     * @type {boolean}
     * @memberof DealStrict
     */
    'deleted'?: boolean;
    /**
     * The status of the deal
     * @type {string}
     * @memberof DealStrict
     */
    'status'?: string;
    /**
     * The success probability percentage of the deal
     * @type {number}
     * @memberof DealStrict
     */
    'probability'?: number | null;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof DealStrict
     */
    'next_activity_date'?: string;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof DealStrict
     */
    'next_activity_time'?: string;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof DealStrict
     */
    'last_activity_date'?: string | null;
    /**
     * The reason for losing the deal
     * @type {string}
     * @memberof DealStrict
     */
    'lost_reason'?: string | null;
    /**
     * The visibility of the deal
     * @type {string}
     * @memberof DealStrict
     */
    'visible_to'?: string;
    /**
     * The date and time of closing the deal
     * @type {string}
     * @memberof DealStrict
     */
    'close_time'?: string | null;
    /**
     * The ID of the pipeline associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'pipeline_id'?: number;
    /**
     * The date and time of changing the deal status as won
     * @type {string}
     * @memberof DealStrict
     */
    'won_time'?: string;
    /**
     * The date and time of the first time changing the deal status as won
     * @type {string}
     * @memberof DealStrict
     */
    'first_won_time'?: string;
    /**
     * The date and time of changing the deal status as lost
     * @type {string}
     * @memberof DealStrict
     */
    'lost_time'?: string;
    /**
     * The number of products associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'products_count'?: number;
    /**
     * The number of files associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'files_count'?: number;
    /**
     * The number of notes associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'notes_count'?: number;
    /**
     * The number of followers associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'followers_count'?: number;
    /**
     * The number of emails associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'email_messages_count'?: number;
    /**
     * The number of activities associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'activities_count'?: number;
    /**
     * The number of completed activities associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'done_activities_count'?: number;
    /**
     * The number of incomplete activities associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'undone_activities_count'?: number;
    /**
     * The number of participants associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'participants_count'?: number;
    /**
     * The expected close date of the deal
     * @type {string}
     * @memberof DealStrict
     */
    'expected_close_date'?: string;
    /**
     * The date and time of the last incoming email associated with the deal
     * @type {string}
     * @memberof DealStrict
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the deal
     * @type {string}
     * @memberof DealStrict
     */
    'last_outgoing_mail_time'?: string;
    /**
     * The label or multiple labels assigned to the deal
     * @type {string}
     * @memberof DealStrict
     */
    'label'?: string;
    /**
     * The order number of the deal stage associated with the deal
     * @type {number}
     * @memberof DealStrict
     */
    'stage_order_nr'?: number;
    /**
     * The name of the person associated with the deal
     * @type {string}
     * @memberof DealStrict
     */
    'person_name'?: string;
    /**
     * The name of the organization associated with the deal
     * @type {string}
     * @memberof DealStrict
     */
    'org_name'?: string;
    /**
     * The subject of the next activity associated with the deal
     * @type {string}
     * @memberof DealStrict
     */
    'next_activity_subject'?: string;
    /**
     * The type of the next activity associated with the deal
     * @type {string}
     * @memberof DealStrict
     */
    'next_activity_type'?: string;
    /**
     * The duration of the next activity associated with the deal
     * @type {string}
     * @memberof DealStrict
     */
    'next_activity_duration'?: string;
    /**
     * The note of the next activity associated with the deal
     * @type {string}
     * @memberof DealStrict
     */
    'next_activity_note'?: string;
    /**
     * The deal value formatted with selected currency. E.g. US$500
     * @type {string}
     * @memberof DealStrict
     */
    'formatted_value'?: string;
    /**
     * Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
     * @type {number}
     * @memberof DealStrict
     */
    'weighted_value'?: number;
    /**
     * The weighted_value formatted with selected currency. E.g. US$500
     * @type {string}
     * @memberof DealStrict
     */
    'formatted_weighted_value'?: string;
    /**
     * The currency associated with the deal
     * @type {string}
     * @memberof DealStrict
     */
    'weighted_value_currency'?: string;
    /**
     * The date and time of changing the deal status as rotten
     * @type {string}
     * @memberof DealStrict
     */
    'rotten_time'?: string | null;
    /**
     * The name of the deal owner
     * @type {string}
     * @memberof DealStrict
     */
    'owner_name'?: string;
    /**
     * The BCC email of the deal
     * @type {string}
     * @memberof DealStrict
     */
    'cc_email'?: string;
    /**
     * If the organization that is associated with the deal is hidden or not
     * @type {boolean}
     * @memberof DealStrict
     */
    'org_hidden'?: boolean;
    /**
     * If the person that is associated with the deal is hidden or not
     * @type {boolean}
     * @memberof DealStrict
     */
    'person_hidden'?: boolean;
}
/**
 *
 * @export
 * @interface DealStrictAllOf
 */
export interface DealStrictAllOf {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealStrictAllOf
     */
    'id'?: number;
    /**
     * The ID of the deal creator
     * @type {number}
     * @memberof DealStrictAllOf
     */
    'creator_user_id'?: number;
    /**
     * The ID of the user
     * @type {number}
     * @memberof DealStrictAllOf
     */
    'user_id'?: number;
    /**
     * The ID of the person associated with the deal
     * @type {number}
     * @memberof DealStrictAllOf
     */
    'person_id'?: number;
    /**
     * The ID of the organization associated with the deal
     * @type {number}
     * @memberof DealStrictAllOf
     */
    'org_id'?: number;
}
/**
 *
 * @export
 * @interface DealTitleParam
 */
export interface DealTitleParam {
    /**
     * The title of the deal
     * @type {string}
     * @memberof DealTitleParam
     */
    'title'?: string;
}
/**
 *
 * @export
 * @interface DealUserDataWithId
 */
export interface DealUserDataWithId {
    /**
     * The ID of the user
     * @type {number}
     * @memberof DealUserDataWithId
     */
    'id'?: number;
    /**
     * The name of the user
     * @type {string}
     * @memberof DealUserDataWithId
     */
    'name'?: string;
    /**
     * The email of the user
     * @type {string}
     * @memberof DealUserDataWithId
     */
    'email'?: string;
    /**
     * If the user has a picture or not
     * @type {boolean}
     * @memberof DealUserDataWithId
     */
    'has_pic'?: boolean;
    /**
     * The user picture hash
     * @type {string}
     * @memberof DealUserDataWithId
     */
    'pic_hash'?: string | null;
    /**
     * Whether the user is active or not
     * @type {boolean}
     * @memberof DealUserDataWithId
     */
    'active_flag'?: boolean;
    /**
     * The ID of the user
     * @type {number}
     * @memberof DealUserDataWithId
     */
    'value'?: number;
}
/**
 * The user who is associated with the deal
 * @export
 * @interface DealUserDataWithIdAllOf
 */
export interface DealUserDataWithIdAllOf {
    /**
     * The ID of the user
     * @type {number}
     * @memberof DealUserDataWithIdAllOf
     */
    'id'?: number;
    /**
     * The name of the user
     * @type {string}
     * @memberof DealUserDataWithIdAllOf
     */
    'name'?: string;
    /**
     * The email of the user
     * @type {string}
     * @memberof DealUserDataWithIdAllOf
     */
    'email'?: string;
    /**
     * If the user has a picture or not
     * @type {boolean}
     * @memberof DealUserDataWithIdAllOf
     */
    'has_pic'?: boolean;
    /**
     * The user picture hash
     * @type {string}
     * @memberof DealUserDataWithIdAllOf
     */
    'pic_hash'?: string | null;
    /**
     * Whether the user is active or not
     * @type {boolean}
     * @memberof DealUserDataWithIdAllOf
     */
    'active_flag'?: boolean;
}
/**
 *
 * @export
 * @interface DealUserDataWithIdAllOf1
 */
export interface DealUserDataWithIdAllOf1 {
    /**
     * The ID of the user
     * @type {number}
     * @memberof DealUserDataWithIdAllOf1
     */
    'value'?: number;
}
/**
 *
 * @export
 * @interface DealsCountAndActivityInfo
 */
export interface DealsCountAndActivityInfo {
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof DealsCountAndActivityInfo
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof DealsCountAndActivityInfo
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof DealsCountAndActivityInfo
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof DealsCountAndActivityInfo
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof DealsCountAndActivityInfo
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof DealsCountAndActivityInfo
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof DealsCountAndActivityInfo
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof DealsCountAndActivityInfo
     */
    'related_lost_deals_count'?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof DealsCountAndActivityInfo
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof DealsCountAndActivityInfo
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof DealsCountAndActivityInfo
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof DealsCountAndActivityInfo
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof DealsCountAndActivityInfo
     */
    'last_activity_date'?: string | null;
}
/**
 *
 * @export
 * @interface DeleteActivitiesResponse200
 */
export interface DeleteActivitiesResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof DeleteActivitiesResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteActivitiesResponse200Data}
     * @memberof DeleteActivitiesResponse200
     */
    'data'?: DeleteActivitiesResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteActivitiesResponse200Data
 */
export interface DeleteActivitiesResponse200Data {
    /**
     * An array of the IDs of activities that were deleted
     * @type {Array<number>}
     * @memberof DeleteActivitiesResponse200Data
     */
    'id'?: Array<number>;
}
/**
 *
 * @export
 * @interface DeleteActivityResponse200
 */
export interface DeleteActivityResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof DeleteActivityResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteActivityResponse200Data}
     * @memberof DeleteActivityResponse200
     */
    'data'?: DeleteActivityResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteActivityResponse200Data
 */
export interface DeleteActivityResponse200Data {
    /**
     * The ID of the activity that was deleted
     * @type {number}
     * @memberof DeleteActivityResponse200Data
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteActivityTypesResponse200
 */
export interface DeleteActivityTypesResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteActivityTypesResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteActivityTypesResponse200AllOfData}
     * @memberof DeleteActivityTypesResponse200
     */
    'data'?: DeleteActivityTypesResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteActivityTypesResponse200AllOf
 */
export interface DeleteActivityTypesResponse200AllOf {
    /**
     *
     * @type {DeleteActivityTypesResponse200AllOfData}
     * @memberof DeleteActivityTypesResponse200AllOf
     */
    'data'?: DeleteActivityTypesResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteActivityTypesResponse200AllOfData
 */
export interface DeleteActivityTypesResponse200AllOfData {
    /**
     * The IDs of the deleted activity types
     * @type {Array<number>}
     * @memberof DeleteActivityTypesResponse200AllOfData
     */
    'id'?: Array<number>;
}
/**
 *
 * @export
 * @interface DeleteChannel200Response
 */
export interface DeleteChannel200Response {
    /**
     *
     * @type {boolean}
     * @memberof DeleteChannel200Response
     */
    'success'?: boolean;
}
/**
 *
 * @export
 * @interface DeleteCommentResponse200
 */
export interface DeleteCommentResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteCommentResponse200
     */
    'success'?: boolean;
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteCommentResponse200
     */
    'data'?: boolean;
}
/**
 *
 * @export
 * @interface DeleteConversation403Response
 */
export interface DeleteConversation403Response {
    /**
     *
     * @type {boolean}
     * @memberof DeleteConversation403Response
     */
    'success'?: boolean;
    /**
     * The error description
     * @type {string}
     * @memberof DeleteConversation403Response
     */
    'error'?: string;
    /**
     *
     * @type {string}
     * @memberof DeleteConversation403Response
     */
    'error_info'?: string;
    /**
     *
     * @type {DeleteConversation403ResponseAdditionalData}
     * @memberof DeleteConversation403Response
     */
    'additional_data'?: DeleteConversation403ResponseAdditionalData;
}
/**
 *
 * @export
 * @interface DeleteConversation403ResponseAdditionalData
 */
export interface DeleteConversation403ResponseAdditionalData {
    /**
     * An error code sent by the API
     * @type {string}
     * @memberof DeleteConversation403ResponseAdditionalData
     */
    'code'?: string;
}
/**
 *
 * @export
 * @interface DeleteConversation404Response
 */
export interface DeleteConversation404Response {
    /**
     *
     * @type {boolean}
     * @memberof DeleteConversation404Response
     */
    'success'?: boolean;
    /**
     * The error description
     * @type {string}
     * @memberof DeleteConversation404Response
     */
    'error'?: string;
    /**
     *
     * @type {string}
     * @memberof DeleteConversation404Response
     */
    'error_info'?: string;
    /**
     *
     * @type {DeleteConversation404ResponseAdditionalData}
     * @memberof DeleteConversation404Response
     */
    'additional_data'?: DeleteConversation404ResponseAdditionalData;
}
/**
 *
 * @export
 * @interface DeleteConversation404ResponseAdditionalData
 */
export interface DeleteConversation404ResponseAdditionalData {
    /**
     * An error code sent by the API
     * @type {string}
     * @memberof DeleteConversation404ResponseAdditionalData
     */
    'code'?: string;
}
/**
 *
 * @export
 * @interface DeleteDealFollowerResponse200
 */
export interface DeleteDealFollowerResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteDealFollowerResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteDealFollowerResponse200Data}
     * @memberof DeleteDealFollowerResponse200
     */
    'data'?: DeleteDealFollowerResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteDealFollowerResponse200Data
 */
export interface DeleteDealFollowerResponse200Data {
    /**
     * The ID of the deal follower that was deleted
     * @type {number}
     * @memberof DeleteDealFollowerResponse200Data
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteDealParticipantResponse200
 */
export interface DeleteDealParticipantResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteDealParticipantResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteDealParticipantResponse200Data}
     * @memberof DeleteDealParticipantResponse200
     */
    'data'?: DeleteDealParticipantResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteDealParticipantResponse200Data
 */
export interface DeleteDealParticipantResponse200Data {
    /**
     * The ID of the deal participant that was deleted
     * @type {number}
     * @memberof DeleteDealParticipantResponse200Data
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteDealProductResponse200
 */
export interface DeleteDealProductResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteDealProductResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteDealProductResponse200Data}
     * @memberof DeleteDealProductResponse200
     */
    'data'?: DeleteDealProductResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteDealProductResponse200Data
 */
export interface DeleteDealProductResponse200Data {
    /**
     * The ID of an attached product that was deleted from the deal
     * @type {number}
     * @memberof DeleteDealProductResponse200Data
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteDealResponse200
 */
export interface DeleteDealResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteDealResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteDealResponse200Data}
     * @memberof DeleteDealResponse200
     */
    'data'?: DeleteDealResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteDealResponse200Data
 */
export interface DeleteDealResponse200Data {
    /**
     * The ID of the deal that was deleted
     * @type {number}
     * @memberof DeleteDealResponse200Data
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteDealsResponse200
 */
export interface DeleteDealsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteDealsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteDealsResponse200Data}
     * @memberof DeleteDealsResponse200
     */
    'data'?: DeleteDealsResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteDealsResponse200Data
 */
export interface DeleteDealsResponse200Data {
    /**
     * The list of deleted deals IDs
     * @type {Array<number>}
     * @memberof DeleteDealsResponse200Data
     */
    'id'?: Array<number>;
}
/**
 *
 * @export
 * @interface DeleteFieldResponse200
 */
export interface DeleteFieldResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteFieldResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteFieldResponse200AllOfData}
     * @memberof DeleteFieldResponse200
     */
    'data'?: DeleteFieldResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteFieldResponse200AllOf
 */
export interface DeleteFieldResponse200AllOf {
    /**
     *
     * @type {DeleteFieldResponse200AllOfData}
     * @memberof DeleteFieldResponse200AllOf
     */
    'data'?: DeleteFieldResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteFieldResponse200AllOfData
 */
export interface DeleteFieldResponse200AllOfData {
    /**
     * The ID of the field that was deleted
     * @type {number}
     * @memberof DeleteFieldResponse200AllOfData
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteFieldsResponse200
 */
export interface DeleteFieldsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteFieldsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteFieldsResponse200AllOfData}
     * @memberof DeleteFieldsResponse200
     */
    'data'?: DeleteFieldsResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteFieldsResponse200AllOf
 */
export interface DeleteFieldsResponse200AllOf {
    /**
     *
     * @type {DeleteFieldsResponse200AllOfData}
     * @memberof DeleteFieldsResponse200AllOf
     */
    'data'?: DeleteFieldsResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteFieldsResponse200AllOfData
 */
export interface DeleteFieldsResponse200AllOfData {
    /**
     * The list of deleted field IDs
     * @type {Array<number>}
     * @memberof DeleteFieldsResponse200AllOfData
     */
    'id'?: Array<number>;
}
/**
 *
 * @export
 * @interface DeleteFileResponse200
 */
export interface DeleteFileResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteFileResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteFileResponse200Data}
     * @memberof DeleteFileResponse200
     */
    'data'?: DeleteFileResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteFileResponse200Data
 */
export interface DeleteFileResponse200Data {
    /**
     * The ID of the file
     * @type {number}
     * @memberof DeleteFileResponse200Data
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteFilterResponse200
 */
export interface DeleteFilterResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteFilterResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteFilterResponse200AllOfData}
     * @memberof DeleteFilterResponse200
     */
    'data'?: DeleteFilterResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteFilterResponse200AllOf
 */
export interface DeleteFilterResponse200AllOf {
    /**
     *
     * @type {DeleteFilterResponse200AllOfData}
     * @memberof DeleteFilterResponse200AllOf
     */
    'data'?: DeleteFilterResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteFilterResponse200AllOfData
 */
export interface DeleteFilterResponse200AllOfData {
    /**
     * The ID of the deleted filter
     * @type {number}
     * @memberof DeleteFilterResponse200AllOfData
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteFiltersResponse200
 */
export interface DeleteFiltersResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteFiltersResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteFiltersResponse200AllOfData}
     * @memberof DeleteFiltersResponse200
     */
    'data'?: DeleteFiltersResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteFiltersResponse200AllOf
 */
export interface DeleteFiltersResponse200AllOf {
    /**
     *
     * @type {DeleteFiltersResponse200AllOfData}
     * @memberof DeleteFiltersResponse200AllOf
     */
    'data'?: DeleteFiltersResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteFiltersResponse200AllOfData
 */
export interface DeleteFiltersResponse200AllOfData {
    /**
     * The array of the IDs of the deleted filter
     * @type {Array<number>}
     * @memberof DeleteFiltersResponse200AllOfData
     */
    'id'?: Array<number>;
}
/**
 *
 * @export
 * @interface DeleteGoalResponse200
 */
export interface DeleteGoalResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteGoalResponse200
     */
    'success'?: boolean;
}
/**
 *
 * @export
 * @interface DeleteMailThreadResponse200
 */
export interface DeleteMailThreadResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteMailThreadResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteMailThreadResponse200AllOfData}
     * @memberof DeleteMailThreadResponse200
     */
    'data'?: DeleteMailThreadResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteMailThreadResponse200AllOf
 */
export interface DeleteMailThreadResponse200AllOf {
    /**
     *
     * @type {DeleteMailThreadResponse200AllOfData}
     * @memberof DeleteMailThreadResponse200AllOf
     */
    'data'?: DeleteMailThreadResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteMailThreadResponse200AllOfData
 */
export interface DeleteMailThreadResponse200AllOfData {
    /**
     * The ID of the deleted mail thread
     * @type {number}
     * @memberof DeleteMailThreadResponse200AllOfData
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteNoteResponse200
 */
export interface DeleteNoteResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteNoteResponse200
     */
    'success'?: boolean;
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteNoteResponse200
     */
    'data'?: boolean;
}
/**
 *
 * @export
 * @interface DeleteOrganizationFollowerResponse200
 */
export interface DeleteOrganizationFollowerResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteOrganizationFollowerResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteOrganizationFollowerResponse200Data}
     * @memberof DeleteOrganizationFollowerResponse200
     */
    'data'?: DeleteOrganizationFollowerResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteOrganizationFollowerResponse200Data
 */
export interface DeleteOrganizationFollowerResponse200Data {
    /**
     * The ID of the follower that was deleted from the organization
     * @type {number}
     * @memberof DeleteOrganizationFollowerResponse200Data
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteOrganizationRelationshipResponse200
 */
export interface DeleteOrganizationRelationshipResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteOrganizationRelationshipResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteOrganizationRelationshipResponse200AllOfData}
     * @memberof DeleteOrganizationRelationshipResponse200
     */
    'data'?: DeleteOrganizationRelationshipResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteOrganizationRelationshipResponse200AllOf
 */
export interface DeleteOrganizationRelationshipResponse200AllOf {
    /**
     *
     * @type {DeleteOrganizationRelationshipResponse200AllOfData}
     * @memberof DeleteOrganizationRelationshipResponse200AllOf
     */
    'data'?: DeleteOrganizationRelationshipResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteOrganizationRelationshipResponse200AllOfData
 */
export interface DeleteOrganizationRelationshipResponse200AllOfData {
    /**
     * The ID of the deleted organization relationship
     * @type {number}
     * @memberof DeleteOrganizationRelationshipResponse200AllOfData
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteOrganizationResponse200
 */
export interface DeleteOrganizationResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteOrganizationResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteOrganizationResponse200Data}
     * @memberof DeleteOrganizationResponse200
     */
    'data'?: DeleteOrganizationResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteOrganizationResponse200Data
 */
export interface DeleteOrganizationResponse200Data {
    /**
     * The ID of the organization that was deleted
     * @type {number}
     * @memberof DeleteOrganizationResponse200Data
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteOrganizationsResponse200
 */
export interface DeleteOrganizationsResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteOrganizationsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteOrganizationsResponse200Data}
     * @memberof DeleteOrganizationsResponse200
     */
    'data'?: DeleteOrganizationsResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteOrganizationsResponse200Data
 */
export interface DeleteOrganizationsResponse200Data {
    /**
     * The IDs of the organizations that were deleted
     * @type {Array<number>}
     * @memberof DeleteOrganizationsResponse200Data
     */
    'id'?: Array<number>;
}
/**
 *
 * @export
 * @interface DeletePersonResponse200
 */
export interface DeletePersonResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeletePersonResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeletePersonResponse200AllOfData}
     * @memberof DeletePersonResponse200
     */
    'data'?: DeletePersonResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeletePersonResponse200AllOf
 */
export interface DeletePersonResponse200AllOf {
    /**
     *
     * @type {DeletePersonResponse200AllOfData}
     * @memberof DeletePersonResponse200AllOf
     */
    'data'?: DeletePersonResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeletePersonResponse200AllOfData
 */
export interface DeletePersonResponse200AllOfData {
    /**
     * The ID of the deleted person
     * @type {number}
     * @memberof DeletePersonResponse200AllOfData
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeletePersonsResponse200
 */
export interface DeletePersonsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeletePersonsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeletePersonsResponse200AllOfData}
     * @memberof DeletePersonsResponse200
     */
    'data'?: DeletePersonsResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeletePersonsResponse200AllOf
 */
export interface DeletePersonsResponse200AllOf {
    /**
     *
     * @type {DeletePersonsResponse200AllOfData}
     * @memberof DeletePersonsResponse200AllOf
     */
    'data'?: DeletePersonsResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeletePersonsResponse200AllOfData
 */
export interface DeletePersonsResponse200AllOfData {
    /**
     * The list of deleted persons IDs
     * @type {Array<number>}
     * @memberof DeletePersonsResponse200AllOfData
     */
    'id'?: Array<number>;
}
/**
 *
 * @export
 * @interface DeletePipelineResponse200
 */
export interface DeletePipelineResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeletePipelineResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeletePipelineResponse200Data}
     * @memberof DeletePipelineResponse200
     */
    'data'?: DeletePipelineResponse200Data;
}
/**
 *
 * @export
 * @interface DeletePipelineResponse200Data
 */
export interface DeletePipelineResponse200Data {
    /**
     * Deleted Pipeline ID
     * @type {number}
     * @memberof DeletePipelineResponse200Data
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteProductFieldResponse200
 */
export interface DeleteProductFieldResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteProductFieldResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteProductResponse200Data}
     * @memberof DeleteProductFieldResponse200
     */
    'data'?: DeleteProductResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteProductFieldsResponse200
 */
export interface DeleteProductFieldsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteProductFieldsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteProductFieldsResponse200Data}
     * @memberof DeleteProductFieldsResponse200
     */
    'data'?: DeleteProductFieldsResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteProductFieldsResponse200Data
 */
export interface DeleteProductFieldsResponse200Data {
    /**
     * Array of all the IDs of the deleted product fields
     * @type {Array<number>}
     * @memberof DeleteProductFieldsResponse200Data
     */
    'id'?: Array<number>;
}
/**
 *
 * @export
 * @interface DeleteProductFollowerResponse200
 */
export interface DeleteProductFollowerResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteProductFollowerResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteProductResponse200Data}
     * @memberof DeleteProductFollowerResponse200
     */
    'data'?: DeleteProductResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteProductResponse200
 */
export interface DeleteProductResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteProductResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteProductResponse200Data}
     * @memberof DeleteProductResponse200
     */
    'data'?: DeleteProductResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteProductResponse200Data
 */
export interface DeleteProductResponse200Data {
    /**
     *
     * @type {number}
     * @memberof DeleteProductResponse200Data
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteProject
 */
export interface DeleteProject {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteProject
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteProjectData}
     * @memberof DeleteProject
     */
    'data'?: DeleteProjectData;
}
/**
 *
 * @export
 * @interface DeleteProjectData
 */
export interface DeleteProjectData {
    /**
     * The ID of the project that was deleted
     * @type {number}
     * @memberof DeleteProjectData
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteProjectResponse200
 */
export interface DeleteProjectResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof DeleteProjectResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteProject}
     * @memberof DeleteProjectResponse200
     */
    'data'?: DeleteProject;
    /**
     *
     * @type {object}
     * @memberof DeleteProjectResponse200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface DeleteRoleAssignmentRequest
 */
export interface DeleteRoleAssignmentRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof DeleteRoleAssignmentRequest
     */
    'user_id': number;
}
/**
 *
 * @export
 * @interface DeleteRoleAssignmentResponse200
 */
export interface DeleteRoleAssignmentResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteRoleAssignmentResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {AddRoleResponse200AllOfData}
     * @memberof DeleteRoleAssignmentResponse200
     */
    'data'?: AddRoleResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteRoleResponse200
 */
export interface DeleteRoleResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteRoleResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {AddRoleResponse200AllOfData}
     * @memberof DeleteRoleResponse200
     */
    'data'?: AddRoleResponse200AllOfData;
}
/**
 *
 * @export
 * @interface DeleteStageResponse200
 */
export interface DeleteStageResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteStageResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteStageResponse200Data}
     * @memberof DeleteStageResponse200
     */
    'data'?: DeleteStageResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteStageResponse200Data
 */
export interface DeleteStageResponse200Data {
    /**
     * Deleted stage ID
     * @type {number}
     * @memberof DeleteStageResponse200Data
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteStagesResponse200
 */
export interface DeleteStagesResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteStagesResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteStagesResponse200Data}
     * @memberof DeleteStagesResponse200
     */
    'data'?: DeleteStagesResponse200Data;
}
/**
 *
 * @export
 * @interface DeleteStagesResponse200Data
 */
export interface DeleteStagesResponse200Data {
    /**
     * The list of deleted stage IDs
     * @type {Array<number>}
     * @memberof DeleteStagesResponse200Data
     */
    'id'?: Array<number>;
}
/**
 *
 * @export
 * @interface DeleteTask
 */
export interface DeleteTask {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteTask
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteTaskData}
     * @memberof DeleteTask
     */
    'data'?: DeleteTaskData;
}
/**
 *
 * @export
 * @interface DeleteTaskData
 */
export interface DeleteTaskData {
    /**
     * The ID of the task that was deleted
     * @type {number}
     * @memberof DeleteTaskData
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface DeleteTaskResponse200
 */
export interface DeleteTaskResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof DeleteTaskResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DeleteTask}
     * @memberof DeleteTaskResponse200
     */
    'data'?: DeleteTask;
    /**
     *
     * @type {object}
     * @memberof DeleteTaskResponse200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface DeleteTeamUserRequest
 */
export interface DeleteTeamUserRequest {
    /**
     * The list of user IDs
     * @type {Array<number>}
     * @memberof DeleteTeamUserRequest
     */
    'users': Array<number>;
}
/**
 *
 * @export
 * @interface DeleteWebhook403Response
 */
export interface DeleteWebhook403Response {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteWebhook403Response
     */
    'success'?: boolean;
    /**
     * The error message
     * @type {string}
     * @memberof DeleteWebhook403Response
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface DeleteWebhook403ResponseAllOf
 */
export interface DeleteWebhook403ResponseAllOf {
    /**
     * The error message
     * @type {string}
     * @memberof DeleteWebhook403ResponseAllOf
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface DuplicateDealResponse200
 */
export interface DuplicateDealResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DuplicateDealResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DealStrict}
     * @memberof DuplicateDealResponse200
     */
    'data'?: DealStrict;
}
/**
 *
 * @export
 * @interface FailResponse
 */
export interface FailResponse {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof FailResponse
     */
    'success'?: boolean;
    /**
     * The error message
     * @type {string}
     * @memberof FailResponse
     */
    'error'?: string;
}
/**
 *
 * @export
 * @interface FieldResponse200
 */
export interface FieldResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof FieldResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {FieldsResponse200AllOfDataInner}
     * @memberof FieldResponse200
     */
    'data'?: FieldsResponse200AllOfDataInner;
}
/**
 *
 * @export
 * @interface FieldResponse200AllOf
 */
export interface FieldResponse200AllOf {
    /**
     *
     * @type {FieldsResponse200AllOfDataInner}
     * @memberof FieldResponse200AllOf
     */
    'data'?: FieldsResponse200AllOfDataInner;
}
/**
 *
 * @export
 * @interface FieldsResponse200
 */
export interface FieldsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof FieldsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<FieldsResponse200AllOfDataInner>}
     * @memberof FieldsResponse200
     */
    'data'?: Array<FieldsResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof FieldsResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface FieldsResponse200AllOf
 */
export interface FieldsResponse200AllOf {
    /**
     *
     * @type {Array<FieldsResponse200AllOfDataInner>}
     * @memberof FieldsResponse200AllOf
     */
    'data'?: Array<FieldsResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof FieldsResponse200AllOf
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 * The additional data of the list
 * @export
 * @interface FieldsResponse200AllOfAdditionalData
 */
export interface FieldsResponse200AllOfAdditionalData {
    /**
     * Pagination start
     * @type {number}
     * @memberof FieldsResponse200AllOfAdditionalData
     */
    'start'?: number;
    /**
     * Items shown per page
     * @type {number}
     * @memberof FieldsResponse200AllOfAdditionalData
     */
    'limit'?: number;
    /**
     * If there are more list items in the collection than displayed or not
     * @type {boolean}
     * @memberof FieldsResponse200AllOfAdditionalData
     */
    'more_items_in_collection'?: boolean;
}
/**
 *
 * @export
 * @interface FieldsResponse200AllOfDataInner
 */
export interface FieldsResponse200AllOfDataInner {
    /**
     * The ID of the field. Value is `null` in case of subfields.
     * @type {number}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'id'?: number;
    /**
     * The key of the field. For custom fields this is generated upon creation.
     * @type {string}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'key'?: string;
    /**
     * The name of the field
     * @type {string}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'name'?: string;
    /**
     * The order number of the field
     * @type {number}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'order_nr'?: number;
    /**
     * The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`address`</td><td>Address field (has multiple subfields, autocompleted by Google Maps)</td></tr><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td></tr><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td></tr><tr><td>`double`</td><td>Numeric value</td></tr><tr><td>`enum`</td><td>Options field with a single possible chosen option</td></tr><tr></tr><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td></tr><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td></tr><tr><td>`people`</td><td>Person field (contains a person ID which is stored on the same account)</td></tr><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td></tr><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td></tr><tr><td>`text`</td><td>Long text (up to 65k characters)</td></tr><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td></tr><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td></tr><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td></tr><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td></tr><tr><td>`visible_to`</td><td>System field that keeps item\'s visibility setting</td></tr></table>
     * @type {string}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'field_type'?: FieldsResponse200AllOfDataInnerFieldTypeConst;
    /**
     * The creation time of the field
     * @type {string}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'add_time'?: string;
    /**
     * The update time of the field
     * @type {string}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'update_time'?: string;
    /**
     * The ID of the user who created or most recently updated the field, only applicable for custom fields
     * @type {number}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'last_updated_by_user_id'?: number;
    /**
     * The active flag of the field
     * @type {boolean}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'active_flag'?: boolean;
    /**
     * The edit flag of the field
     * @type {boolean}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'edit_flag'?: boolean;
    /**
     * Not used
     * @type {boolean}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'index_visible_flag'?: boolean;
    /**
     * Not used
     * @type {boolean}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'details_visible_flag'?: boolean;
    /**
     * Not used
     * @type {boolean}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'add_visible_flag'?: boolean;
    /**
     * Not used
     * @type {boolean}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'important_flag'?: boolean;
    /**
     * Whether or not the field of an item can be edited in bulk
     * @type {boolean}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'bulk_edit_allowed'?: boolean;
    /**
     * Whether or not items can be searched by this field
     * @type {boolean}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'searchable_flag'?: boolean;
    /**
     * Whether or not items can be filtered by this field
     * @type {boolean}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'filtering_allowed'?: boolean;
    /**
     * Whether or not items can be sorted by this field
     * @type {boolean}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'sortable_flag'?: boolean;
    /**
     * Whether or not the field is mandatory
     * @type {boolean}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'mandatory_flag'?: boolean;
    /**
     * The options of the field. When there are no options, `null` is returned.
     * @type {Array<object>}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'options'?: Array<object> | null;
    /**
     * The deleted options of the field. Only present when there is at least 1 deleted option.
     * @type {Array<object>}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'options_deleted'?: Array<object>;
    /**
     * Whether or not the field is a subfield of another field. Only present if field is subfield.
     * @type {boolean}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'is_subfield'?: boolean;
    /**
     * The subfields of the field. Only present when the field has subfields.
     * @type {Array<object>}
     * @memberof FieldsResponse200AllOfDataInner
     */
    'subfields'?: Array<object>;
}

export const FieldsResponse200AllOfDataInnerFieldTypeConst = {
    address: 'address',
    date: 'date',
    daterange: 'daterange',
    double: 'double',
    enum: 'enum',
    monetary: 'monetary',
    org: 'org',
    people: 'people',
    phone: 'phone',
    set: 'set',
    text: 'text',
    time: 'time',
    timerange: 'timerange',
    user: 'user',
    varchar: 'varchar',
    varchar_auto: 'varchar_auto',
    visible_to: 'visible_to'
} as const;

export type FieldsResponse200AllOfDataInnerFieldTypeConst = typeof FieldsResponse200AllOfDataInnerFieldTypeConst[keyof typeof FieldsResponse200AllOfDataInnerFieldTypeConst];

/**
 *
 * @export
 * @interface FullProjectObject
 */
export interface FullProjectObject {
    /**
     * The title of the project
     * @type {string}
     * @memberof FullProjectObject
     */
    'title'?: string;
    /**
     * The ID of the board this project is associated with
     * @type {number}
     * @memberof FullProjectObject
     */
    'board_id'?: number;
    /**
     * The ID of the phase this project is associated with
     * @type {number}
     * @memberof FullProjectObject
     */
    'phase_id'?: number;
    /**
     * The description of the project
     * @type {string}
     * @memberof FullProjectObject
     */
    'description'?: string;
    /**
     * The status of the project
     * @type {string}
     * @memberof FullProjectObject
     */
    'status'?: string;
    /**
     * The ID of a project owner
     * @type {number}
     * @memberof FullProjectObject
     */
    'owner_id'?: number;
    /**
     * The start date of the project. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof FullProjectObject
     */
    'start_date'?: string;
    /**
     * The end date of the project. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof FullProjectObject
     */
    'end_date'?: string;
    /**
     * An array of IDs of the deals this project is associated with
     * @type {Array<number>}
     * @memberof FullProjectObject
     */
    'deal_ids'?: Array<number>;
    /**
     * The ID of the organization this project is associated with
     * @type {number}
     * @memberof FullProjectObject
     */
    'org_id'?: number;
    /**
     * The ID of the person this project is associated with
     * @type {number}
     * @memberof FullProjectObject
     */
    'person_id'?: number;
    /**
     * An array of IDs of the labels this project has
     * @type {Array<number>}
     * @memberof FullProjectObject
     */
    'labels'?: Array<number>;
    /**
     * The creation date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof FullProjectObject
     */
    'add_time'?: string;
    /**
     * The update date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof FullProjectObject
     */
    'update_time'?: string;
    /**
     * The status changed date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof FullProjectObject
     */
    'status_change_time'?: string;
    /**
     * The archived date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS. If not archived then \'null\'.
     * @type {string}
     * @memberof FullProjectObject
     */
    'archive_time'?: string;
}
/**
 *
 * @export
 * @interface FullProjectObjectAllOf
 */
export interface FullProjectObjectAllOf {
    /**
     * The title of the project
     * @type {string}
     * @memberof FullProjectObjectAllOf
     */
    'title'?: string;
    /**
     * The ID of the board this project is associated with
     * @type {number}
     * @memberof FullProjectObjectAllOf
     */
    'board_id'?: number;
    /**
     * The ID of the phase this project is associated with
     * @type {number}
     * @memberof FullProjectObjectAllOf
     */
    'phase_id'?: number;
}
/**
 *
 * @export
 * @interface FullProjectObjectAllOf1
 */
export interface FullProjectObjectAllOf1 {
    /**
     * The description of the project
     * @type {string}
     * @memberof FullProjectObjectAllOf1
     */
    'description'?: string;
    /**
     * The status of the project
     * @type {string}
     * @memberof FullProjectObjectAllOf1
     */
    'status'?: string;
    /**
     * The ID of a project owner
     * @type {number}
     * @memberof FullProjectObjectAllOf1
     */
    'owner_id'?: number;
    /**
     * The start date of the project. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof FullProjectObjectAllOf1
     */
    'start_date'?: string;
    /**
     * The end date of the project. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof FullProjectObjectAllOf1
     */
    'end_date'?: string;
    /**
     * An array of IDs of the deals this project is associated with
     * @type {Array<number>}
     * @memberof FullProjectObjectAllOf1
     */
    'deal_ids'?: Array<number>;
    /**
     * The ID of the organization this project is associated with
     * @type {number}
     * @memberof FullProjectObjectAllOf1
     */
    'org_id'?: number;
    /**
     * The ID of the person this project is associated with
     * @type {number}
     * @memberof FullProjectObjectAllOf1
     */
    'person_id'?: number;
    /**
     * An array of IDs of the labels this project has
     * @type {Array<number>}
     * @memberof FullProjectObjectAllOf1
     */
    'labels'?: Array<number>;
}
/**
 *
 * @export
 * @interface FullProjectObjectAllOf2
 */
export interface FullProjectObjectAllOf2 {
    /**
     * The creation date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof FullProjectObjectAllOf2
     */
    'add_time'?: string;
    /**
     * The update date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof FullProjectObjectAllOf2
     */
    'update_time'?: string;
    /**
     * The status changed date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof FullProjectObjectAllOf2
     */
    'status_change_time'?: string;
    /**
     * The archived date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS. If not archived then \'null\'.
     * @type {string}
     * @memberof FullProjectObjectAllOf2
     */
    'archive_time'?: string;
}
/**
 *
 * @export
 * @interface FullRole
 */
export interface FullRole {
    /**
     * The ID of the parent role
     * @type {number}
     * @memberof FullRole
     */
    'parent_role_id'?: number;
    /**
     * The name of the role
     * @type {string}
     * @memberof FullRole
     */
    'name'?: string;
    /**
     * The ID of the role
     * @type {number}
     * @memberof FullRole
     */
    'id'?: number;
    /**
     * Whether the role is active or not
     * @type {boolean}
     * @memberof FullRole
     */
    'active_flag'?: boolean;
    /**
     * The number of users assigned to this role
     * @type {string}
     * @memberof FullRole
     */
    'assignment_count'?: string;
    /**
     * The number of sub-roles
     * @type {string}
     * @memberof FullRole
     */
    'sub_role_count'?: string;
    /**
     * The level of role in the role hierarchy
     * @type {number}
     * @memberof FullRole
     */
    'level'?: number;
}
/**
 *
 * @export
 * @interface FullRoleAllOf
 */
export interface FullRoleAllOf {
    /**
     * The level of role in the role hierarchy
     * @type {number}
     * @memberof FullRoleAllOf
     */
    'level'?: number;
}
/**
 *
 * @export
 * @interface GetActivitiesCollectionResponse200
 */
export interface GetActivitiesCollectionResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetActivitiesCollectionResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<ActivityCollectionResponseObject>}
     * @memberof GetActivitiesCollectionResponse200
     */
    'data'?: Array<ActivityCollectionResponseObject>;
    /**
     *
     * @type {GetActivitiesCollectionResponse200AdditionalData}
     * @memberof GetActivitiesCollectionResponse200
     */
    'additional_data'?: GetActivitiesCollectionResponse200AdditionalData;
}
/**
 * The additional data of the list
 * @export
 * @interface GetActivitiesCollectionResponse200AdditionalData
 */
export interface GetActivitiesCollectionResponse200AdditionalData {
    /**
     * The first item on the next page. The value of the `next_cursor` field will be `null` if you have reached the end of the dataset and there’s no more pages to be returned.
     * @type {string}
     * @memberof GetActivitiesCollectionResponse200AdditionalData
     */
    'next_cursor'?: string;
}
/**
 *
 * @export
 * @interface GetActivitiesResponse200
 */
export interface GetActivitiesResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetActivitiesResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<ActivityResponseObject>}
     * @memberof GetActivitiesResponse200
     */
    'data'?: Array<ActivityResponseObject>;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof GetActivitiesResponse200
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjects}
     * @memberof GetActivitiesResponse200
     */
    'related_objects'?: GetActivitiesResponse200RelatedObjects;
}
/**
 *
 * @export
 * @interface GetActivitiesResponse200AdditionalData
 */
export interface GetActivitiesResponse200AdditionalData {
    /**
     *
     * @type {GetActivitiesResponse200AdditionalDataPagination}
     * @memberof GetActivitiesResponse200AdditionalData
     */
    'pagination'?: GetActivitiesResponse200AdditionalDataPagination;
}
/**
 * Pagination details of the list
 * @export
 * @interface GetActivitiesResponse200AdditionalDataPagination
 */
export interface GetActivitiesResponse200AdditionalDataPagination {
    /**
     * Pagination start
     * @type {number}
     * @memberof GetActivitiesResponse200AdditionalDataPagination
     */
    'start'?: number;
    /**
     * Items shown per page
     * @type {number}
     * @memberof GetActivitiesResponse200AdditionalDataPagination
     */
    'limit'?: number;
    /**
     * Whether there are more list items in the collection than displayed
     * @type {boolean}
     * @memberof GetActivitiesResponse200AdditionalDataPagination
     */
    'more_items_in_collection'?: boolean;
    /**
     * Next pagination start
     * @type {number}
     * @memberof GetActivitiesResponse200AdditionalDataPagination
     */
    'next_start'?: number;
}
/**
 *
 * @export
 * @interface GetActivitiesResponse200RelatedObjects
 */
export interface GetActivitiesResponse200RelatedObjects {
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsUser}
     * @memberof GetActivitiesResponse200RelatedObjects
     */
    'user'?: GetActivitiesResponse200RelatedObjectsUser;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsDeal}
     * @memberof GetActivitiesResponse200RelatedObjects
     */
    'deal'?: GetActivitiesResponse200RelatedObjectsDeal;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsPerson}
     * @memberof GetActivitiesResponse200RelatedObjects
     */
    'person'?: GetActivitiesResponse200RelatedObjectsPerson;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsOrganization}
     * @memberof GetActivitiesResponse200RelatedObjects
     */
    'organization'?: GetActivitiesResponse200RelatedObjectsOrganization;
}
/**
 *
 * @export
 * @interface GetActivitiesResponse200RelatedObjectsDeal
 */
export interface GetActivitiesResponse200RelatedObjectsDeal {
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsDealDEALID}
     * @memberof GetActivitiesResponse200RelatedObjectsDeal
     */
    'DEAL_ID'?: GetActivitiesResponse200RelatedObjectsDealDEALID;
}
/**
 * The ID of the deal which is associated with the item
 * @export
 * @interface GetActivitiesResponse200RelatedObjectsDealDEALID
 */
export interface GetActivitiesResponse200RelatedObjectsDealDEALID {
    /**
     * The ID of the deal associated with the item
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsDealDEALID
     */
    'id'?: number;
    /**
     * The title of the deal associated with the item
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsDealDEALID
     */
    'title'?: string;
    /**
     * The status of the deal associated with the item
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsDealDEALID
     */
    'status'?: string;
    /**
     * The value of the deal that is associated with the item
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsDealDEALID
     */
    'value'?: number;
    /**
     * The currency of the deal value
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsDealDEALID
     */
    'currency'?: string;
    /**
     * The ID of the stage the deal is currently at
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsDealDEALID
     */
    'stage_id'?: number;
    /**
     * The ID of the pipeline the deal is in
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsDealDEALID
     */
    'pipeline_id'?: number;
}
/**
 *
 * @export
 * @interface GetActivitiesResponse200RelatedObjectsOrganization
 */
export interface GetActivitiesResponse200RelatedObjectsOrganization {
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONID}
     * @memberof GetActivitiesResponse200RelatedObjectsOrganization
     */
    'ORGANIZATION_ID'?: GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONID;
}
/**
 * The ID of the organization associated with the item
 * @export
 * @interface GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONID
 */
export interface GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONID {
    /**
     * The ID of the organization associated with the item
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONID
     */
    'id'?: number;
    /**
     * The name of the organization associated with the item
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONID
     */
    'name'?: string;
    /**
     * The number of people connected with the organization that is associated with the item
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONID
     */
    'people_count'?: number;
    /**
     * The ID of the owner of the organization that is associated with the item
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONID
     */
    'owner_id'?: number;
    /**
     * The address of the organization
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONID
     */
    'address'?: string;
    /**
     * The BCC email of the organization associated with the item
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONID
     */
    'cc_email'?: string;
}
/**
 *
 * @export
 * @interface GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONIDAllOf
 */
export interface GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONIDAllOf {
    /**
     * The ID of the organization associated with the item
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONIDAllOf
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONIDAllOf1
 */
export interface GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONIDAllOf1 {
    /**
     * The name of the organization associated with the item
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONIDAllOf1
     */
    'name'?: string;
    /**
     * The number of people connected with the organization that is associated with the item
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONIDAllOf1
     */
    'people_count'?: number;
    /**
     * The ID of the owner of the organization that is associated with the item
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONIDAllOf1
     */
    'owner_id'?: number;
    /**
     * The address of the organization
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONIDAllOf1
     */
    'address'?: string;
    /**
     * The BCC email of the organization associated with the item
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsOrganizationORGANIZATIONIDAllOf1
     */
    'cc_email'?: string;
}
/**
 *
 * @export
 * @interface GetActivitiesResponse200RelatedObjectsPerson
 */
export interface GetActivitiesResponse200RelatedObjectsPerson {
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsPersonPERSONID}
     * @memberof GetActivitiesResponse200RelatedObjectsPerson
     */
    'PERSON_ID'?: GetActivitiesResponse200RelatedObjectsPersonPERSONID;
}
/**
 * The ID of the person associated with the item
 * @export
 * @interface GetActivitiesResponse200RelatedObjectsPersonPERSONID
 */
export interface GetActivitiesResponse200RelatedObjectsPersonPERSONID {
    /**
     * The ID of the person associated with the item
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONID
     */
    'id'?: number;
    /**
     * The name of the person associated with the item
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONID
     */
    'name'?: string;
    /**
     * The emails of the person associated with the item
     * @type {Array<GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfEmailInner>}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONID
     */
    'email'?: Array<GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfEmailInner>;
    /**
     * The phone numbers of the person associated with the item
     * @type {Array<GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfPhoneInner>}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONID
     */
    'phone'?: Array<GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfPhoneInner>;
    /**
     * The ID of the owner of the person that is associated with the item
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONID
     */
    'owner_id'?: number;
}
/**
 *
 * @export
 * @interface GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOf
 */
export interface GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOf {
    /**
     * The ID of the person associated with the item
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOf
     */
    'id'?: number;
    /**
     * The name of the person associated with the item
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOf
     */
    'name'?: string;
    /**
     * The emails of the person associated with the item
     * @type {Array<GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfEmailInner>}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOf
     */
    'email'?: Array<GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfEmailInner>;
    /**
     * The phone numbers of the person associated with the item
     * @type {Array<GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfPhoneInner>}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOf
     */
    'phone'?: Array<GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfPhoneInner>;
    /**
     * The ID of the owner of the person that is associated with the item
     * @type {number}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOf
     */
    'owner_id'?: number;
}
/**
 *
 * @export
 * @interface GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfEmailInner
 */
export interface GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfEmailInner {
    /**
     * The type of the email
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfEmailInner
     */
    'label'?: string;
    /**
     * The email of the associated person
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfEmailInner
     */
    'value'?: string;
    /**
     * Whether this is the primary email or not
     * @type {boolean}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfEmailInner
     */
    'primary'?: boolean;
}
/**
 *
 * @export
 * @interface GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfPhoneInner
 */
export interface GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfPhoneInner {
    /**
     * The type of the phone number
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfPhoneInner
     */
    'label'?: string;
    /**
     * The phone number of the person associated with the item
     * @type {string}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfPhoneInner
     */
    'value'?: string;
    /**
     * Whether this is the primary phone number or not
     * @type {boolean}
     * @memberof GetActivitiesResponse200RelatedObjectsPersonPERSONIDAllOfPhoneInner
     */
    'primary'?: boolean;
}
/**
 *
 * @export
 * @interface GetActivitiesResponse200RelatedObjectsUser
 */
export interface GetActivitiesResponse200RelatedObjectsUser {
    /**
     *
     * @type {UserDataWithId}
     * @memberof GetActivitiesResponse200RelatedObjectsUser
     */
    'USER_ID'?: UserDataWithId;
}
/**
 *
 * @export
 * @interface GetActivityResponse200
 */
export interface GetActivityResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetActivityResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {ActivityResponseObject}
     * @memberof GetActivityResponse200
     */
    'data'?: ActivityResponseObject;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjects}
     * @memberof GetActivityResponse200
     */
    'related_objects'?: GetActivitiesResponse200RelatedObjects;
}
/**
 *
 * @export
 * @interface GetActivityTypesResponse200
 */
export interface GetActivityTypesResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetActivityTypesResponse200
     */
    'success'?: boolean;
    /**
     * The array of activity types
     * @type {Array<GetActivityTypesResponse200AllOfDataInner>}
     * @memberof GetActivityTypesResponse200
     */
    'data'?: Array<GetActivityTypesResponse200AllOfDataInner>;
}
/**
 *
 * @export
 * @interface GetActivityTypesResponse200AllOf
 */
export interface GetActivityTypesResponse200AllOf {
    /**
     * The array of activity types
     * @type {Array<GetActivityTypesResponse200AllOfDataInner>}
     * @memberof GetActivityTypesResponse200AllOf
     */
    'data'?: Array<GetActivityTypesResponse200AllOfDataInner>;
}
/**
 *
 * @export
 * @interface GetActivityTypesResponse200AllOfDataInner
 */
export interface GetActivityTypesResponse200AllOfDataInner {
    /**
     * The ID of the activity type
     * @type {number}
     * @memberof GetActivityTypesResponse200AllOfDataInner
     */
    'id'?: number;
    /**
     * The name of the activity type
     * @type {string}
     * @memberof GetActivityTypesResponse200AllOfDataInner
     */
    'name'?: string;
    /**
     * Icon graphic to use for representing this activity type
     * @type {string}
     * @memberof GetActivityTypesResponse200AllOfDataInner
     */
    'icon_key'?: GetActivityTypesResponse200AllOfDataInnerIconKeyConst;
    /**
     * A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
     * @type {string}
     * @memberof GetActivityTypesResponse200AllOfDataInner
     */
    'color'?: string;
    /**
     * An order number for the activity type. Order numbers should be used to order the types in the activity type selections.
     * @type {number}
     * @memberof GetActivityTypesResponse200AllOfDataInner
     */
    'order_nr'?: number;
    /**
     * A string that is generated by the API based on the given name of the activity type upon creation
     * @type {string}
     * @memberof GetActivityTypesResponse200AllOfDataInner
     */
    'key_string'?: string;
    /**
     * The active flag of the activity type
     * @type {boolean}
     * @memberof GetActivityTypesResponse200AllOfDataInner
     */
    'active_flag'?: boolean;
    /**
     * Whether the activity type is a custom one or not
     * @type {boolean}
     * @memberof GetActivityTypesResponse200AllOfDataInner
     */
    'is_custom_flag'?: boolean;
    /**
     * The creation time of the activity type
     * @type {string}
     * @memberof GetActivityTypesResponse200AllOfDataInner
     */
    'add_time'?: string;
    /**
     * The update time of the activity type
     * @type {string}
     * @memberof GetActivityTypesResponse200AllOfDataInner
     */
    'update_time'?: string;
}

export const GetActivityTypesResponse200AllOfDataInnerIconKeyConst = {
    task: 'task',
    email: 'email',
    meeting: 'meeting',
    deadline: 'deadline',
    call: 'call',
    lunch: 'lunch',
    calendar: 'calendar',
    downarrow: 'downarrow',
    document: 'document',
    smartphone: 'smartphone',
    camera: 'camera',
    scissors: 'scissors',
    cogs: 'cogs',
    bubble: 'bubble',
    uparrow: 'uparrow',
    checkbox: 'checkbox',
    signpost: 'signpost',
    shuffle: 'shuffle',
    addressbook: 'addressbook',
    linegraph: 'linegraph',
    picture: 'picture',
    car: 'car',
    world: 'world',
    search: 'search',
    clip: 'clip',
    sound: 'sound',
    brush: 'brush',
    key: 'key',
    padlock: 'padlock',
    pricetag: 'pricetag',
    suitcase: 'suitcase',
    finish: 'finish',
    plane: 'plane',
    loop: 'loop',
    wifi: 'wifi',
    truck: 'truck',
    cart: 'cart',
    bulb: 'bulb',
    bell: 'bell',
    presentation: 'presentation'
} as const;

export type GetActivityTypesResponse200AllOfDataInnerIconKeyConst = typeof GetActivityTypesResponse200AllOfDataInnerIconKeyConst[keyof typeof GetActivityTypesResponse200AllOfDataInnerIconKeyConst];

/**
 *
 * @export
 * @interface GetAddProductAttachementResponse200
 */
export interface GetAddProductAttachementResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetAddProductAttachementResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetAddProductAttachementResponse200Data}
     * @memberof GetAddProductAttachementResponse200
     */
    'data'?: GetAddProductAttachementResponse200Data;
}
/**
 * The added product object attached to the deal
 * @export
 * @interface GetAddProductAttachementResponse200Data
 */
export interface GetAddProductAttachementResponse200Data {
    /**
     * The ID of the product
     * @type {number}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'product_id': number;
    /**
     * The price at which this product will be added to the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'item_price': number;
    /**
     * Quantity – e.g. how many items of this product will be added to the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'quantity': number;
    /**
     * The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage.
     * @type {number}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'discount'?: number;
    /**
     * The type of the discount\'s value.
     * @type {string}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'discount_type'?: GetAddProductAttachementResponse200DataDiscountTypeConst;
    /**
     * The duration of the product. If omitted, will be set to 1.
     * @type {number}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'duration'?: number;
    /**
     * The type of the duration. (For example hourly, daily, etc.)
     * @type {string}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'duration_unit'?: string;
    /**
     * The ID of the product variation to use. When omitted, no variation will be used.
     * @type {number}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'product_variation_id'?: number | null;
    /**
     * A textual comment associated with this product-deal attachment
     * @type {string}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'comments'?: string;
    /**
     * The product tax
     * @type {number}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'tax'?: number;
    /**
     * The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal.
     * @type {string}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'tax_method'?: GetAddProductAttachementResponse200DataTaxMethodConst;
    /**
     * Whether the product is enabled for a deal or not. This makes it possible to add products to a deal with a specific price and discount criteria, but keep them disabled, which refrains them from being included in the deal value calculation. When omitted, the product will be marked as enabled by default.
     * @type {boolean}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'enabled_flag'?: boolean;
    /**
     * The ID of the deal-product (the ID of the product attached to the deal)
     * @type {number}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'id'?: number;
    /**
     * The ID of the company
     * @type {number}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'company_id'?: number;
    /**
     * The ID of the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'deal_id'?: number;
    /**
     * The sum of all the products attached to the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'sum'?: number;
    /**
     * The currency associated with the deal product
     * @type {string}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'currency'?: string;
    /**
     * The date and time when the product was added to the deal
     * @type {string}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'add_time'?: string;
    /**
     * The date and time when the deal product was last edited
     * @type {string}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'last_edit'?: string;
    /**
     * Whether the product is active or not
     * @type {boolean}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'active_flag'?: boolean;
    /**
     * The product name
     * @type {string}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'name'?: string;
    /**
     * The ID of the deal-product (the ID of the product attached to the deal)
     * @type {number}
     * @memberof GetAddProductAttachementResponse200Data
     */
    'product_attachment_id'?: number;
}

export const GetAddProductAttachementResponse200DataDiscountTypeConst = {
    percentage: 'percentage',
    amount: 'amount'
} as const;

export type GetAddProductAttachementResponse200DataDiscountTypeConst = typeof GetAddProductAttachementResponse200DataDiscountTypeConst[keyof typeof GetAddProductAttachementResponse200DataDiscountTypeConst];
export const GetAddProductAttachementResponse200DataTaxMethodConst = {
    exclusive: 'exclusive',
    inclusive: 'inclusive',
    none: 'none'
} as const;

export type GetAddProductAttachementResponse200DataTaxMethodConst = typeof GetAddProductAttachementResponse200DataTaxMethodConst[keyof typeof GetAddProductAttachementResponse200DataTaxMethodConst];

/**
 *
 * @export
 * @interface GetAddProductAttachementResponse200DataAllOf
 */
export interface GetAddProductAttachementResponse200DataAllOf {
    /**
     * The ID of the product
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'product_id': number;
    /**
     * The price at which this product will be added to the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'item_price': number;
    /**
     * Quantity – e.g. how many items of this product will be added to the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'quantity': number;
    /**
     * The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage.
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'discount'?: number;
    /**
     * The type of the discount\'s value.
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'discount_type'?: GetAddProductAttachementResponse200DataAllOfDiscountTypeConst;
    /**
     * The duration of the product. If omitted, will be set to 1.
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'duration'?: number;
    /**
     * The type of the duration. (For example hourly, daily, etc.)
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'duration_unit'?: string;
    /**
     * The ID of the product variation to use. When omitted, no variation will be used.
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'product_variation_id'?: number | null;
    /**
     * A textual comment associated with this product-deal attachment
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'comments'?: string;
    /**
     * The product tax
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'tax'?: number;
    /**
     * The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal.
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'tax_method'?: GetAddProductAttachementResponse200DataAllOfTaxMethodConst;
    /**
     * Whether the product is enabled for a deal or not. This makes it possible to add products to a deal with a specific price and discount criteria, but keep them disabled, which refrains them from being included in the deal value calculation. When omitted, the product will be marked as enabled by default.
     * @type {boolean}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'enabled_flag'?: boolean;
    /**
     * The ID of the deal-product (the ID of the product attached to the deal)
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'id'?: number;
    /**
     * The ID of the company
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'company_id'?: number;
    /**
     * The ID of the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'deal_id'?: number;
    /**
     * The sum of all the products attached to the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'sum'?: number;
    /**
     * The currency associated with the deal product
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'currency'?: string;
    /**
     * The date and time when the product was added to the deal
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'add_time'?: string;
    /**
     * The date and time when the deal product was last edited
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'last_edit'?: string;
    /**
     * Whether the product is active or not
     * @type {boolean}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'active_flag'?: boolean;
    /**
     * The product name
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'name'?: string;
    /**
     * The ID of the deal-product (the ID of the product attached to the deal)
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOf
     */
    'product_attachment_id'?: number;
}

export const GetAddProductAttachementResponse200DataAllOfDiscountTypeConst = {
    percentage: 'percentage',
    amount: 'amount'
} as const;

export type GetAddProductAttachementResponse200DataAllOfDiscountTypeConst = typeof GetAddProductAttachementResponse200DataAllOfDiscountTypeConst[keyof typeof GetAddProductAttachementResponse200DataAllOfDiscountTypeConst];
export const GetAddProductAttachementResponse200DataAllOfTaxMethodConst = {
    exclusive: 'exclusive',
    inclusive: 'inclusive',
    none: 'none'
} as const;

export type GetAddProductAttachementResponse200DataAllOfTaxMethodConst = typeof GetAddProductAttachementResponse200DataAllOfTaxMethodConst[keyof typeof GetAddProductAttachementResponse200DataAllOfTaxMethodConst];

/**
 *
 * @export
 * @interface GetAddProductAttachementResponse200DataAllOfAllOf
 */
export interface GetAddProductAttachementResponse200DataAllOfAllOf {
    /**
     * The ID of the product
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'product_id': number;
    /**
     * The price at which this product will be added to the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'item_price': number;
    /**
     * Quantity – e.g. how many items of this product will be added to the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'quantity': number;
    /**
     * The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage.
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'discount'?: number;
    /**
     * The type of the discount\'s value.
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'discount_type'?: GetAddProductAttachementResponse200DataAllOfAllOfDiscountTypeConst;
    /**
     * The duration of the product. If omitted, will be set to 1.
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'duration'?: number;
    /**
     * The type of the duration. (For example hourly, daily, etc.)
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'duration_unit'?: string;
    /**
     * The ID of the product variation to use. When omitted, no variation will be used.
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'product_variation_id'?: number | null;
    /**
     * A textual comment associated with this product-deal attachment
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'comments'?: string;
    /**
     * The product tax
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'tax'?: number;
    /**
     * The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal.
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'tax_method'?: GetAddProductAttachementResponse200DataAllOfAllOfTaxMethodConst;
    /**
     * Whether the product is enabled for a deal or not. This makes it possible to add products to a deal with a specific price and discount criteria, but keep them disabled, which refrains them from being included in the deal value calculation. When omitted, the product will be marked as enabled by default.
     * @type {boolean}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'enabled_flag'?: boolean;
    /**
     * The ID of the deal-product (the ID of the product attached to the deal)
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'id'?: number;
    /**
     * The ID of the company
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'company_id'?: number;
    /**
     * The ID of the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'deal_id'?: number;
    /**
     * The sum of all the products attached to the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'sum'?: number;
    /**
     * The currency associated with the deal product
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'currency'?: string;
    /**
     * The date and time when the product was added to the deal
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'add_time'?: string;
    /**
     * The date and time when the deal product was last edited
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'last_edit'?: string;
    /**
     * Whether the product is active or not
     * @type {boolean}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'active_flag'?: boolean;
    /**
     * The product name
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf
     */
    'name'?: string;
}

export const GetAddProductAttachementResponse200DataAllOfAllOfDiscountTypeConst = {
    percentage: 'percentage',
    amount: 'amount'
} as const;

export type GetAddProductAttachementResponse200DataAllOfAllOfDiscountTypeConst = typeof GetAddProductAttachementResponse200DataAllOfAllOfDiscountTypeConst[keyof typeof GetAddProductAttachementResponse200DataAllOfAllOfDiscountTypeConst];
export const GetAddProductAttachementResponse200DataAllOfAllOfTaxMethodConst = {
    exclusive: 'exclusive',
    inclusive: 'inclusive',
    none: 'none'
} as const;

export type GetAddProductAttachementResponse200DataAllOfAllOfTaxMethodConst = typeof GetAddProductAttachementResponse200DataAllOfAllOfTaxMethodConst[keyof typeof GetAddProductAttachementResponse200DataAllOfAllOfTaxMethodConst];

/**
 *
 * @export
 * @interface GetAddProductAttachementResponse200DataAllOfAllOf1
 */
export interface GetAddProductAttachementResponse200DataAllOfAllOf1 {
    /**
     * The ID of the deal-product (the ID of the product attached to the deal)
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOf1
     */
    'product_attachment_id'?: number;
}
/**
 *
 * @export
 * @interface GetAddProductAttachementResponse200DataAllOfAllOfAllOf
 */
export interface GetAddProductAttachementResponse200DataAllOfAllOfAllOf {
    /**
     * The ID of the deal-product (the ID of the product attached to the deal)
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOfAllOf
     */
    'id'?: number;
    /**
     * The ID of the company
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOfAllOf
     */
    'company_id'?: number;
    /**
     * The ID of the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOfAllOf
     */
    'deal_id'?: number;
    /**
     * The ID of the product
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOfAllOf
     */
    'product_id'?: number;
    /**
     * The type of the duration. (For example hourly, daily, etc.)
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOfAllOf
     */
    'duration_unit'?: string;
    /**
     * The sum of all the products attached to the deal
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOfAllOf
     */
    'sum'?: number;
    /**
     * The currency associated with the deal product
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOfAllOf
     */
    'currency'?: string;
    /**
     * The date and time when the product was added to the deal
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOfAllOf
     */
    'add_time'?: string;
    /**
     * The date and time when the deal product was last edited
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOfAllOf
     */
    'last_edit'?: string;
    /**
     * Whether the product is active or not
     * @type {boolean}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOfAllOf
     */
    'active_flag'?: boolean;
    /**
     * The product tax
     * @type {number}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOfAllOf
     */
    'tax'?: number;
    /**
     * The product name
     * @type {string}
     * @memberof GetAddProductAttachementResponse200DataAllOfAllOfAllOf
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface GetAllMailMessagesOfMailThreadResponse200
 */
export interface GetAllMailMessagesOfMailThreadResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetAllMailMessagesOfMailThreadResponse200
     */
    'success'?: boolean;
    /**
     * The array of the mail messages of the mail thread
     * @type {Array<GetAllMailMessagesOfMailThreadResponse200AllOfDataInner>}
     * @memberof GetAllMailMessagesOfMailThreadResponse200
     */
    'data'?: Array<GetAllMailMessagesOfMailThreadResponse200AllOfDataInner>;
}
/**
 *
 * @export
 * @interface GetAllMailMessagesOfMailThreadResponse200AllOf
 */
export interface GetAllMailMessagesOfMailThreadResponse200AllOf {
    /**
     * The array of the mail messages of the mail thread
     * @type {Array<GetAllMailMessagesOfMailThreadResponse200AllOfDataInner>}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOf
     */
    'data'?: Array<GetAllMailMessagesOfMailThreadResponse200AllOfDataInner>;
}
/**
 *
 * @export
 * @interface GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
 */
export interface GetAllMailMessagesOfMailThreadResponse200AllOfDataInner {
    /**
     * ID of the mail thread
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'id'?: number;
    /**
     * The connection account ID
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'account_id'?: string;
    /**
     * ID of the user whom mail message will be assigned to
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'user_id'?: number;
    /**
     * The subject
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'subject'?: string;
    /**
     * A snippet
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'snippet'?: string;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'read_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerReadFlagConst;
    /**
     * Mail tracking status
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'mail_tracking_status'?: string | null;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'has_attachments_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'has_inline_attachments_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasInlineAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'has_real_attachments_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasRealAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'deleted_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerDeletedFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'synced_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSyncedFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'smart_bcc_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSmartBccFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'mail_link_tracking_enabled_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerMailLinkTrackingEnabledFlagConst;
    /**
     * Senders of the mail thread
     * @type {Array<BaseMailThreadAllOf1PartiesToInner>}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'from'?: Array<BaseMailThreadAllOf1PartiesToInner>;
    /**
     * Recipients of the mail thread
     * @type {Array<BaseMailThreadAllOf1PartiesToInner>}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'to'?: Array<BaseMailThreadAllOf1PartiesToInner>;
    /**
     * Participants of the Cc
     * @type {Array<BaseMailThreadAllOf1PartiesToInner>}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'cc'?: Array<BaseMailThreadAllOf1PartiesToInner>;
    /**
     * Participants of the Bcc
     * @type {Array<BaseMailThreadAllOf1PartiesToInner>}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'bcc'?: Array<BaseMailThreadAllOf1PartiesToInner>;
    /**
     * A link to the mail thread message
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'body_url'?: string;
    /**
     * ID of the mail thread
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'mail_thread_id'?: number;
    /**
     * If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'draft'?: string | null;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'has_body_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasBodyFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'sent_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSentFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'sent_from_pipedrive_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSentFromPipedriveFlagConst;
    /**
     * The time when the mail message was received or created
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'message_time'?: string;
    /**
     * The time when the mail message was inserted to database
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'add_time'?: string;
    /**
     * The time when the mail message was updated in database received
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInner
     */
    'update_time'?: string;
}

export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerReadFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerReadFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerReadFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerReadFlagConst];
export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasAttachmentsFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasAttachmentsFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasAttachmentsFlagConst];
export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasInlineAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasInlineAttachmentsFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasInlineAttachmentsFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasInlineAttachmentsFlagConst];
export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasRealAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasRealAttachmentsFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasRealAttachmentsFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasRealAttachmentsFlagConst];
export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerDeletedFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerDeletedFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerDeletedFlagConst];
export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSyncedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSyncedFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSyncedFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSyncedFlagConst];
export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSmartBccFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSmartBccFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSmartBccFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSmartBccFlagConst];
export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerMailLinkTrackingEnabledFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerMailLinkTrackingEnabledFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerMailLinkTrackingEnabledFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerMailLinkTrackingEnabledFlagConst];
export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasBodyFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasBodyFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasBodyFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerHasBodyFlagConst];
export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSentFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSentFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSentFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSentFlagConst];
export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSentFromPipedriveFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSentFromPipedriveFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSentFromPipedriveFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerSentFromPipedriveFlagConst];

/**
 *
 * @export
 * @interface GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
 */
export interface GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf {
    /**
     * Senders of the mail thread
     * @type {Array<BaseMailThreadAllOf1PartiesToInner>}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
     */
    'from'?: Array<BaseMailThreadAllOf1PartiesToInner>;
    /**
     * Recipients of the mail thread
     * @type {Array<BaseMailThreadAllOf1PartiesToInner>}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
     */
    'to'?: Array<BaseMailThreadAllOf1PartiesToInner>;
    /**
     * Participants of the Cc
     * @type {Array<BaseMailThreadAllOf1PartiesToInner>}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
     */
    'cc'?: Array<BaseMailThreadAllOf1PartiesToInner>;
    /**
     * Participants of the Bcc
     * @type {Array<BaseMailThreadAllOf1PartiesToInner>}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
     */
    'bcc'?: Array<BaseMailThreadAllOf1PartiesToInner>;
    /**
     * A link to the mail thread message
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
     */
    'body_url'?: string;
    /**
     * ID of the mail thread
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
     */
    'mail_thread_id'?: number;
    /**
     * If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
     */
    'draft'?: string | null;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
     */
    'has_body_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfHasBodyFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
     */
    'sent_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfSentFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
     */
    'sent_from_pipedrive_flag'?: GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfSentFromPipedriveFlagConst;
    /**
     * The time when the mail message was received or created
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
     */
    'message_time'?: string;
    /**
     * The time when the mail message was inserted to database
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
     */
    'add_time'?: string;
    /**
     * The time when the mail message was updated in database received
     * @type {string}
     * @memberof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOf
     */
    'update_time'?: string;
}

export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfHasBodyFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfHasBodyFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfHasBodyFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfHasBodyFlagConst];
export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfSentFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfSentFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfSentFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfSentFlagConst];
export const GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfSentFromPipedriveFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfSentFromPipedriveFlagConst = typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfSentFromPipedriveFlagConst[keyof typeof GetAllMailMessagesOfMailThreadResponse200AllOfDataInnerAllOfSentFromPipedriveFlagConst];

/**
 *
 * @export
 * @interface GetAssociatedActivitiesResponse200
 */
export interface GetAssociatedActivitiesResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetAssociatedActivitiesResponse200
     */
    'success'?: boolean;
    /**
     * The array of activities
     * @type {Array<ActivityResponseObject>}
     * @memberof GetAssociatedActivitiesResponse200
     */
    'data'?: Array<ActivityResponseObject>;
    /**
     *
     * @type {ActivityDistributionDataWithAdditionalData}
     * @memberof GetAssociatedActivitiesResponse200
     */
    'additional_data'?: ActivityDistributionDataWithAdditionalData;
}
/**
 *
 * @export
 * @interface GetAssociatedActivitiesResponse200AllOf
 */
export interface GetAssociatedActivitiesResponse200AllOf {
    /**
     * The array of activities
     * @type {Array<ActivityResponseObject>}
     * @memberof GetAssociatedActivitiesResponse200AllOf
     */
    'data'?: Array<ActivityResponseObject>;
    /**
     *
     * @type {ActivityDistributionDataWithAdditionalData}
     * @memberof GetAssociatedActivitiesResponse200AllOf
     */
    'additional_data'?: ActivityDistributionDataWithAdditionalData;
}
/**
 *
 * @export
 * @interface GetAssociatedDealsResponse200
 */
export interface GetAssociatedDealsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetAssociatedDealsResponse200
     */
    'success'?: boolean;
    /**
     * The array of deals
     * @type {Array<DealNonStrict>}
     * @memberof GetAssociatedDealsResponse200
     */
    'data'?: Array<DealNonStrict>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedDealsResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetAssociatedDealsResponse200AllOfRelatedObjects}
     * @memberof GetAssociatedDealsResponse200
     */
    'related_objects'?: GetAssociatedDealsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetAssociatedDealsResponse200AllOf
 */
export interface GetAssociatedDealsResponse200AllOf {
    /**
     * The array of deals
     * @type {Array<DealNonStrict>}
     * @memberof GetAssociatedDealsResponse200AllOf
     */
    'data'?: Array<DealNonStrict>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedDealsResponse200AllOf
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetAssociatedDealsResponse200AllOfRelatedObjects}
     * @memberof GetAssociatedDealsResponse200AllOf
     */
    'related_objects'?: GetAssociatedDealsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetAssociatedDealsResponse200AllOfRelatedObjects
 */
export interface GetAssociatedDealsResponse200AllOfRelatedObjects {
    /**
     *
     * @type {AddActivityResponse200RelatedObjectsOrganization}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjects
     */
    'organization'?: AddActivityResponse200RelatedObjectsOrganization;
    /**
     *
     * @type {AddActivityResponse200RelatedObjectsPerson}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjects
     */
    'person'?: AddActivityResponse200RelatedObjectsPerson;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsUser}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjects
     */
    'user'?: GetActivitiesResponse200RelatedObjectsUser;
    /**
     *
     * @type {GetAssociatedDealsResponse200AllOfRelatedObjectsStage}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjects
     */
    'stage'?: GetAssociatedDealsResponse200AllOfRelatedObjectsStage;
    /**
     *
     * @type {GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjects
     */
    'pipeline'?: GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline;
}
/**
 *
 * @export
 * @interface GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline
 */
export interface GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline {
    /**
     * The ID of the pipeline
     * @type {number}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline
     */
    'id'?: number;
    /**
     * The name of the pipeline
     * @type {string}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline
     */
    'name'?: string;
    /**
     * The pipeline title displayed in the URL
     * @type {string}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline
     */
    'url_title'?: string;
    /**
     * Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
     * @type {number}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline
     */
    'order_nr'?: number;
    /**
     * Whether this pipeline will be made inactive (hidden) or active
     * @type {boolean}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline
     */
    'active'?: boolean;
    /**
     * Whether deal probability is disabled or enabled for this pipeline
     * @type {boolean}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline
     */
    'deal_probability'?: boolean;
    /**
     * The pipeline creation time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline
     */
    'add_time'?: string;
    /**
     * The pipeline update time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline
     */
    'update_time'?: string;
}
/**
 *
 * @export
 * @interface GetAssociatedDealsResponse200AllOfRelatedObjectsStage
 */
export interface GetAssociatedDealsResponse200AllOfRelatedObjectsStage {
    /**
     * The ID of the stage
     * @type {number}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsStage
     */
    'id'?: number;
    /**
     * Defines the order of the stage
     * @type {number}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsStage
     */
    'order_nr'?: number;
    /**
     * The name of the stage
     * @type {string}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsStage
     */
    'name'?: string;
    /**
     * Whether the stage is active or deleted
     * @type {boolean}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsStage
     */
    'active_flag'?: boolean;
    /**
     * The success probability percentage of the deal. Used/shown when the deal weighted values are used.
     * @type {number}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsStage
     */
    'deal_probability'?: number;
    /**
     * The ID of the pipeline to add the stage to
     * @type {number}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsStage
     */
    'pipeline_id'?: number;
    /**
     * Whether deals in this stage can become rotten
     * @type {boolean}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsStage
     */
    'rotten_flag'?: boolean;
    /**
     * The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
     * @type {number}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsStage
     */
    'rotten_days'?: number;
    /**
     * The stage creation time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsStage
     */
    'add_time'?: string;
    /**
     * The stage update time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof GetAssociatedDealsResponse200AllOfRelatedObjectsStage
     */
    'update_time'?: string;
}
/**
 *
 * @export
 * @interface GetAssociatedFilesResponse200
 */
export interface GetAssociatedFilesResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetAssociatedFilesResponse200
     */
    'success'?: boolean;
    /**
     * The array of files
     * @type {Array<GetAssociatedFilesResponse200AllOfDataInner>}
     * @memberof GetAssociatedFilesResponse200
     */
    'data'?: Array<GetAssociatedFilesResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedFilesResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetAssociatedFilesResponse2001
 */
export interface GetAssociatedFilesResponse2001 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetAssociatedFilesResponse2001
     */
    'success'?: boolean;
    /**
     * The array of files
     * @type {Array<GetAssociatedFilesResponse2001AllOfDataInner>}
     * @memberof GetAssociatedFilesResponse2001
     */
    'data'?: Array<GetAssociatedFilesResponse2001AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedFilesResponse2001
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetAssociatedFilesResponse2001AllOf
 */
export interface GetAssociatedFilesResponse2001AllOf {
    /**
     * The array of files
     * @type {Array<GetAssociatedFilesResponse2001AllOfDataInner>}
     * @memberof GetAssociatedFilesResponse2001AllOf
     */
    'data'?: Array<GetAssociatedFilesResponse2001AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedFilesResponse2001AllOf
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 * The file data
 * @export
 * @interface GetAssociatedFilesResponse2001AllOfDataInner
 */
export interface GetAssociatedFilesResponse2001AllOfDataInner {
    /**
     * The ID of the file
     * @type {number}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'id'?: number;
    /**
     * The ID of the product associated with the file
     * @type {number}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'product_id'?: number;
    /**
     * The UTC date time when the file was uploaded. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'add_time'?: string;
    /**
     * The UTC date time when the file was last updated. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'update_time'?: string;
    /**
     * The original name of the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'file_name'?: string;
    /**
     * The size of the file in bytes
     * @type {number}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'file_size'?: number;
    /**
     * Whether the user is active or not.
     * @type {boolean}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'active_flag'?: boolean;
    /**
     * Whether the file was uploaded as inline or not
     * @type {boolean}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'inline_flag'?: boolean;
    /**
     * The location type to send the file to. Only googledrive is supported at the moment.
     * @type {string}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'remote_location'?: string;
    /**
     * The ID of the remote item
     * @type {string}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'remote_id'?: string;
    /**
     * The location of the cloud storage
     * @type {string}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    's3_bucket'?: string;
    /**
     * The name of the product associated with the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'product_name'?: string;
    /**
     * The URL to download the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'url'?: string;
    /**
     * The visible name of the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'name'?: string;
    /**
     * The description of the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse2001AllOfDataInner
     */
    'description'?: string;
}
/**
 *
 * @export
 * @interface GetAssociatedFilesResponse200AllOf
 */
export interface GetAssociatedFilesResponse200AllOf {
    /**
     * The array of files
     * @type {Array<GetAssociatedFilesResponse200AllOfDataInner>}
     * @memberof GetAssociatedFilesResponse200AllOf
     */
    'data'?: Array<GetAssociatedFilesResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedFilesResponse200AllOf
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 * The file data
 * @export
 * @interface GetAssociatedFilesResponse200AllOfDataInner
 */
export interface GetAssociatedFilesResponse200AllOfDataInner {
    /**
     * The ID of the file
     * @type {number}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'id'?: number;
    /**
     * The ID of the user to associate the file with
     * @type {number}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'user_id'?: number;
    /**
     * The ID of the deal to associate the file with
     * @type {number}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'deal_id'?: number;
    /**
     * The ID of the person to associate the file with
     * @type {number}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'person_id'?: number;
    /**
     * The ID of the organization to associate the file with
     * @type {number}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'org_id'?: number;
    /**
     * The ID of the product to associate the file with
     * @type {number}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'product_id'?: number;
    /**
     * The ID of the activity to associate the file with
     * @type {number}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'activity_id'?: number;
    /**
     * The ID of the lead to associate the file with
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'lead_id'?: string;
    /**
     * The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'update_time'?: string;
    /**
     * The original name of the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'file_name'?: string;
    /**
     * The size of the file
     * @type {number}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'file_size'?: number;
    /**
     * Whether the user is active or not. false = Not activated, true = Activated
     * @type {boolean}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'active_flag'?: boolean;
    /**
     * Whether the file was uploaded as inline or not
     * @type {boolean}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'inline_flag'?: boolean;
    /**
     * The location type to send the file to. Only googledrive is supported at the moment.
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'remote_location'?: string;
    /**
     * The ID of the remote item
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'remote_id'?: string;
    /**
     * The ID of the inline attachment
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'cid'?: string;
    /**
     * The location of the cloud storage
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    's3_bucket'?: string;
    /**
     * The ID of the mail message to associate the file with
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'mail_message_id'?: string;
    /**
     * The ID of the mail template to associate the file with
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'mail_template_id'?: string;
    /**
     * The name of the deal associated with the dile
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'deal_name'?: string;
    /**
     * The name of the person associated with the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'person_name'?: string;
    /**
     * The name of the organization associated with the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'org_name'?: string;
    /**
     * The name of the product associated with the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'product_name'?: string;
    /**
     * The name of the lead associated with the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'lead_name'?: string;
    /**
     * The URL of the download file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'url'?: string;
    /**
     * The visible name of the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'name'?: string;
    /**
     * The description of the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200AllOfDataInner
     */
    'description'?: string;
}
/**
 *
 * @export
 * @interface GetAssociatedFollowersResponse200
 */
export interface GetAssociatedFollowersResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetAssociatedFollowersResponse200
     */
    'success'?: boolean;
    /**
     * The list of followers
     * @type {Array<GetAssociatedFollowersResponse200AllOfDataInner>}
     * @memberof GetAssociatedFollowersResponse200
     */
    'data'?: Array<GetAssociatedFollowersResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedFollowersResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetAssociatedFollowersResponse2001
 */
export interface GetAssociatedFollowersResponse2001 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetAssociatedFollowersResponse2001
     */
    'success'?: boolean;
    /**
     * The array of followers
     * @type {Array<GetAssociatedFollowersResponse2001DataInner>}
     * @memberof GetAssociatedFollowersResponse2001
     */
    'data'?: Array<GetAssociatedFollowersResponse2001DataInner>;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof GetAssociatedFollowersResponse2001
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface GetAssociatedFollowersResponse2001DataInner
 */
export interface GetAssociatedFollowersResponse2001DataInner {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof GetAssociatedFollowersResponse2001DataInner
     */
    'org_id'?: number;
    /**
     * The user ID of the follower related to the item
     * @type {number}
     * @memberof GetAssociatedFollowersResponse2001DataInner
     */
    'user_id'?: number;
    /**
     * The ID of the follower
     * @type {number}
     * @memberof GetAssociatedFollowersResponse2001DataInner
     */
    'id'?: number;
    /**
     * The date and time of adding the follower to the item
     * @type {string}
     * @memberof GetAssociatedFollowersResponse2001DataInner
     */
    'add_time'?: string;
}
/**
 *
 * @export
 * @interface GetAssociatedFollowersResponse2001DataInnerAllOf
 */
export interface GetAssociatedFollowersResponse2001DataInnerAllOf {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof GetAssociatedFollowersResponse2001DataInnerAllOf
     */
    'org_id'?: number;
}
/**
 *
 * @export
 * @interface GetAssociatedFollowersResponse2001DataInnerAllOf1
 */
export interface GetAssociatedFollowersResponse2001DataInnerAllOf1 {
    /**
     * The user ID of the follower related to the item
     * @type {number}
     * @memberof GetAssociatedFollowersResponse2001DataInnerAllOf1
     */
    'user_id'?: number;
    /**
     * The ID of the follower
     * @type {number}
     * @memberof GetAssociatedFollowersResponse2001DataInnerAllOf1
     */
    'id'?: number;
    /**
     * The date and time of adding the follower to the item
     * @type {string}
     * @memberof GetAssociatedFollowersResponse2001DataInnerAllOf1
     */
    'add_time'?: string;
}
/**
 *
 * @export
 * @interface GetAssociatedFollowersResponse200AllOf
 */
export interface GetAssociatedFollowersResponse200AllOf {
    /**
     * The list of followers
     * @type {Array<GetAssociatedFollowersResponse200AllOfDataInner>}
     * @memberof GetAssociatedFollowersResponse200AllOf
     */
    'data'?: Array<GetAssociatedFollowersResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedFollowersResponse200AllOf
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetAssociatedFollowersResponse200AllOfDataInner
 */
export interface GetAssociatedFollowersResponse200AllOfDataInner {
    /**
     * The ID of the user
     * @type {number}
     * @memberof GetAssociatedFollowersResponse200AllOfDataInner
     */
    'user_id'?: number;
    /**
     * The ID of the user follower
     * @type {number}
     * @memberof GetAssociatedFollowersResponse200AllOfDataInner
     */
    'id'?: number;
    /**
     * The ID of the deal which the follower was added to
     * @type {number}
     * @memberof GetAssociatedFollowersResponse200AllOfDataInner
     */
    'deal_id'?: number;
    /**
     * The date and time when the follower was added to the person
     * @type {string}
     * @memberof GetAssociatedFollowersResponse200AllOfDataInner
     */
    'add_time'?: string;
}
/**
 *
 * @export
 * @interface GetAssociatedMailMessagesResponse200
 */
export interface GetAssociatedMailMessagesResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetAssociatedMailMessagesResponse200
     */
    'success'?: boolean;
    /**
     * The array of mail messages
     * @type {Array<GetAssociatedMailMessagesResponse200AllOfDataInner>}
     * @memberof GetAssociatedMailMessagesResponse200
     */
    'data'?: Array<GetAssociatedMailMessagesResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedMailMessagesResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetAssociatedMailMessagesResponse200AllOf
 */
export interface GetAssociatedMailMessagesResponse200AllOf {
    /**
     * The array of mail messages
     * @type {Array<GetAssociatedMailMessagesResponse200AllOfDataInner>}
     * @memberof GetAssociatedMailMessagesResponse200AllOf
     */
    'data'?: Array<GetAssociatedMailMessagesResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedMailMessagesResponse200AllOf
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetAssociatedMailMessagesResponse200AllOfDataInner
 */
export interface GetAssociatedMailMessagesResponse200AllOfDataInner {
    /**
     * The type of the data item
     * @type {string}
     * @memberof GetAssociatedMailMessagesResponse200AllOfDataInner
     */
    'object'?: string;
    /**
     * The date and time when the item was created
     * @type {string}
     * @memberof GetAssociatedMailMessagesResponse200AllOfDataInner
     */
    'timestamp'?: string;
    /**
     *
     * @type {MailMessageItemForList}
     * @memberof GetAssociatedMailMessagesResponse200AllOfDataInner
     */
    'data'?: MailMessageItemForList;
}
/**
 *
 * @export
 * @interface GetAssociatedPersonUpdatesResponse200
 */
export interface GetAssociatedPersonUpdatesResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetAssociatedPersonUpdatesResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<GetAssociatedPersonUpdatesResponse200AllOfDataInner>}
     * @memberof GetAssociatedPersonUpdatesResponse200
     */
    'data'?: Array<GetAssociatedPersonUpdatesResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedPersonUpdatesResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetDealUpdatesResponse200AllOfRelatedObjects}
     * @memberof GetAssociatedPersonUpdatesResponse200
     */
    'related_objects'?: GetDealUpdatesResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetAssociatedPersonUpdatesResponse200AllOf
 */
export interface GetAssociatedPersonUpdatesResponse200AllOf {
    /**
     *
     * @type {Array<GetAssociatedPersonUpdatesResponse200AllOfDataInner>}
     * @memberof GetAssociatedPersonUpdatesResponse200AllOf
     */
    'data'?: Array<GetAssociatedPersonUpdatesResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedPersonUpdatesResponse200AllOf
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetDealUpdatesResponse200AllOfRelatedObjects}
     * @memberof GetAssociatedPersonUpdatesResponse200AllOf
     */
    'related_objects'?: GetDealUpdatesResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetAssociatedPersonUpdatesResponse200AllOfDataInner
 */
export interface GetAssociatedPersonUpdatesResponse200AllOfDataInner {
    /**
     * The type of the person update. (Possible object types - personChange, note, activity, file)
     * @type {string}
     * @memberof GetAssociatedPersonUpdatesResponse200AllOfDataInner
     */
    'object'?: string;
    /**
     * The creation date and time of the update
     * @type {string}
     * @memberof GetAssociatedPersonUpdatesResponse200AllOfDataInner
     */
    'timestamp'?: string;
    /**
     * The data related to the update
     * @type {object}
     * @memberof GetAssociatedPersonUpdatesResponse200AllOfDataInner
     */
    'data'?: object;
}
/**
 *
 * @export
 * @interface GetAssociatedUpdatesResponse200
 */
export interface GetAssociatedUpdatesResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetAssociatedUpdatesResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<GetAssociatedUpdatesResponse200AllOfDataInner>}
     * @memberof GetAssociatedUpdatesResponse200
     */
    'data'?: Array<GetAssociatedUpdatesResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedUpdatesResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetAssociatedUpdatesResponse200AllOfRelatedObjects}
     * @memberof GetAssociatedUpdatesResponse200
     */
    'related_objects'?: GetAssociatedUpdatesResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetAssociatedUpdatesResponse200AllOf
 */
export interface GetAssociatedUpdatesResponse200AllOf {
    /**
     *
     * @type {Array<GetAssociatedUpdatesResponse200AllOfDataInner>}
     * @memberof GetAssociatedUpdatesResponse200AllOf
     */
    'data'?: Array<GetAssociatedUpdatesResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetAssociatedUpdatesResponse200AllOf
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetAssociatedUpdatesResponse200AllOfRelatedObjects}
     * @memberof GetAssociatedUpdatesResponse200AllOf
     */
    'related_objects'?: GetAssociatedUpdatesResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetAssociatedUpdatesResponse200AllOfDataInner
 */
export interface GetAssociatedUpdatesResponse200AllOfDataInner {
    /**
     * The type of the person update. (Possible object types - organizationChange, dealChange, file, activity)
     * @type {string}
     * @memberof GetAssociatedUpdatesResponse200AllOfDataInner
     */
    'object'?: string;
    /**
     * The creation date and time of the update
     * @type {string}
     * @memberof GetAssociatedUpdatesResponse200AllOfDataInner
     */
    'timestamp'?: string;
    /**
     * The data related to the update
     * @type {object}
     * @memberof GetAssociatedUpdatesResponse200AllOfDataInner
     */
    'data'?: object;
}
/**
 *
 * @export
 * @interface GetAssociatedUpdatesResponse200AllOfRelatedObjects
 */
export interface GetAssociatedUpdatesResponse200AllOfRelatedObjects {
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsOrganization}
     * @memberof GetAssociatedUpdatesResponse200AllOfRelatedObjects
     */
    'organization'?: GetActivitiesResponse200RelatedObjectsOrganization;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsUser}
     * @memberof GetAssociatedUpdatesResponse200AllOfRelatedObjects
     */
    'user'?: GetActivitiesResponse200RelatedObjectsUser;
}
/**
 *
 * @export
 * @interface GetCommentsResponse200
 */
export interface GetCommentsResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetCommentsResponse200
     */
    'success'?: boolean;
    /**
     * The array of comments
     * @type {Array<GetCommentsResponse200DataInner>}
     * @memberof GetCommentsResponse200
     */
    'data'?: Array<GetCommentsResponse200DataInner>;
    /**
     *
     * @type {GetNotesResponse200AdditionalData}
     * @memberof GetCommentsResponse200
     */
    'additional_data'?: GetNotesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface GetCommentsResponse200DataInner
 */
export interface GetCommentsResponse200DataInner {
    /**
     * The ID of the note
     * @type {string}
     * @memberof GetCommentsResponse200DataInner
     */
    'uuid'?: string;
    /**
     * Whether the note is active or deleted
     * @type {boolean}
     * @memberof GetCommentsResponse200DataInner
     */
    'active_flag'?: boolean;
    /**
     * The creation date and time of the note
     * @type {string}
     * @memberof GetCommentsResponse200DataInner
     */
    'add_time'?: string;
    /**
     * The creation date and time of the note
     * @type {string}
     * @memberof GetCommentsResponse200DataInner
     */
    'update_time'?: string;
    /**
     * The content of the note in HTML format. Subject to sanitization on the back-end.
     * @type {string}
     * @memberof GetCommentsResponse200DataInner
     */
    'content'?: string;
    /**
     * The ID of the object that the comment is attached to, will be the id of the note
     * @type {string}
     * @memberof GetCommentsResponse200DataInner
     */
    'object_id'?: string;
    /**
     * The type of object that the comment is attached to, will be \"note\"
     * @type {string}
     * @memberof GetCommentsResponse200DataInner
     */
    'object_type'?: string;
    /**
     * The ID of the user who created the comment
     * @type {number}
     * @memberof GetCommentsResponse200DataInner
     */
    'user_id'?: number;
    /**
     * The ID of the user who last updated the comment
     * @type {number}
     * @memberof GetCommentsResponse200DataInner
     */
    'updater_id'?: number;
    /**
     * The ID of the company
     * @type {number}
     * @memberof GetCommentsResponse200DataInner
     */
    'company_id'?: number;
}
/**
 *
 * @export
 * @interface GetCurrenciesResponse200
 */
export interface GetCurrenciesResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetCurrenciesResponse200
     */
    'success'?: boolean;
    /**
     * The array of currencies
     * @type {Array<GetCurrenciesResponse200DataInner>}
     * @memberof GetCurrenciesResponse200
     */
    'data'?: Array<GetCurrenciesResponse200DataInner>;
}
/**
 *
 * @export
 * @interface GetCurrenciesResponse200DataInner
 */
export interface GetCurrenciesResponse200DataInner {
    /**
     * The ID of the currency
     * @type {number}
     * @memberof GetCurrenciesResponse200DataInner
     */
    'id'?: number;
    /**
     * The code of the currency
     * @type {string}
     * @memberof GetCurrenciesResponse200DataInner
     */
    'code'?: string;
    /**
     * The name of the currency
     * @type {string}
     * @memberof GetCurrenciesResponse200DataInner
     */
    'name'?: string;
    /**
     * The amount of decimal points of the currency
     * @type {number}
     * @memberof GetCurrenciesResponse200DataInner
     */
    'decimal_points'?: number;
    /**
     * The symbol of the currency
     * @type {string}
     * @memberof GetCurrenciesResponse200DataInner
     */
    'symbol'?: string;
    /**
     * Whether the currency is active or not
     * @type {boolean}
     * @memberof GetCurrenciesResponse200DataInner
     */
    'active_flag'?: boolean;
    /**
     * Whether the currency is a custom one or not
     * @type {boolean}
     * @memberof GetCurrenciesResponse200DataInner
     */
    'is_custom_flag'?: boolean;
}
/**
 *
 * @export
 * @interface GetCurrentUserResponse200
 */
export interface GetCurrentUserResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetCurrentUserResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetCurrentUserResponse200AllOfData}
     * @memberof GetCurrentUserResponse200
     */
    'data'?: GetCurrentUserResponse200AllOfData;
}
/**
 *
 * @export
 * @interface GetCurrentUserResponse200AllOf
 */
export interface GetCurrentUserResponse200AllOf {
    /**
     *
     * @type {GetCurrentUserResponse200AllOfData}
     * @memberof GetCurrentUserResponse200AllOf
     */
    'data'?: GetCurrentUserResponse200AllOfData;
}
/**
 *
 * @export
 * @interface GetCurrentUserResponse200AllOfData
 */
export interface GetCurrentUserResponse200AllOfData {
    /**
     * The user ID
     * @type {number}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'id'?: number;
    /**
     * The user name
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'name'?: string;
    /**
     * The user default currency
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'default_currency'?: string;
    /**
     * The user locale
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'locale'?: string;
    /**
     * The user language ID
     * @type {number}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'lang'?: number;
    /**
     * The user email
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'email'?: string;
    /**
     * The user phone
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'phone'?: string | null;
    /**
     * Boolean that indicates whether the user is activated
     * @type {boolean}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'activated'?: boolean;
    /**
     * The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'last_login'?: string;
    /**
     * The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'created'?: string;
    /**
     * The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'modified'?: string | null;
    /**
     * Boolean that indicates whether the user has created a company
     * @type {boolean}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'has_created_company'?: boolean;
    /**
     *
     * @type {Array<GetRecentsResponse200DataInnerAnyOf11DataAccessInner>}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'access'?: Array<GetRecentsResponse200DataInnerAnyOf11DataAccessInner>;
    /**
     * Boolean that indicates whether the user is activated
     * @type {boolean}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'active_flag'?: boolean;
    /**
     * The user timezone name
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'timezone_name'?: string;
    /**
     * The user timezone offset
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'timezone_offset'?: string;
    /**
     * The ID of the user role
     * @type {number}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'role_id'?: number;
    /**
     * The user icon URL
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'icon_url'?: string | null;
    /**
     * Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
     * @type {boolean}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'is_you'?: boolean;
    /**
     * The user company ID
     * @type {number}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'company_id'?: number;
    /**
     * The user company name
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'company_name'?: string;
    /**
     * The user company domain
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'company_domain'?: string;
    /**
     * The user company country
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'company_country'?: string;
    /**
     * The user company industry
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'company_industry'?: string;
    /**
     *
     * @type {GetCurrentUserResponse200AllOfDataAllOfLanguage}
     * @memberof GetCurrentUserResponse200AllOfData
     */
    'language'?: GetCurrentUserResponse200AllOfDataAllOfLanguage;
}
/**
 *
 * @export
 * @interface GetCurrentUserResponse200AllOfDataAllOf
 */
export interface GetCurrentUserResponse200AllOfDataAllOf {
    /**
     * The user company ID
     * @type {number}
     * @memberof GetCurrentUserResponse200AllOfDataAllOf
     */
    'company_id'?: number;
    /**
     * The user company name
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfDataAllOf
     */
    'company_name'?: string;
    /**
     * The user company domain
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfDataAllOf
     */
    'company_domain'?: string;
    /**
     * The user company country
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfDataAllOf
     */
    'company_country'?: string;
    /**
     * The user company industry
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfDataAllOf
     */
    'company_industry'?: string;
    /**
     *
     * @type {GetCurrentUserResponse200AllOfDataAllOfLanguage}
     * @memberof GetCurrentUserResponse200AllOfDataAllOf
     */
    'language'?: GetCurrentUserResponse200AllOfDataAllOfLanguage;
}
/**
 * The user language details
 * @export
 * @interface GetCurrentUserResponse200AllOfDataAllOfLanguage
 */
export interface GetCurrentUserResponse200AllOfDataAllOfLanguage {
    /**
     * The language code. E.g. en
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfDataAllOfLanguage
     */
    'language_code'?: string;
    /**
     * The country code. E.g. US
     * @type {string}
     * @memberof GetCurrentUserResponse200AllOfDataAllOfLanguage
     */
    'country_code'?: string;
}
/**
 *
 * @export
 * @interface GetDealActivitiesResponse200
 */
export interface GetDealActivitiesResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetDealActivitiesResponse200
     */
    'success'?: boolean;
    /**
     * The array of activities
     * @type {Array<ActivityResponseObject>}
     * @memberof GetDealActivitiesResponse200
     */
    'data'?: Array<ActivityResponseObject>;
    /**
     *
     * @type {ActivityDistributionDataWithAdditionalData}
     * @memberof GetDealActivitiesResponse200
     */
    'additional_data'?: ActivityDistributionDataWithAdditionalData;
    /**
     *
     * @type {GetDealActivitiesResponse200AllOfRelatedObjects}
     * @memberof GetDealActivitiesResponse200
     */
    'related_objects'?: GetDealActivitiesResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetDealActivitiesResponse200AllOf
 */
export interface GetDealActivitiesResponse200AllOf {
    /**
     * The array of activities
     * @type {Array<ActivityResponseObject>}
     * @memberof GetDealActivitiesResponse200AllOf
     */
    'data'?: Array<ActivityResponseObject>;
    /**
     *
     * @type {ActivityDistributionDataWithAdditionalData}
     * @memberof GetDealActivitiesResponse200AllOf
     */
    'additional_data'?: ActivityDistributionDataWithAdditionalData;
    /**
     *
     * @type {GetDealActivitiesResponse200AllOfRelatedObjects}
     * @memberof GetDealActivitiesResponse200AllOf
     */
    'related_objects'?: GetDealActivitiesResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetDealActivitiesResponse200AllOfRelatedObjects
 */
export interface GetDealActivitiesResponse200AllOfRelatedObjects {
    /**
     *
     * @type {AddActivityResponse200RelatedObjectsOrganization}
     * @memberof GetDealActivitiesResponse200AllOfRelatedObjects
     */
    'organization'?: AddActivityResponse200RelatedObjectsOrganization;
    /**
     *
     * @type {AddActivityResponse200RelatedObjectsPerson}
     * @memberof GetDealActivitiesResponse200AllOfRelatedObjects
     */
    'person'?: AddActivityResponse200RelatedObjectsPerson;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsDeal}
     * @memberof GetDealActivitiesResponse200AllOfRelatedObjects
     */
    'deal'?: GetActivitiesResponse200RelatedObjectsDeal;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsUser}
     * @memberof GetDealActivitiesResponse200AllOfRelatedObjects
     */
    'user'?: GetActivitiesResponse200RelatedObjectsUser;
}
/**
 *
 * @export
 * @interface GetDealParticipantsResponse200
 */
export interface GetDealParticipantsResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetDealParticipantsResponse200
     */
    'success'?: boolean;
    /**
     * The array of participants
     * @type {Array<PersonItem>}
     * @memberof GetDealParticipantsResponse200
     */
    'data'?: Array<PersonItem>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetDealParticipantsResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetDealsResponse200RelatedObjects}
     * @memberof GetDealParticipantsResponse200
     */
    'related_objects'?: GetDealsResponse200RelatedObjects;
}
/**
 *
 * @export
 * @interface GetDealResponse200
 */
export interface GetDealResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetDealResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {DealNonStrictWithDetails}
     * @memberof GetDealResponse200
     */
    'data'?: DealNonStrictWithDetails;
    /**
     *
     * @type {GetDealResponse200AdditionalData}
     * @memberof GetDealResponse200
     */
    'additional_data'?: GetDealResponse200AdditionalData;
    /**
     *
     * @type {GetDealsResponse200RelatedObjects}
     * @memberof GetDealResponse200
     */
    'related_objects'?: GetDealsResponse200RelatedObjects;
}
/**
 *
 * @export
 * @interface GetDealResponse200AdditionalData
 */
export interface GetDealResponse200AdditionalData {
    /**
     * The BCC email of the deal
     * @type {string}
     * @memberof GetDealResponse200AdditionalData
     */
    'dropbox_email'?: string;
}
/**
 *
 * @export
 * @interface GetDealUpdatesResponse200
 */
export interface GetDealUpdatesResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetDealUpdatesResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<GetDealUpdatesResponse200AllOfDataInner>}
     * @memberof GetDealUpdatesResponse200
     */
    'data'?: Array<GetDealUpdatesResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetDealUpdatesResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetDealUpdatesResponse200AllOfRelatedObjects}
     * @memberof GetDealUpdatesResponse200
     */
    'related_objects'?: GetDealUpdatesResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetDealUpdatesResponse200AllOf
 */
export interface GetDealUpdatesResponse200AllOf {
    /**
     *
     * @type {Array<GetDealUpdatesResponse200AllOfDataInner>}
     * @memberof GetDealUpdatesResponse200AllOf
     */
    'data'?: Array<GetDealUpdatesResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetDealUpdatesResponse200AllOf
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetDealUpdatesResponse200AllOfRelatedObjects}
     * @memberof GetDealUpdatesResponse200AllOf
     */
    'related_objects'?: GetDealUpdatesResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetDealUpdatesResponse200AllOfDataInner
 */
export interface GetDealUpdatesResponse200AllOfDataInner {
    /**
     * The type of the deal update. (Possible object types - dealChange, note, activity, mailMessage, invoice, document, file)
     * @type {string}
     * @memberof GetDealUpdatesResponse200AllOfDataInner
     */
    'object'?: string;
    /**
     * The creation date and time of the update
     * @type {string}
     * @memberof GetDealUpdatesResponse200AllOfDataInner
     */
    'timestamp'?: string;
    /**
     * The data related to the update
     * @type {object}
     * @memberof GetDealUpdatesResponse200AllOfDataInner
     */
    'data'?: object;
}
/**
 *
 * @export
 * @interface GetDealUpdatesResponse200AllOfRelatedObjects
 */
export interface GetDealUpdatesResponse200AllOfRelatedObjects {
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsDeal}
     * @memberof GetDealUpdatesResponse200AllOfRelatedObjects
     */
    'deal'?: GetActivitiesResponse200RelatedObjectsDeal;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsOrganization}
     * @memberof GetDealUpdatesResponse200AllOfRelatedObjects
     */
    'organization'?: GetActivitiesResponse200RelatedObjectsOrganization;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsUser}
     * @memberof GetDealUpdatesResponse200AllOfRelatedObjects
     */
    'user'?: GetActivitiesResponse200RelatedObjectsUser;
    /**
     *
     * @type {AddActivityResponse200RelatedObjectsPerson}
     * @memberof GetDealUpdatesResponse200AllOfRelatedObjects
     */
    'person'?: AddActivityResponse200RelatedObjectsPerson;
}
/**
 *
 * @export
 * @interface GetDealsCollectionResponse200
 */
export interface GetDealsCollectionResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetDealsCollectionResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<DealCollectionResponseObject>}
     * @memberof GetDealsCollectionResponse200
     */
    'data'?: Array<DealCollectionResponseObject>;
    /**
     *
     * @type {GetActivitiesCollectionResponse200AdditionalData}
     * @memberof GetDealsCollectionResponse200
     */
    'additional_data'?: GetActivitiesCollectionResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface GetDealsResponse200
 */
export interface GetDealsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetDealsResponse200
     */
    'success'?: boolean;
    /**
     * The array of deals
     * @type {Array<DealNonStrict>}
     * @memberof GetDealsResponse200
     */
    'data'?: Array<DealNonStrict>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetDealsResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetDealsResponse200RelatedObjects}
     * @memberof GetDealsResponse200
     */
    'related_objects'?: GetDealsResponse200RelatedObjects;
}
/**
 *
 * @export
 * @interface GetDealsResponse200RelatedObjects
 */
export interface GetDealsResponse200RelatedObjects {
    /**
     *
     * @type {DealUserDataWithIdAllOf}
     * @memberof GetDealsResponse200RelatedObjects
     */
    'user'?: DealUserDataWithIdAllOf;
    /**
     *
     * @type {DealOrganizationDataWithIdAllOf}
     * @memberof GetDealsResponse200RelatedObjects
     */
    'organization'?: DealOrganizationDataWithIdAllOf;
    /**
     *
     * @type {DealPersonDataWithIdAllOf}
     * @memberof GetDealsResponse200RelatedObjects
     */
    'person'?: DealPersonDataWithIdAllOf;
}
/**
 *
 * @export
 * @interface GetDealsSummaryResponse200
 */
export interface GetDealsSummaryResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetDealsSummaryResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetDealsSummaryResponse200Data}
     * @memberof GetDealsSummaryResponse200
     */
    'data'?: GetDealsSummaryResponse200Data;
}
/**
 * The summary of deals
 * @export
 * @interface GetDealsSummaryResponse200Data
 */
export interface GetDealsSummaryResponse200Data {
    /**
     *
     * @type {GetDealsSummaryResponse200DataValuesTotal}
     * @memberof GetDealsSummaryResponse200Data
     */
    'values_total'?: GetDealsSummaryResponse200DataValuesTotal;
    /**
     *
     * @type {GetDealsSummaryResponse200DataWeightedValuesTotal}
     * @memberof GetDealsSummaryResponse200Data
     */
    'weighted_values_total'?: GetDealsSummaryResponse200DataWeightedValuesTotal;
    /**
     * The total number of deals
     * @type {number}
     * @memberof GetDealsSummaryResponse200Data
     */
    'total_count'?: number;
    /**
     * The total value of deals converted into the company default currency
     * @type {number}
     * @memberof GetDealsSummaryResponse200Data
     */
    'total_currency_converted_value'?: number;
    /**
     * The total weighted value of deals converted into the company default currency
     * @type {number}
     * @memberof GetDealsSummaryResponse200Data
     */
    'total_weighted_currency_converted_value'?: number;
    /**
     * The total converted value of deals formatted with the company default currency. E.g. US$5,100.96
     * @type {string}
     * @memberof GetDealsSummaryResponse200Data
     */
    'total_currency_converted_value_formatted'?: string;
    /**
     * The total weighted value of deals formatted with the company default currency. E.g. US$5,100.96
     * @type {string}
     * @memberof GetDealsSummaryResponse200Data
     */
    'total_weighted_currency_converted_value_formatted'?: string;
}
/**
 * The total values of the deals grouped by deal currency
 * @export
 * @interface GetDealsSummaryResponse200DataValuesTotal
 */
export interface GetDealsSummaryResponse200DataValuesTotal {
    /**
     * The total value of deals in the deal currency group
     * @type {number}
     * @memberof GetDealsSummaryResponse200DataValuesTotal
     */
    'value'?: number;
    /**
     * The number of deals in the deal currency group
     * @type {number}
     * @memberof GetDealsSummaryResponse200DataValuesTotal
     */
    'count'?: number;
    /**
     * The total value of deals converted into the company default currency
     * @type {number}
     * @memberof GetDealsSummaryResponse200DataValuesTotal
     */
    'value_converted'?: number;
    /**
     * The total value of deals formatted with deal currency. E.g. €50
     * @type {string}
     * @memberof GetDealsSummaryResponse200DataValuesTotal
     */
    'value_formatted'?: string;
    /**
     * The value_converted formatted with deal currency. E.g. US$50.10
     * @type {string}
     * @memberof GetDealsSummaryResponse200DataValuesTotal
     */
    'value_converted_formatted'?: string;
}
/**
 * The total weighted values of the deals grouped by deal currency. The weighted value is calculated as probability times deal value.
 * @export
 * @interface GetDealsSummaryResponse200DataWeightedValuesTotal
 */
export interface GetDealsSummaryResponse200DataWeightedValuesTotal {
    /**
     * The total weighted value of the deals in the deal currency group
     * @type {number}
     * @memberof GetDealsSummaryResponse200DataWeightedValuesTotal
     */
    'value'?: number;
    /**
     * The number of deals in the deal currency group
     * @type {number}
     * @memberof GetDealsSummaryResponse200DataWeightedValuesTotal
     */
    'count'?: number;
    /**
     * The total weighted value of the deals formatted with deal currency. E.g. €50
     * @type {string}
     * @memberof GetDealsSummaryResponse200DataWeightedValuesTotal
     */
    'value_formatted'?: string;
}
/**
 *
 * @export
 * @interface GetDealsTimelineResponse200
 */
export interface GetDealsTimelineResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetDealsTimelineResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetDealsTimelineResponse200Data}
     * @memberof GetDealsTimelineResponse200
     */
    'data'?: GetDealsTimelineResponse200Data;
}
/**
 * Open and won deals grouped into periods by defined interval, amount and date-type dealField (`field_key`)
 * @export
 * @interface GetDealsTimelineResponse200Data
 */
export interface GetDealsTimelineResponse200Data {
    /**
     * The start date and time of the period
     * @type {string}
     * @memberof GetDealsTimelineResponse200Data
     */
    'period_start'?: string;
    /**
     * The end date and time of the period
     * @type {string}
     * @memberof GetDealsTimelineResponse200Data
     */
    'period_end'?: string;
    /**
     *
     * @type {Array<DealStrict>}
     * @memberof GetDealsTimelineResponse200Data
     */
    'deals'?: Array<DealStrict>;
    /**
     *
     * @type {GetDealsTimelineResponse200DataTotals}
     * @memberof GetDealsTimelineResponse200Data
     */
    'totals'?: GetDealsTimelineResponse200DataTotals;
}
/**
 * The total values of deals for the given period
 * @export
 * @interface GetDealsTimelineResponse200DataTotals
 */
export interface GetDealsTimelineResponse200DataTotals {
    /**
     * The number of deals for the given period
     * @type {number}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    'count'?: number;
    /**
     * The total values of deals grouped by deal currency
     * @type {object}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    'values'?: object;
    /**
     * The total weighted values of deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value.
     * @type {object}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    'weighted_values'?: object;
    /**
     * The number of open deals for the given period
     * @type {number}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    'open_count'?: number;
    /**
     * The total values of open deals for the given period grouped by deal currency
     * @type {object}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    'open_values'?: object;
    /**
     * The total weighted values of open deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value.
     * @type {object}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    'weighted_open_values'?: object;
    /**
     * The number of won deals for the given period
     * @type {number}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    'won_count'?: number;
    /**
     * The total values of won deals for the given period grouped by deal currency
     * @type {object}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    'won_values'?: object;
}
/**
 *
 * @export
 * @interface GetFileResponse200
 */
export interface GetFileResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetFileResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetFilesResponse200DataInner}
     * @memberof GetFileResponse200
     */
    'data'?: GetFilesResponse200DataInner;
}
/**
 *
 * @export
 * @interface GetFilesResponse200
 */
export interface GetFilesResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetFilesResponse200
     */
    'success'?: boolean;
    /**
     * The array of all uploaded files
     * @type {Array<GetFilesResponse200DataInner>}
     * @memberof GetFilesResponse200
     */
    'data'?: Array<GetFilesResponse200DataInner>;
    /**
     *
     * @type {GetFilesResponse200AdditionalData}
     * @memberof GetFilesResponse200
     */
    'additional_data'?: GetFilesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface GetFilesResponse200AdditionalData
 */
export interface GetFilesResponse200AdditionalData {
    /**
     *
     * @type {PaginationDetails}
     * @memberof GetFilesResponse200AdditionalData
     */
    'pagination'?: PaginationDetails;
}
/**
 * The file data
 * @export
 * @interface GetFilesResponse200DataInner
 */
export interface GetFilesResponse200DataInner {
    /**
     * The ID of the file
     * @type {number}
     * @memberof GetFilesResponse200DataInner
     */
    'id'?: number;
    /**
     * The ID of the user to associate the file with
     * @type {number}
     * @memberof GetFilesResponse200DataInner
     */
    'user_id'?: number;
    /**
     * The ID of the deal to associate the file with
     * @type {number}
     * @memberof GetFilesResponse200DataInner
     */
    'deal_id'?: number;
    /**
     * The ID of the person to associate the file with
     * @type {number}
     * @memberof GetFilesResponse200DataInner
     */
    'person_id'?: number;
    /**
     * The ID of the organization to associate the file with
     * @type {number}
     * @memberof GetFilesResponse200DataInner
     */
    'org_id'?: number;
    /**
     * The ID of the product to associate the file with
     * @type {number}
     * @memberof GetFilesResponse200DataInner
     */
    'product_id'?: number;
    /**
     * The ID of the activity to associate the file with
     * @type {number}
     * @memberof GetFilesResponse200DataInner
     */
    'activity_id'?: number;
    /**
     * The ID of the lead to associate the file with
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'lead_id'?: string;
    /**
     * The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'update_time'?: string;
    /**
     * The original name of the file
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'file_name'?: string;
    /**
     * The size of the file
     * @type {number}
     * @memberof GetFilesResponse200DataInner
     */
    'file_size'?: number;
    /**
     * Whether the user is active or not. false = Not activated, true = Activated
     * @type {boolean}
     * @memberof GetFilesResponse200DataInner
     */
    'active_flag'?: boolean;
    /**
     * Whether the file was uploaded as inline or not
     * @type {boolean}
     * @memberof GetFilesResponse200DataInner
     */
    'inline_flag'?: boolean;
    /**
     * The location type to send the file to. Only googledrive is supported at the moment.
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'remote_location'?: string;
    /**
     * The ID of the remote item
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'remote_id'?: string;
    /**
     * The ID of the inline attachment
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'cid'?: string;
    /**
     * The location of the cloud storage
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    's3_bucket'?: string;
    /**
     * The ID of the mail message to associate the file with
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'mail_message_id'?: string;
    /**
     * The ID of the mail template to associate the file with
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'mail_template_id'?: string;
    /**
     * The name of the deal associated with the file
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'deal_name'?: string;
    /**
     * The name of the person associated with the file
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'person_name'?: string;
    /**
     * The name of the organization associated with the file
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'org_name'?: string;
    /**
     * The name of the product associated with the file
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'product_name'?: string;
    /**
     * The name of the lead associated with the file
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'lead_name'?: string;
    /**
     * The URL of the download file
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'url'?: string;
    /**
     * The visible name of the file
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'name'?: string;
    /**
     * The description of the file
     * @type {string}
     * @memberof GetFilesResponse200DataInner
     */
    'description'?: string;
}
/**
 *
 * @export
 * @interface GetFilterResponse200
 */
export interface GetFilterResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetFilterResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetFiltersResponse200AllOfDataInner}
     * @memberof GetFilterResponse200
     */
    'data'?: GetFiltersResponse200AllOfDataInner;
}
/**
 *
 * @export
 * @interface GetFilterResponse200AllOf
 */
export interface GetFilterResponse200AllOf {
    /**
     *
     * @type {GetFiltersResponse200AllOfDataInner}
     * @memberof GetFilterResponse200AllOf
     */
    'data'?: GetFiltersResponse200AllOfDataInner;
}
/**
 *
 * @export
 * @interface GetFiltersResponse200
 */
export interface GetFiltersResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetFiltersResponse200
     */
    'success'?: boolean;
    /**
     * The array of filters
     * @type {Array<GetFiltersResponse200AllOfDataInner>}
     * @memberof GetFiltersResponse200
     */
    'data'?: Array<GetFiltersResponse200AllOfDataInner>;
}
/**
 *
 * @export
 * @interface GetFiltersResponse200AllOf
 */
export interface GetFiltersResponse200AllOf {
    /**
     * The array of filters
     * @type {Array<GetFiltersResponse200AllOfDataInner>}
     * @memberof GetFiltersResponse200AllOf
     */
    'data'?: Array<GetFiltersResponse200AllOfDataInner>;
}
/**
 * The filter object
 * @export
 * @interface GetFiltersResponse200AllOfDataInner
 */
export interface GetFiltersResponse200AllOfDataInner {
    /**
     * The ID of the filter
     * @type {number}
     * @memberof GetFiltersResponse200AllOfDataInner
     */
    'id'?: number;
    /**
     * The name of the filter
     * @type {string}
     * @memberof GetFiltersResponse200AllOfDataInner
     */
    'name'?: string;
    /**
     * The active flag of the filter
     * @type {boolean}
     * @memberof GetFiltersResponse200AllOfDataInner
     */
    'active_flag'?: boolean;
    /**
     * The type of the item
     * @type {string}
     * @memberof GetFiltersResponse200AllOfDataInner
     */
    'type'?: string;
    /**
     * The owner of the filter
     * @type {number}
     * @memberof GetFiltersResponse200AllOfDataInner
     */
    'user_id'?: number;
    /**
     * The date and time when the filter was added
     * @type {string}
     * @memberof GetFiltersResponse200AllOfDataInner
     */
    'add_time'?: string;
    /**
     * The date and time when the filter was updated
     * @type {string}
     * @memberof GetFiltersResponse200AllOfDataInner
     */
    'update_time'?: string;
    /**
     * The visibility group ID of who can see then filter
     * @type {number}
     * @memberof GetFiltersResponse200AllOfDataInner
     */
    'visible_to'?: number;
    /**
     * Used by Pipedrive webapp
     * @type {number}
     * @memberof GetFiltersResponse200AllOfDataInner
     */
    'custom_view_id'?: number;
}
/**
 *
 * @export
 * @interface GetGoalResultResponse200
 */
export interface GetGoalResultResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetGoalResultResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetGoalResultResponse200Data}
     * @memberof GetGoalResultResponse200
     */
    'data'?: GetGoalResultResponse200Data;
}
/**
 *
 * @export
 * @interface GetGoalResultResponse200Data
 */
export interface GetGoalResultResponse200Data {
    /**
     * The numeric progress of the goal
     * @type {number}
     * @memberof GetGoalResultResponse200Data
     */
    'progress'?: number;
    /**
     *
     * @type {AddOrUpdateGoalResponse200DataGoal}
     * @memberof GetGoalResultResponse200Data
     */
    'goal'?: AddOrUpdateGoalResponse200DataGoal;
}
/**
 *
 * @export
 * @interface GetGoalsResponse200
 */
export interface GetGoalsResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetGoalsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetGoalsResponse200Data}
     * @memberof GetGoalsResponse200
     */
    'data'?: GetGoalsResponse200Data;
}
/**
 *
 * @export
 * @interface GetGoalsResponse200Data
 */
export interface GetGoalsResponse200Data {
    /**
     *
     * @type {Array<AddOrUpdateGoalResponse200DataGoal>}
     * @memberof GetGoalsResponse200Data
     */
    'goals'?: Array<AddOrUpdateGoalResponse200DataGoal>;
}
/**
 *
 * @export
 * @interface GetLeadLabelsResponse200
 */
export interface GetLeadLabelsResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetLeadLabelsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<GetLeadLabelsResponse200DataInner>}
     * @memberof GetLeadLabelsResponse200
     */
    'data'?: Array<GetLeadLabelsResponse200DataInner>;
}
/**
 *
 * @export
 * @interface GetLeadLabelsResponse200DataInner
 */
export interface GetLeadLabelsResponse200DataInner {
    /**
     * The unique ID of the lead label
     * @type {string}
     * @memberof GetLeadLabelsResponse200DataInner
     */
    'id'?: string;
    /**
     * The name of the lead label
     * @type {string}
     * @memberof GetLeadLabelsResponse200DataInner
     */
    'name'?: string;
    /**
     * The color of the label. Only a subset of colors can be used.
     * @type {string}
     * @memberof GetLeadLabelsResponse200DataInner
     */
    'color'?: GetLeadLabelsResponse200DataInnerColorConst;
    /**
     * The date and time of when the lead label was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
     * @type {string}
     * @memberof GetLeadLabelsResponse200DataInner
     */
    'add_time'?: string;
    /**
     * The date and time of when the lead label was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
     * @type {string}
     * @memberof GetLeadLabelsResponse200DataInner
     */
    'update_time'?: string;
}

export const GetLeadLabelsResponse200DataInnerColorConst = {
    green: 'green',
    blue: 'blue',
    red: 'red',
    yellow: 'yellow',
    purple: 'purple',
    gray: 'gray'
} as const;

export type GetLeadLabelsResponse200DataInnerColorConst = typeof GetLeadLabelsResponse200DataInnerColorConst[keyof typeof GetLeadLabelsResponse200DataInnerColorConst];

/**
 *
 * @export
 * @interface GetLeadSourcesResponse200
 */
export interface GetLeadSourcesResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetLeadSourcesResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<GetLeadSourcesResponse200DataInner>}
     * @memberof GetLeadSourcesResponse200
     */
    'data'?: Array<GetLeadSourcesResponse200DataInner>;
}
/**
 *
 * @export
 * @interface GetLeadSourcesResponse200DataInner
 */
export interface GetLeadSourcesResponse200DataInner {
    /**
     * The unique name of a lead source
     * @type {string}
     * @memberof GetLeadSourcesResponse200DataInner
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface GetLeadsResponse200
 */
export interface GetLeadsResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetLeadsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<GetLeadsResponse200DataInner>}
     * @memberof GetLeadsResponse200
     */
    'data'?: Array<GetLeadsResponse200DataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetLeadsResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetLeadsResponse200DataInner
 */
export interface GetLeadsResponse200DataInner {
    /**
     * The unique ID of the lead in the UUID format
     * @type {string}
     * @memberof GetLeadsResponse200DataInner
     */
    'id'?: string;
    /**
     * The title of the lead
     * @type {string}
     * @memberof GetLeadsResponse200DataInner
     */
    'title'?: string;
    /**
     * The ID of the user who owns the lead
     * @type {number}
     * @memberof GetLeadsResponse200DataInner
     */
    'owner_id'?: number;
    /**
     * The ID of the user who created the lead
     * @type {number}
     * @memberof GetLeadsResponse200DataInner
     */
    'creator_id'?: number;
    /**
     * The IDs of the lead labels which are associated with the lead
     * @type {Array<string>}
     * @memberof GetLeadsResponse200DataInner
     */
    'label_ids'?: Array<string>;
    /**
     * The ID of a person which this lead is linked to
     * @type {number}
     * @memberof GetLeadsResponse200DataInner
     */
    'person_id'?: number | null;
    /**
     * The ID of an organization which this lead is linked to
     * @type {number}
     * @memberof GetLeadsResponse200DataInner
     */
    'organization_id'?: number | null;
    /**
     * Defines where the lead comes from. Will be `API` if the lead was created through the Public API and will be `Manually created` if the lead was created manually through the UI.
     * @type {string}
     * @memberof GetLeadsResponse200DataInner
     */
    'source_name'?: string;
    /**
     * A flag indicating whether the lead is archived or not
     * @type {boolean}
     * @memberof GetLeadsResponse200DataInner
     */
    'is_archived'?: boolean;
    /**
     * A flag indicating whether the lead was seen by someone in the Pipedrive UI
     * @type {boolean}
     * @memberof GetLeadsResponse200DataInner
     */
    'was_seen'?: boolean;
    /**
     *
     * @type {GetLeadsResponse200DataInnerValue}
     * @memberof GetLeadsResponse200DataInner
     */
    'value'?: GetLeadsResponse200DataInnerValue;
    /**
     * The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
     * @type {string}
     * @memberof GetLeadsResponse200DataInner
     */
    'expected_close_date'?: string | null;
    /**
     * The ID of the next activity associated with the lead
     * @type {number}
     * @memberof GetLeadsResponse200DataInner
     */
    'next_activity_id'?: number | null;
    /**
     * The date and time of when the lead was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
     * @type {string}
     * @memberof GetLeadsResponse200DataInner
     */
    'add_time'?: string;
    /**
     * The date and time of when the lead was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
     * @type {string}
     * @memberof GetLeadsResponse200DataInner
     */
    'update_time'?: string;
    /**
     *
     * @type {string}
     * @memberof GetLeadsResponse200DataInner
     */
    'visible_to'?: GetLeadsResponse200DataInnerVisibleToConst;
    /**
     * The BCC email of the lead
     * @type {string}
     * @memberof GetLeadsResponse200DataInner
     */
    'cc_email'?: string;
}

export const GetLeadsResponse200DataInnerVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type GetLeadsResponse200DataInnerVisibleToConst = typeof GetLeadsResponse200DataInnerVisibleToConst[keyof typeof GetLeadsResponse200DataInnerVisibleToConst];

/**
 * The potential value of the lead
 * @export
 * @interface GetLeadsResponse200DataInnerValue
 */
export interface GetLeadsResponse200DataInnerValue {
    /**
     *
     * @type {number}
     * @memberof GetLeadsResponse200DataInnerValue
     */
    'amount': number;
    /**
     *
     * @type {string}
     * @memberof GetLeadsResponse200DataInnerValue
     */
    'currency': string;
}
/**
 *
 * @export
 * @interface GetMailThreadsResponse200
 */
export interface GetMailThreadsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetMailThreadsResponse200
     */
    'success'?: boolean;
    /**
     * The array of mail threads
     * @type {Array<BaseMailThread>}
     * @memberof GetMailThreadsResponse200
     */
    'data'?: Array<BaseMailThread>;
}
/**
 *
 * @export
 * @interface GetMailThreadsResponse200AllOf
 */
export interface GetMailThreadsResponse200AllOf {
    /**
     * The array of mail threads
     * @type {Array<BaseMailThread>}
     * @memberof GetMailThreadsResponse200AllOf
     */
    'data'?: Array<BaseMailThread>;
}
/**
 *
 * @export
 * @interface GetNoteFieldsResponse200
 */
export interface GetNoteFieldsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetNoteFieldsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<GetNoteFieldsResponse200AllOfDataInner>}
     * @memberof GetNoteFieldsResponse200
     */
    'data'?: Array<GetNoteFieldsResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetNoteFieldsResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetNoteFieldsResponse200AllOf
 */
export interface GetNoteFieldsResponse200AllOf {
    /**
     *
     * @type {Array<GetNoteFieldsResponse200AllOfDataInner>}
     * @memberof GetNoteFieldsResponse200AllOf
     */
    'data'?: Array<GetNoteFieldsResponse200AllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetNoteFieldsResponse200AllOf
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetNoteFieldsResponse200AllOfDataInner
 */
export interface GetNoteFieldsResponse200AllOfDataInner {
    /**
     * The ID of the field
     * @type {number}
     * @memberof GetNoteFieldsResponse200AllOfDataInner
     */
    'id'?: number;
    /**
     * The key of the field
     * @type {string}
     * @memberof GetNoteFieldsResponse200AllOfDataInner
     */
    'key'?: string;
    /**
     * The name of the field
     * @type {string}
     * @memberof GetNoteFieldsResponse200AllOfDataInner
     */
    'name'?: string;
    /**
     * The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`address`</td><td>Address field (has multiple subfields, autocompleted by Google Maps)</td></tr><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td></tr><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td></tr><tr><td>`double`</td><td>Numeric value</td></tr><tr><td>`enum`</td><td>Options field with a single possible chosen option</td></tr><tr></tr><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td></tr><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td></tr><tr><td>`people`</td><td>Person field (contains a person ID which is stored on the same account)</td></tr><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td></tr><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td></tr><tr><td>`text`</td><td>Long text (up to 65k characters)</td></tr><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td></tr><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td></tr><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td></tr><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td></tr><tr><td>`visible_to`</td><td>System field that keeps item\'s visibility setting</td></tr></table>
     * @type {string}
     * @memberof GetNoteFieldsResponse200AllOfDataInner
     */
    'field_type'?: GetNoteFieldsResponse200AllOfDataInnerFieldTypeConst;
    /**
     * The active flag of the field
     * @type {boolean}
     * @memberof GetNoteFieldsResponse200AllOfDataInner
     */
    'active_flag'?: boolean;
    /**
     * The edit flag of the field
     * @type {boolean}
     * @memberof GetNoteFieldsResponse200AllOfDataInner
     */
    'edit_flag'?: boolean;
    /**
     * Not used
     * @type {boolean}
     * @memberof GetNoteFieldsResponse200AllOfDataInner
     */
    'bulk_edit_allowed'?: boolean;
    /**
     * Whether or not the field is mandatory
     * @type {boolean}
     * @memberof GetNoteFieldsResponse200AllOfDataInner
     */
    'mandatory_flag'?: boolean;
    /**
     * The options of the field. When there are no options, `null` is returned.
     * @type {Array<GetNoteFieldsResponse200AllOfDataInnerOptionsInner>}
     * @memberof GetNoteFieldsResponse200AllOfDataInner
     */
    'options'?: Array<GetNoteFieldsResponse200AllOfDataInnerOptionsInner>;
}

export const GetNoteFieldsResponse200AllOfDataInnerFieldTypeConst = {
    address: 'address',
    date: 'date',
    daterange: 'daterange',
    double: 'double',
    enum: 'enum',
    monetary: 'monetary',
    org: 'org',
    people: 'people',
    phone: 'phone',
    set: 'set',
    text: 'text',
    time: 'time',
    timerange: 'timerange',
    user: 'user',
    varchar: 'varchar',
    varchar_auto: 'varchar_auto',
    visible_to: 'visible_to'
} as const;

export type GetNoteFieldsResponse200AllOfDataInnerFieldTypeConst = typeof GetNoteFieldsResponse200AllOfDataInnerFieldTypeConst[keyof typeof GetNoteFieldsResponse200AllOfDataInnerFieldTypeConst];

/**
 *
 * @export
 * @interface GetNoteFieldsResponse200AllOfDataInnerOptionsInner
 */
export interface GetNoteFieldsResponse200AllOfDataInnerOptionsInner {
    /**
     *
     * @type {number}
     * @memberof GetNoteFieldsResponse200AllOfDataInnerOptionsInner
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof GetNoteFieldsResponse200AllOfDataInnerOptionsInner
     */
    'label'?: string;
}
/**
 *
 * @export
 * @interface GetNotesResponse200
 */
export interface GetNotesResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetNotesResponse200
     */
    'success'?: boolean;
    /**
     * The array of notes
     * @type {Array<GetNotesResponse200DataInner>}
     * @memberof GetNotesResponse200
     */
    'data'?: Array<GetNotesResponse200DataInner>;
    /**
     *
     * @type {GetNotesResponse200AdditionalData}
     * @memberof GetNotesResponse200
     */
    'additional_data'?: GetNotesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface GetNotesResponse200AdditionalData
 */
export interface GetNotesResponse200AdditionalData {
    /**
     *
     * @type {GetNotesResponse200AdditionalDataPagination}
     * @memberof GetNotesResponse200AdditionalData
     */
    'pagination'?: GetNotesResponse200AdditionalDataPagination;
}
/**
 * The pagination details of the list
 * @export
 * @interface GetNotesResponse200AdditionalDataPagination
 */
export interface GetNotesResponse200AdditionalDataPagination {
    /**
     * Pagination start
     * @type {number}
     * @memberof GetNotesResponse200AdditionalDataPagination
     */
    'start'?: number;
    /**
     * Items shown per page
     * @type {number}
     * @memberof GetNotesResponse200AdditionalDataPagination
     */
    'limit'?: number;
    /**
     * If there are more list items in the collection than displayed or not
     * @type {boolean}
     * @memberof GetNotesResponse200AdditionalDataPagination
     */
    'more_items_in_collection'?: boolean;
    /**
     * Next pagination start
     * @type {number}
     * @memberof GetNotesResponse200AdditionalDataPagination
     */
    'next_start'?: number;
}
/**
 *
 * @export
 * @interface GetNotesResponse200DataInner
 */
export interface GetNotesResponse200DataInner {
    /**
     * The ID of the note
     * @type {number}
     * @memberof GetNotesResponse200DataInner
     */
    'id'?: number;
    /**
     * Whether the note is active or deleted
     * @type {boolean}
     * @memberof GetNotesResponse200DataInner
     */
    'active_flag'?: boolean;
    /**
     * The creation date and time of the note
     * @type {string}
     * @memberof GetNotesResponse200DataInner
     */
    'add_time'?: string;
    /**
     * The content of the note in HTML format. Subject to sanitization on the back-end.
     * @type {string}
     * @memberof GetNotesResponse200DataInner
     */
    'content'?: string;
    /**
     *
     * @type {GetNotesResponse200DataInnerDeal}
     * @memberof GetNotesResponse200DataInner
     */
    'deal'?: GetNotesResponse200DataInnerDeal;
    /**
     * The ID of the lead the note is attached to
     * @type {string}
     * @memberof GetNotesResponse200DataInner
     */
    'lead_id'?: string;
    /**
     * The ID of the deal the note is attached to
     * @type {number}
     * @memberof GetNotesResponse200DataInner
     */
    'deal_id'?: number;
    /**
     * The ID of the user who last updated the note
     * @type {number}
     * @memberof GetNotesResponse200DataInner
     */
    'last_update_user_id'?: number;
    /**
     * The ID of the organization the note is attached to
     * @type {number}
     * @memberof GetNotesResponse200DataInner
     */
    'org_id'?: number;
    /**
     *
     * @type {GetNotesResponse200DataInnerOrganization}
     * @memberof GetNotesResponse200DataInner
     */
    'organization'?: GetNotesResponse200DataInnerOrganization;
    /**
     *
     * @type {GetNotesResponse200DataInnerPerson}
     * @memberof GetNotesResponse200DataInner
     */
    'person'?: GetNotesResponse200DataInnerPerson;
    /**
     * The ID of the person the note is attached to
     * @type {number}
     * @memberof GetNotesResponse200DataInner
     */
    'person_id'?: number;
    /**
     * If true, the results are filtered by note to deal pinning state
     * @type {boolean}
     * @memberof GetNotesResponse200DataInner
     */
    'pinned_to_deal_flag'?: boolean;
    /**
     * If true, the results are filtered by note to organization pinning state
     * @type {boolean}
     * @memberof GetNotesResponse200DataInner
     */
    'pinned_to_organization_flag'?: boolean;
    /**
     * If true, the results are filtered by note to person pinning state
     * @type {boolean}
     * @memberof GetNotesResponse200DataInner
     */
    'pinned_to_person_flag'?: boolean;
    /**
     * The last updated date and time of the note
     * @type {string}
     * @memberof GetNotesResponse200DataInner
     */
    'update_time'?: string;
    /**
     *
     * @type {GetNotesResponse200DataInnerUser}
     * @memberof GetNotesResponse200DataInner
     */
    'user'?: GetNotesResponse200DataInnerUser;
    /**
     * The ID of the note creator
     * @type {number}
     * @memberof GetNotesResponse200DataInner
     */
    'user_id'?: number;
}
/**
 * The deal this note is attached to
 * @export
 * @interface GetNotesResponse200DataInnerDeal
 */
export interface GetNotesResponse200DataInnerDeal {
    /**
     * The title of the deal this note is attached to
     * @type {string}
     * @memberof GetNotesResponse200DataInnerDeal
     */
    'title'?: string;
}
/**
 * The organization the note is attached to
 * @export
 * @interface GetNotesResponse200DataInnerOrganization
 */
export interface GetNotesResponse200DataInnerOrganization {
    /**
     * The name of the organization the note is attached to
     * @type {string}
     * @memberof GetNotesResponse200DataInnerOrganization
     */
    'name'?: string;
}
/**
 * The person the note is attached to
 * @export
 * @interface GetNotesResponse200DataInnerPerson
 */
export interface GetNotesResponse200DataInnerPerson {
    /**
     * The name of the person the note is attached to
     * @type {string}
     * @memberof GetNotesResponse200DataInnerPerson
     */
    'name'?: string;
}
/**
 * The user who created the note
 * @export
 * @interface GetNotesResponse200DataInnerUser
 */
export interface GetNotesResponse200DataInnerUser {
    /**
     * The email of the note creator
     * @type {string}
     * @memberof GetNotesResponse200DataInnerUser
     */
    'email'?: string;
    /**
     * The URL of the note creator avatar picture
     * @type {string}
     * @memberof GetNotesResponse200DataInnerUser
     */
    'icon_url'?: string;
    /**
     * Whether the note is created by you or not
     * @type {boolean}
     * @memberof GetNotesResponse200DataInnerUser
     */
    'is_you'?: boolean;
    /**
     * The name of the note creator
     * @type {string}
     * @memberof GetNotesResponse200DataInnerUser
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface GetOneMailThreadResponse200
 */
export interface GetOneMailThreadResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetOneMailThreadResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetOneMailThreadResponse200AllOfData}
     * @memberof GetOneMailThreadResponse200
     */
    'data'?: GetOneMailThreadResponse200AllOfData;
}
/**
 *
 * @export
 * @interface GetOneMailThreadResponse200AllOf
 */
export interface GetOneMailThreadResponse200AllOf {
    /**
     *
     * @type {GetOneMailThreadResponse200AllOfData}
     * @memberof GetOneMailThreadResponse200AllOf
     */
    'data'?: GetOneMailThreadResponse200AllOfData;
}
/**
 * The mail thread object
 * @export
 * @interface GetOneMailThreadResponse200AllOfData
 */
export interface GetOneMailThreadResponse200AllOfData {
    /**
     * ID of the mail thread
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'id'?: number;
    /**
     * The connection account ID
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'account_id'?: string;
    /**
     * ID of the user whom mail message will be assigned to
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'user_id'?: number;
    /**
     * The subject
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'subject'?: string;
    /**
     * A snippet
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'snippet'?: string;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'read_flag'?: GetOneMailThreadResponse200AllOfDataReadFlagConst;
    /**
     * Mail tracking status
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'mail_tracking_status'?: string | null;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'has_attachments_flag'?: GetOneMailThreadResponse200AllOfDataHasAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'has_inline_attachments_flag'?: GetOneMailThreadResponse200AllOfDataHasInlineAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'has_real_attachments_flag'?: GetOneMailThreadResponse200AllOfDataHasRealAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'deleted_flag'?: GetOneMailThreadResponse200AllOfDataDeletedFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'synced_flag'?: GetOneMailThreadResponse200AllOfDataSyncedFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'smart_bcc_flag'?: GetOneMailThreadResponse200AllOfDataSmartBccFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'mail_link_tracking_enabled_flag'?: GetOneMailThreadResponse200AllOfDataMailLinkTrackingEnabledFlagConst;
    /**
     *
     * @type {BaseMailThreadAllOf1Parties}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'parties'?: BaseMailThreadAllOf1Parties;
    /**
     * Parties of the drafted mail thread
     * @type {Array<object>}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'drafts_parties'?: Array<object>;
    /**
     * Folders in which messages from thread are being stored
     * @type {Array<string>}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'folders'?: Array<string>;
    /**
     * Version
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'version'?: number;
    /**
     * A snippet from a draft
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'snippet_draft'?: string | null;
    /**
     * A snippet from a message sent
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'snippet_sent'?: string;
    /**
     * An amount of messages
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'message_count'?: number;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'has_draft_flag'?: GetOneMailThreadResponse200AllOfDataHasDraftFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'has_sent_flag'?: GetOneMailThreadResponse200AllOfDataHasSentFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'archived_flag'?: GetOneMailThreadResponse200AllOfDataArchivedFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'shared_flag'?: GetOneMailThreadResponse200AllOfDataSharedFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'external_deleted_flag'?: GetOneMailThreadResponse200AllOfDataExternalDeletedFlagConst;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'first_message_to_me_flag'?: GetOneMailThreadResponse200AllOfDataFirstMessageToMeFlagConst;
    /**
     * Last message timestamp
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'last_message_timestamp'?: string;
    /**
     * The time when the mail thread has had the first message received or created
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'first_message_timestamp'?: string;
    /**
     * The last time when the mail thread has had a message sent
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'last_message_sent_timestamp'?: string | null;
    /**
     * The last time when the mail thread has had a message received
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'last_message_received_timestamp'?: string;
    /**
     * The time when the mail thread was inserted to database
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'add_time'?: string;
    /**
     * The time when the mail thread was updated in database received
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'update_time'?: string;
    /**
     * The ID of the deal
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'deal_id'?: number | null;
    /**
     * Status of the deal
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'deal_status'?: string | null;
    /**
     * The ID of the lead
     * @type {string}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'lead_id'?: string | null;
    /**
     *
     * @type {number}
     * @memberof GetOneMailThreadResponse200AllOfData
     */
    'all_messages_sent_flag'?: GetOneMailThreadResponse200AllOfDataAllMessagesSentFlagConst;
}

export const GetOneMailThreadResponse200AllOfDataReadFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataReadFlagConst = typeof GetOneMailThreadResponse200AllOfDataReadFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataReadFlagConst];
export const GetOneMailThreadResponse200AllOfDataHasAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataHasAttachmentsFlagConst = typeof GetOneMailThreadResponse200AllOfDataHasAttachmentsFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataHasAttachmentsFlagConst];
export const GetOneMailThreadResponse200AllOfDataHasInlineAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataHasInlineAttachmentsFlagConst = typeof GetOneMailThreadResponse200AllOfDataHasInlineAttachmentsFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataHasInlineAttachmentsFlagConst];
export const GetOneMailThreadResponse200AllOfDataHasRealAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataHasRealAttachmentsFlagConst = typeof GetOneMailThreadResponse200AllOfDataHasRealAttachmentsFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataHasRealAttachmentsFlagConst];
export const GetOneMailThreadResponse200AllOfDataDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataDeletedFlagConst = typeof GetOneMailThreadResponse200AllOfDataDeletedFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataDeletedFlagConst];
export const GetOneMailThreadResponse200AllOfDataSyncedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataSyncedFlagConst = typeof GetOneMailThreadResponse200AllOfDataSyncedFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataSyncedFlagConst];
export const GetOneMailThreadResponse200AllOfDataSmartBccFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataSmartBccFlagConst = typeof GetOneMailThreadResponse200AllOfDataSmartBccFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataSmartBccFlagConst];
export const GetOneMailThreadResponse200AllOfDataMailLinkTrackingEnabledFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataMailLinkTrackingEnabledFlagConst = typeof GetOneMailThreadResponse200AllOfDataMailLinkTrackingEnabledFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataMailLinkTrackingEnabledFlagConst];
export const GetOneMailThreadResponse200AllOfDataHasDraftFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataHasDraftFlagConst = typeof GetOneMailThreadResponse200AllOfDataHasDraftFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataHasDraftFlagConst];
export const GetOneMailThreadResponse200AllOfDataHasSentFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataHasSentFlagConst = typeof GetOneMailThreadResponse200AllOfDataHasSentFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataHasSentFlagConst];
export const GetOneMailThreadResponse200AllOfDataArchivedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataArchivedFlagConst = typeof GetOneMailThreadResponse200AllOfDataArchivedFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataArchivedFlagConst];
export const GetOneMailThreadResponse200AllOfDataSharedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataSharedFlagConst = typeof GetOneMailThreadResponse200AllOfDataSharedFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataSharedFlagConst];
export const GetOneMailThreadResponse200AllOfDataExternalDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataExternalDeletedFlagConst = typeof GetOneMailThreadResponse200AllOfDataExternalDeletedFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataExternalDeletedFlagConst];
export const GetOneMailThreadResponse200AllOfDataFirstMessageToMeFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataFirstMessageToMeFlagConst = typeof GetOneMailThreadResponse200AllOfDataFirstMessageToMeFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataFirstMessageToMeFlagConst];
export const GetOneMailThreadResponse200AllOfDataAllMessagesSentFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetOneMailThreadResponse200AllOfDataAllMessagesSentFlagConst = typeof GetOneMailThreadResponse200AllOfDataAllMessagesSentFlagConst[keyof typeof GetOneMailThreadResponse200AllOfDataAllMessagesSentFlagConst];

/**
 *
 * @export
 * @interface GetOrganizationRelationshipResponse200
 */
export interface GetOrganizationRelationshipResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetOrganizationRelationshipResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {OrganizationRelationshipWithCalculatedFields}
     * @memberof GetOrganizationRelationshipResponse200
     */
    'data'?: OrganizationRelationshipWithCalculatedFields;
    /**
     *
     * @type {GetOrganizationRelationshipsResponse200AllOfRelatedObjects}
     * @memberof GetOrganizationRelationshipResponse200
     */
    'related_objects'?: GetOrganizationRelationshipsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetOrganizationRelationshipResponse200AllOf
 */
export interface GetOrganizationRelationshipResponse200AllOf {
    /**
     *
     * @type {OrganizationRelationshipWithCalculatedFields}
     * @memberof GetOrganizationRelationshipResponse200AllOf
     */
    'data'?: OrganizationRelationshipWithCalculatedFields;
    /**
     *
     * @type {GetOrganizationRelationshipsResponse200AllOfRelatedObjects}
     * @memberof GetOrganizationRelationshipResponse200AllOf
     */
    'related_objects'?: GetOrganizationRelationshipsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetOrganizationRelationshipsResponse200
 */
export interface GetOrganizationRelationshipsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetOrganizationRelationshipsResponse200
     */
    'success'?: boolean;
    /**
     * The array of organization relationships
     * @type {Array<OrganizationRelationshipDetails>}
     * @memberof GetOrganizationRelationshipsResponse200
     */
    'data'?: Array<OrganizationRelationshipDetails>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetOrganizationRelationshipsResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetOrganizationRelationshipsResponse200AllOfRelatedObjects}
     * @memberof GetOrganizationRelationshipsResponse200
     */
    'related_objects'?: GetOrganizationRelationshipsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetOrganizationRelationshipsResponse200AllOf
 */
export interface GetOrganizationRelationshipsResponse200AllOf {
    /**
     * The array of organization relationships
     * @type {Array<OrganizationRelationshipDetails>}
     * @memberof GetOrganizationRelationshipsResponse200AllOf
     */
    'data'?: Array<OrganizationRelationshipDetails>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetOrganizationRelationshipsResponse200AllOf
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetOrganizationRelationshipsResponse200AllOfRelatedObjects}
     * @memberof GetOrganizationRelationshipsResponse200AllOf
     */
    'related_objects'?: GetOrganizationRelationshipsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetOrganizationRelationshipsResponse200AllOfRelatedObjects
 */
export interface GetOrganizationRelationshipsResponse200AllOfRelatedObjects {
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsOrganization}
     * @memberof GetOrganizationRelationshipsResponse200AllOfRelatedObjects
     */
    'organization'?: GetActivitiesResponse200RelatedObjectsOrganization;
}
/**
 *
 * @export
 * @interface GetOrganizationResponse200
 */
export interface GetOrganizationResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetOrganizationResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {OrganizationItem}
     * @memberof GetOrganizationResponse200
     */
    'data'?: OrganizationItem;
    /**
     *
     * @type {GetOrganizationResponse200AllOfAdditionalData}
     * @memberof GetOrganizationResponse200
     */
    'additional_data'?: GetOrganizationResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjects}
     * @memberof GetOrganizationResponse200
     */
    'related_objects'?: GetOrganizationsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetOrganizationResponse200AllOf
 */
export interface GetOrganizationResponse200AllOf {
    /**
     *
     * @type {OrganizationItem}
     * @memberof GetOrganizationResponse200AllOf
     */
    'data'?: OrganizationItem;
    /**
     *
     * @type {GetOrganizationResponse200AllOfAdditionalData}
     * @memberof GetOrganizationResponse200AllOf
     */
    'additional_data'?: GetOrganizationResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjects}
     * @memberof GetOrganizationResponse200AllOf
     */
    'related_objects'?: GetOrganizationsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetOrganizationResponse200AllOfAdditionalData
 */
export interface GetOrganizationResponse200AllOfAdditionalData {
    /**
     *
     * @type {GetOrganizationResponse200AllOfAdditionalDataFollowers}
     * @memberof GetOrganizationResponse200AllOfAdditionalData
     */
    'followers'?: GetOrganizationResponse200AllOfAdditionalDataFollowers;
    /**
     * Dropbox email for the organization
     * @type {string}
     * @memberof GetOrganizationResponse200AllOfAdditionalData
     */
    'dropbox_email'?: string;
}
/**
 * The follower that is associated with the item
 * @export
 * @interface GetOrganizationResponse200AllOfAdditionalDataFollowers
 */
export interface GetOrganizationResponse200AllOfAdditionalDataFollowers {
    /**
     *
     * @type {GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERID}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowers
     */
    'FOLLOWER_USER_ID'?: GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERID;
}
/**
 * The user ID of the follower
 * @export
 * @interface GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERID
 */
export interface GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERID {
    /**
     * The ID of the follower associated with the item
     * @type {number}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERID
     */
    'id'?: number;
    /**
     * The name of the follower
     * @type {string}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERID
     */
    'name'?: string;
    /**
     * The email of the follower
     * @type {string}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERID
     */
    'email'?: string;
    /**
     * The user ID of the follower
     * @type {number}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERID
     */
    'user_id'?: number;
    /**
     * The follower picture hash
     * @type {string}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERID
     */
    'pic_hash'?: string;
}
/**
 *
 * @export
 * @interface GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOf
 */
export interface GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOf {
    /**
     * The ID of the follower associated with the item
     * @type {number}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOf
     */
    'id'?: number;
    /**
     * The name of the follower
     * @type {string}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOf
     */
    'name'?: string;
    /**
     * The email of the follower
     * @type {string}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOf
     */
    'email'?: string;
    /**
     * The user ID of the follower
     * @type {number}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOf
     */
    'user_id'?: number;
    /**
     * The follower picture hash
     * @type {string}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOf
     */
    'pic_hash'?: string;
}
/**
 *
 * @export
 * @interface GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOfAllOf
 */
export interface GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOfAllOf {
    /**
     * The ID of the follower associated with the item
     * @type {number}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOfAllOf
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOfAllOf1
 */
export interface GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOfAllOf1 {
    /**
     * The name of the follower
     * @type {string}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOfAllOf1
     */
    'name'?: string;
    /**
     * The email of the follower
     * @type {string}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOfAllOf1
     */
    'email'?: string;
    /**
     * The user ID of the follower
     * @type {number}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOfAllOf1
     */
    'user_id'?: number;
    /**
     * The follower picture hash
     * @type {string}
     * @memberof GetOrganizationResponse200AllOfAdditionalDataFollowersFOLLOWERUSERIDAllOfAllOf1
     */
    'pic_hash'?: string;
}
/**
 *
 * @export
 * @interface GetOrganizationsCollection200Response
 */
export interface GetOrganizationsCollection200Response {
    /**
     *
     * @type {boolean}
     * @memberof GetOrganizationsCollection200Response
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<OrganizationsCollectionResponseObject>}
     * @memberof GetOrganizationsCollection200Response
     */
    'data'?: Array<OrganizationsCollectionResponseObject>;
    /**
     *
     * @type {GetActivitiesCollectionResponse200AdditionalData}
     * @memberof GetOrganizationsCollection200Response
     */
    'additional_data'?: GetActivitiesCollectionResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface GetOrganizationsResponse200
 */
export interface GetOrganizationsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetOrganizationsResponse200
     */
    'success'?: boolean;
    /**
     * The array of organizations
     * @type {Array<BaseOrganizationItem>}
     * @memberof GetOrganizationsResponse200
     */
    'data'?: Array<BaseOrganizationItem>;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof GetOrganizationsResponse200
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjects}
     * @memberof GetOrganizationsResponse200
     */
    'related_objects'?: GetOrganizationsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetOrganizationsResponse200AllOf
 */
export interface GetOrganizationsResponse200AllOf {
    /**
     * The array of organizations
     * @type {Array<BaseOrganizationItem>}
     * @memberof GetOrganizationsResponse200AllOf
     */
    'data'?: Array<BaseOrganizationItem>;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof GetOrganizationsResponse200AllOf
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjects}
     * @memberof GetOrganizationsResponse200AllOf
     */
    'related_objects'?: GetOrganizationsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetOrganizationsResponse200AllOfRelatedObjects
 */
export interface GetOrganizationsResponse200AllOfRelatedObjects {
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsOrganization}
     * @memberof GetOrganizationsResponse200AllOfRelatedObjects
     */
    'organization'?: GetActivitiesResponse200RelatedObjectsOrganization;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsUser}
     * @memberof GetOrganizationsResponse200AllOfRelatedObjects
     */
    'user'?: GetActivitiesResponse200RelatedObjectsUser;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjectsPicture}
     * @memberof GetOrganizationsResponse200AllOfRelatedObjects
     */
    'picture'?: GetOrganizationsResponse200AllOfRelatedObjectsPicture;
}
/**
 * The picture that is associated with the item
 * @export
 * @interface GetOrganizationsResponse200AllOfRelatedObjectsPicture
 */
export interface GetOrganizationsResponse200AllOfRelatedObjectsPicture {
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjectsPicturePICTUREID}
     * @memberof GetOrganizationsResponse200AllOfRelatedObjectsPicture
     */
    'PICTURE_ID'?: GetOrganizationsResponse200AllOfRelatedObjectsPicturePICTUREID;
}
/**
 * The ID of the picture
 * @export
 * @interface GetOrganizationsResponse200AllOfRelatedObjectsPicturePICTUREID
 */
export interface GetOrganizationsResponse200AllOfRelatedObjectsPicturePICTUREID {
    /**
     * The ID of the picture associated with the item
     * @type {number}
     * @memberof GetOrganizationsResponse200AllOfRelatedObjectsPicturePICTUREID
     */
    'id'?: number;
    /**
     * The type of item the picture is related to
     * @type {string}
     * @memberof GetOrganizationsResponse200AllOfRelatedObjectsPicturePICTUREID
     */
    'item_type'?: string;
    /**
     * The ID of related item
     * @type {number}
     * @memberof GetOrganizationsResponse200AllOfRelatedObjectsPicturePICTUREID
     */
    'item_id'?: number;
    /**
     * Whether the associated picture is active or not
     * @type {boolean}
     * @memberof GetOrganizationsResponse200AllOfRelatedObjectsPicturePICTUREID
     */
    'active_flag'?: boolean;
    /**
     * The add time of the picture
     * @type {string}
     * @memberof GetOrganizationsResponse200AllOfRelatedObjectsPicturePICTUREID
     */
    'add_time'?: string;
    /**
     * The update time of the picture
     * @type {string}
     * @memberof GetOrganizationsResponse200AllOfRelatedObjectsPicturePICTUREID
     */
    'update_time'?: string;
    /**
     * The ID of the user who added the picture
     * @type {number}
     * @memberof GetOrganizationsResponse200AllOfRelatedObjectsPicturePICTUREID
     */
    'added_by_user_id'?: number;
    /**
     *
     * @type {PersonItemAllOfPictureIdAllOf1Pictures}
     * @memberof GetOrganizationsResponse200AllOfRelatedObjectsPicturePICTUREID
     */
    'pictures'?: PersonItemAllOfPictureIdAllOf1Pictures;
}
/**
 *
 * @export
 * @interface GetPermissionSetsResponse200
 */
export interface GetPermissionSetsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetPermissionSetsResponse200
     */
    'success'?: boolean;
    /**
     * The array of permission set
     * @type {Array<GetPermissionSetsResponse200AllOfDataInner>}
     * @memberof GetPermissionSetsResponse200
     */
    'data'?: Array<GetPermissionSetsResponse200AllOfDataInner>;
}
/**
 *
 * @export
 * @interface GetPermissionSetsResponse200AllOf
 */
export interface GetPermissionSetsResponse200AllOf {
    /**
     * The array of permission set
     * @type {Array<GetPermissionSetsResponse200AllOfDataInner>}
     * @memberof GetPermissionSetsResponse200AllOf
     */
    'data'?: Array<GetPermissionSetsResponse200AllOfDataInner>;
}
/**
 *
 * @export
 * @interface GetPermissionSetsResponse200AllOfDataInner
 */
export interface GetPermissionSetsResponse200AllOfDataInner {
    /**
     * The ID of user permission set
     * @type {string}
     * @memberof GetPermissionSetsResponse200AllOfDataInner
     */
    'id'?: string;
    /**
     * The name of the permission set
     * @type {string}
     * @memberof GetPermissionSetsResponse200AllOfDataInner
     */
    'name'?: string;
    /**
     * The description of the permission set
     * @type {string}
     * @memberof GetPermissionSetsResponse200AllOfDataInner
     */
    'description'?: string;
    /**
     * The app that permission set belongs to
     * @type {string}
     * @memberof GetPermissionSetsResponse200AllOfDataInner
     */
    'app'?: GetPermissionSetsResponse200AllOfDataInnerAppConst;
    /**
     * The type of permission set
     * @type {string}
     * @memberof GetPermissionSetsResponse200AllOfDataInner
     */
    'type'?: GetPermissionSetsResponse200AllOfDataInnerTypeConst;
    /**
     * The number of users assigned to this permission set
     * @type {number}
     * @memberof GetPermissionSetsResponse200AllOfDataInner
     */
    'assignment_count'?: number;
}

export const GetPermissionSetsResponse200AllOfDataInnerAppConst = {
    sales: 'sales',
    projects: 'projects',
    campaigns: 'campaigns',
    global: 'global',
    account_settings: 'account_settings'
} as const;

export type GetPermissionSetsResponse200AllOfDataInnerAppConst = typeof GetPermissionSetsResponse200AllOfDataInnerAppConst[keyof typeof GetPermissionSetsResponse200AllOfDataInnerAppConst];
export const GetPermissionSetsResponse200AllOfDataInnerTypeConst = {
    admin: 'admin',
    manager: 'manager',
    regular: 'regular',
    custom: 'custom'
} as const;

export type GetPermissionSetsResponse200AllOfDataInnerTypeConst = typeof GetPermissionSetsResponse200AllOfDataInnerTypeConst[keyof typeof GetPermissionSetsResponse200AllOfDataInnerTypeConst];

/**
 *
 * @export
 * @interface GetPersonProductsResponse200
 */
export interface GetPersonProductsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetPersonProductsResponse200
     */
    'success'?: boolean;
    /**
     * The array of deal products
     * @type {Array<GetPersonProductsResponse200AllOfDataInner>}
     * @memberof GetPersonProductsResponse200
     */
    'data'?: Array<GetPersonProductsResponse200AllOfDataInner>;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof GetPersonProductsResponse200
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface GetPersonProductsResponse200AllOf
 */
export interface GetPersonProductsResponse200AllOf {
    /**
     * The array of deal products
     * @type {Array<GetPersonProductsResponse200AllOfDataInner>}
     * @memberof GetPersonProductsResponse200AllOf
     */
    'data'?: Array<GetPersonProductsResponse200AllOfDataInner>;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof GetPersonProductsResponse200AllOf
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface GetPersonProductsResponse200AllOfDataInner
 */
export interface GetPersonProductsResponse200AllOfDataInner {
    /**
     *
     * @type {GetPersonProductsResponse200AllOfDataInnerDEALID}
     * @memberof GetPersonProductsResponse200AllOfDataInner
     */
    'DEAL_ID'?: GetPersonProductsResponse200AllOfDataInnerDEALID;
}
/**
 *
 * @export
 * @interface GetPersonProductsResponse200AllOfDataInnerDEALID
 */
export interface GetPersonProductsResponse200AllOfDataInnerDEALID {
    /**
     *
     * @type {GetPersonProductsResponse200AllOfDataInnerDEALIDDeal}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALID
     */
    'deal'?: GetPersonProductsResponse200AllOfDataInnerDEALIDDeal;
    /**
     *
     * @type {GetPersonProductsResponse200AllOfDataInnerDEALIDProduct}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALID
     */
    'product'?: GetPersonProductsResponse200AllOfDataInnerDEALIDProduct;
}
/**
 *
 * @export
 * @interface GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
 */
export interface GetPersonProductsResponse200AllOfDataInnerDEALIDDeal {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'id'?: number;
    /**
     * The ID of the company
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'company_id'?: number;
    /**
     * The ID of the deal creator
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'creator_user_id'?: number;
    /**
     * The ID of the user
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'user_id'?: number;
    /**
     * The ID of the person associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'person_id'?: number;
    /**
     * The ID of the organization associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'org_id'?: number;
    /**
     * The ID of the deal stage
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'stage_id'?: number;
    /**
     * The title of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'title'?: string;
    /**
     * The value of the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'value'?: number;
    /**
     * The currency associated with the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'currency'?: string;
    /**
     * The creation date and time of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'add_time'?: string;
    /**
     * The first creation date and time of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'first_add_time'?: string;
    /**
     * The last updated date and time of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'update_time'?: string;
    /**
     * The last updated date and time of the deal stage
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'stage_change_time'?: string;
    /**
     * Whether the deal is active or not
     * @type {boolean}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'active'?: boolean;
    /**
     * Whether the deal is deleted or not
     * @type {boolean}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'deleted'?: boolean;
    /**
     * The status of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'status'?: string;
    /**
     * The success probability percentage of the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'probability'?: number | null;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'next_activity_date'?: string;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'next_activity_time'?: string;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'last_activity_date'?: string | null;
    /**
     * The reason for losing the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'lost_reason'?: string | null;
    /**
     * The visibility of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'visible_to'?: string;
    /**
     * The date and time of closing the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'close_time'?: string | null;
    /**
     * The ID of the pipeline associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'pipeline_id'?: number;
    /**
     * The date and time of changing the deal status as won
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'won_time'?: string;
    /**
     * The date and time of the first time changing the deal status as won
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'first_won_time'?: string;
    /**
     * The date and time of changing the deal status as lost
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'lost_time'?: string;
    /**
     * The number of products associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'products_count'?: number;
    /**
     * The number of files associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'files_count'?: number;
    /**
     * The number of notes associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'notes_count'?: number;
    /**
     * The number of followers associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'followers_count'?: number;
    /**
     * The number of emails associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'email_messages_count'?: number;
    /**
     * The number of activities associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'activities_count'?: number;
    /**
     * The number of completed activities associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'done_activities_count'?: number;
    /**
     * The number of incomplete activities associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'undone_activities_count'?: number;
    /**
     * The number of participants associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'participants_count'?: number;
    /**
     * The expected close date of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'expected_close_date'?: string;
    /**
     * The date and time of the last incoming email associated with the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'last_outgoing_mail_time'?: string;
    /**
     * The label or multiple labels assigned to the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDDeal
     */
    'label'?: string;
}
/**
 *
 * @export
 * @interface GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
 */
export interface GetPersonProductsResponse200AllOfDataInnerDEALIDProduct {
    /**
     * The ID of the product
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'id'?: number;
    /**
     * The ID of the company
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'company_id'?: number;
    /**
     * The name of the product
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'name'?: string;
    /**
     * The product code
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'code'?: string;
    /**
     * The description of the product
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'description'?: string;
    /**
     * The unit in which this product is sold
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'unit'?: string;
    /**
     * The tax percentage
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'tax'?: number;
    /**
     * The category of the product
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'category'?: string;
    /**
     * Whether this product will be made active or not
     * @type {boolean}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'active_flag'?: boolean;
    /**
     * Whether this product can be selected in deals or not
     * @type {boolean}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'selectable'?: boolean;
    /**
     * The first letter of the product name
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'first_char'?: string;
    /**
     *
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'visible_to'?: GetPersonProductsResponse200AllOfDataInnerDEALIDProductVisibleToConst;
    /**
     * The ID of the user who will be marked as the owner of this product. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'owner_id'?: number;
    /**
     * The count of files
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'files_count'?: number;
    /**
     * The date and time when the product was added to the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'add_time'?: string;
    /**
     * The date and time when the product was updated to the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'update_time'?: string;
    /**
     * The ID of the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200AllOfDataInnerDEALIDProduct
     */
    'deal_id'?: number;
}

export const GetPersonProductsResponse200AllOfDataInnerDEALIDProductVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type GetPersonProductsResponse200AllOfDataInnerDEALIDProductVisibleToConst = typeof GetPersonProductsResponse200AllOfDataInnerDEALIDProductVisibleToConst[keyof typeof GetPersonProductsResponse200AllOfDataInnerDEALIDProductVisibleToConst];

/**
 *
 * @export
 * @interface GetPersonResponse200
 */
export interface GetPersonResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetPersonResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {PersonItem}
     * @memberof GetPersonResponse200
     */
    'data'?: PersonItem;
    /**
     *
     * @type {GetPersonResponse200AllOfAdditionalData}
     * @memberof GetPersonResponse200
     */
    'additional_data'?: GetPersonResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjects}
     * @memberof GetPersonResponse200
     */
    'related_objects'?: GetOrganizationsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetPersonResponse200AllOf
 */
export interface GetPersonResponse200AllOf {
    /**
     *
     * @type {PersonItem}
     * @memberof GetPersonResponse200AllOf
     */
    'data'?: PersonItem;
    /**
     *
     * @type {GetPersonResponse200AllOfAdditionalData}
     * @memberof GetPersonResponse200AllOf
     */
    'additional_data'?: GetPersonResponse200AllOfAdditionalData;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjects}
     * @memberof GetPersonResponse200AllOf
     */
    'related_objects'?: GetOrganizationsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetPersonResponse200AllOfAdditionalData
 */
export interface GetPersonResponse200AllOfAdditionalData {
    /**
     * Dropbox email for the person
     * @type {string}
     * @memberof GetPersonResponse200AllOfAdditionalData
     */
    'dropbox_email'?: string;
}
/**
 *
 * @export
 * @interface GetPersonsCollection200Response
 */
export interface GetPersonsCollection200Response {
    /**
     *
     * @type {boolean}
     * @memberof GetPersonsCollection200Response
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<PersonsCollectionResponseObject>}
     * @memberof GetPersonsCollection200Response
     */
    'data'?: Array<PersonsCollectionResponseObject>;
    /**
     *
     * @type {GetActivitiesCollectionResponse200AdditionalData}
     * @memberof GetPersonsCollection200Response
     */
    'additional_data'?: GetActivitiesCollectionResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface GetPersonsResponse200
 */
export interface GetPersonsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetPersonsResponse200
     */
    'success'?: boolean;
    /**
     * The array of persons
     * @type {Array<PersonItem>}
     * @memberof GetPersonsResponse200
     */
    'data'?: Array<PersonItem>;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof GetPersonsResponse200
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjects}
     * @memberof GetPersonsResponse200
     */
    'related_objects'?: GetOrganizationsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetPersonsResponse200AllOf
 */
export interface GetPersonsResponse200AllOf {
    /**
     * The array of persons
     * @type {Array<PersonItem>}
     * @memberof GetPersonsResponse200AllOf
     */
    'data'?: Array<PersonItem>;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof GetPersonsResponse200AllOf
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjects}
     * @memberof GetPersonsResponse200AllOf
     */
    'related_objects'?: GetOrganizationsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface GetPipelineConversionStatisticsResponse200
 */
export interface GetPipelineConversionStatisticsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetPipelineConversionStatisticsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetPipelineConversionStatisticsResponse200AllOfData}
     * @memberof GetPipelineConversionStatisticsResponse200
     */
    'data'?: GetPipelineConversionStatisticsResponse200AllOfData;
}
/**
 *
 * @export
 * @interface GetPipelineConversionStatisticsResponse200AllOf
 */
export interface GetPipelineConversionStatisticsResponse200AllOf {
    /**
     *
     * @type {GetPipelineConversionStatisticsResponse200AllOfData}
     * @memberof GetPipelineConversionStatisticsResponse200AllOf
     */
    'data'?: GetPipelineConversionStatisticsResponse200AllOfData;
}
/**
 * The pipeline object
 * @export
 * @interface GetPipelineConversionStatisticsResponse200AllOfData
 */
export interface GetPipelineConversionStatisticsResponse200AllOfData {
    /**
     * The stage conversions
     * @type {Array<GetPipelineConversionStatisticsResponse200AllOfDataStageConversionsInner>}
     * @memberof GetPipelineConversionStatisticsResponse200AllOfData
     */
    'stage_conversions'?: Array<GetPipelineConversionStatisticsResponse200AllOfDataStageConversionsInner>;
    /**
     * The won conversion
     * @type {number}
     * @memberof GetPipelineConversionStatisticsResponse200AllOfData
     */
    'won_conversion'?: number;
    /**
     * The lost conversion
     * @type {number}
     * @memberof GetPipelineConversionStatisticsResponse200AllOfData
     */
    'lost_conversion'?: number;
}
/**
 *
 * @export
 * @interface GetPipelineConversionStatisticsResponse200AllOfDataStageConversionsInner
 */
export interface GetPipelineConversionStatisticsResponse200AllOfDataStageConversionsInner {
    /**
     * The stage ID from where conversion starts
     * @type {number}
     * @memberof GetPipelineConversionStatisticsResponse200AllOfDataStageConversionsInner
     */
    'from_stage_id'?: number;
    /**
     * The stage ID to where conversion ends
     * @type {number}
     * @memberof GetPipelineConversionStatisticsResponse200AllOfDataStageConversionsInner
     */
    'to_stage_id'?: number;
    /**
     * The conversion rate
     * @type {number}
     * @memberof GetPipelineConversionStatisticsResponse200AllOfDataStageConversionsInner
     */
    'conversion_rate'?: number;
}
/**
 *
 * @export
 * @interface GetPipelineMovementStatisticsResponse200
 */
export interface GetPipelineMovementStatisticsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetPipelineMovementStatisticsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetPipelineMovementStatisticsResponse200AllOfData}
     * @memberof GetPipelineMovementStatisticsResponse200
     */
    'data'?: GetPipelineMovementStatisticsResponse200AllOfData;
}
/**
 *
 * @export
 * @interface GetPipelineMovementStatisticsResponse200AllOf
 */
export interface GetPipelineMovementStatisticsResponse200AllOf {
    /**
     *
     * @type {GetPipelineMovementStatisticsResponse200AllOfData}
     * @memberof GetPipelineMovementStatisticsResponse200AllOf
     */
    'data'?: GetPipelineMovementStatisticsResponse200AllOfData;
}
/**
 * The pipeline object
 * @export
 * @interface GetPipelineMovementStatisticsResponse200AllOfData
 */
export interface GetPipelineMovementStatisticsResponse200AllOfData {
    /**
     *
     * @type {GetPipelineMovementStatisticsResponse200AllOfDataMovementsBetweenStages}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfData
     */
    'movements_between_stages'?: GetPipelineMovementStatisticsResponse200AllOfDataMovementsBetweenStages;
    /**
     *
     * @type {GetPipelineMovementStatisticsResponse200AllOfDataNewDeals}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfData
     */
    'new_deals'?: GetPipelineMovementStatisticsResponse200AllOfDataNewDeals;
    /**
     *
     * @type {GetPipelineMovementStatisticsResponse200AllOfDataNewDeals}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfData
     */
    'deals_left_open'?: GetPipelineMovementStatisticsResponse200AllOfDataNewDeals;
    /**
     *
     * @type {GetPipelineMovementStatisticsResponse200AllOfDataNewDeals}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfData
     */
    'won_deals'?: GetPipelineMovementStatisticsResponse200AllOfDataNewDeals;
    /**
     *
     * @type {GetPipelineMovementStatisticsResponse200AllOfDataNewDeals}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfData
     */
    'lost_deals'?: GetPipelineMovementStatisticsResponse200AllOfDataNewDeals;
    /**
     *
     * @type {GetPipelineMovementStatisticsResponse200AllOfDataAverageAgeInDays}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfData
     */
    'average_age_in_days'?: GetPipelineMovementStatisticsResponse200AllOfDataAverageAgeInDays;
}
/**
 * The moved deals average age in days
 * @export
 * @interface GetPipelineMovementStatisticsResponse200AllOfDataAverageAgeInDays
 */
export interface GetPipelineMovementStatisticsResponse200AllOfDataAverageAgeInDays {
    /**
     * The moved deals average age across all stages
     * @type {number}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfDataAverageAgeInDays
     */
    'across_all_stages'?: number;
    /**
     * The moved deals average age by stages
     * @type {Array<GetPipelineMovementStatisticsResponse200AllOfDataAverageAgeInDaysByStagesInner>}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfDataAverageAgeInDays
     */
    'by_stages'?: Array<GetPipelineMovementStatisticsResponse200AllOfDataAverageAgeInDaysByStagesInner>;
}
/**
 * The moved deals average age by the stage
 * @export
 * @interface GetPipelineMovementStatisticsResponse200AllOfDataAverageAgeInDaysByStagesInner
 */
export interface GetPipelineMovementStatisticsResponse200AllOfDataAverageAgeInDaysByStagesInner {
    /**
     * The stage ID
     * @type {number}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfDataAverageAgeInDaysByStagesInner
     */
    'stage_id'?: number;
    /**
     * The average deals age in specific stage
     * @type {number}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfDataAverageAgeInDaysByStagesInner
     */
    'value'?: number;
}
/**
 * Movements between stages
 * @export
 * @interface GetPipelineMovementStatisticsResponse200AllOfDataMovementsBetweenStages
 */
export interface GetPipelineMovementStatisticsResponse200AllOfDataMovementsBetweenStages {
    /**
     * The count of the deals that have been moved between stages
     * @type {number}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfDataMovementsBetweenStages
     */
    'count'?: number;
}
/**
 * Deals summary
 * @export
 * @interface GetPipelineMovementStatisticsResponse200AllOfDataNewDeals
 */
export interface GetPipelineMovementStatisticsResponse200AllOfDataNewDeals {
    /**
     * The count of the deals
     * @type {number}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfDataNewDeals
     */
    'count'?: number;
    /**
     * The IDs of the deals that have been moved
     * @type {Array<number>}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfDataNewDeals
     */
    'deals_ids'?: Array<number>;
    /**
     *
     * @type {GetPipelineMovementStatisticsResponse200AllOfDataNewDealsValues}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfDataNewDeals
     */
    'values'?: GetPipelineMovementStatisticsResponse200AllOfDataNewDealsValues;
    /**
     *
     * @type {GetPipelineMovementStatisticsResponse200AllOfDataNewDealsFormattedValues}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfDataNewDeals
     */
    'formatted_values'?: GetPipelineMovementStatisticsResponse200AllOfDataNewDealsFormattedValues;
}
/**
 * The formatted values of the deals
 * @export
 * @interface GetPipelineMovementStatisticsResponse200AllOfDataNewDealsFormattedValues
 */
export interface GetPipelineMovementStatisticsResponse200AllOfDataNewDealsFormattedValues {
    /**
     * The formatted values of the deals
     * @type {string}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfDataNewDealsFormattedValues
     */
    'CURRENCY_ID'?: string;
}
/**
 * The values of the deals
 * @export
 * @interface GetPipelineMovementStatisticsResponse200AllOfDataNewDealsValues
 */
export interface GetPipelineMovementStatisticsResponse200AllOfDataNewDealsValues {
    /**
     * The value of the deals
     * @type {number}
     * @memberof GetPipelineMovementStatisticsResponse200AllOfDataNewDealsValues
     */
    'CURRENCY_ID'?: number;
}
/**
 *
 * @export
 * @interface GetPipelineResponse200
 */
export interface GetPipelineResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetPipelineResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {PipelineDetails}
     * @memberof GetPipelineResponse200
     */
    'data'?: PipelineDetails;
}
/**
 *
 * @export
 * @interface GetPipelineResponse200AllOf
 */
export interface GetPipelineResponse200AllOf {
    /**
     *
     * @type {PipelineDetails}
     * @memberof GetPipelineResponse200AllOf
     */
    'data'?: PipelineDetails;
}
/**
 *
 * @export
 * @interface GetPipelinesResponse200
 */
export interface GetPipelinesResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetPipelinesResponse200
     */
    'success'?: boolean;
    /**
     * Pipelines array
     * @type {Array<BasePipelineWithSelectedFlag>}
     * @memberof GetPipelinesResponse200
     */
    'data'?: Array<BasePipelineWithSelectedFlag>;
}
/**
 *
 * @export
 * @interface GetPipelinesResponse200AllOf
 */
export interface GetPipelinesResponse200AllOf {
    /**
     * Pipelines array
     * @type {Array<BasePipelineWithSelectedFlag>}
     * @memberof GetPipelinesResponse200AllOf
     */
    'data'?: Array<BasePipelineWithSelectedFlag>;
}
/**
 *
 * @export
 * @interface GetProductAttachementResponse200
 */
export interface GetProductAttachementResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetProductAttachementResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetProductAttachementResponse200Data}
     * @memberof GetProductAttachementResponse200
     */
    'data'?: GetProductAttachementResponse200Data;
}
/**
 * The updated product object attached to the deal
 * @export
 * @interface GetProductAttachementResponse200Data
 */
export interface GetProductAttachementResponse200Data {
    /**
     * The ID of the product
     * @type {number}
     * @memberof GetProductAttachementResponse200Data
     */
    'product_id': number;
    /**
     * The price at which this product will be added to the deal
     * @type {number}
     * @memberof GetProductAttachementResponse200Data
     */
    'item_price': number;
    /**
     * Quantity – e.g. how many items of this product will be added to the deal
     * @type {number}
     * @memberof GetProductAttachementResponse200Data
     */
    'quantity': number;
    /**
     * The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage.
     * @type {number}
     * @memberof GetProductAttachementResponse200Data
     */
    'discount'?: number;
    /**
     * The type of the discount\'s value.
     * @type {string}
     * @memberof GetProductAttachementResponse200Data
     */
    'discount_type'?: GetProductAttachementResponse200DataDiscountTypeConst;
    /**
     * The duration of the product. If omitted, will be set to 1.
     * @type {number}
     * @memberof GetProductAttachementResponse200Data
     */
    'duration'?: number;
    /**
     * The type of the duration. (For example hourly, daily, etc.)
     * @type {string}
     * @memberof GetProductAttachementResponse200Data
     */
    'duration_unit'?: string;
    /**
     * The ID of the product variation to use. When omitted, no variation will be used.
     * @type {number}
     * @memberof GetProductAttachementResponse200Data
     */
    'product_variation_id'?: number | null;
    /**
     * A textual comment associated with this product-deal attachment
     * @type {string}
     * @memberof GetProductAttachementResponse200Data
     */
    'comments'?: string;
    /**
     * The product tax
     * @type {number}
     * @memberof GetProductAttachementResponse200Data
     */
    'tax'?: number;
    /**
     * The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal.
     * @type {string}
     * @memberof GetProductAttachementResponse200Data
     */
    'tax_method'?: GetProductAttachementResponse200DataTaxMethodConst;
    /**
     * Whether the product is enabled for a deal or not. This makes it possible to add products to a deal with a specific price and discount criteria, but keep them disabled, which refrains them from being included in the deal value calculation. When omitted, the product will be marked as enabled by default.
     * @type {boolean}
     * @memberof GetProductAttachementResponse200Data
     */
    'enabled_flag'?: boolean;
    /**
     * The ID of the deal-product (the ID of the product attached to the deal)
     * @type {number}
     * @memberof GetProductAttachementResponse200Data
     */
    'id'?: number;
    /**
     * The ID of the company
     * @type {number}
     * @memberof GetProductAttachementResponse200Data
     */
    'company_id'?: number;
    /**
     * The ID of the deal
     * @type {number}
     * @memberof GetProductAttachementResponse200Data
     */
    'deal_id'?: number;
    /**
     * The sum of all the products attached to the deal
     * @type {number}
     * @memberof GetProductAttachementResponse200Data
     */
    'sum'?: number;
    /**
     * The currency associated with the deal product
     * @type {string}
     * @memberof GetProductAttachementResponse200Data
     */
    'currency'?: string;
    /**
     * The date and time when the product was added to the deal
     * @type {string}
     * @memberof GetProductAttachementResponse200Data
     */
    'add_time'?: string;
    /**
     * The date and time when the deal product was last edited
     * @type {string}
     * @memberof GetProductAttachementResponse200Data
     */
    'last_edit'?: string;
    /**
     * Whether the product is active or not
     * @type {boolean}
     * @memberof GetProductAttachementResponse200Data
     */
    'active_flag'?: boolean;
    /**
     * The product name
     * @type {string}
     * @memberof GetProductAttachementResponse200Data
     */
    'name'?: string;
}

export const GetProductAttachementResponse200DataDiscountTypeConst = {
    percentage: 'percentage',
    amount: 'amount'
} as const;

export type GetProductAttachementResponse200DataDiscountTypeConst = typeof GetProductAttachementResponse200DataDiscountTypeConst[keyof typeof GetProductAttachementResponse200DataDiscountTypeConst];
export const GetProductAttachementResponse200DataTaxMethodConst = {
    exclusive: 'exclusive',
    inclusive: 'inclusive',
    none: 'none'
} as const;

export type GetProductAttachementResponse200DataTaxMethodConst = typeof GetProductAttachementResponse200DataTaxMethodConst[keyof typeof GetProductAttachementResponse200DataTaxMethodConst];

/**
 *
 * @export
 * @interface GetProductFieldResponse200
 */
export interface GetProductFieldResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetProductFieldResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetProductFieldResponse200Data}
     * @memberof GetProductFieldResponse200
     */
    'data'?: GetProductFieldResponse200Data;
}
/**
 * All data for the product field
 * @export
 * @interface GetProductFieldResponse200Data
 */
export interface GetProductFieldResponse200Data {
    /**
     * The name of the field
     * @type {string}
     * @memberof GetProductFieldResponse200Data
     */
    'name': string;
    /**
     * When `field_type` is either `set` or `enum`, possible options must be supplied as a JSON-encoded sequential array, for example:</br>`[{\"label\":\"red\"}, {\"label\":\"blue\"}, {\"label\":\"lilac\"}]`
     * @type {Array<object>}
     * @memberof GetProductFieldResponse200Data
     */
    'options'?: Array<object>;
    /**
     * The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td><tr><td>`text`</td><td>Long text (up to 65k characters)</td><tr><td>`double`</td><td>Numeric value</td><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td><tr><td>`enum`</td><td>Options field with a single possible chosen option</td><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td><tr><td>`people`</td><td>Person field (contains a product ID which is stored on the same account)</td><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td><tr><td>`address`</td><td>Address field (autocompleted by Google Maps)</dd></table>
     * @type {string}
     * @memberof GetProductFieldResponse200Data
     */
    'field_type': GetProductFieldResponse200DataFieldTypeConst;
    /**
     * The ID of the product field
     * @type {number}
     * @memberof GetProductFieldResponse200Data
     */
    'id'?: number;
    /**
     * The key of the product field
     * @type {string}
     * @memberof GetProductFieldResponse200Data
     */
    'key'?: string;
    /**
     * The position (index) of the product field in the detail view
     * @type {number}
     * @memberof GetProductFieldResponse200Data
     */
    'order_nr'?: number;
    /**
     * The product field creation time. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetProductFieldResponse200Data
     */
    'add_time'?: string;
    /**
     * The product field last update time. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetProductFieldResponse200Data
     */
    'update_time'?: string;
    /**
     * The ID of the last user to update the product field
     * @type {number}
     * @memberof GetProductFieldResponse200Data
     */
    'last_updated_by_user_id'?: number;
    /**
     * Whether or not the product field is currently active
     * @type {boolean}
     * @memberof GetProductFieldResponse200Data
     */
    'active_flag'?: boolean;
    /**
     * Whether or not the product field name and metadata is editable
     * @type {boolean}
     * @memberof GetProductFieldResponse200Data
     */
    'edit_flag'?: boolean;
    /**
     * Whether or not the product field is visible in the Add Product Modal
     * @type {boolean}
     * @memberof GetProductFieldResponse200Data
     */
    'add_visible_flag'?: boolean;
    /**
     * Whether or not the product field is marked as important
     * @type {boolean}
     * @memberof GetProductFieldResponse200Data
     */
    'important_flag'?: boolean;
    /**
     * Whether or not the product field data can be edited
     * @type {boolean}
     * @memberof GetProductFieldResponse200Data
     */
    'bulk_edit_allowed'?: boolean;
    /**
     * Whether or not the product field is searchable
     * @type {boolean}
     * @memberof GetProductFieldResponse200Data
     */
    'searchable_flag'?: boolean;
    /**
     * Whether or not the product field value can be used when filtering searches
     * @type {boolean}
     * @memberof GetProductFieldResponse200Data
     */
    'filtering_allowed'?: boolean;
    /**
     * Whether or not the product field is sortable
     * @type {boolean}
     * @memberof GetProductFieldResponse200Data
     */
    'sortable_flag'?: boolean;
    /**
     * Whether or not the product field is mandatory when creating products
     * @type {boolean}
     * @memberof GetProductFieldResponse200Data
     */
    'mandatory_flag'?: boolean;
}

export const GetProductFieldResponse200DataFieldTypeConst = {
    varchar: 'varchar',
    varchar_auto: 'varchar_auto',
    text: 'text',
    double: 'double',
    monetary: 'monetary',
    date: 'date',
    set: 'set',
    enum: 'enum',
    user: 'user',
    org: 'org',
    people: 'people',
    phone: 'phone',
    time: 'time',
    timerange: 'timerange',
    daterange: 'daterange',
    address: 'address'
} as const;

export type GetProductFieldResponse200DataFieldTypeConst = typeof GetProductFieldResponse200DataFieldTypeConst[keyof typeof GetProductFieldResponse200DataFieldTypeConst];

/**
 *
 * @export
 * @interface GetProductFieldsResponse200
 */
export interface GetProductFieldsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetProductFieldsResponse200
     */
    'success'?: boolean;
    /**
     * Array containing data for all product fields
     * @type {Array<ProductField>}
     * @memberof GetProductFieldsResponse200
     */
    'data'?: Array<ProductField>;
    /**
     * Additional data for the product field, such as pagination
     * @type {object}
     * @memberof GetProductFieldsResponse200
     */
    'additional_data'?: object;
}
/**
 *
 * @export
 * @interface GetProductFollowersResponseSuccess
 */
export interface GetProductFollowersResponseSuccess {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetProductFollowersResponseSuccess
     */
    'success'?: boolean;
    /**
     * The list of followers
     * @type {Array<GetProductFollowersResponseSuccessAllOfDataInner>}
     * @memberof GetProductFollowersResponseSuccess
     */
    'data'?: Array<GetProductFollowersResponseSuccessAllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetProductFollowersResponseSuccess
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetProductFollowersResponseSuccessAllOf
 */
export interface GetProductFollowersResponseSuccessAllOf {
    /**
     * The list of followers
     * @type {Array<GetProductFollowersResponseSuccessAllOfDataInner>}
     * @memberof GetProductFollowersResponseSuccessAllOf
     */
    'data'?: Array<GetProductFollowersResponseSuccessAllOfDataInner>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetProductFollowersResponseSuccessAllOf
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetProductFollowersResponseSuccessAllOfDataInner
 */
export interface GetProductFollowersResponseSuccessAllOfDataInner {
    /**
     * The ID of the user
     * @type {number}
     * @memberof GetProductFollowersResponseSuccessAllOfDataInner
     */
    'user_id'?: number;
    /**
     * The ID of the user follower
     * @type {number}
     * @memberof GetProductFollowersResponseSuccessAllOfDataInner
     */
    'id'?: number;
    /**
     * The ID of the product
     * @type {number}
     * @memberof GetProductFollowersResponseSuccessAllOfDataInner
     */
    'product_id'?: number;
    /**
     * The date and time when the follower was added to the person
     * @type {string}
     * @memberof GetProductFollowersResponseSuccessAllOfDataInner
     */
    'add_time'?: string;
}
/**
 *
 * @export
 * @interface GetProductsResponse200
 */
export interface GetProductsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetProductsResponse200
     */
    'success'?: boolean;
    /**
     * Array containing data for all products
     * @type {Array<GetproductResponse200>}
     * @memberof GetProductsResponse200
     */
    'data'?: Array<GetproductResponse200>;
    /**
     *
     * @type {GetProductsResponse200AdditionalData}
     * @memberof GetProductsResponse200
     */
    'additional_data'?: GetProductsResponse200AdditionalData;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjects}
     * @memberof GetProductsResponse200
     */
    'related_objects'?: GetActivitiesResponse200RelatedObjects;
}
/**
 * Any additional data related to the products
 * @export
 * @interface GetProductsResponse200AdditionalData
 */
export interface GetProductsResponse200AdditionalData {
    /**
     * Pagination start
     * @type {number}
     * @memberof GetProductsResponse200AdditionalData
     */
    'start'?: number;
    /**
     * Items shown per page
     * @type {number}
     * @memberof GetProductsResponse200AdditionalData
     */
    'limit'?: number;
    /**
     * If there are more list items in the collection than displayed or not
     * @type {boolean}
     * @memberof GetProductsResponse200AdditionalData
     */
    'more_items_in_collection'?: boolean;
}
/**
 *
 * @export
 * @interface GetProjectBoardResponse200
 */
export interface GetProjectBoardResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetProjectBoardResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetProjectBoardsResponse200DataInner}
     * @memberof GetProjectBoardResponse200
     */
    'data'?: GetProjectBoardsResponse200DataInner;
    /**
     *
     * @type {object}
     * @memberof GetProjectBoardResponse200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface GetProjectBoardsResponse200
 */
export interface GetProjectBoardsResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetProjectBoardsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<GetProjectBoardsResponse200DataInner>}
     * @memberof GetProjectBoardsResponse200
     */
    'data'?: Array<GetProjectBoardsResponse200DataInner>;
    /**
     *
     * @type {object}
     * @memberof GetProjectBoardsResponse200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface GetProjectBoardsResponse200DataInner
 */
export interface GetProjectBoardsResponse200DataInner {
    /**
     * The ID of the project board
     * @type {number}
     * @memberof GetProjectBoardsResponse200DataInner
     */
    'id'?: number;
    /**
     * Name of a project board
     * @type {string}
     * @memberof GetProjectBoardsResponse200DataInner
     */
    'name'?: string;
    /**
     * The order of a board
     * @type {number}
     * @memberof GetProjectBoardsResponse200DataInner
     */
    'order_nr'?: number;
    /**
     * The creation date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof GetProjectBoardsResponse200DataInner
     */
    'add_time'?: string;
    /**
     * The update date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof GetProjectBoardsResponse200DataInner
     */
    'update_time'?: string;
}
/**
 *
 * @export
 * @interface GetProjectGroupsResponse200
 */
export interface GetProjectGroupsResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetProjectGroupsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<GetProjectGroupsResponse200DataInner>}
     * @memberof GetProjectGroupsResponse200
     */
    'data'?: Array<GetProjectGroupsResponse200DataInner>;
    /**
     *
     * @type {object}
     * @memberof GetProjectGroupsResponse200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface GetProjectGroupsResponse200DataInner
 */
export interface GetProjectGroupsResponse200DataInner {
    /**
     * ID of the group
     * @type {number}
     * @memberof GetProjectGroupsResponse200DataInner
     */
    'id'?: number;
    /**
     * Name of the group
     * @type {string}
     * @memberof GetProjectGroupsResponse200DataInner
     */
    'name'?: string;
    /**
     * Order number of the group
     * @type {number}
     * @memberof GetProjectGroupsResponse200DataInner
     */
    'order_nr'?: number;
}
/**
 *
 * @export
 * @interface GetProjectPhaseResponse200
 */
export interface GetProjectPhaseResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetProjectPhaseResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetProjectPhasesResponse200DataInner}
     * @memberof GetProjectPhaseResponse200
     */
    'data'?: GetProjectPhasesResponse200DataInner;
    /**
     *
     * @type {object}
     * @memberof GetProjectPhaseResponse200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface GetProjectPhasesResponse200
 */
export interface GetProjectPhasesResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetProjectPhasesResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<GetProjectPhasesResponse200DataInner>}
     * @memberof GetProjectPhasesResponse200
     */
    'data'?: Array<GetProjectPhasesResponse200DataInner>;
    /**
     *
     * @type {object}
     * @memberof GetProjectPhasesResponse200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface GetProjectPhasesResponse200DataInner
 */
export interface GetProjectPhasesResponse200DataInner {
    /**
     * The ID of the project phase
     * @type {number}
     * @memberof GetProjectPhasesResponse200DataInner
     */
    'id'?: number;
    /**
     * Name of a project phase
     * @type {string}
     * @memberof GetProjectPhasesResponse200DataInner
     */
    'name'?: string;
    /**
     * The ID of the project board this phase is linked to
     * @type {number}
     * @memberof GetProjectPhasesResponse200DataInner
     */
    'board_id'?: number;
    /**
     * The order of a phase
     * @type {number}
     * @memberof GetProjectPhasesResponse200DataInner
     */
    'order_nr'?: number;
    /**
     * The creation date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof GetProjectPhasesResponse200DataInner
     */
    'add_time'?: string;
    /**
     * The update date and time of the board in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof GetProjectPhasesResponse200DataInner
     */
    'update_time'?: string;
}
/**
 *
 * @export
 * @interface GetProjectPlanResponse200
 */
export interface GetProjectPlanResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetProjectPlanResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<GetProjectPlanResponse200DataInner>}
     * @memberof GetProjectPlanResponse200
     */
    'data'?: Array<GetProjectPlanResponse200DataInner>;
    /**
     *
     * @type {object}
     * @memberof GetProjectPlanResponse200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface GetProjectPlanResponse200DataInner
 */
export interface GetProjectPlanResponse200DataInner {
    /**
     * ID of plan item (either activity or task ID)
     * @type {number}
     * @memberof GetProjectPlanResponse200DataInner
     */
    'item_id'?: number;
    /**
     * Type of a plan item (task / activity)
     * @type {string}
     * @memberof GetProjectPlanResponse200DataInner
     */
    'item_type'?: string;
    /**
     * The ID of the board this project is associated with. If null then plan item is not in any phase.
     * @type {number}
     * @memberof GetProjectPlanResponse200DataInner
     */
    'phase_id'?: number;
    /**
     * The ID of the board this project is associated with. If null then plan item is not in any group.
     * @type {number}
     * @memberof GetProjectPlanResponse200DataInner
     */
    'group_id'?: number;
}
/**
 *
 * @export
 * @interface GetProjectResponse200
 */
export interface GetProjectResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetProjectResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {ProjectResponseObject}
     * @memberof GetProjectResponse200
     */
    'data'?: ProjectResponseObject;
    /**
     *
     * @type {object}
     * @memberof GetProjectResponse200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface GetProjectTemplateResponse200
 */
export interface GetProjectTemplateResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetProjectTemplateResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {TemplateResponseObject}
     * @memberof GetProjectTemplateResponse200
     */
    'data'?: TemplateResponseObject;
    /**
     *
     * @type {object}
     * @memberof GetProjectTemplateResponse200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface GetProjectTemplatesResponse200
 */
export interface GetProjectTemplatesResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetProjectTemplatesResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<TemplateResponseObject>}
     * @memberof GetProjectTemplatesResponse200
     */
    'data'?: Array<TemplateResponseObject>;
    /**
     *
     * @type {GetActivitiesCollectionResponse200AdditionalData}
     * @memberof GetProjectTemplatesResponse200
     */
    'additional_data'?: GetActivitiesCollectionResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface GetProjectsResponse200
 */
export interface GetProjectsResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetProjectsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<ProjectResponseObject>}
     * @memberof GetProjectsResponse200
     */
    'data'?: Array<ProjectResponseObject>;
    /**
     *
     * @type {GetActivitiesCollectionResponse200AdditionalData}
     * @memberof GetProjectsResponse200
     */
    'additional_data'?: GetActivitiesCollectionResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface GetRecentsResponse200
 */
export interface GetRecentsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetRecentsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<GetRecentsResponse200DataInner>}
     * @memberof GetRecentsResponse200
     */
    'data'?: Array<GetRecentsResponse200DataInner>;
    /**
     *
     * @type {GetRecentsResponse200AdditionalData}
     * @memberof GetRecentsResponse200
     */
    'additional_data'?: GetRecentsResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface GetRecentsResponse200AdditionalData
 */
export interface GetRecentsResponse200AdditionalData {
    /**
     * The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetRecentsResponse200AdditionalData
     */
    'since_timestamp'?: string;
    /**
     * The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetRecentsResponse200AdditionalData
     */
    'last_timestamp_on_page'?: string;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetRecentsResponse200AdditionalData
     */
    'pagination'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetRecentsResponse200DataInner
 */
export interface GetRecentsResponse200DataInner {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInner
     */
    'item'?: GetRecentsResponse200DataInnerItemConst;
    /**
     *
     * @type {number}
     * @memberof GetRecentsResponse200DataInner
     */
    'id'?: number;
    /**
     *
     * @type {GetRecentsResponse200DataInnerAnyOf11Data}
     * @memberof GetRecentsResponse200DataInner
     */
    'data'?: GetRecentsResponse200DataInnerAnyOf11Data;
}

export const GetRecentsResponse200DataInnerItemConst = {
    user: 'user'
} as const;

export type GetRecentsResponse200DataInnerItemConst = typeof GetRecentsResponse200DataInnerItemConst[keyof typeof GetRecentsResponse200DataInnerItemConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf
 */
export interface GetRecentsResponse200DataInnerAnyOf {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf
     */
    'item'?: GetRecentsResponse200DataInnerAnyOfItemConst;
    /**
     *
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf
     */
    'id'?: number;
    /**
     *
     * @type {ActivityResponseObject}
     * @memberof GetRecentsResponse200DataInnerAnyOf
     */
    'data'?: ActivityResponseObject;
}

export const GetRecentsResponse200DataInnerAnyOfItemConst = {
    activity: 'activity'
} as const;

export type GetRecentsResponse200DataInnerAnyOfItemConst = typeof GetRecentsResponse200DataInnerAnyOfItemConst[keyof typeof GetRecentsResponse200DataInnerAnyOfItemConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf1
 */
export interface GetRecentsResponse200DataInnerAnyOf1 {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf1
     */
    'item'?: GetRecentsResponse200DataInnerAnyOf1ItemConst;
    /**
     *
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf1
     */
    'id'?: number;
    /**
     *
     * @type {GetActivityTypesResponse200AllOfDataInner}
     * @memberof GetRecentsResponse200DataInnerAnyOf1
     */
    'data'?: GetActivityTypesResponse200AllOfDataInner;
}

export const GetRecentsResponse200DataInnerAnyOf1ItemConst = {
    activityType: 'activityType'
} as const;

export type GetRecentsResponse200DataInnerAnyOf1ItemConst = typeof GetRecentsResponse200DataInnerAnyOf1ItemConst[keyof typeof GetRecentsResponse200DataInnerAnyOf1ItemConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf10
 */
export interface GetRecentsResponse200DataInnerAnyOf10 {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf10
     */
    'item'?: GetRecentsResponse200DataInnerAnyOf10ItemConst;
    /**
     *
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf10
     */
    'id'?: number;
    /**
     *
     * @type {GetAssociatedDealsResponse200AllOfRelatedObjectsStage}
     * @memberof GetRecentsResponse200DataInnerAnyOf10
     */
    'data'?: GetAssociatedDealsResponse200AllOfRelatedObjectsStage;
}

export const GetRecentsResponse200DataInnerAnyOf10ItemConst = {
    stage: 'stage'
} as const;

export type GetRecentsResponse200DataInnerAnyOf10ItemConst = typeof GetRecentsResponse200DataInnerAnyOf10ItemConst[keyof typeof GetRecentsResponse200DataInnerAnyOf10ItemConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf11
 */
export interface GetRecentsResponse200DataInnerAnyOf11 {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11
     */
    'item'?: GetRecentsResponse200DataInnerAnyOf11ItemConst;
    /**
     *
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf11
     */
    'id'?: number;
    /**
     *
     * @type {GetRecentsResponse200DataInnerAnyOf11Data}
     * @memberof GetRecentsResponse200DataInnerAnyOf11
     */
    'data'?: GetRecentsResponse200DataInnerAnyOf11Data;
}

export const GetRecentsResponse200DataInnerAnyOf11ItemConst = {
    user: 'user'
} as const;

export type GetRecentsResponse200DataInnerAnyOf11ItemConst = typeof GetRecentsResponse200DataInnerAnyOf11ItemConst[keyof typeof GetRecentsResponse200DataInnerAnyOf11ItemConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf11Data
 */
export interface GetRecentsResponse200DataInnerAnyOf11Data {
    /**
     * The user ID
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'id'?: number;
    /**
     * The user name
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'name'?: string;
    /**
     * The user default currency
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'default_currency'?: string;
    /**
     * The user locale
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'locale'?: string;
    /**
     * The user language ID
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'lang'?: number;
    /**
     * The user email
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'email'?: string;
    /**
     * The user phone
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'phone'?: string | null;
    /**
     * Boolean that indicates whether the user is activated
     * @type {boolean}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'activated'?: boolean;
    /**
     * The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'last_login'?: string;
    /**
     * The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'created'?: string;
    /**
     * The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'modified'?: string | null;
    /**
     * Boolean that indicates whether the user has created a company
     * @type {boolean}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'has_created_company'?: boolean;
    /**
     *
     * @type {Array<GetRecentsResponse200DataInnerAnyOf11DataAccessInner>}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'access'?: Array<GetRecentsResponse200DataInnerAnyOf11DataAccessInner>;
    /**
     * Boolean that indicates whether the user is activated
     * @type {boolean}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'active_flag'?: boolean;
    /**
     * The user timezone name
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'timezone_name'?: string;
    /**
     * The user timezone offset
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'timezone_offset'?: string;
    /**
     * The ID of the user role
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'role_id'?: number;
    /**
     * The user icon URL
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'icon_url'?: string | null;
    /**
     * Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
     * @type {boolean}
     * @memberof GetRecentsResponse200DataInnerAnyOf11Data
     */
    'is_you'?: boolean;
}
/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf11DataAccessInner
 */
export interface GetRecentsResponse200DataInnerAnyOf11DataAccessInner {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11DataAccessInner
     */
    'app'?: GetRecentsResponse200DataInnerAnyOf11DataAccessInnerAppConst;
    /**
     *
     * @type {boolean}
     * @memberof GetRecentsResponse200DataInnerAnyOf11DataAccessInner
     */
    'admin'?: boolean;
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf11DataAccessInner
     */
    'permission_set_id'?: string;
}

export const GetRecentsResponse200DataInnerAnyOf11DataAccessInnerAppConst = {
    sales: 'sales',
    projects: 'projects',
    campaigns: 'campaigns',
    global: 'global',
    account_settings: 'account_settings'
} as const;

export type GetRecentsResponse200DataInnerAnyOf11DataAccessInnerAppConst = typeof GetRecentsResponse200DataInnerAnyOf11DataAccessInnerAppConst[keyof typeof GetRecentsResponse200DataInnerAnyOf11DataAccessInnerAppConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf2
 */
export interface GetRecentsResponse200DataInnerAnyOf2 {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf2
     */
    'item'?: GetRecentsResponse200DataInnerAnyOf2ItemConst;
    /**
     *
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf2
     */
    'id'?: number;
    /**
     *
     * @type {DealStrict}
     * @memberof GetRecentsResponse200DataInnerAnyOf2
     */
    'data'?: DealStrict;
}

export const GetRecentsResponse200DataInnerAnyOf2ItemConst = {
    deal: 'deal'
} as const;

export type GetRecentsResponse200DataInnerAnyOf2ItemConst = typeof GetRecentsResponse200DataInnerAnyOf2ItemConst[keyof typeof GetRecentsResponse200DataInnerAnyOf2ItemConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf3
 */
export interface GetRecentsResponse200DataInnerAnyOf3 {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf3
     */
    'item'?: GetRecentsResponse200DataInnerAnyOf3ItemConst;
    /**
     *
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf3
     */
    'id'?: number;
    /**
     *
     * @type {GetAssociatedFilesResponse200AllOfDataInner}
     * @memberof GetRecentsResponse200DataInnerAnyOf3
     */
    'data'?: GetAssociatedFilesResponse200AllOfDataInner;
}

export const GetRecentsResponse200DataInnerAnyOf3ItemConst = {
    file: 'file'
} as const;

export type GetRecentsResponse200DataInnerAnyOf3ItemConst = typeof GetRecentsResponse200DataInnerAnyOf3ItemConst[keyof typeof GetRecentsResponse200DataInnerAnyOf3ItemConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf4
 */
export interface GetRecentsResponse200DataInnerAnyOf4 {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf4
     */
    'item'?: GetRecentsResponse200DataInnerAnyOf4ItemConst;
    /**
     *
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf4
     */
    'id'?: number;
    /**
     *
     * @type {GetFiltersResponse200AllOfDataInner}
     * @memberof GetRecentsResponse200DataInnerAnyOf4
     */
    'data'?: GetFiltersResponse200AllOfDataInner;
}

export const GetRecentsResponse200DataInnerAnyOf4ItemConst = {
    filter: 'filter'
} as const;

export type GetRecentsResponse200DataInnerAnyOf4ItemConst = typeof GetRecentsResponse200DataInnerAnyOf4ItemConst[keyof typeof GetRecentsResponse200DataInnerAnyOf4ItemConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf5
 */
export interface GetRecentsResponse200DataInnerAnyOf5 {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf5
     */
    'item'?: GetRecentsResponse200DataInnerAnyOf5ItemConst;
    /**
     *
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf5
     */
    'id'?: number;
    /**
     *
     * @type {GetNotesResponse200DataInner}
     * @memberof GetRecentsResponse200DataInnerAnyOf5
     */
    'data'?: GetNotesResponse200DataInner;
}

export const GetRecentsResponse200DataInnerAnyOf5ItemConst = {
    note: 'note'
} as const;

export type GetRecentsResponse200DataInnerAnyOf5ItemConst = typeof GetRecentsResponse200DataInnerAnyOf5ItemConst[keyof typeof GetRecentsResponse200DataInnerAnyOf5ItemConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf6
 */
export interface GetRecentsResponse200DataInnerAnyOf6 {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf6
     */
    'item'?: GetRecentsResponse200DataInnerAnyOf6ItemConst;
    /**
     *
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf6
     */
    'id'?: number;
    /**
     *
     * @type {MergePersonItem}
     * @memberof GetRecentsResponse200DataInnerAnyOf6
     */
    'data'?: MergePersonItem;
}

export const GetRecentsResponse200DataInnerAnyOf6ItemConst = {
    person: 'person'
} as const;

export type GetRecentsResponse200DataInnerAnyOf6ItemConst = typeof GetRecentsResponse200DataInnerAnyOf6ItemConst[keyof typeof GetRecentsResponse200DataInnerAnyOf6ItemConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf7
 */
export interface GetRecentsResponse200DataInnerAnyOf7 {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf7
     */
    'item'?: GetRecentsResponse200DataInnerAnyOf7ItemConst;
    /**
     *
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf7
     */
    'id'?: number;
    /**
     *
     * @type {BaseOrganizationItem}
     * @memberof GetRecentsResponse200DataInnerAnyOf7
     */
    'data'?: BaseOrganizationItem;
}

export const GetRecentsResponse200DataInnerAnyOf7ItemConst = {
    organization: 'organization'
} as const;

export type GetRecentsResponse200DataInnerAnyOf7ItemConst = typeof GetRecentsResponse200DataInnerAnyOf7ItemConst[keyof typeof GetRecentsResponse200DataInnerAnyOf7ItemConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf8
 */
export interface GetRecentsResponse200DataInnerAnyOf8 {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf8
     */
    'item'?: GetRecentsResponse200DataInnerAnyOf8ItemConst;
    /**
     *
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf8
     */
    'id'?: number;
    /**
     *
     * @type {GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline}
     * @memberof GetRecentsResponse200DataInnerAnyOf8
     */
    'data'?: GetAssociatedDealsResponse200AllOfRelatedObjectsPipeline;
}

export const GetRecentsResponse200DataInnerAnyOf8ItemConst = {
    pipeline: 'pipeline'
} as const;

export type GetRecentsResponse200DataInnerAnyOf8ItemConst = typeof GetRecentsResponse200DataInnerAnyOf8ItemConst[keyof typeof GetRecentsResponse200DataInnerAnyOf8ItemConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf9
 */
export interface GetRecentsResponse200DataInnerAnyOf9 {
    /**
     *
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf9
     */
    'item'?: GetRecentsResponse200DataInnerAnyOf9ItemConst;
    /**
     *
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf9
     */
    'id'?: number;
    /**
     *
     * @type {GetRecentsResponse200DataInnerAnyOf9Data}
     * @memberof GetRecentsResponse200DataInnerAnyOf9
     */
    'data'?: GetRecentsResponse200DataInnerAnyOf9Data;
}

export const GetRecentsResponse200DataInnerAnyOf9ItemConst = {
    product: 'product'
} as const;

export type GetRecentsResponse200DataInnerAnyOf9ItemConst = typeof GetRecentsResponse200DataInnerAnyOf9ItemConst[keyof typeof GetRecentsResponse200DataInnerAnyOf9ItemConst];

/**
 *
 * @export
 * @interface GetRecentsResponse200DataInnerAnyOf9Data
 */
export interface GetRecentsResponse200DataInnerAnyOf9Data {
    /**
     * The ID of the product
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'id'?: number;
    /**
     * The name of the product
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'name'?: string;
    /**
     * The product code
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'code'?: string;
    /**
     * The description of the product
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'description'?: string;
    /**
     * The unit in which this product is sold
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'unit'?: string;
    /**
     * The tax percentage
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'tax'?: number;
    /**
     * The category of the product
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'category'?: string;
    /**
     * Whether this product will be made active or not
     * @type {boolean}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'active_flag'?: boolean;
    /**
     * Whether this product can be selected in deals or not
     * @type {boolean}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'selectable'?: boolean;
    /**
     * The first letter of the product name
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'first_char'?: string;
    /**
     * The visibility of the product. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'visible_to'?: number;
    /**
     * The ID of the user who will be marked as the owner of this product. When omitted, authorized user ID will be used.
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'owner_id'?: number;
    /**
     * The count of files
     * @type {number}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'files_count'?: number;
    /**
     * The date and time when the product was added to the deal
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'add_time'?: string;
    /**
     * The date and time when the product was updated to the deal
     * @type {string}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'update_time'?: string;
    /**
     * Array of objects, each containing: `currency` (string), `price` (number), `cost` (number, optional), `overhead_cost` (number, optional). Note that there can only be one price per product per currency. When `prices` is omitted altogether, a default price of 0 and a default currency based on the company\'s currency will be assigned.
     * @type {Array<object>}
     * @memberof GetRecentsResponse200DataInnerAnyOf9Data
     */
    'prices'?: Array<object>;
}
/**
 *
 * @export
 * @interface GetRolePipelines200
 */
export interface GetRolePipelines200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetRolePipelines200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetRolePipelines200AllOfData}
     * @memberof GetRolePipelines200
     */
    'data'?: GetRolePipelines200AllOfData;
}
/**
 *
 * @export
 * @interface GetRolePipelines200AllOf
 */
export interface GetRolePipelines200AllOf {
    /**
     *
     * @type {GetRolePipelines200AllOfData}
     * @memberof GetRolePipelines200AllOf
     */
    'data'?: GetRolePipelines200AllOfData;
}
/**
 * The response data
 * @export
 * @interface GetRolePipelines200AllOfData
 */
export interface GetRolePipelines200AllOfData {
    /**
     * Either visible or hidden pipeline ids
     * @type {Array<number>}
     * @memberof GetRolePipelines200AllOfData
     */
    'pipeline_ids'?: Array<number>;
    /**
     * Whether visible or hidden pipeline ids were returned
     * @type {boolean}
     * @memberof GetRolePipelines200AllOfData
     */
    'visible'?: boolean;
}
/**
 *
 * @export
 * @interface GetRoleResponse200
 */
export interface GetRoleResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetRoleResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {SubRole}
     * @memberof GetRoleResponse200
     */
    'data'?: SubRole;
    /**
     *
     * @type {GetRoleResponse200AllOfAdditionalData}
     * @memberof GetRoleResponse200
     */
    'additional_data'?: GetRoleResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetRoleResponse200AllOf
 */
export interface GetRoleResponse200AllOf {
    /**
     *
     * @type {SubRole}
     * @memberof GetRoleResponse200AllOf
     */
    'data'?: SubRole;
    /**
     *
     * @type {GetRoleResponse200AllOfAdditionalData}
     * @memberof GetRoleResponse200AllOf
     */
    'additional_data'?: GetRoleResponse200AllOfAdditionalData;
}
/**
 * The additional data in the role
 * @export
 * @interface GetRoleResponse200AllOfAdditionalData
 */
export interface GetRoleResponse200AllOfAdditionalData {
    /**
     *
     * @type {GetRoleResponse200AllOfAdditionalDataSettings}
     * @memberof GetRoleResponse200AllOfAdditionalData
     */
    'settings'?: GetRoleResponse200AllOfAdditionalDataSettings;
}
/**
 * The settings for the role
 * @export
 * @interface GetRoleResponse200AllOfAdditionalDataSettings
 */
export interface GetRoleResponse200AllOfAdditionalDataSettings {
    /**
     * The default visibility level of the deals for the role
     * @type {number}
     * @memberof GetRoleResponse200AllOfAdditionalDataSettings
     */
    'deal_default_visibility'?: number;
    /**
     * The default visibility level of the leads for the role
     * @type {number}
     * @memberof GetRoleResponse200AllOfAdditionalDataSettings
     */
    'lead_default_visibility'?: number;
    /**
     * The default visibility level of the organizations for the role
     * @type {number}
     * @memberof GetRoleResponse200AllOfAdditionalDataSettings
     */
    'org_default_visibility'?: number;
    /**
     * The default visibility level of the people for the role
     * @type {number}
     * @memberof GetRoleResponse200AllOfAdditionalDataSettings
     */
    'person_default_visibility'?: number;
    /**
     * The default visibility level of the products for the role
     * @type {number}
     * @memberof GetRoleResponse200AllOfAdditionalDataSettings
     */
    'product_default_visibility'?: number;
    /**
     * The access level of the deals for the role (only for default role)
     * @type {number}
     * @memberof GetRoleResponse200AllOfAdditionalDataSettings
     */
    'deal_access_level'?: number;
    /**
     * The access level of the organizations for the role (only for default role)
     * @type {number}
     * @memberof GetRoleResponse200AllOfAdditionalDataSettings
     */
    'org_access_level'?: number;
    /**
     * The access level of the people for the role (only for default role)
     * @type {number}
     * @memberof GetRoleResponse200AllOfAdditionalDataSettings
     */
    'person_access_level'?: number;
    /**
     * The access level of the products for the role (only for default role)
     * @type {number}
     * @memberof GetRoleResponse200AllOfAdditionalDataSettings
     */
    'product_access_level'?: number;
}
/**
 *
 * @export
 * @interface GetRoleSettingsResponse200
 */
export interface GetRoleSettingsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetRoleSettingsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetRoleResponse200AllOfAdditionalDataSettings}
     * @memberof GetRoleSettingsResponse200
     */
    'data'?: GetRoleResponse200AllOfAdditionalDataSettings;
}
/**
 *
 * @export
 * @interface GetRoleSettingsResponse200AllOf
 */
export interface GetRoleSettingsResponse200AllOf {
    /**
     *
     * @type {GetRoleResponse200AllOfAdditionalDataSettings}
     * @memberof GetRoleSettingsResponse200AllOf
     */
    'data'?: GetRoleResponse200AllOfAdditionalDataSettings;
}
/**
 *
 * @export
 * @interface GetRolesResponse200
 */
export interface GetRolesResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetRolesResponse200
     */
    'success'?: boolean;
    /**
     * The array of roles
     * @type {Array<FullRole>}
     * @memberof GetRolesResponse200
     */
    'data'?: Array<FullRole>;
    /**
     *
     * @type {GetRolesResponse200AllOfAdditionalData}
     * @memberof GetRolesResponse200
     */
    'additional_data'?: GetRolesResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetRolesResponse200AllOf
 */
export interface GetRolesResponse200AllOf {
    /**
     * The array of roles
     * @type {Array<FullRole>}
     * @memberof GetRolesResponse200AllOf
     */
    'data'?: Array<FullRole>;
    /**
     *
     * @type {GetRolesResponse200AllOfAdditionalData}
     * @memberof GetRolesResponse200AllOf
     */
    'additional_data'?: GetRolesResponse200AllOfAdditionalData;
}
/**
 * The additional data in the role list
 * @export
 * @interface GetRolesResponse200AllOfAdditionalData
 */
export interface GetRolesResponse200AllOfAdditionalData {
    /**
     *
     * @type {GetRolesResponse200AllOfAdditionalDataPagination}
     * @memberof GetRolesResponse200AllOfAdditionalData
     */
    'pagination'?: GetRolesResponse200AllOfAdditionalDataPagination;
}
/**
 * The pagination details in the role list
 * @export
 * @interface GetRolesResponse200AllOfAdditionalDataPagination
 */
export interface GetRolesResponse200AllOfAdditionalDataPagination {
    /**
     * Pagination start
     * @type {number}
     * @memberof GetRolesResponse200AllOfAdditionalDataPagination
     */
    'start'?: number;
    /**
     * Items shown per page
     * @type {number}
     * @memberof GetRolesResponse200AllOfAdditionalDataPagination
     */
    'limit'?: number;
    /**
     * Whether there are more list items in the collection than displayed
     * @type {boolean}
     * @memberof GetRolesResponse200AllOfAdditionalDataPagination
     */
    'more_items_in_collection'?: boolean;
}
/**
 *
 * @export
 * @interface GetStageDealsResponse200
 */
export interface GetStageDealsResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetStageDealsResponse200
     */
    'success'?: boolean;
    /**
     * The array of deals
     * @type {Array<DealStrict>}
     * @memberof GetStageDealsResponse200
     */
    'data'?: Array<DealStrict>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof GetStageDealsResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetStageResponse200
 */
export interface GetStageResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetStageResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetStageResponse200Data}
     * @memberof GetStageResponse200
     */
    'data'?: GetStageResponse200Data;
}
/**
 * The stage object
 * @export
 * @interface GetStageResponse200Data
 */
export interface GetStageResponse200Data {
    /**
     * The ID of the stage
     * @type {number}
     * @memberof GetStageResponse200Data
     */
    'id'?: number;
    /**
     * Defines the order of the stage
     * @type {number}
     * @memberof GetStageResponse200Data
     */
    'order_nr'?: number;
    /**
     * The name of the stage
     * @type {string}
     * @memberof GetStageResponse200Data
     */
    'name'?: string;
    /**
     * Whether the stage is active or deleted
     * @type {boolean}
     * @memberof GetStageResponse200Data
     */
    'active_flag'?: boolean;
    /**
     * The success probability percentage of the deal. Used/shown when the deal weighted values are used.
     * @type {number}
     * @memberof GetStageResponse200Data
     */
    'deal_probability'?: number;
    /**
     * The ID of the pipeline to add the stage to
     * @type {number}
     * @memberof GetStageResponse200Data
     */
    'pipeline_id'?: number;
    /**
     * Whether deals in this stage can become rotten
     * @type {boolean}
     * @memberof GetStageResponse200Data
     */
    'rotten_flag'?: boolean;
    /**
     * The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
     * @type {number}
     * @memberof GetStageResponse200Data
     */
    'rotten_days'?: number;
    /**
     * The stage creation time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof GetStageResponse200Data
     */
    'add_time'?: string;
    /**
     * The stage update time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof GetStageResponse200Data
     */
    'update_time'?: string;
    /**
     *
     * @type {PipelineDetailsAllOfDealsSummary}
     * @memberof GetStageResponse200Data
     */
    'deals_summary'?: PipelineDetailsAllOfDealsSummary;
}
/**
 *
 * @export
 * @interface GetStagesResponse200
 */
export interface GetStagesResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetStagesResponse200
     */
    'success'?: boolean;
    /**
     * The array of stages
     * @type {Array<GetStagesResponse200DataInner>}
     * @memberof GetStagesResponse200
     */
    'data'?: Array<GetStagesResponse200DataInner>;
}
/**
 *
 * @export
 * @interface GetStagesResponse200DataInner
 */
export interface GetStagesResponse200DataInner {
    /**
     * The ID of the stage
     * @type {number}
     * @memberof GetStagesResponse200DataInner
     */
    'id'?: number;
    /**
     * Defines the order of the stage
     * @type {number}
     * @memberof GetStagesResponse200DataInner
     */
    'order_nr'?: number;
    /**
     * The name of the stage
     * @type {string}
     * @memberof GetStagesResponse200DataInner
     */
    'name'?: string;
    /**
     * Whether the stage is active or deleted
     * @type {boolean}
     * @memberof GetStagesResponse200DataInner
     */
    'active_flag'?: boolean;
    /**
     * The success probability percentage of the deal. Used/shown when the deal weighted values are used.
     * @type {number}
     * @memberof GetStagesResponse200DataInner
     */
    'deal_probability'?: number;
    /**
     * The ID of the pipeline to add the stage to
     * @type {number}
     * @memberof GetStagesResponse200DataInner
     */
    'pipeline_id'?: number;
    /**
     * Whether deals in this stage can become rotten
     * @type {boolean}
     * @memberof GetStagesResponse200DataInner
     */
    'rotten_flag'?: boolean;
    /**
     * The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
     * @type {number}
     * @memberof GetStagesResponse200DataInner
     */
    'rotten_days'?: number;
    /**
     * The stage creation time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof GetStagesResponse200DataInner
     */
    'add_time'?: string;
    /**
     * The stage update time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof GetStagesResponse200DataInner
     */
    'update_time'?: string;
    /**
     * The name of the pipeline
     * @type {string}
     * @memberof GetStagesResponse200DataInner
     */
    'pipeline_name'?: string;
    /**
     * The pipeline deal probability. When `true`, overrides the stage probability.
     * @type {boolean}
     * @memberof GetStagesResponse200DataInner
     */
    'pipeline_deal_probability'?: boolean;
}
/**
 *
 * @export
 * @interface GetStagesResponse200DataInnerAllOf
 */
export interface GetStagesResponse200DataInnerAllOf {
    /**
     * The name of the pipeline
     * @type {string}
     * @memberof GetStagesResponse200DataInnerAllOf
     */
    'pipeline_name'?: string;
    /**
     * The pipeline deal probability. When `true`, overrides the stage probability.
     * @type {boolean}
     * @memberof GetStagesResponse200DataInnerAllOf
     */
    'pipeline_deal_probability'?: boolean;
}
/**
 *
 * @export
 * @interface GetTaskResponse200
 */
export interface GetTaskResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetTaskResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {TaskResponseObject}
     * @memberof GetTaskResponse200
     */
    'data'?: TaskResponseObject;
    /**
     *
     * @type {object}
     * @memberof GetTaskResponse200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface GetTasksResponse200
 */
export interface GetTasksResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof GetTasksResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<TaskResponseObject>}
     * @memberof GetTasksResponse200
     */
    'data'?: Array<TaskResponseObject>;
    /**
     *
     * @type {GetActivitiesCollectionResponse200AdditionalData}
     * @memberof GetTasksResponse200
     */
    'additional_data'?: GetActivitiesCollectionResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface GetUserPermissionsResponse200
 */
export interface GetUserPermissionsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetUserPermissionsResponse200AllOfData}
     * @memberof GetUserPermissionsResponse200
     */
    'data'?: GetUserPermissionsResponse200AllOfData;
}
/**
 *
 * @export
 * @interface GetUserPermissionsResponse200AllOf
 */
export interface GetUserPermissionsResponse200AllOf {
    /**
     *
     * @type {GetUserPermissionsResponse200AllOfData}
     * @memberof GetUserPermissionsResponse200AllOf
     */
    'data'?: GetUserPermissionsResponse200AllOfData;
}
/**
 *
 * @export
 * @interface GetUserPermissionsResponse200AllOfData
 */
export interface GetUserPermissionsResponse200AllOfData {
    /**
     * If the user can add custom fields
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_add_custom_fields'?: boolean;
    /**
     * If the user can add products
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_add_products'?: boolean;
    /**
     * If the user can add prospects as leads
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_add_prospects_as_leads'?: boolean;
    /**
     * If the user can bulk edit items
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_bulk_edit_items'?: boolean;
    /**
     * If the user can change visibility of items
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_change_visibility_of_items'?: boolean;
    /**
     * If the user can convert deals to leads
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_convert_deals_to_leads'?: boolean;
    /**
     * If the user can create workflows
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_create_own_workflow'?: boolean;
    /**
     * If the user can delete activities
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_delete_activities'?: boolean;
    /**
     * If the user can delete custom fields
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_delete_custom_fields'?: boolean;
    /**
     * If the user can delete deals
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_delete_deals'?: boolean;
    /**
     * If the user can edit custom fields
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_edit_custom_fields'?: boolean;
    /**
     * If the user can edit deals\' closed date
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_edit_deals_closed_date'?: boolean;
    /**
     * If the user can edit products
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_edit_products'?: boolean;
    /**
     * If the user can edit shared filters
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_edit_shared_filters'?: boolean;
    /**
     * If the user can export data from item lists
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_export_data_from_lists'?: boolean;
    /**
     * If the user can follow other users
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_follow_other_users'?: boolean;
    /**
     * If the user can merge deals
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_merge_deals'?: boolean;
    /**
     * If the user can merge organizations
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_merge_organizations'?: boolean;
    /**
     * If the user can merge people
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_merge_people'?: boolean;
    /**
     * If the user can modify labels
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_modify_labels'?: boolean;
    /**
     * If the user can see company-wide statistics
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_see_company_wide_statistics'?: boolean;
    /**
     * If the user can see the summary on the deals page
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_see_deals_list_summary'?: boolean;
    /**
     * If the user can see the names of hidden items
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_see_hidden_items_names'?: boolean;
    /**
     * If the user can see other users
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_see_other_users'?: boolean;
    /**
     * If the user can see other users\' statistics
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_see_other_users_statistics'?: boolean;
    /**
     * If the user can see security dashboard
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_see_security_dashboard'?: boolean;
    /**
     * If the user can share filters
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_share_filters'?: boolean;
    /**
     * If the user can share insights
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_share_insights'?: boolean;
    /**
     * If the user can use API
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_use_api'?: boolean;
    /**
     * If the user can use email tracking
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_use_email_tracking'?: boolean;
    /**
     * If the user can use import
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200AllOfData
     */
    'can_use_import'?: boolean;
}
/**
 *
 * @export
 * @interface GetUserRoleAssignmentsResponse200
 */
export interface GetUserRoleAssignmentsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetUserRoleAssignmentsResponse200
     */
    'success'?: boolean;
    /**
     * The role assignments
     * @type {Array<RoleAssignment>}
     * @memberof GetUserRoleAssignmentsResponse200
     */
    'data'?: Array<RoleAssignment>;
    /**
     *
     * @type {GetRolesResponse200AllOfAdditionalData}
     * @memberof GetUserRoleAssignmentsResponse200
     */
    'additional_data'?: GetRolesResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetUserRoleAssignmentsResponse200AllOf
 */
export interface GetUserRoleAssignmentsResponse200AllOf {
    /**
     * The role assignments
     * @type {Array<RoleAssignment>}
     * @memberof GetUserRoleAssignmentsResponse200AllOf
     */
    'data'?: Array<RoleAssignment>;
    /**
     *
     * @type {GetRolesResponse200AllOfAdditionalData}
     * @memberof GetUserRoleAssignmentsResponse200AllOf
     */
    'additional_data'?: GetRolesResponse200AllOfAdditionalData;
}
/**
 *
 * @export
 * @interface GetUserSettingsResponse200
 */
export interface GetUserSettingsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetUserSettingsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetUserSettingsResponse200AllOfData}
     * @memberof GetUserSettingsResponse200
     */
    'data'?: GetUserSettingsResponse200AllOfData;
}
/**
 *
 * @export
 * @interface GetUserSettingsResponse200AllOf
 */
export interface GetUserSettingsResponse200AllOf {
    /**
     *
     * @type {GetUserSettingsResponse200AllOfData}
     * @memberof GetUserSettingsResponse200AllOf
     */
    'data'?: GetUserSettingsResponse200AllOfData;
}
/**
 *
 * @export
 * @interface GetUserSettingsResponse200AllOfData
 */
export interface GetUserSettingsResponse200AllOfData {
    /**
     * If the vendors are allowed to install custom Marketplace apps with functionality and content in the Pipedrive UI or not
     * @type {boolean}
     * @memberof GetUserSettingsResponse200AllOfData
     */
    'marketplace_allow_custom_install_url'?: boolean;
    /**
     * If the vendors are allowed to extend their Marketplace apps with functionality and content in the Pipedrive UI or not
     * @type {boolean}
     * @memberof GetUserSettingsResponse200AllOfData
     */
    'marketplace_app_extensions_vendor'?: boolean;
    /**
     * If the vendors are allowed to be part of the Marketplace team or not
     * @type {boolean}
     * @memberof GetUserSettingsResponse200AllOfData
     */
    'marketplace_team'?: boolean;
    /**
     * The number of results shown in list by default
     * @type {number}
     * @memberof GetUserSettingsResponse200AllOfData
     */
    'list_limit'?: number;
    /**
     * Whether beta app is enabled
     * @type {boolean}
     * @memberof GetUserSettingsResponse200AllOfData
     */
    'beta_app'?: boolean;
    /**
     * Prevent salesphone call to override
     * @type {boolean}
     * @memberof GetUserSettingsResponse200AllOfData
     */
    'prevent_salesphone_callto_override'?: boolean;
    /**
     * The destination of file upload
     * @type {string}
     * @memberof GetUserSettingsResponse200AllOfData
     */
    'file_upload_destination'?: string;
    /**
     * The call to link syntax
     * @type {string}
     * @memberof GetUserSettingsResponse200AllOfData
     */
    'callto_link_syntax'?: string;
    /**
     * Whether the expected close date of the deal is filled automatically or not
     * @type {boolean}
     * @memberof GetUserSettingsResponse200AllOfData
     */
    'autofill_deal_expected_close_date'?: boolean;
    /**
     * Allow the vendors to duplicate a person
     * @type {string}
     * @memberof GetUserSettingsResponse200AllOfData
     */
    'person_duplicate_condition'?: string;
}
/**
 *
 * @export
 * @interface GetWebhooksResponse200
 */
export interface GetWebhooksResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetWebhooksResponse200
     */
    'success'?: boolean;
    /**
     * The status of the response
     * @type {string}
     * @memberof GetWebhooksResponse200
     */
    'status'?: string;
    /**
     * The array of Webhooks
     * @type {Array<GetWebhooksResponse200AllOfDataInner>}
     * @memberof GetWebhooksResponse200
     */
    'data'?: Array<GetWebhooksResponse200AllOfDataInner>;
}
/**
 *
 * @export
 * @interface GetWebhooksResponse200AllOf
 */
export interface GetWebhooksResponse200AllOf {
    /**
     * The array of Webhooks
     * @type {Array<GetWebhooksResponse200AllOfDataInner>}
     * @memberof GetWebhooksResponse200AllOf
     */
    'data'?: Array<GetWebhooksResponse200AllOfDataInner>;
}
/**
 *
 * @export
 * @interface GetWebhooksResponse200AllOfDataInner
 */
export interface GetWebhooksResponse200AllOfDataInner {
    /**
     * The ID of the Webhook
     * @type {number}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'id'?: number;
    /**
     * The ID of the company related to the Webhook
     * @type {number}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'company_id'?: number;
    /**
     * The ID of the user who owns the Webhook
     * @type {number}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'owner_id'?: number;
    /**
     * The ID of the user related to the Webhook
     * @type {number}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'user_id'?: number;
    /**
     * The Webhook action
     * @type {string}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'event_action'?: string;
    /**
     * The Webhook object
     * @type {string}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'event_object'?: string;
    /**
     * The subscription URL of the Webhook
     * @type {string}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'subscription_url'?: string;
    /**
     *
     * @type {number}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'is_active'?: GetWebhooksResponse200AllOfDataInnerIsActiveConst;
    /**
     * The date when the Webhook was added
     * @type {string}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'add_time'?: string;
    /**
     * The date when the Webhook was removed (if removed)
     * @type {string}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'remove_time'?: string | null;
    /**
     * The type of the Webhook
     * @type {string}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'type'?: GetWebhooksResponse200AllOfDataInnerTypeConst;
    /**
     * The username of the `subscription_url` of the Webhook
     * @type {string}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'http_auth_user'?: string | null;
    /**
     * The password of the `subscription_url` of the Webhook
     * @type {string}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'http_auth_password'?: string | null;
    /**
     * Any additional data related to the Webhook
     * @type {object}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'additional_data'?: object;
    /**
     * The removal reason of the Webhook (if removed)
     * @type {string}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'remove_reason'?: string | null;
    /**
     * The last delivery time of the Webhook
     * @type {string}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'last_delivery_time'?: string | null;
    /**
     * The last delivery HTTP status of the Webhook
     * @type {number}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'last_http_status'?: number | null;
    /**
     * The ID of the admin of the Webhook
     * @type {number}
     * @memberof GetWebhooksResponse200AllOfDataInner
     */
    'admin_id'?: number;
}

export const GetWebhooksResponse200AllOfDataInnerIsActiveConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type GetWebhooksResponse200AllOfDataInnerIsActiveConst = typeof GetWebhooksResponse200AllOfDataInnerIsActiveConst[keyof typeof GetWebhooksResponse200AllOfDataInnerIsActiveConst];
export const GetWebhooksResponse200AllOfDataInnerTypeConst = {
    general: 'general',
    app: 'app'
} as const;

export type GetWebhooksResponse200AllOfDataInnerTypeConst = typeof GetWebhooksResponse200AllOfDataInnerTypeConst[keyof typeof GetWebhooksResponse200AllOfDataInnerTypeConst];

/**
 *
 * @export
 * @interface GetproductResponse200
 */
export interface GetproductResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetproductResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetproductResponse200Data}
     * @memberof GetproductResponse200
     */
    'data'?: GetproductResponse200Data;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjects}
     * @memberof GetproductResponse200
     */
    'related_objects'?: GetActivitiesResponse200RelatedObjects;
}
/**
 *
 * @export
 * @interface GetproductResponse200Data
 */
export interface GetproductResponse200Data {
    /**
     * The ID of the product
     * @type {number}
     * @memberof GetproductResponse200Data
     */
    'id'?: number;
    /**
     * The name of the product
     * @type {string}
     * @memberof GetproductResponse200Data
     */
    'name'?: string;
    /**
     * The product code
     * @type {string}
     * @memberof GetproductResponse200Data
     */
    'code'?: string;
    /**
     * The unit in which this product is sold
     * @type {string}
     * @memberof GetproductResponse200Data
     */
    'unit'?: string;
    /**
     * The ax percentage
     * @type {number}
     * @memberof GetproductResponse200Data
     */
    'tax'?: number;
    /**
     * Whether this product is active or not
     * @type {boolean}
     * @memberof GetproductResponse200Data
     */
    'active_flag'?: boolean;
    /**
     * Whether this product is selected in deals or not
     * @type {boolean}
     * @memberof GetproductResponse200Data
     */
    'selectable'?: boolean;
    /**
     *
     * @type {string}
     * @memberof GetproductResponse200Data
     */
    'visible_to'?: GetproductResponse200DataVisibleToConst;
    /**
     * Information about the Pipedrive user who owns the product
     * @type {object}
     * @memberof GetproductResponse200Data
     */
    'owner_id'?: object;
    /**
     * Array of objects, each containing: currency (string), price (number), cost (number, optional), overhead_cost (number, optional)
     * @type {Array<object>}
     * @memberof GetproductResponse200Data
     */
    'prices'?: Array<object>;
}

export const GetproductResponse200DataVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type GetproductResponse200DataVisibleToConst = typeof GetproductResponse200DataVisibleToConst[keyof typeof GetproductResponse200DataVisibleToConst];

/**
 *
 * @export
 * @interface GetproductResponse200DataAllOf
 */
export interface GetproductResponse200DataAllOf {
    /**
     * Array of objects, each containing: currency (string), price (number), cost (number, optional), overhead_cost (number, optional)
     * @type {Array<object>}
     * @memberof GetproductResponse200DataAllOf
     */
    'prices'?: Array<object>;
}
/**
 *
 * @export
 * @interface LeadIdResponse200
 */
export interface LeadIdResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof LeadIdResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {LeadIdResponse200Data}
     * @memberof LeadIdResponse200
     */
    'data'?: LeadIdResponse200Data;
}
/**
 *
 * @export
 * @interface LeadIdResponse200Data
 */
export interface LeadIdResponse200Data {
    /**
     *
     * @type {string}
     * @memberof LeadIdResponse200Data
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface LeadResponse404
 */
export interface LeadResponse404 {
    /**
     *
     * @type {boolean}
     * @memberof LeadResponse404
     */
    'success'?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof LeadResponse404
     */
    'error'?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof LeadResponse404
     */
    'error_info'?: string;
    /**
     *
     * @type {object}
     * @memberof LeadResponse404
     */
    'data'?: object | null;
    /**
     *
     * @type {object}
     * @memberof LeadResponse404
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface LinkFileToItemResponse200
 */
export interface LinkFileToItemResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof LinkFileToItemResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetFilesResponse200DataInner}
     * @memberof LinkFileToItemResponse200
     */
    'data'?: GetFilesResponse200DataInner;
}
/**
 *
 * @export
 * @interface ListPermittedUsersResponse200
 */
export interface ListPermittedUsersResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof ListPermittedUsersResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {ListPermittedUsersResponse200AllOfData}
     * @memberof ListPermittedUsersResponse200
     */
    'data'?: ListPermittedUsersResponse200AllOfData;
}
/**
 *
 * @export
 * @interface ListPermittedUsersResponse2001
 */
export interface ListPermittedUsersResponse2001 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof ListPermittedUsersResponse2001
     */
    'success'?: boolean;
    /**
     * The list of permitted user IDs
     * @type {Array<number>}
     * @memberof ListPermittedUsersResponse2001
     */
    'data'?: Array<number>;
}
/**
 *
 * @export
 * @interface ListPermittedUsersResponse2001AllOf
 */
export interface ListPermittedUsersResponse2001AllOf {
    /**
     * The list of permitted user IDs
     * @type {Array<number>}
     * @memberof ListPermittedUsersResponse2001AllOf
     */
    'data'?: Array<number>;
}
/**
 *
 * @export
 * @interface ListPermittedUsersResponse200AllOf
 */
export interface ListPermittedUsersResponse200AllOf {
    /**
     *
     * @type {ListPermittedUsersResponse200AllOfData}
     * @memberof ListPermittedUsersResponse200AllOf
     */
    'data'?: ListPermittedUsersResponse200AllOfData;
}
/**
 *
 * @export
 * @interface ListPermittedUsersResponse200AllOfData
 */
export interface ListPermittedUsersResponse200AllOfData {
    /**
     * The list of permitted users IDs
     * @type {Array<number>}
     * @memberof ListPermittedUsersResponse200AllOfData
     */
    'id'?: Array<number>;
}
/**
 *
 * @export
 * @interface ListPersonsResponse200
 */
export interface ListPersonsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof ListPersonsResponse200
     */
    'success'?: boolean;
    /**
     * The array of persons
     * @type {Array<PersonItem>}
     * @memberof ListPersonsResponse200
     */
    'data'?: Array<PersonItem>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof ListPersonsResponse200
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {ListPersonsResponse200AllOfRelatedObjects}
     * @memberof ListPersonsResponse200
     */
    'related_objects'?: ListPersonsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface ListPersonsResponse200AllOf
 */
export interface ListPersonsResponse200AllOf {
    /**
     * The array of persons
     * @type {Array<PersonItem>}
     * @memberof ListPersonsResponse200AllOf
     */
    'data'?: Array<PersonItem>;
    /**
     *
     * @type {FieldsResponse200AllOfAdditionalData}
     * @memberof ListPersonsResponse200AllOf
     */
    'additional_data'?: FieldsResponse200AllOfAdditionalData;
    /**
     *
     * @type {ListPersonsResponse200AllOfRelatedObjects}
     * @memberof ListPersonsResponse200AllOf
     */
    'related_objects'?: ListPersonsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface ListPersonsResponse200AllOfRelatedObjects
 */
export interface ListPersonsResponse200AllOfRelatedObjects {
    /**
     *
     * @type {AddActivityResponse200RelatedObjectsOrganization}
     * @memberof ListPersonsResponse200AllOfRelatedObjects
     */
    'organization'?: AddActivityResponse200RelatedObjectsOrganization;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsUser}
     * @memberof ListPersonsResponse200AllOfRelatedObjects
     */
    'user'?: GetActivitiesResponse200RelatedObjectsUser;
}
/**
 *
 * @export
 * @interface ListProductsResponse200
 */
export interface ListProductsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof ListProductsResponse200
     */
    'success'?: boolean;
    /**
     * The array of products
     * @type {Array<ListProductsResponse200AllOfDataInner>}
     * @memberof ListProductsResponse200
     */
    'data'?: Array<ListProductsResponse200AllOfDataInner>;
    /**
     *
     * @type {ListProductsResponse200AllOfAdditionalData}
     * @memberof ListProductsResponse200
     */
    'additional_data'?: ListProductsResponse200AllOfAdditionalData;
    /**
     *
     * @type {ListProductsResponse200AllOfRelatedObjects}
     * @memberof ListProductsResponse200
     */
    'related_objects'?: ListProductsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface ListProductsResponse200AllOf
 */
export interface ListProductsResponse200AllOf {
    /**
     * The array of products
     * @type {Array<ListProductsResponse200AllOfDataInner>}
     * @memberof ListProductsResponse200AllOf
     */
    'data'?: Array<ListProductsResponse200AllOfDataInner>;
    /**
     *
     * @type {ListProductsResponse200AllOfAdditionalData}
     * @memberof ListProductsResponse200AllOf
     */
    'additional_data'?: ListProductsResponse200AllOfAdditionalData;
    /**
     *
     * @type {ListProductsResponse200AllOfRelatedObjects}
     * @memberof ListProductsResponse200AllOf
     */
    'related_objects'?: ListProductsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface ListProductsResponse200AllOfAdditionalData
 */
export interface ListProductsResponse200AllOfAdditionalData {
    /**
     * The total quantity of the products
     * @type {number}
     * @memberof ListProductsResponse200AllOfAdditionalData
     */
    'products_quantity_total'?: number;
    /**
     * The total sum of the products
     * @type {number}
     * @memberof ListProductsResponse200AllOfAdditionalData
     */
    'products_sum_total'?: number;
    /**
     * The total formatted quantity of the products
     * @type {string}
     * @memberof ListProductsResponse200AllOfAdditionalData
     */
    'products_quantity_total_formatted'?: string;
    /**
     * The total formatted sum of the products
     * @type {string}
     * @memberof ListProductsResponse200AllOfAdditionalData
     */
    'products_sum_total_formatted'?: string;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalDataPagination}
     * @memberof ListProductsResponse200AllOfAdditionalData
     */
    'pagination'?: GetActivitiesResponse200AdditionalDataPagination;
}
/**
 *
 * @export
 * @interface ListProductsResponse200AllOfAdditionalDataAllOf
 */
export interface ListProductsResponse200AllOfAdditionalDataAllOf {
    /**
     * The total quantity of the products
     * @type {number}
     * @memberof ListProductsResponse200AllOfAdditionalDataAllOf
     */
    'products_quantity_total'?: number;
    /**
     * The total sum of the products
     * @type {number}
     * @memberof ListProductsResponse200AllOfAdditionalDataAllOf
     */
    'products_sum_total'?: number;
    /**
     * The total formatted quantity of the products
     * @type {string}
     * @memberof ListProductsResponse200AllOfAdditionalDataAllOf
     */
    'products_quantity_total_formatted'?: string;
    /**
     * The total formatted sum of the products
     * @type {string}
     * @memberof ListProductsResponse200AllOfAdditionalDataAllOf
     */
    'products_sum_total_formatted'?: string;
}
/**
 *
 * @export
 * @interface ListProductsResponse200AllOfDataInner
 */
export interface ListProductsResponse200AllOfDataInner {
    /**
     * The ID of the deal-product (the ID of the product attached to the deal)
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'id'?: number;
    /**
     * The ID of the deal
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'deal_id'?: number;
    /**
     * The order number of the product
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'order_nr'?: number;
    /**
     * The ID of the product
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'product_id'?: number;
    /**
     * The ID of the product variation
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'product_variation_id'?: number | null;
    /**
     * The price value of the product
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'item_price'?: number;
    /**
     * The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage.
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'discount'?: number;
    /**
     * The type of the discount\'s value.
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'discount_type'?: ListProductsResponse200AllOfDataInnerDiscountTypeConst;
    /**
     * The duration of the product
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'duration'?: number;
    /**
     * The type of the duration. (For example hourly, daily, etc.)
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'duration_unit'?: string;
    /**
     * The sum of all the products attached to the deal
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'sum'?: number;
    /**
     * The currency associated with the deal product
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'currency'?: string;
    /**
     * Whether the product is enabled or not
     * @type {boolean}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'enabled_flag'?: boolean;
    /**
     * The date and time when the product was added to the deal
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'add_time'?: string;
    /**
     * The date and time when the deal product was last edited
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'last_edit'?: string;
    /**
     * The comments of the product
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'comments'?: string;
    /**
     * Whether the product is active or not
     * @type {boolean}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'active_flag'?: boolean;
    /**
     * The product tax
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'tax'?: number;
    /**
     * The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount. By default, the user setting value for tax options will be used. Changing this in one product affects the rest of the products attached to the deal.
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'tax_method'?: ListProductsResponse200AllOfDataInnerTaxMethodConst;
    /**
     * The product name
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'name'?: string;
    /**
     * The formatted sum of the product
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'sum_formatted'?: string;
    /**
     * The formatted quantity of the product
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'quantity_formatted'?: string;
    /**
     * The quantity of the product
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'quantity'?: number;
    /**
     *
     * @type {ListProductsResponse200AllOfDataInnerProduct}
     * @memberof ListProductsResponse200AllOfDataInner
     */
    'product'?: ListProductsResponse200AllOfDataInnerProduct;
}

export const ListProductsResponse200AllOfDataInnerDiscountTypeConst = {
    percentage: 'percentage',
    amount: 'amount'
} as const;

export type ListProductsResponse200AllOfDataInnerDiscountTypeConst = typeof ListProductsResponse200AllOfDataInnerDiscountTypeConst[keyof typeof ListProductsResponse200AllOfDataInnerDiscountTypeConst];
export const ListProductsResponse200AllOfDataInnerTaxMethodConst = {
    exclusive: 'exclusive',
    inclusive: 'inclusive',
    none: 'none'
} as const;

export type ListProductsResponse200AllOfDataInnerTaxMethodConst = typeof ListProductsResponse200AllOfDataInnerTaxMethodConst[keyof typeof ListProductsResponse200AllOfDataInnerTaxMethodConst];

/**
 *
 * @export
 * @interface ListProductsResponse200AllOfDataInnerProduct
 */
export interface ListProductsResponse200AllOfDataInnerProduct {
    /**
     * The ID of the product
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInnerProduct
     */
    'id'?: number;
    /**
     * The name of the product
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInnerProduct
     */
    'name'?: string;
    /**
     * The product code
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInnerProduct
     */
    'code'?: string;
    /**
     * The unit in which this product is sold
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInnerProduct
     */
    'unit'?: string;
    /**
     * The ax percentage
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInnerProduct
     */
    'tax'?: number;
    /**
     * Whether this product is active or not
     * @type {boolean}
     * @memberof ListProductsResponse200AllOfDataInnerProduct
     */
    'active_flag'?: boolean;
    /**
     * Whether this product is selected in deals or not
     * @type {boolean}
     * @memberof ListProductsResponse200AllOfDataInnerProduct
     */
    'selectable'?: boolean;
    /**
     *
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInnerProduct
     */
    'visible_to'?: ListProductsResponse200AllOfDataInnerProductVisibleToConst;
    /**
     * Information about the Pipedrive user who owns the product
     * @type {object}
     * @memberof ListProductsResponse200AllOfDataInnerProduct
     */
    'owner_id'?: object;
    /**
     * Object of objects, each containing: currency (string), price (number), cost (number, optional), overhead_cost (number, optional)
     * @type {object}
     * @memberof ListProductsResponse200AllOfDataInnerProduct
     */
    'prices'?: object;
}

export const ListProductsResponse200AllOfDataInnerProductVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type ListProductsResponse200AllOfDataInnerProductVisibleToConst = typeof ListProductsResponse200AllOfDataInnerProductVisibleToConst[keyof typeof ListProductsResponse200AllOfDataInnerProductVisibleToConst];

/**
 *
 * @export
 * @interface ListProductsResponse200AllOfDataInnerProductAllOf
 */
export interface ListProductsResponse200AllOfDataInnerProductAllOf {
    /**
     * The ID of the product
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInnerProductAllOf
     */
    'id'?: number;
    /**
     * The name of the product
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInnerProductAllOf
     */
    'name'?: string;
    /**
     * The product code
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInnerProductAllOf
     */
    'code'?: string;
    /**
     * The unit in which this product is sold
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInnerProductAllOf
     */
    'unit'?: string;
    /**
     * The ax percentage
     * @type {number}
     * @memberof ListProductsResponse200AllOfDataInnerProductAllOf
     */
    'tax'?: number;
    /**
     * Whether this product is active or not
     * @type {boolean}
     * @memberof ListProductsResponse200AllOfDataInnerProductAllOf
     */
    'active_flag'?: boolean;
    /**
     * Whether this product is selected in deals or not
     * @type {boolean}
     * @memberof ListProductsResponse200AllOfDataInnerProductAllOf
     */
    'selectable'?: boolean;
    /**
     *
     * @type {string}
     * @memberof ListProductsResponse200AllOfDataInnerProductAllOf
     */
    'visible_to'?: ListProductsResponse200AllOfDataInnerProductAllOfVisibleToConst;
    /**
     * Information about the Pipedrive user who owns the product
     * @type {object}
     * @memberof ListProductsResponse200AllOfDataInnerProductAllOf
     */
    'owner_id'?: object;
}

export const ListProductsResponse200AllOfDataInnerProductAllOfVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type ListProductsResponse200AllOfDataInnerProductAllOfVisibleToConst = typeof ListProductsResponse200AllOfDataInnerProductAllOfVisibleToConst[keyof typeof ListProductsResponse200AllOfDataInnerProductAllOfVisibleToConst];

/**
 *
 * @export
 * @interface ListProductsResponse200AllOfDataInnerProductAllOf1
 */
export interface ListProductsResponse200AllOfDataInnerProductAllOf1 {
    /**
     * Object of objects, each containing: currency (string), price (number), cost (number, optional), overhead_cost (number, optional)
     * @type {object}
     * @memberof ListProductsResponse200AllOfDataInnerProductAllOf1
     */
    'prices'?: object;
}
/**
 *
 * @export
 * @interface ListProductsResponse200AllOfRelatedObjects
 */
export interface ListProductsResponse200AllOfRelatedObjects {
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjectsUser}
     * @memberof ListProductsResponse200AllOfRelatedObjects
     */
    'user'?: GetActivitiesResponse200RelatedObjectsUser;
}
/**
 *
 * @export
 * @interface MailMessageItemForList
 */
export interface MailMessageItemForList {
    /**
     * ID of the mail message.
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'id'?: number;
    /**
     * The array of mail message sender (object)
     * @type {Array<MailMessageItemForListAllOfFromInner>}
     * @memberof MailMessageItemForList
     */
    'from'?: Array<MailMessageItemForListAllOfFromInner>;
    /**
     * The array of mail message receiver (object)
     * @type {Array<MailMessageItemForListAllOfFromInner>}
     * @memberof MailMessageItemForList
     */
    'to'?: Array<MailMessageItemForListAllOfFromInner>;
    /**
     * The array of mail message copies (object)
     * @type {Array<MailMessageItemForListAllOfFromInner>}
     * @memberof MailMessageItemForList
     */
    'cc'?: Array<MailMessageItemForListAllOfFromInner>;
    /**
     * The array of mail message blind copies (object)
     * @type {Array<MailMessageItemForListAllOfFromInner>}
     * @memberof MailMessageItemForList
     */
    'bcc'?: Array<MailMessageItemForListAllOfFromInner>;
    /**
     * The mail message body URL
     * @type {string}
     * @memberof MailMessageItemForList
     */
    'body_url'?: string;
    /**
     * The connection account ID
     * @type {string}
     * @memberof MailMessageItemForList
     */
    'account_id'?: string;
    /**
     * ID of the user whom mail message will be assigned to
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'user_id'?: number;
    /**
     * ID of the mail message thread
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'mail_thread_id'?: number;
    /**
     * The subject of mail message
     * @type {string}
     * @memberof MailMessageItemForList
     */
    'subject'?: string;
    /**
     * The snippet of mail message. Snippet length is up to 225 characters.
     * @type {string}
     * @memberof MailMessageItemForList
     */
    'snippet'?: string;
    /**
     * The status of tracking mail message. Value is `null` if tracking is not enabled.
     * @type {string}
     * @memberof MailMessageItemForList
     */
    'mail_tracking_status'?: MailMessageItemForListMailTrackingStatusConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'mail_link_tracking_enabled_flag'?: MailMessageItemForListMailLinkTrackingEnabledFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'read_flag'?: MailMessageItemForListReadFlagConst;
    /**
     * If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
     * @type {string}
     * @memberof MailMessageItemForList
     */
    'draft'?: string;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'draft_flag'?: MailMessageItemForListDraftFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'synced_flag'?: MailMessageItemForListSyncedFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'deleted_flag'?: MailMessageItemForListDeletedFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'has_body_flag'?: MailMessageItemForListHasBodyFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'sent_flag'?: MailMessageItemForListSentFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'sent_from_pipedrive_flag'?: MailMessageItemForListSentFromPipedriveFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'smart_bcc_flag'?: MailMessageItemForListSmartBccFlagConst;
    /**
     * Creation or receival time of the mail message
     * @type {string}
     * @memberof MailMessageItemForList
     */
    'message_time'?: string;
    /**
     * The insertion into the database time of the mail message
     * @type {string}
     * @memberof MailMessageItemForList
     */
    'add_time'?: string;
    /**
     * The updating time in the database of the mail message
     * @type {string}
     * @memberof MailMessageItemForList
     */
    'update_time'?: string;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'has_attachments_flag'?: MailMessageItemForListHasAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'has_inline_attachments_flag'?: MailMessageItemForListHasInlineAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'has_real_attachments_flag'?: MailMessageItemForListHasRealAttachmentsFlagConst;
    /**
     * The Mail Message ID assigned by the sync provider
     * @type {string}
     * @memberof MailMessageItemForList
     */
    'nylas_id'?: string;
    /**
     * The name of the S3 bucket
     * @type {string}
     * @memberof MailMessageItemForList
     */
    's3_bucket'?: string;
    /**
     * The path of the S3 bucket
     * @type {string}
     * @memberof MailMessageItemForList
     */
    's3_bucket_path'?: string;
    /**
     * If the Mail Message has been deleted on the provider side or not
     * @type {boolean}
     * @memberof MailMessageItemForList
     */
    'external_deleted_flag'?: boolean;
    /**
     * The Mail Message ID assigned by the mail user agent
     * @type {string}
     * @memberof MailMessageItemForList
     */
    'mua_message_id'?: string;
    /**
     * The ID of the mail template
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'template_id'?: number;
    /**
     * The add date and time of the Mail Message
     * @type {string}
     * @memberof MailMessageItemForList
     */
    'timestamp'?: string;
    /**
     * The type of the data item
     * @type {string}
     * @memberof MailMessageItemForList
     */
    'item_type'?: string;
    /**
     * The ID of the company
     * @type {number}
     * @memberof MailMessageItemForList
     */
    'company_id'?: number;
}

export const MailMessageItemForListMailTrackingStatusConst = {
    opened: 'opened',
    not_opened: 'not opened'
} as const;

export type MailMessageItemForListMailTrackingStatusConst = typeof MailMessageItemForListMailTrackingStatusConst[keyof typeof MailMessageItemForListMailTrackingStatusConst];
export const MailMessageItemForListMailLinkTrackingEnabledFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListMailLinkTrackingEnabledFlagConst = typeof MailMessageItemForListMailLinkTrackingEnabledFlagConst[keyof typeof MailMessageItemForListMailLinkTrackingEnabledFlagConst];
export const MailMessageItemForListReadFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListReadFlagConst = typeof MailMessageItemForListReadFlagConst[keyof typeof MailMessageItemForListReadFlagConst];
export const MailMessageItemForListDraftFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListDraftFlagConst = typeof MailMessageItemForListDraftFlagConst[keyof typeof MailMessageItemForListDraftFlagConst];
export const MailMessageItemForListSyncedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListSyncedFlagConst = typeof MailMessageItemForListSyncedFlagConst[keyof typeof MailMessageItemForListSyncedFlagConst];
export const MailMessageItemForListDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListDeletedFlagConst = typeof MailMessageItemForListDeletedFlagConst[keyof typeof MailMessageItemForListDeletedFlagConst];
export const MailMessageItemForListHasBodyFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListHasBodyFlagConst = typeof MailMessageItemForListHasBodyFlagConst[keyof typeof MailMessageItemForListHasBodyFlagConst];
export const MailMessageItemForListSentFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListSentFlagConst = typeof MailMessageItemForListSentFlagConst[keyof typeof MailMessageItemForListSentFlagConst];
export const MailMessageItemForListSentFromPipedriveFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListSentFromPipedriveFlagConst = typeof MailMessageItemForListSentFromPipedriveFlagConst[keyof typeof MailMessageItemForListSentFromPipedriveFlagConst];
export const MailMessageItemForListSmartBccFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListSmartBccFlagConst = typeof MailMessageItemForListSmartBccFlagConst[keyof typeof MailMessageItemForListSmartBccFlagConst];
export const MailMessageItemForListHasAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListHasAttachmentsFlagConst = typeof MailMessageItemForListHasAttachmentsFlagConst[keyof typeof MailMessageItemForListHasAttachmentsFlagConst];
export const MailMessageItemForListHasInlineAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListHasInlineAttachmentsFlagConst = typeof MailMessageItemForListHasInlineAttachmentsFlagConst[keyof typeof MailMessageItemForListHasInlineAttachmentsFlagConst];
export const MailMessageItemForListHasRealAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListHasRealAttachmentsFlagConst = typeof MailMessageItemForListHasRealAttachmentsFlagConst[keyof typeof MailMessageItemForListHasRealAttachmentsFlagConst];

/**
 *
 * @export
 * @interface MailMessageItemForListAllOf
 */
export interface MailMessageItemForListAllOf {
    /**
     * ID of the mail message.
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'id'?: number;
    /**
     * The array of mail message sender (object)
     * @type {Array<MailMessageItemForListAllOfFromInner>}
     * @memberof MailMessageItemForListAllOf
     */
    'from'?: Array<MailMessageItemForListAllOfFromInner>;
    /**
     * The array of mail message receiver (object)
     * @type {Array<MailMessageItemForListAllOfFromInner>}
     * @memberof MailMessageItemForListAllOf
     */
    'to'?: Array<MailMessageItemForListAllOfFromInner>;
    /**
     * The array of mail message copies (object)
     * @type {Array<MailMessageItemForListAllOfFromInner>}
     * @memberof MailMessageItemForListAllOf
     */
    'cc'?: Array<MailMessageItemForListAllOfFromInner>;
    /**
     * The array of mail message blind copies (object)
     * @type {Array<MailMessageItemForListAllOfFromInner>}
     * @memberof MailMessageItemForListAllOf
     */
    'bcc'?: Array<MailMessageItemForListAllOfFromInner>;
    /**
     * The mail message body URL
     * @type {string}
     * @memberof MailMessageItemForListAllOf
     */
    'body_url'?: string;
    /**
     * The connection account ID
     * @type {string}
     * @memberof MailMessageItemForListAllOf
     */
    'account_id'?: string;
    /**
     * ID of the user whom mail message will be assigned to
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'user_id'?: number;
    /**
     * ID of the mail message thread
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'mail_thread_id'?: number;
    /**
     * The subject of mail message
     * @type {string}
     * @memberof MailMessageItemForListAllOf
     */
    'subject'?: string;
    /**
     * The snippet of mail message. Snippet length is up to 225 characters.
     * @type {string}
     * @memberof MailMessageItemForListAllOf
     */
    'snippet'?: string;
    /**
     * The status of tracking mail message. Value is `null` if tracking is not enabled.
     * @type {string}
     * @memberof MailMessageItemForListAllOf
     */
    'mail_tracking_status'?: MailMessageItemForListAllOfMailTrackingStatusConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'mail_link_tracking_enabled_flag'?: MailMessageItemForListAllOfMailLinkTrackingEnabledFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'read_flag'?: MailMessageItemForListAllOfReadFlagConst;
    /**
     * If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
     * @type {string}
     * @memberof MailMessageItemForListAllOf
     */
    'draft'?: string;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'draft_flag'?: MailMessageItemForListAllOfDraftFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'synced_flag'?: MailMessageItemForListAllOfSyncedFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'deleted_flag'?: MailMessageItemForListAllOfDeletedFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'has_body_flag'?: MailMessageItemForListAllOfHasBodyFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'sent_flag'?: MailMessageItemForListAllOfSentFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'sent_from_pipedrive_flag'?: MailMessageItemForListAllOfSentFromPipedriveFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'smart_bcc_flag'?: MailMessageItemForListAllOfSmartBccFlagConst;
    /**
     * Creation or receival time of the mail message
     * @type {string}
     * @memberof MailMessageItemForListAllOf
     */
    'message_time'?: string;
    /**
     * The insertion into the database time of the mail message
     * @type {string}
     * @memberof MailMessageItemForListAllOf
     */
    'add_time'?: string;
    /**
     * The updating time in the database of the mail message
     * @type {string}
     * @memberof MailMessageItemForListAllOf
     */
    'update_time'?: string;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'has_attachments_flag'?: MailMessageItemForListAllOfHasAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'has_inline_attachments_flag'?: MailMessageItemForListAllOfHasInlineAttachmentsFlagConst;
    /**
     *
     * @type {number}
     * @memberof MailMessageItemForListAllOf
     */
    'has_real_attachments_flag'?: MailMessageItemForListAllOfHasRealAttachmentsFlagConst;
}

export const MailMessageItemForListAllOfMailTrackingStatusConst = {
    opened: 'opened',
    not_opened: 'not opened'
} as const;

export type MailMessageItemForListAllOfMailTrackingStatusConst = typeof MailMessageItemForListAllOfMailTrackingStatusConst[keyof typeof MailMessageItemForListAllOfMailTrackingStatusConst];
export const MailMessageItemForListAllOfMailLinkTrackingEnabledFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListAllOfMailLinkTrackingEnabledFlagConst = typeof MailMessageItemForListAllOfMailLinkTrackingEnabledFlagConst[keyof typeof MailMessageItemForListAllOfMailLinkTrackingEnabledFlagConst];
export const MailMessageItemForListAllOfReadFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListAllOfReadFlagConst = typeof MailMessageItemForListAllOfReadFlagConst[keyof typeof MailMessageItemForListAllOfReadFlagConst];
export const MailMessageItemForListAllOfDraftFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListAllOfDraftFlagConst = typeof MailMessageItemForListAllOfDraftFlagConst[keyof typeof MailMessageItemForListAllOfDraftFlagConst];
export const MailMessageItemForListAllOfSyncedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListAllOfSyncedFlagConst = typeof MailMessageItemForListAllOfSyncedFlagConst[keyof typeof MailMessageItemForListAllOfSyncedFlagConst];
export const MailMessageItemForListAllOfDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListAllOfDeletedFlagConst = typeof MailMessageItemForListAllOfDeletedFlagConst[keyof typeof MailMessageItemForListAllOfDeletedFlagConst];
export const MailMessageItemForListAllOfHasBodyFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListAllOfHasBodyFlagConst = typeof MailMessageItemForListAllOfHasBodyFlagConst[keyof typeof MailMessageItemForListAllOfHasBodyFlagConst];
export const MailMessageItemForListAllOfSentFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListAllOfSentFlagConst = typeof MailMessageItemForListAllOfSentFlagConst[keyof typeof MailMessageItemForListAllOfSentFlagConst];
export const MailMessageItemForListAllOfSentFromPipedriveFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListAllOfSentFromPipedriveFlagConst = typeof MailMessageItemForListAllOfSentFromPipedriveFlagConst[keyof typeof MailMessageItemForListAllOfSentFromPipedriveFlagConst];
export const MailMessageItemForListAllOfSmartBccFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListAllOfSmartBccFlagConst = typeof MailMessageItemForListAllOfSmartBccFlagConst[keyof typeof MailMessageItemForListAllOfSmartBccFlagConst];
export const MailMessageItemForListAllOfHasAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListAllOfHasAttachmentsFlagConst = typeof MailMessageItemForListAllOfHasAttachmentsFlagConst[keyof typeof MailMessageItemForListAllOfHasAttachmentsFlagConst];
export const MailMessageItemForListAllOfHasInlineAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListAllOfHasInlineAttachmentsFlagConst = typeof MailMessageItemForListAllOfHasInlineAttachmentsFlagConst[keyof typeof MailMessageItemForListAllOfHasInlineAttachmentsFlagConst];
export const MailMessageItemForListAllOfHasRealAttachmentsFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MailMessageItemForListAllOfHasRealAttachmentsFlagConst = typeof MailMessageItemForListAllOfHasRealAttachmentsFlagConst[keyof typeof MailMessageItemForListAllOfHasRealAttachmentsFlagConst];

/**
 *
 * @export
 * @interface MailMessageItemForListAllOf1
 */
export interface MailMessageItemForListAllOf1 {
    /**
     * The Mail Message ID assigned by the sync provider
     * @type {string}
     * @memberof MailMessageItemForListAllOf1
     */
    'nylas_id'?: string;
    /**
     * The name of the S3 bucket
     * @type {string}
     * @memberof MailMessageItemForListAllOf1
     */
    's3_bucket'?: string;
    /**
     * The path of the S3 bucket
     * @type {string}
     * @memberof MailMessageItemForListAllOf1
     */
    's3_bucket_path'?: string;
    /**
     * If the Mail Message has been deleted on the provider side or not
     * @type {boolean}
     * @memberof MailMessageItemForListAllOf1
     */
    'external_deleted_flag'?: boolean;
    /**
     * The Mail Message ID assigned by the mail user agent
     * @type {string}
     * @memberof MailMessageItemForListAllOf1
     */
    'mua_message_id'?: string;
    /**
     * The ID of the mail template
     * @type {number}
     * @memberof MailMessageItemForListAllOf1
     */
    'template_id'?: number;
    /**
     * The add date and time of the Mail Message
     * @type {string}
     * @memberof MailMessageItemForListAllOf1
     */
    'timestamp'?: string;
    /**
     * The type of the data item
     * @type {string}
     * @memberof MailMessageItemForListAllOf1
     */
    'item_type'?: string;
    /**
     * The ID of the company
     * @type {number}
     * @memberof MailMessageItemForListAllOf1
     */
    'company_id'?: number;
}
/**
 *
 * @export
 * @interface MailMessageItemForListAllOfFromInner
 */
export interface MailMessageItemForListAllOfFromInner {
    /**
     * ID of the mail participant
     * @type {number}
     * @memberof MailMessageItemForListAllOfFromInner
     */
    'id'?: number;
    /**
     * Mail address of the mail participant
     * @type {string}
     * @memberof MailMessageItemForListAllOfFromInner
     */
    'email_address'?: string;
    /**
     * Name of the mail participant
     * @type {string}
     * @memberof MailMessageItemForListAllOfFromInner
     */
    'name'?: string;
    /**
     * ID of the linked person to the mail message
     * @type {number}
     * @memberof MailMessageItemForListAllOfFromInner
     */
    'linked_person_id'?: number;
    /**
     * Name of the linked person to the mail message
     * @type {string}
     * @memberof MailMessageItemForListAllOfFromInner
     */
    'linked_person_name'?: string;
    /**
     * ID of the mail message participant
     * @type {number}
     * @memberof MailMessageItemForListAllOfFromInner
     */
    'mail_message_party_id'?: number;
}
/**
 *
 * @export
 * @interface MailMessageResponse200
 */
export interface MailMessageResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof MailMessageResponse200
     */
    'success'?: boolean;
    /**
     * The email service specific status code and it is returned through the response body.
     * @type {number}
     * @memberof MailMessageResponse200
     */
    'statusCode'?: number;
    /**
     * The status text of the response.
     * @type {string}
     * @memberof MailMessageResponse200
     */
    'statusText'?: string;
    /**
     * The service name of the response.
     * @type {string}
     * @memberof MailMessageResponse200
     */
    'service'?: string;
    /**
     *
     * @type {MailMessageItemForListAllOf}
     * @memberof MailMessageResponse200
     */
    'data'?: MailMessageItemForListAllOf;
}
/**
 *
 * @export
 * @interface MailMessageResponse200AllOf
 */
export interface MailMessageResponse200AllOf {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof MailMessageResponse200AllOf
     */
    'success'?: boolean;
    /**
     * The email service specific status code and it is returned through the response body.
     * @type {number}
     * @memberof MailMessageResponse200AllOf
     */
    'statusCode'?: number;
    /**
     * The status text of the response.
     * @type {string}
     * @memberof MailMessageResponse200AllOf
     */
    'statusText'?: string;
    /**
     * The service name of the response.
     * @type {string}
     * @memberof MailMessageResponse200AllOf
     */
    'service'?: string;
}
/**
 *
 * @export
 * @interface MailMessageResponse200AllOf1
 */
export interface MailMessageResponse200AllOf1 {
    /**
     *
     * @type {MailMessageItemForListAllOf}
     * @memberof MailMessageResponse200AllOf1
     */
    'data'?: MailMessageItemForListAllOf;
}
/**
 *
 * @export
 * @interface MergeDealsRequest
 */
export interface MergeDealsRequest {
    /**
     * The ID of the deal that the deal will be merged with
     * @type {number}
     * @memberof MergeDealsRequest
     */
    'merge_with_id': number;
}
/**
 *
 * @export
 * @interface MergeDealsResponse200
 */
export interface MergeDealsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof MergeDealsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {MergeDealsResponse200Data}
     * @memberof MergeDealsResponse200
     */
    'data'?: MergeDealsResponse200Data;
}
/**
 *
 * @export
 * @interface MergeDealsResponse200Data
 */
export interface MergeDealsResponse200Data {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'id'?: number;
    /**
     * The ID of the deal creator
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'creator_user_id'?: number;
    /**
     * The ID of the user
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'user_id'?: number;
    /**
     * The ID of the person associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'person_id'?: number;
    /**
     * The ID of the organization associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'org_id'?: number;
    /**
     * The ID of the deal stage
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'stage_id'?: number;
    /**
     * The title of the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'title'?: string;
    /**
     * The value of the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'value'?: number;
    /**
     * The currency associated with the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'currency'?: string;
    /**
     * The creation date and time of the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'update_time'?: string;
    /**
     * The last updated date and time of the deal stage
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'stage_change_time'?: string;
    /**
     * Whether the deal is active or not
     * @type {boolean}
     * @memberof MergeDealsResponse200Data
     */
    'active'?: boolean;
    /**
     * Whether the deal is deleted or not
     * @type {boolean}
     * @memberof MergeDealsResponse200Data
     */
    'deleted'?: boolean;
    /**
     * The status of the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'status'?: string;
    /**
     * The success probability percentage of the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'probability'?: number | null;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'next_activity_date'?: string;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'next_activity_time'?: string;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'last_activity_date'?: string | null;
    /**
     * The reason for losing the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'lost_reason'?: string | null;
    /**
     * The visibility of the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'visible_to'?: string;
    /**
     * The date and time of closing the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'close_time'?: string | null;
    /**
     * The ID of the pipeline associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'pipeline_id'?: number;
    /**
     * The date and time of changing the deal status as won
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'won_time'?: string;
    /**
     * The date and time of the first time changing the deal status as won
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'first_won_time'?: string;
    /**
     * The date and time of changing the deal status as lost
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'lost_time'?: string;
    /**
     * The number of products associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'products_count'?: number;
    /**
     * The number of files associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'files_count'?: number;
    /**
     * The number of notes associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'notes_count'?: number;
    /**
     * The number of followers associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'followers_count'?: number;
    /**
     * The number of emails associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'email_messages_count'?: number;
    /**
     * The number of activities associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'activities_count'?: number;
    /**
     * The number of completed activities associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'done_activities_count'?: number;
    /**
     * The number of incomplete activities associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'undone_activities_count'?: number;
    /**
     * The number of participants associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'participants_count'?: number;
    /**
     * The expected close date of the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'expected_close_date'?: string;
    /**
     * The date and time of the last incoming email associated with the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'last_outgoing_mail_time'?: string;
    /**
     * The label or multiple labels assigned to the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'label'?: string;
    /**
     * The order number of the deal stage associated with the deal
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'stage_order_nr'?: number;
    /**
     * The name of the person associated with the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'person_name'?: string;
    /**
     * The name of the organization associated with the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'org_name'?: string;
    /**
     * The subject of the next activity associated with the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'next_activity_subject'?: string;
    /**
     * The type of the next activity associated with the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'next_activity_type'?: string;
    /**
     * The duration of the next activity associated with the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'next_activity_duration'?: string;
    /**
     * The note of the next activity associated with the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'next_activity_note'?: string;
    /**
     * The deal value formatted with selected currency. E.g. US$500
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'formatted_value'?: string;
    /**
     * Probability times deal value. Probability can either be deal probability or if not set, then stage probability.
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'weighted_value'?: number;
    /**
     * The weighted_value formatted with selected currency. E.g. US$500
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'formatted_weighted_value'?: string;
    /**
     * The currency associated with the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'weighted_value_currency'?: string;
    /**
     * The date and time of changing the deal status as rotten
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'rotten_time'?: string | null;
    /**
     * The name of the deal owner
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'owner_name'?: string;
    /**
     * The BCC email of the deal
     * @type {string}
     * @memberof MergeDealsResponse200Data
     */
    'cc_email'?: string;
    /**
     * If the organization that is associated with the deal is hidden or not
     * @type {boolean}
     * @memberof MergeDealsResponse200Data
     */
    'org_hidden'?: boolean;
    /**
     * If the person that is associated with the deal is hidden or not
     * @type {boolean}
     * @memberof MergeDealsResponse200Data
     */
    'person_hidden'?: boolean;
    /**
     * The deal ID of the deal which the original deal was merged with
     * @type {number}
     * @memberof MergeDealsResponse200Data
     */
    'merge_what_id'?: number;
}
/**
 *
 * @export
 * @interface MergeDealsResponse200DataAllOf
 */
export interface MergeDealsResponse200DataAllOf {
    /**
     * The deal ID of the deal which the original deal was merged with
     * @type {number}
     * @memberof MergeDealsResponse200DataAllOf
     */
    'merge_what_id'?: number;
}
/**
 *
 * @export
 * @interface MergeOrganizationsRequest
 */
export interface MergeOrganizationsRequest {
    /**
     * The ID of the organization that the organization will be merged with
     * @type {number}
     * @memberof MergeOrganizationsRequest
     */
    'merge_with_id': number;
}
/**
 *
 * @export
 * @interface MergeOrganizationsResponse200
 */
export interface MergeOrganizationsResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof MergeOrganizationsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {MergeOrganizationsResponse200Data}
     * @memberof MergeOrganizationsResponse200
     */
    'data'?: MergeOrganizationsResponse200Data;
}
/**
 *
 * @export
 * @interface MergeOrganizationsResponse200Data
 */
export interface MergeOrganizationsResponse200Data {
    /**
     * The ID of the merged organization
     * @type {number}
     * @memberof MergeOrganizationsResponse200Data
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface MergePersonDealRelatedInfo
 */
export interface MergePersonDealRelatedInfo {
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof MergePersonDealRelatedInfo
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof MergePersonDealRelatedInfo
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof MergePersonDealRelatedInfo
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof MergePersonDealRelatedInfo
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof MergePersonDealRelatedInfo
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof MergePersonDealRelatedInfo
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof MergePersonDealRelatedInfo
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof MergePersonDealRelatedInfo
     */
    'related_lost_deals_count'?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof MergePersonDealRelatedInfo
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof MergePersonDealRelatedInfo
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof MergePersonDealRelatedInfo
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof MergePersonDealRelatedInfo
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof MergePersonDealRelatedInfo
     */
    'last_activity_date'?: string | null;
    /**
     * The count of open participant deals related with the item
     * @type {number}
     * @memberof MergePersonDealRelatedInfo
     */
    'participant_open_deals_count'?: number;
    /**
     * The count of closed participant deals related with the item
     * @type {number}
     * @memberof MergePersonDealRelatedInfo
     */
    'participant_closed_deals_count'?: number;
}
/**
 *
 * @export
 * @interface MergePersonDealRelatedInfoAllOf
 */
export interface MergePersonDealRelatedInfoAllOf {
    /**
     * The count of open participant deals related with the item
     * @type {number}
     * @memberof MergePersonDealRelatedInfoAllOf
     */
    'participant_open_deals_count'?: number;
    /**
     * The count of closed participant deals related with the item
     * @type {number}
     * @memberof MergePersonDealRelatedInfoAllOf
     */
    'participant_closed_deals_count'?: number;
}
/**
 *
 * @export
 * @interface MergePersonItem
 */
export interface MergePersonItem {
    /**
     * The ID of the person
     * @type {number}
     * @memberof MergePersonItem
     */
    'id'?: number;
    /**
     * The ID of the company related to the person
     * @type {number}
     * @memberof MergePersonItem
     */
    'company_id'?: number;
    /**
     * Whether the person is active or not
     * @type {boolean}
     * @memberof MergePersonItem
     */
    'active_flag'?: boolean;
    /**
     * A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ \"value\": \"12345\", \"primary\": \"true\", \"label\": \"mobile\" }]`. Please note that only `value` is required.
     * @type {Array<PersonItemAllOfPhoneInner>}
     * @memberof MergePersonItem
     */
    'phone'?: Array<PersonItemAllOfPhoneInner>;
    /**
     * An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ \"value\": \"mail@example.com\", \"primary\": \"true\", \"label\": \"main\" } ]`. Please note that only `value` is required.
     * @type {Array<PersonItemAllOfEmailInner>}
     * @memberof MergePersonItem
     */
    'email'?: Array<PersonItemAllOfEmailInner>;
    /**
     * The first letter of the name of the person
     * @type {string}
     * @memberof MergePersonItem
     */
    'first_char'?: string;
    /**
     * The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof MergePersonItem
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof MergePersonItem
     */
    'update_time'?: string;
    /**
     * The visibility group ID of who can see the person
     * @type {string}
     * @memberof MergePersonItem
     */
    'visible_to'?: string;
    /**
     *
     * @type {PersonItemAllOfPictureId}
     * @memberof MergePersonItem
     */
    'picture_id'?: PersonItemAllOfPictureId;
    /**
     * The label assigned to the person
     * @type {number}
     * @memberof MergePersonItem
     */
    'label'?: number;
    /**
     * The name of the organization associated with the person
     * @type {string}
     * @memberof MergePersonItem
     */
    'org_name'?: string;
    /**
     * The name of the owner associated with the person
     * @type {string}
     * @memberof MergePersonItem
     */
    'owner_name'?: string;
    /**
     * The BCC email associated with the person
     * @type {string}
     * @memberof MergePersonItem
     */
    'cc_email'?: string;
    /**
     * The ID of the owner related to the person
     * @type {number}
     * @memberof MergePersonItem
     */
    'owner_id'?: number;
    /**
     * The ID of the organization related to the person
     * @type {number}
     * @memberof MergePersonItem
     */
    'org_id'?: number;
    /**
     * The ID of the person with what the main person was merged
     * @type {number}
     * @memberof MergePersonItem
     */
    'merge_what_id'?: number;
    /**
     * The name of the person
     * @type {string}
     * @memberof MergePersonItem
     */
    'name'?: string;
    /**
     * The first name of the person
     * @type {string}
     * @memberof MergePersonItem
     */
    'first_name'?: string;
    /**
     * The last name of the person
     * @type {string}
     * @memberof MergePersonItem
     */
    'last_name'?: string;
    /**
     * The count of email messages related to the person
     * @type {number}
     * @memberof MergePersonItem
     */
    'email_messages_count'?: number;
    /**
     * The count of activities related to the person
     * @type {number}
     * @memberof MergePersonItem
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the person
     * @type {number}
     * @memberof MergePersonItem
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the person
     * @type {number}
     * @memberof MergePersonItem
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the person
     * @type {number}
     * @memberof MergePersonItem
     */
    'files_count'?: number;
    /**
     * The count of notes related to the person
     * @type {number}
     * @memberof MergePersonItem
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the person
     * @type {number}
     * @memberof MergePersonItem
     */
    'followers_count'?: number;
    /**
     * The date and time of the last incoming email associated with the person
     * @type {string}
     * @memberof MergePersonItem
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the person
     * @type {string}
     * @memberof MergePersonItem
     */
    'last_outgoing_mail_time'?: string;
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof MergePersonItem
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof MergePersonItem
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof MergePersonItem
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof MergePersonItem
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof MergePersonItem
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof MergePersonItem
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof MergePersonItem
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof MergePersonItem
     */
    'related_lost_deals_count'?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof MergePersonItem
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof MergePersonItem
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof MergePersonItem
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof MergePersonItem
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof MergePersonItem
     */
    'last_activity_date'?: string | null;
    /**
     * The count of open participant deals related with the item
     * @type {number}
     * @memberof MergePersonItem
     */
    'participant_open_deals_count'?: number;
    /**
     * The count of closed participant deals related with the item
     * @type {number}
     * @memberof MergePersonItem
     */
    'participant_closed_deals_count'?: number;
}
/**
 *
 * @export
 * @interface MergePersonsRequest
 */
export interface MergePersonsRequest {
    /**
     * The ID of the person that will not be overwritten. This person’s data will be prioritized in case of conflict with the other person.
     * @type {number}
     * @memberof MergePersonsRequest
     */
    'merge_with_id': number;
}
/**
 *
 * @export
 * @interface MergePersonsResponse200
 */
export interface MergePersonsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof MergePersonsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {MergePersonItem}
     * @memberof MergePersonsResponse200
     */
    'data'?: MergePersonItem;
}
/**
 *
 * @export
 * @interface MergePersonsResponse200AllOf
 */
export interface MergePersonsResponse200AllOf {
    /**
     *
     * @type {MergePersonItem}
     * @memberof MergePersonsResponse200AllOf
     */
    'data'?: MergePersonItem;
}
/**
 *
 * @export
 * @interface NewDealParameters
 */
export interface NewDealParameters {
    /**
     * The value of the deal. If omitted, value will be set to 0.
     * @type {string}
     * @memberof NewDealParameters
     */
    'value'?: string;
    /**
     * The array of the labels IDs.
     * @type {Array<number>}
     * @memberof NewDealParameters
     */
    'label'?: Array<number>;
    /**
     * The currency of the deal. Accepts a 3-character currency code. If omitted, currency will be set to the default currency of the authorized user.
     * @type {string}
     * @memberof NewDealParameters
     */
    'currency'?: string;
    /**
     * The ID of the user which will be the owner of the created deal. If not provided, the user making the request will be used.
     * @type {number}
     * @memberof NewDealParameters
     */
    'user_id'?: number;
    /**
     * The ID of a person which this deal will be linked to. If the person does not exist yet, it needs to be created first. This property is required unless `org_id` is specified.
     * @type {number}
     * @memberof NewDealParameters
     */
    'person_id'?: number;
    /**
     * The ID of an organization which this deal will be linked to. If the organization does not exist yet, it needs to be created first. This property is required unless `person_id` is specified.
     * @type {number}
     * @memberof NewDealParameters
     */
    'org_id'?: number;
    /**
     * The ID of the pipeline this deal will be added to. By default, the deal will be added to the first stage of the specified pipeline. Please note that `pipeline_id` and `stage_id` should not be used together as `pipeline_id` will be ignored.
     * @type {number}
     * @memberof NewDealParameters
     */
    'pipeline_id'?: number;
    /**
     * The ID of the stage this deal will be added to. Please note that a pipeline will be assigned automatically based on the `stage_id`. If omitted, the deal will be placed in the first stage of the default pipeline.
     * @type {number}
     * @memberof NewDealParameters
     */
    'stage_id'?: number;
    /**
     * open = Open, won = Won, lost = Lost, deleted = Deleted. If omitted, status will be set to open.
     * @type {string}
     * @memberof NewDealParameters
     */
    'status'?: NewDealParametersStatusConst;
    /**
     * The optional creation date & time of the deal in UTC. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof NewDealParameters
     */
    'add_time'?: string;
}

export const NewDealParametersStatusConst = {
    open: 'open',
    won: 'won',
    lost: 'lost',
    deleted: 'deleted'
} as const;

export type NewDealParametersStatusConst = typeof NewDealParametersStatusConst[keyof typeof NewDealParametersStatusConst];

/**
 *
 * @export
 * @interface NewFollowerResponse200
 */
export interface NewFollowerResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof NewFollowerResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {NewFollowerResponse200Data}
     * @memberof NewFollowerResponse200
     */
    'data'?: NewFollowerResponse200Data;
}
/**
 *
 * @export
 * @interface NewFollowerResponse200Data
 */
export interface NewFollowerResponse200Data {
    /**
     * The ID of the user that was added as follower
     * @type {number}
     * @memberof NewFollowerResponse200Data
     */
    'user_id'?: number;
    /**
     * The ID of the follower
     * @type {number}
     * @memberof NewFollowerResponse200Data
     */
    'id'?: number;
    /**
     * The ID of the product
     * @type {number}
     * @memberof NewFollowerResponse200Data
     */
    'product_id'?: number;
    /**
     * The follower creation time. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof NewFollowerResponse200Data
     */
    'add_time'?: string;
}
/**
 *
 * @export
 * @interface NoteRequest
 */
export interface NoteRequest {
    /**
     * The content of the note in HTML format. Subject to sanitization on the back-end.
     * @type {string}
     * @memberof NoteRequest
     */
    'content'?: string;
    /**
     * The ID of the lead the note will be attached to
     * @type {string}
     * @memberof NoteRequest
     */
    'lead_id'?: string;
    /**
     * The ID of the deal the note will be attached to
     * @type {number}
     * @memberof NoteRequest
     */
    'deal_id'?: number;
    /**
     * The ID of the person the note will be attached to
     * @type {number}
     * @memberof NoteRequest
     */
    'person_id'?: number;
    /**
     * The ID of the organization the note will be attached to
     * @type {number}
     * @memberof NoteRequest
     */
    'org_id'?: number;
    /**
     * The ID of the user who will be marked as the author of the note. Only an admin can change the author.
     * @type {number}
     * @memberof NoteRequest
     */
    'user_id'?: number;
    /**
     * The optional creation date & time of the note in UTC. Can be set in the past or in the future. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof NoteRequest
     */
    'add_time'?: string;
    /**
     *
     * @type {number}
     * @memberof NoteRequest
     */
    'pinned_to_lead_flag'?: NoteRequestPinnedToLeadFlagConst;
    /**
     *
     * @type {number}
     * @memberof NoteRequest
     */
    'pinned_to_deal_flag'?: NoteRequestPinnedToDealFlagConst;
    /**
     *
     * @type {number}
     * @memberof NoteRequest
     */
    'pinned_to_organization_flag'?: NoteRequestPinnedToOrganizationFlagConst;
    /**
     *
     * @type {number}
     * @memberof NoteRequest
     */
    'pinned_to_person_flag'?: NoteRequestPinnedToPersonFlagConst;
}

export const NoteRequestPinnedToLeadFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type NoteRequestPinnedToLeadFlagConst = typeof NoteRequestPinnedToLeadFlagConst[keyof typeof NoteRequestPinnedToLeadFlagConst];
export const NoteRequestPinnedToDealFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type NoteRequestPinnedToDealFlagConst = typeof NoteRequestPinnedToDealFlagConst[keyof typeof NoteRequestPinnedToDealFlagConst];
export const NoteRequestPinnedToOrganizationFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type NoteRequestPinnedToOrganizationFlagConst = typeof NoteRequestPinnedToOrganizationFlagConst[keyof typeof NoteRequestPinnedToOrganizationFlagConst];
export const NoteRequestPinnedToPersonFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type NoteRequestPinnedToPersonFlagConst = typeof NoteRequestPinnedToPersonFlagConst[keyof typeof NoteRequestPinnedToPersonFlagConst];

/**
 *
 * @export
 * @interface NoteRequestAllOf
 */
export interface NoteRequestAllOf {
    /**
     * The content of the note in HTML format. Subject to sanitization on the back-end.
     * @type {string}
     * @memberof NoteRequestAllOf
     */
    'content'?: string;
}
/**
 *
 * @export
 * @interface NoteRequestAllOf1
 */
export interface NoteRequestAllOf1 {
    /**
     * The ID of the lead the note will be attached to
     * @type {string}
     * @memberof NoteRequestAllOf1
     */
    'lead_id'?: string;
    /**
     * The ID of the deal the note will be attached to
     * @type {number}
     * @memberof NoteRequestAllOf1
     */
    'deal_id'?: number;
    /**
     * The ID of the person the note will be attached to
     * @type {number}
     * @memberof NoteRequestAllOf1
     */
    'person_id'?: number;
    /**
     * The ID of the organization the note will be attached to
     * @type {number}
     * @memberof NoteRequestAllOf1
     */
    'org_id'?: number;
}
/**
 *
 * @export
 * @interface OneCommentResponse200
 */
export interface OneCommentResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof OneCommentResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetCommentsResponse200DataInner}
     * @memberof OneCommentResponse200
     */
    'data'?: GetCommentsResponse200DataInner;
}
/**
 *
 * @export
 * @interface OneLeadResponse200
 */
export interface OneLeadResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof OneLeadResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetLeadsResponse200DataInner}
     * @memberof OneLeadResponse200
     */
    'data'?: GetLeadsResponse200DataInner;
}
/**
 *
 * @export
 * @interface OneNoteResponse200
 */
export interface OneNoteResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof OneNoteResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetNotesResponse200DataInner}
     * @memberof OneNoteResponse200
     */
    'data'?: GetNotesResponse200DataInner;
}
/**
 *
 * @export
 * @interface OrganizationCountAndAddressInfo
 */
export interface OrganizationCountAndAddressInfo {
    /**
     * The count of email messages related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfo
     */
    'email_messages_count'?: number;
    /**
     * The count of persons related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfo
     */
    'people_count'?: number;
    /**
     * The count of activities related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfo
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfo
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfo
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfo
     */
    'files_count'?: number;
    /**
     * The count of notes related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfo
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfo
     */
    'followers_count'?: number;
    /**
     * The full address of the organization
     * @type {string}
     * @memberof OrganizationCountAndAddressInfo
     */
    'address'?: string;
    /**
     * The sub-premise of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfo
     */
    'address_subpremise'?: string;
    /**
     * The street number of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfo
     */
    'address_street_number'?: string;
    /**
     * The route of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfo
     */
    'address_route'?: string;
    /**
     * The sub-locality of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfo
     */
    'address_sublocality'?: string;
    /**
     * The locality of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfo
     */
    'address_locality'?: string;
    /**
     * The level 1 admin area of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfo
     */
    'address_admin_area_level_1'?: string;
    /**
     * The level 2 admin area of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfo
     */
    'address_admin_area_level_2'?: string;
    /**
     * The country of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfo
     */
    'address_country'?: string;
    /**
     * The postal code of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfo
     */
    'address_postal_code'?: string;
    /**
     * The formatted organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfo
     */
    'address_formatted_address'?: string;
}
/**
 *
 * @export
 * @interface OrganizationCountAndAddressInfoAllOf
 */
export interface OrganizationCountAndAddressInfoAllOf {
    /**
     * The count of email messages related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfoAllOf
     */
    'email_messages_count'?: number;
    /**
     * The count of persons related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfoAllOf
     */
    'people_count'?: number;
    /**
     * The count of activities related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfoAllOf
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfoAllOf
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfoAllOf
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfoAllOf
     */
    'files_count'?: number;
    /**
     * The count of notes related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfoAllOf
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the organization
     * @type {number}
     * @memberof OrganizationCountAndAddressInfoAllOf
     */
    'followers_count'?: number;
}
/**
 *
 * @export
 * @interface OrganizationCountAndAddressInfoAllOf1
 */
export interface OrganizationCountAndAddressInfoAllOf1 {
    /**
     * The full address of the organization
     * @type {string}
     * @memberof OrganizationCountAndAddressInfoAllOf1
     */
    'address'?: string;
    /**
     * The sub-premise of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfoAllOf1
     */
    'address_subpremise'?: string;
    /**
     * The street number of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfoAllOf1
     */
    'address_street_number'?: string;
    /**
     * The route of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfoAllOf1
     */
    'address_route'?: string;
    /**
     * The sub-locality of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfoAllOf1
     */
    'address_sublocality'?: string;
    /**
     * The locality of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfoAllOf1
     */
    'address_locality'?: string;
    /**
     * The level 1 admin area of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfoAllOf1
     */
    'address_admin_area_level_1'?: string;
    /**
     * The level 2 admin area of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfoAllOf1
     */
    'address_admin_area_level_2'?: string;
    /**
     * The country of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfoAllOf1
     */
    'address_country'?: string;
    /**
     * The postal code of the organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfoAllOf1
     */
    'address_postal_code'?: string;
    /**
     * The formatted organization location
     * @type {string}
     * @memberof OrganizationCountAndAddressInfoAllOf1
     */
    'address_formatted_address'?: string;
}
/**
 *
 * @export
 * @interface OrganizationItem
 */
export interface OrganizationItem {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationItem
     */
    'id'?: number;
    /**
     * The ID of the company related to the organization
     * @type {number}
     * @memberof OrganizationItem
     */
    'company_id'?: number;
    /**
     *
     * @type {Owner}
     * @memberof OrganizationItem
     */
    'owner_id'?: Owner;
    /**
     * The name of the organization
     * @type {string}
     * @memberof OrganizationItem
     */
    'name'?: string;
    /**
     * Whether the organization is active or not
     * @type {boolean}
     * @memberof OrganizationItem
     */
    'active_flag'?: boolean;
    /**
     *
     * @type {BaseOrganizationItemAllOfPictureId}
     * @memberof OrganizationItem
     */
    'picture_id'?: BaseOrganizationItemAllOfPictureId;
    /**
     * The country code of the organization
     * @type {string}
     * @memberof OrganizationItem
     */
    'country_code'?: string;
    /**
     * The first character of the organization name
     * @type {string}
     * @memberof OrganizationItem
     */
    'first_char'?: string;
    /**
     * The creation date and time of the organization
     * @type {string}
     * @memberof OrganizationItem
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the organization
     * @type {string}
     * @memberof OrganizationItem
     */
    'update_time'?: string;
    /**
     * The visibility group ID of who can see the organization
     * @type {string}
     * @memberof OrganizationItem
     */
    'visible_to'?: string;
    /**
     * The label assigned to the organization
     * @type {number}
     * @memberof OrganizationItem
     */
    'label'?: number;
    /**
     * The name of the organization owner
     * @type {string}
     * @memberof OrganizationItem
     */
    'owner_name'?: string;
    /**
     * The BCC email associated with the organization
     * @type {string}
     * @memberof OrganizationItem
     */
    'cc_email'?: string;
    /**
     * The count of email messages related to the organization
     * @type {number}
     * @memberof OrganizationItem
     */
    'email_messages_count'?: number;
    /**
     * The count of persons related to the organization
     * @type {number}
     * @memberof OrganizationItem
     */
    'people_count'?: number;
    /**
     * The count of activities related to the organization
     * @type {number}
     * @memberof OrganizationItem
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the organization
     * @type {number}
     * @memberof OrganizationItem
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the organization
     * @type {number}
     * @memberof OrganizationItem
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the organization
     * @type {number}
     * @memberof OrganizationItem
     */
    'files_count'?: number;
    /**
     * The count of notes related to the organization
     * @type {number}
     * @memberof OrganizationItem
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the organization
     * @type {number}
     * @memberof OrganizationItem
     */
    'followers_count'?: number;
    /**
     * The full address of the organization
     * @type {string}
     * @memberof OrganizationItem
     */
    'address'?: string;
    /**
     * The sub-premise of the organization location
     * @type {string}
     * @memberof OrganizationItem
     */
    'address_subpremise'?: string;
    /**
     * The street number of the organization location
     * @type {string}
     * @memberof OrganizationItem
     */
    'address_street_number'?: string;
    /**
     * The route of the organization location
     * @type {string}
     * @memberof OrganizationItem
     */
    'address_route'?: string;
    /**
     * The sub-locality of the organization location
     * @type {string}
     * @memberof OrganizationItem
     */
    'address_sublocality'?: string;
    /**
     * The locality of the organization location
     * @type {string}
     * @memberof OrganizationItem
     */
    'address_locality'?: string;
    /**
     * The level 1 admin area of the organization location
     * @type {string}
     * @memberof OrganizationItem
     */
    'address_admin_area_level_1'?: string;
    /**
     * The level 2 admin area of the organization location
     * @type {string}
     * @memberof OrganizationItem
     */
    'address_admin_area_level_2'?: string;
    /**
     * The country of the organization location
     * @type {string}
     * @memberof OrganizationItem
     */
    'address_country'?: string;
    /**
     * The postal code of the organization location
     * @type {string}
     * @memberof OrganizationItem
     */
    'address_postal_code'?: string;
    /**
     * The formatted organization location
     * @type {string}
     * @memberof OrganizationItem
     */
    'address_formatted_address'?: string;
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof OrganizationItem
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof OrganizationItem
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof OrganizationItem
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof OrganizationItem
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof OrganizationItem
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof OrganizationItem
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof OrganizationItem
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof OrganizationItem
     */
    'related_lost_deals_count'?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof OrganizationItem
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof OrganizationItem
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof OrganizationItem
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof OrganizationItem
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof OrganizationItem
     */
    'last_activity_date'?: string | null;
    /**
     * If the company ID of the organization and company ID of the request is same or not
     * @type {boolean}
     * @memberof OrganizationItem
     */
    'edit_name'?: boolean;
    /**
     * Please refer to response schema of <a href=\"https://developers.pipedrive.com/docs/api/v1/Activities#getActivity\">Activity</a>
     * @type {object}
     * @memberof OrganizationItem
     */
    'last_activity'?: object | null;
    /**
     * Please refer to response schema of <a href=\"https://developers.pipedrive.com/docs/api/v1/Activities#getActivity\">Activity</a>
     * @type {object}
     * @memberof OrganizationItem
     */
    'next_activity'?: object | null;
}
/**
 *
 * @export
 * @interface OrganizationItemAllOf
 */
export interface OrganizationItemAllOf {
    /**
     * Please refer to response schema of <a href=\"https://developers.pipedrive.com/docs/api/v1/Activities#getActivity\">Activity</a>
     * @type {object}
     * @memberof OrganizationItemAllOf
     */
    'last_activity'?: object | null;
    /**
     * Please refer to response schema of <a href=\"https://developers.pipedrive.com/docs/api/v1/Activities#getActivity\">Activity</a>
     * @type {object}
     * @memberof OrganizationItemAllOf
     */
    'next_activity'?: object | null;
}
/**
 *
 * @export
 * @interface OrganizationRelationship
 */
export interface OrganizationRelationship {
    /**
     * The ID of the base organization for the returned calculated values
     * @type {number}
     * @memberof OrganizationRelationship
     */
    'org_id'?: number;
    /**
     * The type of organization relationship
     * @type {string}
     * @memberof OrganizationRelationship
     */
    'type'?: OrganizationRelationshipTypeConst;
    /**
     * The owner of this relationship. If type is `parent`, then the owner is the parent and the linked organization is the daughter.
     * @type {number}
     * @memberof OrganizationRelationship
     */
    'rel_owner_org_id'?: number;
    /**
     * The linked organization in this relationship. If type is `parent`, then the linked organization is the daughter.
     * @type {number}
     * @memberof OrganizationRelationship
     */
    'rel_linked_org_id'?: number;
}

export const OrganizationRelationshipTypeConst = {
    parent: 'parent',
    related: 'related'
} as const;

export type OrganizationRelationshipTypeConst = typeof OrganizationRelationshipTypeConst[keyof typeof OrganizationRelationshipTypeConst];

/**
 *
 * @export
 * @interface OrganizationRelationshipDetails
 */
export interface OrganizationRelationshipDetails {
    /**
     * The ID of the organization relationship
     * @type {number}
     * @memberof OrganizationRelationshipDetails
     */
    'id'?: number;
    /**
     * The type of the relationship
     * @type {string}
     * @memberof OrganizationRelationshipDetails
     */
    'type'?: string;
    /**
     *
     * @type {RelationshipOrganizationInfoItem}
     * @memberof OrganizationRelationshipDetails
     */
    'rel_owner_org_id'?: RelationshipOrganizationInfoItem;
    /**
     *
     * @type {RelationshipOrganizationInfoItem}
     * @memberof OrganizationRelationshipDetails
     */
    'rel_linked_org_id'?: RelationshipOrganizationInfoItem;
    /**
     * The creation date and time of the relationship
     * @type {string}
     * @memberof OrganizationRelationshipDetails
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the relationship
     * @type {string}
     * @memberof OrganizationRelationshipDetails
     */
    'update_time'?: string;
    /**
     * Whether the relationship is active or not
     * @type {string}
     * @memberof OrganizationRelationshipDetails
     */
    'active_flag'?: string;
    /**
     * The calculated type of the relationship with the linked organization
     * @type {string}
     * @memberof OrganizationRelationshipDetails
     */
    'calculated_type'?: string;
    /**
     * The ID of the linked organization
     * @type {number}
     * @memberof OrganizationRelationshipDetails
     */
    'calculated_related_org_id'?: number;
    /**
     * The name of the linked organization
     * @type {string}
     * @memberof OrganizationRelationshipDetails
     */
    'related_organization_name'?: string;
}
/**
 *
 * @export
 * @interface OrganizationRelationshipDetailsAllOf
 */
export interface OrganizationRelationshipDetailsAllOf {
    /**
     * The name of the linked organization
     * @type {string}
     * @memberof OrganizationRelationshipDetailsAllOf
     */
    'related_organization_name'?: string;
}
/**
 *
 * @export
 * @interface OrganizationRelationshipWithCalculatedFields
 */
export interface OrganizationRelationshipWithCalculatedFields {
    /**
     * The ID of the organization relationship
     * @type {number}
     * @memberof OrganizationRelationshipWithCalculatedFields
     */
    'id'?: number;
    /**
     * The type of the relationship
     * @type {string}
     * @memberof OrganizationRelationshipWithCalculatedFields
     */
    'type'?: string;
    /**
     *
     * @type {RelationshipOrganizationInfoItem}
     * @memberof OrganizationRelationshipWithCalculatedFields
     */
    'rel_owner_org_id'?: RelationshipOrganizationInfoItem;
    /**
     *
     * @type {RelationshipOrganizationInfoItem}
     * @memberof OrganizationRelationshipWithCalculatedFields
     */
    'rel_linked_org_id'?: RelationshipOrganizationInfoItem;
    /**
     * The creation date and time of the relationship
     * @type {string}
     * @memberof OrganizationRelationshipWithCalculatedFields
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the relationship
     * @type {string}
     * @memberof OrganizationRelationshipWithCalculatedFields
     */
    'update_time'?: string;
    /**
     * Whether the relationship is active or not
     * @type {string}
     * @memberof OrganizationRelationshipWithCalculatedFields
     */
    'active_flag'?: string;
    /**
     * The calculated type of the relationship with the linked organization
     * @type {string}
     * @memberof OrganizationRelationshipWithCalculatedFields
     */
    'calculated_type'?: string;
    /**
     * The ID of the linked organization
     * @type {number}
     * @memberof OrganizationRelationshipWithCalculatedFields
     */
    'calculated_related_org_id'?: number;
}
/**
 *
 * @export
 * @interface OrganizationRelationshipWithCalculatedFieldsAllOf
 */
export interface OrganizationRelationshipWithCalculatedFieldsAllOf {
    /**
     * The ID of the organization relationship
     * @type {number}
     * @memberof OrganizationRelationshipWithCalculatedFieldsAllOf
     */
    'id'?: number;
    /**
     * The type of the relationship
     * @type {string}
     * @memberof OrganizationRelationshipWithCalculatedFieldsAllOf
     */
    'type'?: string;
    /**
     *
     * @type {RelationshipOrganizationInfoItem}
     * @memberof OrganizationRelationshipWithCalculatedFieldsAllOf
     */
    'rel_owner_org_id'?: RelationshipOrganizationInfoItem;
    /**
     *
     * @type {RelationshipOrganizationInfoItem}
     * @memberof OrganizationRelationshipWithCalculatedFieldsAllOf
     */
    'rel_linked_org_id'?: RelationshipOrganizationInfoItem;
    /**
     * The creation date and time of the relationship
     * @type {string}
     * @memberof OrganizationRelationshipWithCalculatedFieldsAllOf
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the relationship
     * @type {string}
     * @memberof OrganizationRelationshipWithCalculatedFieldsAllOf
     */
    'update_time'?: string;
    /**
     * Whether the relationship is active or not
     * @type {string}
     * @memberof OrganizationRelationshipWithCalculatedFieldsAllOf
     */
    'active_flag'?: string;
}
/**
 *
 * @export
 * @interface OrganizationRelationshipWithCalculatedFieldsAllOf1
 */
export interface OrganizationRelationshipWithCalculatedFieldsAllOf1 {
    /**
     * The calculated type of the relationship with the linked organization
     * @type {string}
     * @memberof OrganizationRelationshipWithCalculatedFieldsAllOf1
     */
    'calculated_type'?: string;
    /**
     * The ID of the linked organization
     * @type {number}
     * @memberof OrganizationRelationshipWithCalculatedFieldsAllOf1
     */
    'calculated_related_org_id'?: number;
}
/**
 *
 * @export
 * @interface OrganizationsCollectionResponseObject
 */
export interface OrganizationsCollectionResponseObject {
    /**
     * The full address of the organization
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'address'?: string;
    /**
     * The sub-premise of the organization location
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'address_subpremise'?: string;
    /**
     * The street number of the organization location
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'address_street_number'?: string;
    /**
     * The route of the organization location
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'address_route'?: string;
    /**
     * The sub-locality of the organization location
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'address_sublocality'?: string;
    /**
     * The locality of the organization location
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'address_locality'?: string;
    /**
     * The level 1 admin area of the organization location
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'address_admin_area_level_1'?: string;
    /**
     * The level 2 admin area of the organization location
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'address_admin_area_level_2'?: string;
    /**
     * The country of the organization location
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'address_country'?: string;
    /**
     * The postal code of the organization location
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'address_postal_code'?: string;
    /**
     * The formatted organization location
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'address_formatted_address'?: string;
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsCollectionResponseObject
     */
    'id'?: number;
    /**
     * Whether the organization is active or not
     * @type {boolean}
     * @memberof OrganizationsCollectionResponseObject
     */
    'active_flag'?: boolean;
    /**
     * The ID of the owner
     * @type {number}
     * @memberof OrganizationsCollectionResponseObject
     */
    'owner_id'?: number;
    /**
     * The name of the organization
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'name'?: string;
    /**
     * The last updated date and time of the organization. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'update_time'?: string;
    /**
     * The date and time this organization was deleted. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'delete_time'?: string | null;
    /**
     * The date and time when the organization was added/created. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'add_time'?: string;
    /**
     * The visibility group ID of who can see the organization
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'visible_to'?: string;
    /**
     * The label assigned to the organization
     * @type {number}
     * @memberof OrganizationsCollectionResponseObject
     */
    'label'?: number | null;
    /**
     * The BCC email associated with the organization
     * @type {string}
     * @memberof OrganizationsCollectionResponseObject
     */
    'cc_email'?: string;
}
/**
 *
 * @export
 * @interface OrganizationsCollectionResponseObjectAllOf
 */
export interface OrganizationsCollectionResponseObjectAllOf {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsCollectionResponseObjectAllOf
     */
    'id'?: number;
    /**
     * Whether the organization is active or not
     * @type {boolean}
     * @memberof OrganizationsCollectionResponseObjectAllOf
     */
    'active_flag'?: boolean;
    /**
     * The ID of the owner
     * @type {number}
     * @memberof OrganizationsCollectionResponseObjectAllOf
     */
    'owner_id'?: number;
    /**
     * The name of the organization
     * @type {string}
     * @memberof OrganizationsCollectionResponseObjectAllOf
     */
    'name'?: string;
    /**
     * The last updated date and time of the organization. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof OrganizationsCollectionResponseObjectAllOf
     */
    'update_time'?: string;
    /**
     * The date and time this organization was deleted. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof OrganizationsCollectionResponseObjectAllOf
     */
    'delete_time'?: string | null;
    /**
     * The date and time when the organization was added/created. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof OrganizationsCollectionResponseObjectAllOf
     */
    'add_time'?: string;
    /**
     * The visibility group ID of who can see the organization
     * @type {string}
     * @memberof OrganizationsCollectionResponseObjectAllOf
     */
    'visible_to'?: string;
    /**
     * The label assigned to the organization
     * @type {number}
     * @memberof OrganizationsCollectionResponseObjectAllOf
     */
    'label'?: number | null;
    /**
     * The BCC email associated with the organization
     * @type {string}
     * @memberof OrganizationsCollectionResponseObjectAllOf
     */
    'cc_email'?: string;
}
/**
 *
 * @export
 * @interface Owner
 */
export interface Owner {
    /**
     * The ID of the user
     * @type {number}
     * @memberof Owner
     */
    'id'?: number;
    /**
     * The name of the user
     * @type {string}
     * @memberof Owner
     */
    'name'?: string;
    /**
     * The email of the user
     * @type {string}
     * @memberof Owner
     */
    'email'?: string;
    /**
     * Whether the user has picture or not. 0 = No picture, 1 = Has picture.
     * @type {number}
     * @memberof Owner
     */
    'has_pic'?: number;
    /**
     * The user picture hash
     * @type {string}
     * @memberof Owner
     */
    'pic_hash'?: string | null;
    /**
     * Whether the user is active or not
     * @type {boolean}
     * @memberof Owner
     */
    'active_flag'?: boolean;
    /**
     * The ID of the owner
     * @type {number}
     * @memberof Owner
     */
    'value'?: number;
}
/**
 *
 * @export
 * @interface OwnerAllOf
 */
export interface OwnerAllOf {
    /**
     * The ID of the owner
     * @type {number}
     * @memberof OwnerAllOf
     */
    'value'?: number;
}
/**
 * Pagination details of the list
 * @export
 * @interface PaginationDetails
 */
export interface PaginationDetails {
    /**
     * Pagination start
     * @type {number}
     * @memberof PaginationDetails
     */
    'start'?: number;
    /**
     * Items shown per page
     * @type {number}
     * @memberof PaginationDetails
     */
    'limit'?: number;
    /**
     * If there are more list items in the collection than displayed or not
     * @type {boolean}
     * @memberof PaginationDetails
     */
    'more_items_in_collection'?: boolean;
    /**
     * Next pagination start
     * @type {number}
     * @memberof PaginationDetails
     */
    'next_start'?: number;
}
/**
 *
 * @export
 * @interface PaginationDetailsAllOf
 */
export interface PaginationDetailsAllOf {
    /**
     * Next pagination start
     * @type {number}
     * @memberof PaginationDetailsAllOf
     */
    'next_start'?: number;
}
/**
 *
 * @export
 * @interface PaymentResponse200
 */
export interface PaymentResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof PaymentResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<PaymentResponse200AllOfDataInner>}
     * @memberof PaymentResponse200
     */
    'data'?: Array<PaymentResponse200AllOfDataInner>;
}
/**
 *
 * @export
 * @interface PaymentResponse200AllOf
 */
export interface PaymentResponse200AllOf {
    /**
     *
     * @type {Array<PaymentResponse200AllOfDataInner>}
     * @memberof PaymentResponse200AllOf
     */
    'data'?: Array<PaymentResponse200AllOfDataInner>;
}
/**
 *
 * @export
 * @interface PaymentResponse200AllOfDataInner
 */
export interface PaymentResponse200AllOfDataInner {
    /**
     * The ID of the payment
     * @type {number}
     * @memberof PaymentResponse200AllOfDataInner
     */
    'id'?: number;
    /**
     * The ID of the subscription this payment is associated with
     * @type {number}
     * @memberof PaymentResponse200AllOfDataInner
     */
    'subscription_id'?: number;
    /**
     * The ID of the deal this payment is associated with
     * @type {number}
     * @memberof PaymentResponse200AllOfDataInner
     */
    'deal_id'?: number;
    /**
     * The payment status
     * @type {boolean}
     * @memberof PaymentResponse200AllOfDataInner
     */
    'is_active'?: boolean;
    /**
     * The payment amount
     * @type {number}
     * @memberof PaymentResponse200AllOfDataInner
     */
    'amount'?: number;
    /**
     * The currency of the payment
     * @type {string}
     * @memberof PaymentResponse200AllOfDataInner
     */
    'currency'?: string;
    /**
     * The difference between the amount of the current payment and the previous payment. The value can be either positive or negative.
     * @type {number}
     * @memberof PaymentResponse200AllOfDataInner
     */
    'change_amount'?: number;
    /**
     * The date when payment occurs
     * @type {string}
     * @memberof PaymentResponse200AllOfDataInner
     */
    'due_at'?: string;
    /**
     * Represents the movement of revenue in comparison with the previous payment. Possible values are: `New` - first payment of the subscription. `Recurring` - no movement. `Expansion` - current payment amount > previous payment amount. `Contraction` - current payment amount < previous payment amount. `Churn` - last payment of the subscription.
     * @type {string}
     * @memberof PaymentResponse200AllOfDataInner
     */
    'revenue_movement_type'?: PaymentResponse200AllOfDataInnerRevenueMovementTypeConst;
    /**
     * The type of the payment. Possible values are: `Recurring` - payments occur over fixed intervals of time, `Additional` - extra payment not the recurring payment of the recurring subscription, `Installment` - payment of the installment subscription.
     * @type {string}
     * @memberof PaymentResponse200AllOfDataInner
     */
    'payment_type'?: PaymentResponse200AllOfDataInnerPaymentTypeConst;
    /**
     * The description of the payment
     * @type {string}
     * @memberof PaymentResponse200AllOfDataInner
     */
    'description'?: string;
    /**
     * The creation time of the payment
     * @type {string}
     * @memberof PaymentResponse200AllOfDataInner
     */
    'add_time'?: string;
    /**
     * The update time of the payment
     * @type {string}
     * @memberof PaymentResponse200AllOfDataInner
     */
    'update_time'?: string;
}

export const PaymentResponse200AllOfDataInnerRevenueMovementTypeConst = {
    new: 'new',
    recurring: 'recurring',
    expansion: 'expansion',
    contraction: 'contraction',
    none: 'none',
    churn: 'churn'
} as const;

export type PaymentResponse200AllOfDataInnerRevenueMovementTypeConst = typeof PaymentResponse200AllOfDataInnerRevenueMovementTypeConst[keyof typeof PaymentResponse200AllOfDataInnerRevenueMovementTypeConst];
export const PaymentResponse200AllOfDataInnerPaymentTypeConst = {
    recurring: 'recurring',
    additional: 'additional',
    installment: 'installment'
} as const;

export type PaymentResponse200AllOfDataInnerPaymentTypeConst = typeof PaymentResponse200AllOfDataInnerPaymentTypeConst[keyof typeof PaymentResponse200AllOfDataInnerPaymentTypeConst];

/**
 *
 * @export
 * @interface PersonCountAndEmailInfo
 */
export interface PersonCountAndEmailInfo {
    /**
     * The count of email messages related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfo
     */
    'email_messages_count'?: number;
    /**
     * The count of activities related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfo
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfo
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfo
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfo
     */
    'files_count'?: number;
    /**
     * The count of notes related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfo
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfo
     */
    'followers_count'?: number;
    /**
     * The date and time of the last incoming email associated with the person
     * @type {string}
     * @memberof PersonCountAndEmailInfo
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the person
     * @type {string}
     * @memberof PersonCountAndEmailInfo
     */
    'last_outgoing_mail_time'?: string;
}
/**
 *
 * @export
 * @interface PersonCountAndEmailInfoAllOf
 */
export interface PersonCountAndEmailInfoAllOf {
    /**
     * The count of email messages related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfoAllOf
     */
    'email_messages_count'?: number;
    /**
     * The count of activities related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfoAllOf
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfoAllOf
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfoAllOf
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfoAllOf
     */
    'files_count'?: number;
    /**
     * The count of notes related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfoAllOf
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the person
     * @type {number}
     * @memberof PersonCountAndEmailInfoAllOf
     */
    'followers_count'?: number;
}
/**
 *
 * @export
 * @interface PersonCountAndEmailInfoAllOf1
 */
export interface PersonCountAndEmailInfoAllOf1 {
    /**
     * The date and time of the last incoming email associated with the person
     * @type {string}
     * @memberof PersonCountAndEmailInfoAllOf1
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the person
     * @type {string}
     * @memberof PersonCountAndEmailInfoAllOf1
     */
    'last_outgoing_mail_time'?: string;
}
/**
 *
 * @export
 * @interface PersonCountEmailDealAndActivityInfo
 */
export interface PersonCountEmailDealAndActivityInfo {
    /**
     * The count of email messages related to the person
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'email_messages_count'?: number;
    /**
     * The count of activities related to the person
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the person
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the person
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the person
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'files_count'?: number;
    /**
     * The count of notes related to the person
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the person
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'followers_count'?: number;
    /**
     * The date and time of the last incoming email associated with the person
     * @type {string}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the person
     * @type {string}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'last_outgoing_mail_time'?: string;
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'related_lost_deals_count'?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof PersonCountEmailDealAndActivityInfo
     */
    'last_activity_date'?: string | null;
}
/**
 *
 * @export
 * @interface PersonItem
 */
export interface PersonItem {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonItem
     */
    'id'?: number;
    /**
     * The ID of the company related to the person
     * @type {number}
     * @memberof PersonItem
     */
    'company_id'?: number;
    /**
     * Whether the person is active or not
     * @type {boolean}
     * @memberof PersonItem
     */
    'active_flag'?: boolean;
    /**
     * A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ \"value\": \"12345\", \"primary\": \"true\", \"label\": \"mobile\" }]`. Please note that only `value` is required.
     * @type {Array<PersonItemAllOfPhoneInner>}
     * @memberof PersonItem
     */
    'phone'?: Array<PersonItemAllOfPhoneInner>;
    /**
     * An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ \"value\": \"mail@example.com\", \"primary\": \"true\", \"label\": \"main\" } ]`. Please note that only `value` is required.
     * @type {Array<PersonItemAllOfEmailInner>}
     * @memberof PersonItem
     */
    'email'?: Array<PersonItemAllOfEmailInner>;
    /**
     * The first letter of the name of the person
     * @type {string}
     * @memberof PersonItem
     */
    'first_char'?: string;
    /**
     * The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof PersonItem
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof PersonItem
     */
    'update_time'?: string;
    /**
     * The visibility group ID of who can see the person
     * @type {string}
     * @memberof PersonItem
     */
    'visible_to'?: string;
    /**
     *
     * @type {PersonItemAllOfPictureId}
     * @memberof PersonItem
     */
    'picture_id'?: PersonItemAllOfPictureId;
    /**
     * The label assigned to the person
     * @type {number}
     * @memberof PersonItem
     */
    'label'?: number;
    /**
     * The name of the organization associated with the person
     * @type {string}
     * @memberof PersonItem
     */
    'org_name'?: string;
    /**
     * The name of the owner associated with the person
     * @type {string}
     * @memberof PersonItem
     */
    'owner_name'?: string;
    /**
     * The BCC email associated with the person
     * @type {string}
     * @memberof PersonItem
     */
    'cc_email'?: string;
    /**
     *
     * @type {Owner}
     * @memberof PersonItem
     */
    'owner_id'?: Owner;
    /**
     *
     * @type {RelationshipOrganizationInfoItemWithActiveFlag}
     * @memberof PersonItem
     */
    'org_id'?: RelationshipOrganizationInfoItemWithActiveFlag;
    /**
     * The name of the person
     * @type {string}
     * @memberof PersonItem
     */
    'name'?: string;
    /**
     * The first name of the person
     * @type {string}
     * @memberof PersonItem
     */
    'first_name'?: string;
    /**
     * The last name of the person
     * @type {string}
     * @memberof PersonItem
     */
    'last_name'?: string;
    /**
     * The count of email messages related to the person
     * @type {number}
     * @memberof PersonItem
     */
    'email_messages_count'?: number;
    /**
     * The count of activities related to the person
     * @type {number}
     * @memberof PersonItem
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the person
     * @type {number}
     * @memberof PersonItem
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the person
     * @type {number}
     * @memberof PersonItem
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the person
     * @type {number}
     * @memberof PersonItem
     */
    'files_count'?: number;
    /**
     * The count of notes related to the person
     * @type {number}
     * @memberof PersonItem
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the person
     * @type {number}
     * @memberof PersonItem
     */
    'followers_count'?: number;
    /**
     * The date and time of the last incoming email associated with the person
     * @type {string}
     * @memberof PersonItem
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the person
     * @type {string}
     * @memberof PersonItem
     */
    'last_outgoing_mail_time'?: string;
    /**
     * The count of open deals related with the item
     * @type {number}
     * @memberof PersonItem
     */
    'open_deals_count'?: number;
    /**
     * The count of related open deals related with the item
     * @type {number}
     * @memberof PersonItem
     */
    'related_open_deals_count'?: number;
    /**
     * The count of closed deals related with the item
     * @type {number}
     * @memberof PersonItem
     */
    'closed_deals_count'?: number;
    /**
     * The count of related closed deals related with the item
     * @type {number}
     * @memberof PersonItem
     */
    'related_closed_deals_count'?: number;
    /**
     * The count of won deals related with the item
     * @type {number}
     * @memberof PersonItem
     */
    'won_deals_count'?: number;
    /**
     * The count of related won deals related with the item
     * @type {number}
     * @memberof PersonItem
     */
    'related_won_deals_count'?: number;
    /**
     * The count of lost deals related with the item
     * @type {number}
     * @memberof PersonItem
     */
    'lost_deals_count'?: number;
    /**
     * The count of related lost deals related with the item
     * @type {number}
     * @memberof PersonItem
     */
    'related_lost_deals_count'?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof PersonItem
     */
    'next_activity_date'?: string | null;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof PersonItem
     */
    'next_activity_time'?: string | null;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof PersonItem
     */
    'next_activity_id'?: number | null;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof PersonItem
     */
    'last_activity_id'?: number | null;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof PersonItem
     */
    'last_activity_date'?: string | null;
}
/**
 *
 * @export
 * @interface PersonItemAllOf
 */
export interface PersonItemAllOf {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonItemAllOf
     */
    'id'?: number;
    /**
     * The ID of the company related to the person
     * @type {number}
     * @memberof PersonItemAllOf
     */
    'company_id'?: number;
    /**
     * Whether the person is active or not
     * @type {boolean}
     * @memberof PersonItemAllOf
     */
    'active_flag'?: boolean;
    /**
     * A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ \"value\": \"12345\", \"primary\": \"true\", \"label\": \"mobile\" }]`. Please note that only `value` is required.
     * @type {Array<PersonItemAllOfPhoneInner>}
     * @memberof PersonItemAllOf
     */
    'phone'?: Array<PersonItemAllOfPhoneInner>;
    /**
     * An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ \"value\": \"mail@example.com\", \"primary\": \"true\", \"label\": \"main\" } ]`. Please note that only `value` is required.
     * @type {Array<PersonItemAllOfEmailInner>}
     * @memberof PersonItemAllOf
     */
    'email'?: Array<PersonItemAllOfEmailInner>;
    /**
     * The first letter of the name of the person
     * @type {string}
     * @memberof PersonItemAllOf
     */
    'first_char'?: string;
    /**
     * The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof PersonItemAllOf
     */
    'add_time'?: string;
    /**
     * The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof PersonItemAllOf
     */
    'update_time'?: string;
    /**
     * The visibility group ID of who can see the person
     * @type {string}
     * @memberof PersonItemAllOf
     */
    'visible_to'?: string;
    /**
     *
     * @type {PersonItemAllOfPictureId}
     * @memberof PersonItemAllOf
     */
    'picture_id'?: PersonItemAllOfPictureId;
    /**
     * The label assigned to the person
     * @type {number}
     * @memberof PersonItemAllOf
     */
    'label'?: number;
    /**
     * The name of the organization associated with the person
     * @type {string}
     * @memberof PersonItemAllOf
     */
    'org_name'?: string;
    /**
     * The name of the owner associated with the person
     * @type {string}
     * @memberof PersonItemAllOf
     */
    'owner_name'?: string;
    /**
     * The BCC email associated with the person
     * @type {string}
     * @memberof PersonItemAllOf
     */
    'cc_email'?: string;
}
/**
 *
 * @export
 * @interface PersonItemAllOfEmailInner
 */
export interface PersonItemAllOfEmailInner {
    /**
     * Email
     * @type {string}
     * @memberof PersonItemAllOfEmailInner
     */
    'value'?: string;
    /**
     * Boolean that indicates if email is primary for the person or not
     * @type {boolean}
     * @memberof PersonItemAllOfEmailInner
     */
    'primary'?: boolean;
    /**
     * The label that indicates the type of the email. (Possible values - work, home or other)
     * @type {string}
     * @memberof PersonItemAllOfEmailInner
     */
    'label'?: string;
}
/**
 *
 * @export
 * @interface PersonItemAllOfPhoneInner
 */
export interface PersonItemAllOfPhoneInner {
    /**
     * The phone number
     * @type {string}
     * @memberof PersonItemAllOfPhoneInner
     */
    'value'?: string;
    /**
     * Boolean that indicates if phone number is primary for the person or not
     * @type {boolean}
     * @memberof PersonItemAllOfPhoneInner
     */
    'primary'?: boolean;
    /**
     * The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
     * @type {string}
     * @memberof PersonItemAllOfPhoneInner
     */
    'label'?: string;
}
/**
 *
 * @export
 * @interface PersonItemAllOfPictureId
 */
export interface PersonItemAllOfPictureId {
    /**
     * The ID of the picture associated with the item
     * @type {number}
     * @memberof PersonItemAllOfPictureId
     */
    'id'?: number;
    /**
     * The type of item the picture is related to
     * @type {string}
     * @memberof PersonItemAllOfPictureId
     */
    'item_type'?: string;
    /**
     * The ID of related item
     * @type {number}
     * @memberof PersonItemAllOfPictureId
     */
    'item_id'?: number;
    /**
     * Whether the associated picture is active or not
     * @type {boolean}
     * @memberof PersonItemAllOfPictureId
     */
    'active_flag'?: boolean;
    /**
     * The add time of the picture
     * @type {string}
     * @memberof PersonItemAllOfPictureId
     */
    'add_time'?: string;
    /**
     * The update time of the picture
     * @type {string}
     * @memberof PersonItemAllOfPictureId
     */
    'update_time'?: string;
    /**
     * The ID of the user who added the picture
     * @type {number}
     * @memberof PersonItemAllOfPictureId
     */
    'added_by_user_id'?: number;
    /**
     *
     * @type {PersonItemAllOfPictureIdAllOf1Pictures}
     * @memberof PersonItemAllOfPictureId
     */
    'pictures'?: PersonItemAllOfPictureIdAllOf1Pictures;
}
/**
 *
 * @export
 * @interface PersonItemAllOfPictureIdAllOf
 */
export interface PersonItemAllOfPictureIdAllOf {
    /**
     * The ID of the picture associated with the item
     * @type {number}
     * @memberof PersonItemAllOfPictureIdAllOf
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface PersonItemAllOfPictureIdAllOf1
 */
export interface PersonItemAllOfPictureIdAllOf1 {
    /**
     * The type of item the picture is related to
     * @type {string}
     * @memberof PersonItemAllOfPictureIdAllOf1
     */
    'item_type'?: string;
    /**
     * The ID of related item
     * @type {number}
     * @memberof PersonItemAllOfPictureIdAllOf1
     */
    'item_id'?: number;
    /**
     * Whether the associated picture is active or not
     * @type {boolean}
     * @memberof PersonItemAllOfPictureIdAllOf1
     */
    'active_flag'?: boolean;
    /**
     * The add time of the picture
     * @type {string}
     * @memberof PersonItemAllOfPictureIdAllOf1
     */
    'add_time'?: string;
    /**
     * The update time of the picture
     * @type {string}
     * @memberof PersonItemAllOfPictureIdAllOf1
     */
    'update_time'?: string;
    /**
     * The ID of the user who added the picture
     * @type {number}
     * @memberof PersonItemAllOfPictureIdAllOf1
     */
    'added_by_user_id'?: number;
    /**
     *
     * @type {PersonItemAllOfPictureIdAllOf1Pictures}
     * @memberof PersonItemAllOfPictureIdAllOf1
     */
    'pictures'?: PersonItemAllOfPictureIdAllOf1Pictures;
}
/**
 *
 * @export
 * @interface PersonItemAllOfPictureIdAllOf1Pictures
 */
export interface PersonItemAllOfPictureIdAllOf1Pictures {
    /**
     * The URL of the 128*128 picture
     * @type {string}
     * @memberof PersonItemAllOfPictureIdAllOf1Pictures
     */
    '128'?: string;
    /**
     * The URL of the 512*512 picture
     * @type {string}
     * @memberof PersonItemAllOfPictureIdAllOf1Pictures
     */
    '512'?: string;
}
/**
 *
 * @export
 * @interface PersonNameCountAndEmailInfo
 */
export interface PersonNameCountAndEmailInfo {
    /**
     * The name of the person
     * @type {string}
     * @memberof PersonNameCountAndEmailInfo
     */
    'name'?: string;
    /**
     * The first name of the person
     * @type {string}
     * @memberof PersonNameCountAndEmailInfo
     */
    'first_name'?: string;
    /**
     * The last name of the person
     * @type {string}
     * @memberof PersonNameCountAndEmailInfo
     */
    'last_name'?: string;
    /**
     * The count of email messages related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfo
     */
    'email_messages_count'?: number;
    /**
     * The count of activities related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfo
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfo
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfo
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfo
     */
    'files_count'?: number;
    /**
     * The count of notes related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfo
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfo
     */
    'followers_count'?: number;
    /**
     * The date and time of the last incoming email associated with the person
     * @type {string}
     * @memberof PersonNameCountAndEmailInfo
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the person
     * @type {string}
     * @memberof PersonNameCountAndEmailInfo
     */
    'last_outgoing_mail_time'?: string;
}
/**
 *
 * @export
 * @interface PersonNameCountAndEmailInfoWithIds
 */
export interface PersonNameCountAndEmailInfoWithIds {
    /**
     * The ID of the owner related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'owner_id'?: number;
    /**
     * The ID of the organization related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'org_id'?: number;
    /**
     * The ID of the person with what the main person was merged
     * @type {number}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'merge_what_id'?: number;
    /**
     * The name of the person
     * @type {string}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'name'?: string;
    /**
     * The first name of the person
     * @type {string}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'first_name'?: string;
    /**
     * The last name of the person
     * @type {string}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'last_name'?: string;
    /**
     * The count of email messages related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'email_messages_count'?: number;
    /**
     * The count of activities related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'activities_count'?: number;
    /**
     * The count of done activities related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'done_activities_count'?: number;
    /**
     * The count of undone activities related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'undone_activities_count'?: number;
    /**
     * The count of files related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'files_count'?: number;
    /**
     * The count of notes related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'notes_count'?: number;
    /**
     * The count of followers related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'followers_count'?: number;
    /**
     * The date and time of the last incoming email associated with the person
     * @type {string}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'last_incoming_mail_time'?: string;
    /**
     * The date and time of the last outgoing email associated with the person
     * @type {string}
     * @memberof PersonNameCountAndEmailInfoWithIds
     */
    'last_outgoing_mail_time'?: string;
}
/**
 *
 * @export
 * @interface PersonNameCountAndEmailInfoWithIdsAllOf
 */
export interface PersonNameCountAndEmailInfoWithIdsAllOf {
    /**
     * The ID of the owner related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfoWithIdsAllOf
     */
    'owner_id'?: number;
    /**
     * The ID of the organization related to the person
     * @type {number}
     * @memberof PersonNameCountAndEmailInfoWithIdsAllOf
     */
    'org_id'?: number;
    /**
     * The ID of the person with what the main person was merged
     * @type {number}
     * @memberof PersonNameCountAndEmailInfoWithIdsAllOf
     */
    'merge_what_id'?: number;
}
/**
 *
 * @export
 * @interface PersonNameInfoWithOrgAndOwnerId
 */
export interface PersonNameInfoWithOrgAndOwnerId {
    /**
     *
     * @type {Owner}
     * @memberof PersonNameInfoWithOrgAndOwnerId
     */
    'owner_id'?: Owner;
    /**
     *
     * @type {RelationshipOrganizationInfoItemWithActiveFlag}
     * @memberof PersonNameInfoWithOrgAndOwnerId
     */
    'org_id'?: RelationshipOrganizationInfoItemWithActiveFlag;
    /**
     * The name of the person
     * @type {string}
     * @memberof PersonNameInfoWithOrgAndOwnerId
     */
    'name'?: string;
    /**
     * The first name of the person
     * @type {string}
     * @memberof PersonNameInfoWithOrgAndOwnerId
     */
    'first_name'?: string;
    /**
     * The last name of the person
     * @type {string}
     * @memberof PersonNameInfoWithOrgAndOwnerId
     */
    'last_name'?: string;
}
/**
 *
 * @export
 * @interface PersonNameInfoWithOrgAndOwnerIdAllOf
 */
export interface PersonNameInfoWithOrgAndOwnerIdAllOf {
    /**
     *
     * @type {Owner}
     * @memberof PersonNameInfoWithOrgAndOwnerIdAllOf
     */
    'owner_id'?: Owner;
    /**
     *
     * @type {RelationshipOrganizationInfoItemWithActiveFlag}
     * @memberof PersonNameInfoWithOrgAndOwnerIdAllOf
     */
    'org_id'?: RelationshipOrganizationInfoItemWithActiveFlag;
}
/**
 *
 * @export
 * @interface PersonNameInfoWithOrgAndOwnerIdAllOf1
 */
export interface PersonNameInfoWithOrgAndOwnerIdAllOf1 {
    /**
     * The name of the person
     * @type {string}
     * @memberof PersonNameInfoWithOrgAndOwnerIdAllOf1
     */
    'name'?: string;
    /**
     * The first name of the person
     * @type {string}
     * @memberof PersonNameInfoWithOrgAndOwnerIdAllOf1
     */
    'first_name'?: string;
    /**
     * The last name of the person
     * @type {string}
     * @memberof PersonNameInfoWithOrgAndOwnerIdAllOf1
     */
    'last_name'?: string;
}
/**
 *
 * @export
 * @interface PersonsCollectionResponseObject
 */
export interface PersonsCollectionResponseObject {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsCollectionResponseObject
     */
    'id'?: number;
    /**
     * Whether the person is active or not
     * @type {boolean}
     * @memberof PersonsCollectionResponseObject
     */
    'active_flag'?: boolean;
    /**
     * The ID of the owner related to the person
     * @type {number}
     * @memberof PersonsCollectionResponseObject
     */
    'owner_id'?: number;
    /**
     * The ID of the organization related to the person
     * @type {number}
     * @memberof PersonsCollectionResponseObject
     */
    'org_id'?: number;
    /**
     * The name of the person
     * @type {string}
     * @memberof PersonsCollectionResponseObject
     */
    'name'?: string;
    /**
     * An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ \"value\": \"mail@example.com\", \"primary\": \"true\", \"label\": \"main\" }]`. Please note that only `value` is required.
     * @type {Array<BasicPersonRequestEmailInner>}
     * @memberof PersonsCollectionResponseObject
     */
    'email'?: Array<BasicPersonRequestEmailInner>;
    /**
     * A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ \"value\": \"12345\", \"primary\": \"true\", \"label\": \"mobile\" }]`. Please note that only `value` is required.
     * @type {Array<PersonItemAllOfPhoneInner>}
     * @memberof PersonsCollectionResponseObject
     */
    'phone'?: Array<PersonItemAllOfPhoneInner>;
    /**
     * The last updated date and time of the person. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof PersonsCollectionResponseObject
     */
    'update_time'?: string;
    /**
     * The date and time this person was deleted. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof PersonsCollectionResponseObject
     */
    'delete_time'?: string | null;
    /**
     * The date and time when the person was added/created. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof PersonsCollectionResponseObject
     */
    'add_time'?: string;
    /**
     * The visibility group ID of who can see the person
     * @type {string}
     * @memberof PersonsCollectionResponseObject
     */
    'visible_to'?: string;
    /**
     * The ID of the picture associated with the item
     * @type {number}
     * @memberof PersonsCollectionResponseObject
     */
    'picture_id'?: number | null;
    /**
     * The label assigned to the person
     * @type {number}
     * @memberof PersonsCollectionResponseObject
     */
    'label'?: number | null;
    /**
     * The BCC email associated with the person
     * @type {string}
     * @memberof PersonsCollectionResponseObject
     */
    'cc_email'?: string;
}
/**
 * The pipeline object
 * @export
 * @interface PipelineDetails
 */
export interface PipelineDetails {
    /**
     * The ID of the pipeline
     * @type {number}
     * @memberof PipelineDetails
     */
    'id'?: number;
    /**
     * The name of the pipeline
     * @type {string}
     * @memberof PipelineDetails
     */
    'name'?: string;
    /**
     * The pipeline title displayed in the URL
     * @type {string}
     * @memberof PipelineDetails
     */
    'url_title'?: string;
    /**
     * Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
     * @type {number}
     * @memberof PipelineDetails
     */
    'order_nr'?: number;
    /**
     * Whether this pipeline will be made inactive (hidden) or active
     * @type {boolean}
     * @memberof PipelineDetails
     */
    'active'?: boolean;
    /**
     * Whether deal probability is disabled or enabled for this pipeline
     * @type {boolean}
     * @memberof PipelineDetails
     */
    'deal_probability'?: boolean;
    /**
     * The pipeline creation time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof PipelineDetails
     */
    'add_time'?: string;
    /**
     * The pipeline update time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof PipelineDetails
     */
    'update_time'?: string;
    /**
     * A boolean that shows if the pipeline is selected from a filter or not
     * @type {boolean}
     * @memberof PipelineDetails
     */
    'selected'?: boolean;
    /**
     *
     * @type {PipelineDetailsAllOfDealsSummary}
     * @memberof PipelineDetails
     */
    'deals_summary'?: PipelineDetailsAllOfDealsSummary;
}
/**
 *
 * @export
 * @interface PipelineDetailsAllOf
 */
export interface PipelineDetailsAllOf {
    /**
     *
     * @type {PipelineDetailsAllOfDealsSummary}
     * @memberof PipelineDetailsAllOf
     */
    'deals_summary'?: PipelineDetailsAllOfDealsSummary;
}
/**
 * Deals summary
 * @export
 * @interface PipelineDetailsAllOfDealsSummary
 */
export interface PipelineDetailsAllOfDealsSummary {
    /**
     *
     * @type {PipelineDetailsAllOfDealsSummaryPerStages}
     * @memberof PipelineDetailsAllOfDealsSummary
     */
    'per_stages'?: PipelineDetailsAllOfDealsSummaryPerStages;
    /**
     *
     * @type {PipelineDetailsAllOfDealsSummaryPerCurrency}
     * @memberof PipelineDetailsAllOfDealsSummary
     */
    'per_currency'?: PipelineDetailsAllOfDealsSummaryPerCurrency;
    /**
     * Deals count
     * @type {number}
     * @memberof PipelineDetailsAllOfDealsSummary
     */
    'total_count'?: number;
    /**
     *
     * @type {PipelineDetailsAllOfDealsSummaryPerCurrencyFull}
     * @memberof PipelineDetailsAllOfDealsSummary
     */
    'per_currency_full'?: PipelineDetailsAllOfDealsSummaryPerCurrencyFull;
}
/**
 * The currency count summary
 * @export
 * @interface PipelineDetailsAllOfDealsSummaryPerCurrency
 */
export interface PipelineDetailsAllOfDealsSummaryPerCurrency {
    /**
     * Deals count per currency. This parameter is dynamic and changes according to `currency_id` value.
     * @type {number}
     * @memberof PipelineDetailsAllOfDealsSummaryPerCurrency
     */
    'CURRENCY_ID'?: number;
}
/**
 * Full currency summaries
 * @export
 * @interface PipelineDetailsAllOfDealsSummaryPerCurrencyFull
 */
export interface PipelineDetailsAllOfDealsSummaryPerCurrencyFull {
    /**
     *
     * @type {PipelineDetailsAllOfDealsSummaryPerCurrencyFullCURRENCYID}
     * @memberof PipelineDetailsAllOfDealsSummaryPerCurrencyFull
     */
    'CURRENCY_ID'?: PipelineDetailsAllOfDealsSummaryPerCurrencyFullCURRENCYID;
}
/**
 * The currency summary. This parameter is dynamic and changes according to `currency_id` value.
 * @export
 * @interface PipelineDetailsAllOfDealsSummaryPerCurrencyFullCURRENCYID
 */
export interface PipelineDetailsAllOfDealsSummaryPerCurrencyFullCURRENCYID {
    /**
     * Deals count per currency
     * @type {number}
     * @memberof PipelineDetailsAllOfDealsSummaryPerCurrencyFullCURRENCYID
     */
    'count'?: number;
    /**
     * Deals value per currency
     * @type {number}
     * @memberof PipelineDetailsAllOfDealsSummaryPerCurrencyFullCURRENCYID
     */
    'value'?: number;
}
/**
 * The stage objects containing deals currency information
 * @export
 * @interface PipelineDetailsAllOfDealsSummaryPerStages
 */
export interface PipelineDetailsAllOfDealsSummaryPerStages {
    /**
     *
     * @type {PipelineDetailsAllOfDealsSummaryPerStagesSTAGEID}
     * @memberof PipelineDetailsAllOfDealsSummaryPerStages
     */
    'STAGE_ID'?: PipelineDetailsAllOfDealsSummaryPerStagesSTAGEID;
}
/**
 * The currency summaries per stage. This parameter is dynamic and changes according to `stage_id` value.
 * @export
 * @interface PipelineDetailsAllOfDealsSummaryPerStagesSTAGEID
 */
export interface PipelineDetailsAllOfDealsSummaryPerStagesSTAGEID {
    /**
     *
     * @type {PipelineDetailsAllOfDealsSummaryPerStagesSTAGEIDCURRENCYID}
     * @memberof PipelineDetailsAllOfDealsSummaryPerStagesSTAGEID
     */
    'CURRENCY_ID'?: PipelineDetailsAllOfDealsSummaryPerStagesSTAGEIDCURRENCYID;
}
/**
 * The currency summary. This parameter is dynamic and changes according to `currency_id` value.
 * @export
 * @interface PipelineDetailsAllOfDealsSummaryPerStagesSTAGEIDCURRENCYID
 */
export interface PipelineDetailsAllOfDealsSummaryPerStagesSTAGEIDCURRENCYID {
    /**
     * Deals count per currency
     * @type {number}
     * @memberof PipelineDetailsAllOfDealsSummaryPerStagesSTAGEIDCURRENCYID
     */
    'count'?: number;
    /**
     * Deals value per currency
     * @type {number}
     * @memberof PipelineDetailsAllOfDealsSummaryPerStagesSTAGEIDCURRENCYID
     */
    'value'?: number;
    /**
     * Deals value formatted per currency
     * @type {string}
     * @memberof PipelineDetailsAllOfDealsSummaryPerStagesSTAGEIDCURRENCYID
     */
    'value_formatted'?: string;
    /**
     * Deals weighted value per currency
     * @type {number}
     * @memberof PipelineDetailsAllOfDealsSummaryPerStagesSTAGEIDCURRENCYID
     */
    'weighted_value'?: number;
    /**
     * Deals weighted value formatted per currency
     * @type {string}
     * @memberof PipelineDetailsAllOfDealsSummaryPerStagesSTAGEIDCURRENCYID
     */
    'weighted_value_formatted'?: string;
}
/**
 *
 * @export
 * @interface PipelineRequest
 */
export interface PipelineRequest {
    /**
     * The name of the pipeline
     * @type {string}
     * @memberof PipelineRequest
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof PipelineRequest
     */
    'deal_probability'?: PipelineRequestDealProbabilityConst;
    /**
     * Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
     * @type {number}
     * @memberof PipelineRequest
     */
    'order_nr'?: number;
    /**
     *
     * @type {number}
     * @memberof PipelineRequest
     */
    'active'?: PipelineRequestActiveConst;
}

export const PipelineRequestDealProbabilityConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type PipelineRequestDealProbabilityConst = typeof PipelineRequestDealProbabilityConst[keyof typeof PipelineRequestDealProbabilityConst];
export const PipelineRequestActiveConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type PipelineRequestActiveConst = typeof PipelineRequestActiveConst[keyof typeof PipelineRequestActiveConst];

/**
 *
 * @export
 * @interface PipelineRequest1
 */
export interface PipelineRequest1 {
    /**
     * The name of the pipeline
     * @type {string}
     * @memberof PipelineRequest1
     */
    'name'?: string;
    /**
     *
     * @type {number}
     * @memberof PipelineRequest1
     */
    'deal_probability'?: PipelineRequest1DealProbabilityConst;
    /**
     * Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
     * @type {number}
     * @memberof PipelineRequest1
     */
    'order_nr'?: number;
    /**
     *
     * @type {number}
     * @memberof PipelineRequest1
     */
    'active'?: PipelineRequest1ActiveConst;
}

export const PipelineRequest1DealProbabilityConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type PipelineRequest1DealProbabilityConst = typeof PipelineRequest1DealProbabilityConst[keyof typeof PipelineRequest1DealProbabilityConst];
export const PipelineRequest1ActiveConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type PipelineRequest1ActiveConst = typeof PipelineRequest1ActiveConst[keyof typeof PipelineRequest1ActiveConst];

/**
 *
 * @export
 * @interface PostFilterResponse200
 */
export interface PostFilterResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof PostFilterResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {PostFilterResponse200AllOfData}
     * @memberof PostFilterResponse200
     */
    'data'?: PostFilterResponse200AllOfData;
}
/**
 *
 * @export
 * @interface PostFilterResponse200AllOf
 */
export interface PostFilterResponse200AllOf {
    /**
     *
     * @type {PostFilterResponse200AllOfData}
     * @memberof PostFilterResponse200AllOf
     */
    'data'?: PostFilterResponse200AllOfData;
}
/**
 *
 * @export
 * @interface PostFilterResponse200AllOfData
 */
export interface PostFilterResponse200AllOfData {
    /**
     * The ID of the created filter
     * @type {number}
     * @memberof PostFilterResponse200AllOfData
     */
    'id'?: number;
    /**
     * The name of the created filter
     * @type {string}
     * @memberof PostFilterResponse200AllOfData
     */
    'name'?: string;
    /**
     * The activity flag of the created filter
     * @type {boolean}
     * @memberof PostFilterResponse200AllOfData
     */
    'active_flag'?: boolean;
    /**
     *
     * @type {string}
     * @memberof PostFilterResponse200AllOfData
     */
    'type'?: PostFilterResponse200AllOfDataTypeConst;
    /**
     * If the created filter is temporary or not
     * @type {boolean}
     * @memberof PostFilterResponse200AllOfData
     */
    'temporary_flag'?: boolean;
    /**
     * The user ID of the created filter
     * @type {number}
     * @memberof PostFilterResponse200AllOfData
     */
    'user_id'?: number;
    /**
     * The add time of the created filter
     * @type {string}
     * @memberof PostFilterResponse200AllOfData
     */
    'add_time'?: string;
    /**
     * The update time of the created filter
     * @type {string}
     * @memberof PostFilterResponse200AllOfData
     */
    'update_time'?: string;
    /**
     * The visibility group ID of the created filter
     * @type {number}
     * @memberof PostFilterResponse200AllOfData
     */
    'visible_to'?: number;
    /**
     * The custom view ID of the created filter
     * @type {number}
     * @memberof PostFilterResponse200AllOfData
     */
    'custom_view_id'?: number;
    /**
     * The created filter conditions object
     * @type {object}
     * @memberof PostFilterResponse200AllOfData
     */
    'conditions'?: object;
}

export const PostFilterResponse200AllOfDataTypeConst = {
    deals: 'deals',
    leads: 'leads',
    org: 'org',
    people: 'people',
    products: 'products',
    activity: 'activity',
    projects: 'projects'
} as const;

export type PostFilterResponse200AllOfDataTypeConst = typeof PostFilterResponse200AllOfDataTypeConst[keyof typeof PostFilterResponse200AllOfDataTypeConst];

/**
 *
 * @export
 * @interface ProductField
 */
export interface ProductField {
    /**
     * The name of the field
     * @type {string}
     * @memberof ProductField
     */
    'name': string;
    /**
     * When `field_type` is either `set` or `enum`, possible options must be supplied as a JSON-encoded sequential array, for example:</br>`[{\"label\":\"red\"}, {\"label\":\"blue\"}, {\"label\":\"lilac\"}]`
     * @type {Array<object>}
     * @memberof ProductField
     */
    'options'?: Array<object>;
    /**
     * The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td><tr><td>`text`</td><td>Long text (up to 65k characters)</td><tr><td>`double`</td><td>Numeric value</td><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td><tr><td>`enum`</td><td>Options field with a single possible chosen option</td><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td><tr><td>`people`</td><td>Person field (contains a product ID which is stored on the same account)</td><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td><tr><td>`address`</td><td>Address field (autocompleted by Google Maps)</dd></table>
     * @type {string}
     * @memberof ProductField
     */
    'field_type': ProductFieldFieldTypeConst;
    /**
     * The ID of the product field
     * @type {number}
     * @memberof ProductField
     */
    'id'?: number;
    /**
     * The key of the product field
     * @type {string}
     * @memberof ProductField
     */
    'key'?: string;
    /**
     * The position (index) of the product field in the detail view
     * @type {number}
     * @memberof ProductField
     */
    'order_nr'?: number;
    /**
     * The product field creation time. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof ProductField
     */
    'add_time'?: string;
    /**
     * The product field last update time. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof ProductField
     */
    'update_time'?: string;
    /**
     * The ID of the last user to update the product field
     * @type {number}
     * @memberof ProductField
     */
    'last_updated_by_user_id'?: number;
    /**
     * Whether or not the product field is currently active
     * @type {boolean}
     * @memberof ProductField
     */
    'active_flag'?: boolean;
    /**
     * Whether or not the product field name and metadata is editable
     * @type {boolean}
     * @memberof ProductField
     */
    'edit_flag'?: boolean;
    /**
     * Whether or not the product field is visible in the Add Product Modal
     * @type {boolean}
     * @memberof ProductField
     */
    'add_visible_flag'?: boolean;
    /**
     * Whether or not the product field is marked as important
     * @type {boolean}
     * @memberof ProductField
     */
    'important_flag'?: boolean;
    /**
     * Whether or not the product field data can be edited
     * @type {boolean}
     * @memberof ProductField
     */
    'bulk_edit_allowed'?: boolean;
    /**
     * Whether or not the product field is searchable
     * @type {boolean}
     * @memberof ProductField
     */
    'searchable_flag'?: boolean;
    /**
     * Whether or not the product field value can be used when filtering searches
     * @type {boolean}
     * @memberof ProductField
     */
    'filtering_allowed'?: boolean;
    /**
     * Whether or not the product field is sortable
     * @type {boolean}
     * @memberof ProductField
     */
    'sortable_flag'?: boolean;
    /**
     * Whether or not the product field is mandatory when creating products
     * @type {boolean}
     * @memberof ProductField
     */
    'mandatory_flag'?: boolean;
}

export const ProductFieldFieldTypeConst = {
    varchar: 'varchar',
    varchar_auto: 'varchar_auto',
    text: 'text',
    double: 'double',
    monetary: 'monetary',
    date: 'date',
    set: 'set',
    enum: 'enum',
    user: 'user',
    org: 'org',
    people: 'people',
    phone: 'phone',
    time: 'time',
    timerange: 'timerange',
    daterange: 'daterange',
    address: 'address'
} as const;

export type ProductFieldFieldTypeConst = typeof ProductFieldFieldTypeConst[keyof typeof ProductFieldFieldTypeConst];

/**
 *
 * @export
 * @interface ProductFieldAllOf
 */
export interface ProductFieldAllOf {
    /**
     * The name of the field
     * @type {string}
     * @memberof ProductFieldAllOf
     */
    'name': string;
    /**
     * When `field_type` is either `set` or `enum`, possible options must be supplied as a JSON-encoded sequential array, for example:</br>`[{\"label\":\"red\"}, {\"label\":\"blue\"}, {\"label\":\"lilac\"}]`
     * @type {Array<object>}
     * @memberof ProductFieldAllOf
     */
    'options'?: Array<object>;
    /**
     * The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td><tr><td>`text`</td><td>Long text (up to 65k characters)</td><tr><td>`double`</td><td>Numeric value</td><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td><tr><td>`enum`</td><td>Options field with a single possible chosen option</td><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td><tr><td>`people`</td><td>Person field (contains a product ID which is stored on the same account)</td><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td><tr><td>`address`</td><td>Address field (autocompleted by Google Maps)</dd></table>
     * @type {string}
     * @memberof ProductFieldAllOf
     */
    'field_type': ProductFieldAllOfFieldTypeConst;
}

export const ProductFieldAllOfFieldTypeConst = {
    varchar: 'varchar',
    varchar_auto: 'varchar_auto',
    text: 'text',
    double: 'double',
    monetary: 'monetary',
    date: 'date',
    set: 'set',
    enum: 'enum',
    user: 'user',
    org: 'org',
    people: 'people',
    phone: 'phone',
    time: 'time',
    timerange: 'timerange',
    daterange: 'daterange',
    address: 'address'
} as const;

export type ProductFieldAllOfFieldTypeConst = typeof ProductFieldAllOfFieldTypeConst[keyof typeof ProductFieldAllOfFieldTypeConst];

/**
 *
 * @export
 * @interface ProductFieldAllOf1
 */
export interface ProductFieldAllOf1 {
    /**
     * The ID of the product field
     * @type {number}
     * @memberof ProductFieldAllOf1
     */
    'id'?: number;
    /**
     * The key of the product field
     * @type {string}
     * @memberof ProductFieldAllOf1
     */
    'key'?: string;
    /**
     * The position (index) of the product field in the detail view
     * @type {number}
     * @memberof ProductFieldAllOf1
     */
    'order_nr'?: number;
    /**
     * The product field creation time. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof ProductFieldAllOf1
     */
    'add_time'?: string;
    /**
     * The product field last update time. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof ProductFieldAllOf1
     */
    'update_time'?: string;
    /**
     * The ID of the last user to update the product field
     * @type {number}
     * @memberof ProductFieldAllOf1
     */
    'last_updated_by_user_id'?: number;
    /**
     * Whether or not the product field is currently active
     * @type {boolean}
     * @memberof ProductFieldAllOf1
     */
    'active_flag'?: boolean;
    /**
     * Whether or not the product field name and metadata is editable
     * @type {boolean}
     * @memberof ProductFieldAllOf1
     */
    'edit_flag'?: boolean;
    /**
     * Whether or not the product field is visible in the Add Product Modal
     * @type {boolean}
     * @memberof ProductFieldAllOf1
     */
    'add_visible_flag'?: boolean;
    /**
     * Whether or not the product field is marked as important
     * @type {boolean}
     * @memberof ProductFieldAllOf1
     */
    'important_flag'?: boolean;
    /**
     * Whether or not the product field data can be edited
     * @type {boolean}
     * @memberof ProductFieldAllOf1
     */
    'bulk_edit_allowed'?: boolean;
    /**
     * Whether or not the product field is searchable
     * @type {boolean}
     * @memberof ProductFieldAllOf1
     */
    'searchable_flag'?: boolean;
    /**
     * Whether or not the product field value can be used when filtering searches
     * @type {boolean}
     * @memberof ProductFieldAllOf1
     */
    'filtering_allowed'?: boolean;
    /**
     * Whether or not the product field is sortable
     * @type {boolean}
     * @memberof ProductFieldAllOf1
     */
    'sortable_flag'?: boolean;
    /**
     * Whether or not the product field is mandatory when creating products
     * @type {boolean}
     * @memberof ProductFieldAllOf1
     */
    'mandatory_flag'?: boolean;
}
/**
 *
 * @export
 * @interface ProductRequest
 */
export interface ProductRequest {
    /**
     * The product code
     * @type {string}
     * @memberof ProductRequest
     */
    'code'?: string;
    /**
     * The unit in which this product is sold
     * @type {string}
     * @memberof ProductRequest
     */
    'unit'?: string;
    /**
     * The tax percentage
     * @type {number}
     * @memberof ProductRequest
     */
    'tax'?: number;
    /**
     * Whether this product will be made active or not
     * @type {boolean}
     * @memberof ProductRequest
     */
    'active_flag'?: boolean;
    /**
     * Whether this product can be selected in deals or not
     * @type {boolean}
     * @memberof ProductRequest
     */
    'selectable'?: boolean;
    /**
     *
     * @type {string}
     * @memberof ProductRequest
     */
    'visible_to'?: ProductRequestVisibleToConst;
    /**
     * The ID of the user who will be marked as the owner of this product. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof ProductRequest
     */
    'owner_id'?: number;
    /**
     * An array of objects, each containing: `currency` (string), `price` (number), `cost` (number, optional), `overhead_cost` (number, optional). Note that there can only be one price per product per currency. When `prices` is omitted altogether, a default price of 0 and a default currency based on the company\'s currency will be assigned.
     * @type {Array<object>}
     * @memberof ProductRequest
     */
    'prices'?: Array<object>;
}

export const ProductRequestVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type ProductRequestVisibleToConst = typeof ProductRequestVisibleToConst[keyof typeof ProductRequestVisibleToConst];

/**
 *
 * @export
 * @interface ProjectPutPlanItemBodyObject
 */
export interface ProjectPutPlanItemBodyObject {
    /**
     * The ID of a phase on a project board
     * @type {number}
     * @memberof ProjectPutPlanItemBodyObject
     */
    'phase_id'?: number;
    /**
     * The ID of a group on a project board
     * @type {number}
     * @memberof ProjectPutPlanItemBodyObject
     */
    'group_id'?: number;
}
/**
 *
 * @export
 * @interface ProjectResponseObject
 */
export interface ProjectResponseObject {
    /**
     * The ID of the project, generated when the task was created
     * @type {number}
     * @memberof ProjectResponseObject
     */
    'id'?: number;
    /**
     * The title of the project
     * @type {string}
     * @memberof ProjectResponseObject
     */
    'title'?: string;
    /**
     * The ID of the board this project is associated with
     * @type {number}
     * @memberof ProjectResponseObject
     */
    'board_id'?: number;
    /**
     * The ID of the phase this project is associated with
     * @type {number}
     * @memberof ProjectResponseObject
     */
    'phase_id'?: number;
    /**
     * The description of the project
     * @type {string}
     * @memberof ProjectResponseObject
     */
    'description'?: string;
    /**
     * The status of the project
     * @type {string}
     * @memberof ProjectResponseObject
     */
    'status'?: string;
    /**
     * The ID of a project owner
     * @type {number}
     * @memberof ProjectResponseObject
     */
    'owner_id'?: number;
    /**
     * The start date of the project. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof ProjectResponseObject
     */
    'start_date'?: string;
    /**
     * The end date of the project. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof ProjectResponseObject
     */
    'end_date'?: string;
    /**
     * An array of IDs of the deals this project is associated with
     * @type {Array<number>}
     * @memberof ProjectResponseObject
     */
    'deal_ids'?: Array<number>;
    /**
     * The ID of the organization this project is associated with
     * @type {number}
     * @memberof ProjectResponseObject
     */
    'org_id'?: number;
    /**
     * The ID of the person this project is associated with
     * @type {number}
     * @memberof ProjectResponseObject
     */
    'person_id'?: number;
    /**
     * An array of IDs of the labels this project has
     * @type {Array<number>}
     * @memberof ProjectResponseObject
     */
    'labels'?: Array<number>;
    /**
     * The creation date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ProjectResponseObject
     */
    'add_time'?: string;
    /**
     * The update date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ProjectResponseObject
     */
    'update_time'?: string;
    /**
     * The status changed date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ProjectResponseObject
     */
    'status_change_time'?: string;
    /**
     * The archived date and time of the project in UTC. Format: YYYY-MM-DD HH:MM:SS. If not archived then \'null\'.
     * @type {string}
     * @memberof ProjectResponseObject
     */
    'archive_time'?: string;
}
/**
 *
 * @export
 * @interface ProjectResponseObjectAllOf
 */
export interface ProjectResponseObjectAllOf {
    /**
     * The ID of the project, generated when the task was created
     * @type {number}
     * @memberof ProjectResponseObjectAllOf
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface PutRolePipelinesBody
 */
export interface PutRolePipelinesBody {
    /**
     * The pipeline IDs to make the pipelines visible (add) and/or hidden (remove) for the specified role. It requires the following JSON structure: `{ \"add\": \"[1]\", \"remove\": \"[3, 4]\" }`.
     * @type {object}
     * @memberof PutRolePipelinesBody
     */
    'visible_pipeline_ids': object;
}
/**
 *
 * @export
 * @interface ReceiveMessage200Response
 */
export interface ReceiveMessage200Response {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof ReceiveMessage200Response
     */
    'success'?: boolean;
    /**
     *
     * @type {ReceiveMessageRequest}
     * @memberof ReceiveMessage200Response
     */
    'data'?: ReceiveMessageRequest;
}
/**
 *
 * @export
 * @interface ReceiveMessage400Response
 */
export interface ReceiveMessage400Response {
    /**
     *
     * @type {boolean}
     * @memberof ReceiveMessage400Response
     */
    'success'?: boolean;
    /**
     * The error description
     * @type {string}
     * @memberof ReceiveMessage400Response
     */
    'error'?: string;
    /**
     *
     * @type {string}
     * @memberof ReceiveMessage400Response
     */
    'error_info'?: string;
    /**
     *
     * @type {ReceiveMessage400ResponseAdditionalData}
     * @memberof ReceiveMessage400Response
     */
    'additional_data'?: ReceiveMessage400ResponseAdditionalData;
}
/**
 *
 * @export
 * @interface ReceiveMessage400ResponseAdditionalData
 */
export interface ReceiveMessage400ResponseAdditionalData {
    /**
     * An error code sent by the API
     * @type {string}
     * @memberof ReceiveMessage400ResponseAdditionalData
     */
    'code'?: string;
}
/**
 *
 * @export
 * @interface ReceiveMessageRequest
 */
export interface ReceiveMessageRequest {
    /**
     * The ID of the message
     * @type {string}
     * @memberof ReceiveMessageRequest
     */
    'id': string;
    /**
     * The channel ID as in the provider
     * @type {string}
     * @memberof ReceiveMessageRequest
     */
    'channel_id': string;
    /**
     * The ID of the provider\'s user that sent the message
     * @type {string}
     * @memberof ReceiveMessageRequest
     */
    'sender_id': string;
    /**
     * The ID of the conversation
     * @type {string}
     * @memberof ReceiveMessageRequest
     */
    'conversation_id': string;
    /**
     * The body of the message
     * @type {string}
     * @memberof ReceiveMessageRequest
     */
    'message': string;
    /**
     * The status of the message
     * @type {string}
     * @memberof ReceiveMessageRequest
     */
    'status': ReceiveMessageRequestStatusConst;
    /**
     * The date and time when the message was created in the provider, in UTC. Format: YYYY-MM-DD HH:MM
     * @type {string}
     * @memberof ReceiveMessageRequest
     */
    'created_at': string;
    /**
     * The date and time when the message can no longer receive a reply, in UTC. Format: YYYY-MM-DD HH:MM
     * @type {string}
     * @memberof ReceiveMessageRequest
     */
    'reply_by'?: string;
    /**
     * A URL that can open the conversation in the provider\'s side
     * @type {string}
     * @memberof ReceiveMessageRequest
     */
    'conversation_link'?: string;
    /**
     * The list of attachments available in the message
     * @type {Array<ReceiveMessageRequestAttachmentsInner>}
     * @memberof ReceiveMessageRequest
     */
    'attachments'?: Array<ReceiveMessageRequestAttachmentsInner>;
}

export const ReceiveMessageRequestStatusConst = {
    sent: 'sent',
    delivered: 'delivered',
    read: 'read',
    failed: 'failed'
} as const;

export type ReceiveMessageRequestStatusConst = typeof ReceiveMessageRequestStatusConst[keyof typeof ReceiveMessageRequestStatusConst];

/**
 *
 * @export
 * @interface ReceiveMessageRequestAttachmentsInner
 */
export interface ReceiveMessageRequestAttachmentsInner {
    /**
     * The ID of the attachment
     * @type {string}
     * @memberof ReceiveMessageRequestAttachmentsInner
     */
    'id': string;
    /**
     * The mime-type of the attachment
     * @type {string}
     * @memberof ReceiveMessageRequestAttachmentsInner
     */
    'type': string;
    /**
     * The name of the attachment
     * @type {string}
     * @memberof ReceiveMessageRequestAttachmentsInner
     */
    'name'?: string;
    /**
     * The size of the attachment
     * @type {number}
     * @memberof ReceiveMessageRequestAttachmentsInner
     */
    'size'?: number;
    /**
     * A URL to the file
     * @type {string}
     * @memberof ReceiveMessageRequestAttachmentsInner
     */
    'url': string;
    /**
     * A URL to a preview picture of the file
     * @type {string}
     * @memberof ReceiveMessageRequestAttachmentsInner
     */
    'preview_url'?: string;
    /**
     * If true, it will use the getMessageById endpoint for fetching updated attachment\'s urls. Find out more [here](https://pipedrive.readme.io/docs/implementing-messaging-app-extension)
     * @type {boolean}
     * @memberof ReceiveMessageRequestAttachmentsInner
     */
    'link_expires'?: boolean;
}
/**
 *
 * @export
 * @interface RelationshipOrganizationInfoItem
 */
export interface RelationshipOrganizationInfoItem {
    /**
     * The name of the organization associated with the item
     * @type {string}
     * @memberof RelationshipOrganizationInfoItem
     */
    'name'?: string;
    /**
     * The number of people connected with the organization that is associated with the item
     * @type {number}
     * @memberof RelationshipOrganizationInfoItem
     */
    'people_count'?: number;
    /**
     * The ID of the owner of the organization that is associated with the item
     * @type {number}
     * @memberof RelationshipOrganizationInfoItem
     */
    'owner_id'?: number;
    /**
     * The address of the organization
     * @type {string}
     * @memberof RelationshipOrganizationInfoItem
     */
    'address'?: string;
    /**
     * The BCC email of the organization associated with the item
     * @type {string}
     * @memberof RelationshipOrganizationInfoItem
     */
    'cc_email'?: string;
    /**
     * The ID of the organization
     * @type {number}
     * @memberof RelationshipOrganizationInfoItem
     */
    'value'?: number;
}
/**
 *
 * @export
 * @interface RelationshipOrganizationInfoItemAllOf
 */
export interface RelationshipOrganizationInfoItemAllOf {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof RelationshipOrganizationInfoItemAllOf
     */
    'value'?: number;
}
/**
 *
 * @export
 * @interface RelationshipOrganizationInfoItemWithActiveFlag
 */
export interface RelationshipOrganizationInfoItemWithActiveFlag {
    /**
     * The name of the organization associated with the item
     * @type {string}
     * @memberof RelationshipOrganizationInfoItemWithActiveFlag
     */
    'name'?: string;
    /**
     * The number of people connected with the organization that is associated with the item
     * @type {number}
     * @memberof RelationshipOrganizationInfoItemWithActiveFlag
     */
    'people_count'?: number;
    /**
     * The ID of the owner of the organization that is associated with the item
     * @type {number}
     * @memberof RelationshipOrganizationInfoItemWithActiveFlag
     */
    'owner_id'?: number;
    /**
     * The address of the organization
     * @type {string}
     * @memberof RelationshipOrganizationInfoItemWithActiveFlag
     */
    'address'?: string;
    /**
     * The BCC email of the organization associated with the item
     * @type {string}
     * @memberof RelationshipOrganizationInfoItemWithActiveFlag
     */
    'cc_email'?: string;
    /**
     * The ID of the organization
     * @type {number}
     * @memberof RelationshipOrganizationInfoItemWithActiveFlag
     */
    'value'?: number;
    /**
     * Whether the associated organization is active or not
     * @type {boolean}
     * @memberof RelationshipOrganizationInfoItemWithActiveFlag
     */
    'active_flag'?: boolean;
}
/**
 *
 * @export
 * @interface RequiedPostProjectParameters
 */
export interface RequiedPostProjectParameters {
    /**
     * The title of the task
     * @type {string}
     * @memberof RequiedPostProjectParameters
     */
    'title': string;
    /**
     * The ID of a project
     * @type {number}
     * @memberof RequiedPostProjectParameters
     */
    'project_id': number;
}
/**
 *
 * @export
 * @interface RequiredPostProjectParameters
 */
export interface RequiredPostProjectParameters {
    /**
     * The title of the project
     * @type {string}
     * @memberof RequiredPostProjectParameters
     */
    'title': string;
    /**
     * The ID of a project board
     * @type {number}
     * @memberof RequiredPostProjectParameters
     */
    'board_id': number;
    /**
     * The ID of a phase on a project board
     * @type {number}
     * @memberof RequiredPostProjectParameters
     */
    'phase_id': number;
}
/**
 *
 * @export
 * @interface RequredTitleParameter
 */
export interface RequredTitleParameter {
    /**
     * The title of the deal
     * @type {string}
     * @memberof RequredTitleParameter
     */
    'title': string;
}
/**
 *
 * @export
 * @interface ResponseCallLogObject
 */
export interface ResponseCallLogObject {
    /**
     * The ID of the owner of the call log. Please note that a user without account settings access cannot create call logs for other users.
     * @type {number}
     * @memberof ResponseCallLogObject
     */
    'user_id'?: number;
    /**
     * If specified, this activity will be converted into a call log, with the information provided. When this field is used, you don\'t need to specify `deal_id`, `person_id` or `org_id`, as they will be ignored in favor of the values already available in the activity. The `activity_id` must refer to a `call` type activity.
     * @type {number}
     * @memberof ResponseCallLogObject
     */
    'activity_id'?: number;
    /**
     * The name of the activity this call is attached to
     * @type {string}
     * @memberof ResponseCallLogObject
     */
    'subject'?: string;
    /**
     * The duration of the call in seconds
     * @type {string}
     * @memberof ResponseCallLogObject
     */
    'duration'?: string;
    /**
     * Describes the outcome of the call
     * @type {string}
     * @memberof ResponseCallLogObject
     */
    'outcome': ResponseCallLogObjectOutcomeConst;
    /**
     * The number that made the call
     * @type {string}
     * @memberof ResponseCallLogObject
     */
    'from_phone_number'?: string;
    /**
     * The number called
     * @type {string}
     * @memberof ResponseCallLogObject
     */
    'to_phone_number': string;
    /**
     * The date and time of the start of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ResponseCallLogObject
     */
    'start_time': string;
    /**
     * The date and time of the end of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof ResponseCallLogObject
     */
    'end_time': string;
    /**
     * The ID of the person this call is associated with
     * @type {number}
     * @memberof ResponseCallLogObject
     */
    'person_id'?: number;
    /**
     * The ID of the organization this call is associated with
     * @type {number}
     * @memberof ResponseCallLogObject
     */
    'org_id'?: number;
    /**
     * The ID of the deal this call is associated with
     * @type {number}
     * @memberof ResponseCallLogObject
     */
    'deal_id'?: number;
    /**
     * The note for the call log in HTML format
     * @type {string}
     * @memberof ResponseCallLogObject
     */
    'note'?: string;
    /**
     * The call log ID, generated when the call log was created
     * @type {string}
     * @memberof ResponseCallLogObject
     */
    'id'?: string;
    /**
     * If the call log has an audio recording attached, the value should be true
     * @type {boolean}
     * @memberof ResponseCallLogObject
     */
    'has_recording'?: boolean;
    /**
     * The company ID of the owner of the call log
     * @type {number}
     * @memberof ResponseCallLogObject
     */
    'company_id'?: number;
}

export const ResponseCallLogObjectOutcomeConst = {
    connected: 'connected',
    no_answer: 'no_answer',
    left_message: 'left_message',
    left_voicemail: 'left_voicemail',
    wrong_number: 'wrong_number',
    busy: 'busy'
} as const;

export type ResponseCallLogObjectOutcomeConst = typeof ResponseCallLogObjectOutcomeConst[keyof typeof ResponseCallLogObjectOutcomeConst];

/**
 *
 * @export
 * @interface ResponseCallLogObjectAllOf
 */
export interface ResponseCallLogObjectAllOf {
    /**
     * The call log ID, generated when the call log was created
     * @type {string}
     * @memberof ResponseCallLogObjectAllOf
     */
    'id'?: string;
    /**
     * If the call log has an audio recording attached, the value should be true
     * @type {boolean}
     * @memberof ResponseCallLogObjectAllOf
     */
    'has_recording'?: boolean;
    /**
     * The company ID of the owner of the call log
     * @type {number}
     * @memberof ResponseCallLogObjectAllOf
     */
    'company_id'?: number;
}
/**
 * The assignment data of the role
 * @export
 * @interface RoleAssignment
 */
export interface RoleAssignment {
    /**
     * The ID of the parent role
     * @type {number}
     * @memberof RoleAssignment
     */
    'parent_role_id'?: number;
    /**
     * The name of the role
     * @type {string}
     * @memberof RoleAssignment
     */
    'name'?: string;
    /**
     * The user ID
     * @type {number}
     * @memberof RoleAssignment
     */
    'user_id'?: number;
    /**
     * The role ID
     * @type {number}
     * @memberof RoleAssignment
     */
    'role_id'?: number;
    /**
     * Whether the role is active or not
     * @type {boolean}
     * @memberof RoleAssignment
     */
    'active_flag'?: boolean;
    /**
     * The assignment type
     * @type {string}
     * @memberof RoleAssignment
     */
    'type'?: string;
}
/**
 *
 * @export
 * @interface RoleAssignmentAllOf
 */
export interface RoleAssignmentAllOf {
    /**
     * The user ID
     * @type {number}
     * @memberof RoleAssignmentAllOf
     */
    'user_id'?: number;
    /**
     * The role ID
     * @type {number}
     * @memberof RoleAssignmentAllOf
     */
    'role_id'?: number;
    /**
     * Whether the role is active or not
     * @type {boolean}
     * @memberof RoleAssignmentAllOf
     */
    'active_flag'?: boolean;
    /**
     * The assignment type
     * @type {string}
     * @memberof RoleAssignmentAllOf
     */
    'type'?: string;
}
/**
 *
 * @export
 * @interface SearchDealsResponse200
 */
export interface SearchDealsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof SearchDealsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {SearchDealsResponse200AllOfData}
     * @memberof SearchDealsResponse200
     */
    'data'?: SearchDealsResponse200AllOfData;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchDealsResponse200
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchDealsResponse200AllOf
 */
export interface SearchDealsResponse200AllOf {
    /**
     *
     * @type {SearchDealsResponse200AllOfData}
     * @memberof SearchDealsResponse200AllOf
     */
    'data'?: SearchDealsResponse200AllOfData;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchDealsResponse200AllOf
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchDealsResponse200AllOfData
 */
export interface SearchDealsResponse200AllOfData {
    /**
     * The array of deals
     * @type {Array<SearchDealsResponse200AllOfDataItemsInner>}
     * @memberof SearchDealsResponse200AllOfData
     */
    'items'?: Array<SearchDealsResponse200AllOfDataItemsInner>;
}
/**
 *
 * @export
 * @interface SearchDealsResponse200AllOfDataItemsInner
 */
export interface SearchDealsResponse200AllOfDataItemsInner {
    /**
     * Search result relevancy
     * @type {number}
     * @memberof SearchDealsResponse200AllOfDataItemsInner
     */
    'result_score'?: number;
    /**
     *
     * @type {SearchDealsResponse200AllOfDataItemsInnerItem}
     * @memberof SearchDealsResponse200AllOfDataItemsInner
     */
    'item'?: SearchDealsResponse200AllOfDataItemsInnerItem;
}
/**
 *
 * @export
 * @interface SearchDealsResponse200AllOfDataItemsInnerItem
 */
export interface SearchDealsResponse200AllOfDataItemsInnerItem {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItem
     */
    'id'?: number;
    /**
     * The type of the item
     * @type {string}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItem
     */
    'type'?: string;
    /**
     * The title of the deal
     * @type {string}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItem
     */
    'title'?: string;
    /**
     * The value of the deal
     * @type {number}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItem
     */
    'value'?: number;
    /**
     * The currency of the deal
     * @type {string}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItem
     */
    'currency'?: string;
    /**
     * The status of the deal
     * @type {string}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItem
     */
    'status'?: string;
    /**
     * The visibility of the deal
     * @type {number}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItem
     */
    'visible_to'?: number;
    /**
     *
     * @type {SearchDealsResponse200AllOfDataItemsInnerItemOwner}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItem
     */
    'owner'?: SearchDealsResponse200AllOfDataItemsInnerItemOwner;
    /**
     *
     * @type {SearchDealsResponse200AllOfDataItemsInnerItemStage}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItem
     */
    'stage'?: SearchDealsResponse200AllOfDataItemsInnerItemStage;
    /**
     *
     * @type {SearchDealsResponse200AllOfDataItemsInnerItemPerson}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItem
     */
    'person'?: SearchDealsResponse200AllOfDataItemsInnerItemPerson | null;
    /**
     *
     * @type {SearchDealsResponse200AllOfDataItemsInnerItemOrganization}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItem
     */
    'organization'?: SearchDealsResponse200AllOfDataItemsInnerItemOrganization | null;
    /**
     * Custom fields
     * @type {Array<string>}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItem
     */
    'custom_fields'?: Array<string>;
    /**
     * An array of notes
     * @type {Array<string>}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItem
     */
    'notes'?: Array<string>;
}
/**
 *
 * @export
 * @interface SearchDealsResponse200AllOfDataItemsInnerItemOrganization
 */
export interface SearchDealsResponse200AllOfDataItemsInnerItemOrganization {
    /**
     * The ID of the organization the deal is associated with
     * @type {number}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItemOrganization
     */
    'id'?: number;
    /**
     * The name of the organization the deal is associated with
     * @type {string}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItemOrganization
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface SearchDealsResponse200AllOfDataItemsInnerItemOwner
 */
export interface SearchDealsResponse200AllOfDataItemsInnerItemOwner {
    /**
     * The ID of the owner of the deal
     * @type {number}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItemOwner
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface SearchDealsResponse200AllOfDataItemsInnerItemPerson
 */
export interface SearchDealsResponse200AllOfDataItemsInnerItemPerson {
    /**
     * The ID of the person the deal is associated with
     * @type {number}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItemPerson
     */
    'id'?: number;
    /**
     * The name of the person the deal is associated with
     * @type {string}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItemPerson
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface SearchDealsResponse200AllOfDataItemsInnerItemStage
 */
export interface SearchDealsResponse200AllOfDataItemsInnerItemStage {
    /**
     * The ID of the stage of the deal
     * @type {number}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItemStage
     */
    'id'?: number;
    /**
     * The name of the stage of the deal
     * @type {string}
     * @memberof SearchDealsResponse200AllOfDataItemsInnerItemStage
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface SearchItemByFieldResponse200
 */
export interface SearchItemByFieldResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof SearchItemByFieldResponse200
     */
    'success'?: boolean;
    /**
     * The array of results
     * @type {Array<SearchItemByFieldResponse200AllOfDataInner>}
     * @memberof SearchItemByFieldResponse200
     */
    'data'?: Array<SearchItemByFieldResponse200AllOfDataInner>;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchItemByFieldResponse200
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchItemByFieldResponse200AllOf
 */
export interface SearchItemByFieldResponse200AllOf {
    /**
     * The array of results
     * @type {Array<SearchItemByFieldResponse200AllOfDataInner>}
     * @memberof SearchItemByFieldResponse200AllOf
     */
    'data'?: Array<SearchItemByFieldResponse200AllOfDataInner>;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchItemByFieldResponse200AllOf
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchItemByFieldResponse200AllOfDataInner
 */
export interface SearchItemByFieldResponse200AllOfDataInner {
    /**
     * The ID of the item
     * @type {number}
     * @memberof SearchItemByFieldResponse200AllOfDataInner
     */
    'id'?: number;
    /**
     * The value of the searched `field_key`
     * @type {any}
     * @memberof SearchItemByFieldResponse200AllOfDataInner
     */
    '$field_key'?: any;
}
/**
 *
 * @export
 * @interface SearchItemResponse200
 */
export interface SearchItemResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof SearchItemResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {SearchItemResponse200AllOfData}
     * @memberof SearchItemResponse200
     */
    'data'?: SearchItemResponse200AllOfData;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchItemResponse200
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchItemResponse200AllOf
 */
export interface SearchItemResponse200AllOf {
    /**
     *
     * @type {SearchItemResponse200AllOfData}
     * @memberof SearchItemResponse200AllOf
     */
    'data'?: SearchItemResponse200AllOfData;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchItemResponse200AllOf
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchItemResponse200AllOfData
 */
export interface SearchItemResponse200AllOfData {
    /**
     * The array of found items
     * @type {Array<SearchItemResponse200AllOfDataItemsInner>}
     * @memberof SearchItemResponse200AllOfData
     */
    'items'?: Array<SearchItemResponse200AllOfDataItemsInner>;
    /**
     * The array of related items if `search_for_related_items` was enabled
     * @type {Array<SearchItemResponse200AllOfDataItemsInner>}
     * @memberof SearchItemResponse200AllOfData
     */
    'related_items'?: Array<SearchItemResponse200AllOfDataItemsInner>;
}
/**
 *
 * @export
 * @interface SearchItemResponse200AllOfDataItemsInner
 */
export interface SearchItemResponse200AllOfDataItemsInner {
    /**
     * Search result relevancy
     * @type {number}
     * @memberof SearchItemResponse200AllOfDataItemsInner
     */
    'result_score'?: number;
    /**
     * Item
     * @type {object}
     * @memberof SearchItemResponse200AllOfDataItemsInner
     */
    'item'?: object;
}
/**
 *
 * @export
 * @interface SearchLeadsResponse200
 */
export interface SearchLeadsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof SearchLeadsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {SearchLeadsResponse200AllOfData}
     * @memberof SearchLeadsResponse200
     */
    'data'?: SearchLeadsResponse200AllOfData;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchLeadsResponse200
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchLeadsResponse200AllOf
 */
export interface SearchLeadsResponse200AllOf {
    /**
     *
     * @type {SearchLeadsResponse200AllOfData}
     * @memberof SearchLeadsResponse200AllOf
     */
    'data'?: SearchLeadsResponse200AllOfData;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchLeadsResponse200AllOf
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchLeadsResponse200AllOfData
 */
export interface SearchLeadsResponse200AllOfData {
    /**
     * The array of leads
     * @type {Array<SearchLeadsResponse200AllOfDataItemsInner>}
     * @memberof SearchLeadsResponse200AllOfData
     */
    'items'?: Array<SearchLeadsResponse200AllOfDataItemsInner>;
}
/**
 *
 * @export
 * @interface SearchLeadsResponse200AllOfDataItemsInner
 */
export interface SearchLeadsResponse200AllOfDataItemsInner {
    /**
     * Search result relevancy
     * @type {number}
     * @memberof SearchLeadsResponse200AllOfDataItemsInner
     */
    'result_score'?: number;
    /**
     *
     * @type {SearchLeadsResponse200AllOfDataItemsInnerItem}
     * @memberof SearchLeadsResponse200AllOfDataItemsInner
     */
    'item'?: SearchLeadsResponse200AllOfDataItemsInnerItem;
}
/**
 *
 * @export
 * @interface SearchLeadsResponse200AllOfDataItemsInnerItem
 */
export interface SearchLeadsResponse200AllOfDataItemsInnerItem {
    /**
     * The ID of the lead
     * @type {string}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'id'?: string;
    /**
     * The type of the item
     * @type {string}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'type'?: string;
    /**
     * The title of the lead
     * @type {string}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'title'?: string;
    /**
     *
     * @type {SearchLeadsResponse200AllOfDataItemsInnerItemOwner}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'owner'?: SearchLeadsResponse200AllOfDataItemsInnerItemOwner;
    /**
     *
     * @type {SearchLeadsResponse200AllOfDataItemsInnerItemPerson}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'person'?: SearchLeadsResponse200AllOfDataItemsInnerItemPerson;
    /**
     *
     * @type {SearchLeadsResponse200AllOfDataItemsInnerItemOrganization}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'organization'?: SearchLeadsResponse200AllOfDataItemsInnerItemOrganization;
    /**
     *
     * @type {Array<string>}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'phones'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'emails'?: Array<string>;
    /**
     * Custom fields
     * @type {Array<string>}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'custom_fields'?: Array<string>;
    /**
     * An array of notes
     * @type {Array<string>}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'notes'?: Array<string>;
    /**
     * The value of the lead
     * @type {number}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'value'?: number;
    /**
     * The currency of the lead
     * @type {string}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'currency'?: string;
    /**
     * The visibility of the lead
     * @type {number}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'visible_to'?: number;
    /**
     * A flag indicating whether the lead is archived or not
     * @type {boolean}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItem
     */
    'is_archived'?: boolean;
}
/**
 *
 * @export
 * @interface SearchLeadsResponse200AllOfDataItemsInnerItemOrganization
 */
export interface SearchLeadsResponse200AllOfDataItemsInnerItemOrganization {
    /**
     * The ID of the organization the lead is associated with
     * @type {number}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItemOrganization
     */
    'id'?: number;
    /**
     * The name of the organization the lead is associated with
     * @type {string}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItemOrganization
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface SearchLeadsResponse200AllOfDataItemsInnerItemOwner
 */
export interface SearchLeadsResponse200AllOfDataItemsInnerItemOwner {
    /**
     * The ID of the owner of the lead
     * @type {number}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItemOwner
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface SearchLeadsResponse200AllOfDataItemsInnerItemPerson
 */
export interface SearchLeadsResponse200AllOfDataItemsInnerItemPerson {
    /**
     * The ID of the person the lead is associated with
     * @type {number}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItemPerson
     */
    'id'?: number;
    /**
     * The name of the person the lead is associated with
     * @type {string}
     * @memberof SearchLeadsResponse200AllOfDataItemsInnerItemPerson
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface SearchOrganizationResponse200
 */
export interface SearchOrganizationResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof SearchOrganizationResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {SearchOrganizationResponse200AllOfData}
     * @memberof SearchOrganizationResponse200
     */
    'data'?: SearchOrganizationResponse200AllOfData;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchOrganizationResponse200
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchOrganizationResponse200AllOf
 */
export interface SearchOrganizationResponse200AllOf {
    /**
     *
     * @type {SearchOrganizationResponse200AllOfData}
     * @memberof SearchOrganizationResponse200AllOf
     */
    'data'?: SearchOrganizationResponse200AllOfData;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchOrganizationResponse200AllOf
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchOrganizationResponse200AllOfData
 */
export interface SearchOrganizationResponse200AllOfData {
    /**
     * The array of found items
     * @type {Array<SearchOrganizationResponse200AllOfDataItemsInner>}
     * @memberof SearchOrganizationResponse200AllOfData
     */
    'items'?: Array<SearchOrganizationResponse200AllOfDataItemsInner>;
}
/**
 *
 * @export
 * @interface SearchOrganizationResponse200AllOfDataItemsInner
 */
export interface SearchOrganizationResponse200AllOfDataItemsInner {
    /**
     * Search result relevancy
     * @type {number}
     * @memberof SearchOrganizationResponse200AllOfDataItemsInner
     */
    'result_score'?: number;
    /**
     *
     * @type {SearchOrganizationResponse200AllOfDataItemsInnerItem}
     * @memberof SearchOrganizationResponse200AllOfDataItemsInner
     */
    'item'?: SearchOrganizationResponse200AllOfDataItemsInnerItem;
}
/**
 *
 * @export
 * @interface SearchOrganizationResponse200AllOfDataItemsInnerItem
 */
export interface SearchOrganizationResponse200AllOfDataItemsInnerItem {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof SearchOrganizationResponse200AllOfDataItemsInnerItem
     */
    'id'?: number;
    /**
     * The type of the item
     * @type {string}
     * @memberof SearchOrganizationResponse200AllOfDataItemsInnerItem
     */
    'type'?: string;
    /**
     * The name of the organization
     * @type {string}
     * @memberof SearchOrganizationResponse200AllOfDataItemsInnerItem
     */
    'name'?: string;
    /**
     * The address of the organization
     * @type {string}
     * @memberof SearchOrganizationResponse200AllOfDataItemsInnerItem
     */
    'address'?: string;
    /**
     * The visibility of the organization
     * @type {number}
     * @memberof SearchOrganizationResponse200AllOfDataItemsInnerItem
     */
    'visible_to'?: number;
    /**
     *
     * @type {SearchDealsResponse200AllOfDataItemsInnerItemOwner}
     * @memberof SearchOrganizationResponse200AllOfDataItemsInnerItem
     */
    'owner'?: SearchDealsResponse200AllOfDataItemsInnerItemOwner;
    /**
     * Custom fields
     * @type {Array<string>}
     * @memberof SearchOrganizationResponse200AllOfDataItemsInnerItem
     */
    'custom_fields'?: Array<string>;
    /**
     * An array of notes
     * @type {Array<string>}
     * @memberof SearchOrganizationResponse200AllOfDataItemsInnerItem
     */
    'notes'?: Array<string>;
}
/**
 *
 * @export
 * @interface SearchPersonsResponse200
 */
export interface SearchPersonsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof SearchPersonsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {SearchPersonsResponse200AllOfData}
     * @memberof SearchPersonsResponse200
     */
    'data'?: SearchPersonsResponse200AllOfData;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchPersonsResponse200
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchPersonsResponse200AllOf
 */
export interface SearchPersonsResponse200AllOf {
    /**
     *
     * @type {SearchPersonsResponse200AllOfData}
     * @memberof SearchPersonsResponse200AllOf
     */
    'data'?: SearchPersonsResponse200AllOfData;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchPersonsResponse200AllOf
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchPersonsResponse200AllOfData
 */
export interface SearchPersonsResponse200AllOfData {
    /**
     * The array of found items
     * @type {Array<SearchPersonsResponse200AllOfDataItemsInner>}
     * @memberof SearchPersonsResponse200AllOfData
     */
    'items'?: Array<SearchPersonsResponse200AllOfDataItemsInner>;
}
/**
 *
 * @export
 * @interface SearchPersonsResponse200AllOfDataItemsInner
 */
export interface SearchPersonsResponse200AllOfDataItemsInner {
    /**
     * Search result relevancy
     * @type {number}
     * @memberof SearchPersonsResponse200AllOfDataItemsInner
     */
    'result_score'?: number;
    /**
     *
     * @type {SearchPersonsResponse200AllOfDataItemsInnerItem}
     * @memberof SearchPersonsResponse200AllOfDataItemsInner
     */
    'item'?: SearchPersonsResponse200AllOfDataItemsInnerItem;
}
/**
 *
 * @export
 * @interface SearchPersonsResponse200AllOfDataItemsInnerItem
 */
export interface SearchPersonsResponse200AllOfDataItemsInnerItem {
    /**
     * The ID of the person
     * @type {number}
     * @memberof SearchPersonsResponse200AllOfDataItemsInnerItem
     */
    'id'?: number;
    /**
     * The type of the item
     * @type {string}
     * @memberof SearchPersonsResponse200AllOfDataItemsInnerItem
     */
    'type'?: string;
    /**
     * The name of the person
     * @type {string}
     * @memberof SearchPersonsResponse200AllOfDataItemsInnerItem
     */
    'name'?: string;
    /**
     * An array of phone numbers
     * @type {Array<string>}
     * @memberof SearchPersonsResponse200AllOfDataItemsInnerItem
     */
    'phones'?: Array<string>;
    /**
     * An array of email addresses
     * @type {Array<string>}
     * @memberof SearchPersonsResponse200AllOfDataItemsInnerItem
     */
    'emails'?: Array<string>;
    /**
     * The visibility of the person
     * @type {number}
     * @memberof SearchPersonsResponse200AllOfDataItemsInnerItem
     */
    'visible_to'?: number;
    /**
     *
     * @type {SearchPersonsResponse200AllOfDataItemsInnerItemOwner}
     * @memberof SearchPersonsResponse200AllOfDataItemsInnerItem
     */
    'owner'?: SearchPersonsResponse200AllOfDataItemsInnerItemOwner;
    /**
     *
     * @type {SearchPersonsResponse200AllOfDataItemsInnerItemOrganization}
     * @memberof SearchPersonsResponse200AllOfDataItemsInnerItem
     */
    'organization'?: SearchPersonsResponse200AllOfDataItemsInnerItemOrganization;
    /**
     * Custom fields
     * @type {Array<string>}
     * @memberof SearchPersonsResponse200AllOfDataItemsInnerItem
     */
    'custom_fields'?: Array<string>;
    /**
     * An array of notes
     * @type {Array<string>}
     * @memberof SearchPersonsResponse200AllOfDataItemsInnerItem
     */
    'notes'?: Array<string>;
}
/**
 *
 * @export
 * @interface SearchPersonsResponse200AllOfDataItemsInnerItemOrganization
 */
export interface SearchPersonsResponse200AllOfDataItemsInnerItemOrganization {
    /**
     * The ID of the organization the person is associated with
     * @type {number}
     * @memberof SearchPersonsResponse200AllOfDataItemsInnerItemOrganization
     */
    'id'?: number;
    /**
     * The name of the organization the person is associated with
     * @type {string}
     * @memberof SearchPersonsResponse200AllOfDataItemsInnerItemOrganization
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface SearchPersonsResponse200AllOfDataItemsInnerItemOwner
 */
export interface SearchPersonsResponse200AllOfDataItemsInnerItemOwner {
    /**
     * The ID of the owner of the person
     * @type {number}
     * @memberof SearchPersonsResponse200AllOfDataItemsInnerItemOwner
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface SearchProductsResponse200
 */
export interface SearchProductsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof SearchProductsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {SearchProductsResponse200AllOfData}
     * @memberof SearchProductsResponse200
     */
    'data'?: SearchProductsResponse200AllOfData;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchProductsResponse200
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchProductsResponse200AllOf
 */
export interface SearchProductsResponse200AllOf {
    /**
     *
     * @type {SearchProductsResponse200AllOfData}
     * @memberof SearchProductsResponse200AllOf
     */
    'data'?: SearchProductsResponse200AllOfData;
    /**
     *
     * @type {GetActivitiesResponse200AdditionalData}
     * @memberof SearchProductsResponse200AllOf
     */
    'additional_data'?: GetActivitiesResponse200AdditionalData;
}
/**
 *
 * @export
 * @interface SearchProductsResponse200AllOfData
 */
export interface SearchProductsResponse200AllOfData {
    /**
     * The array of found items
     * @type {Array<SearchProductsResponse200AllOfDataItemsInner>}
     * @memberof SearchProductsResponse200AllOfData
     */
    'items'?: Array<SearchProductsResponse200AllOfDataItemsInner>;
}
/**
 *
 * @export
 * @interface SearchProductsResponse200AllOfDataItemsInner
 */
export interface SearchProductsResponse200AllOfDataItemsInner {
    /**
     * Search result relevancy
     * @type {number}
     * @memberof SearchProductsResponse200AllOfDataItemsInner
     */
    'result_score'?: number;
    /**
     *
     * @type {SearchProductsResponse200AllOfDataItemsInnerItem}
     * @memberof SearchProductsResponse200AllOfDataItemsInner
     */
    'item'?: SearchProductsResponse200AllOfDataItemsInnerItem;
}
/**
 *
 * @export
 * @interface SearchProductsResponse200AllOfDataItemsInnerItem
 */
export interface SearchProductsResponse200AllOfDataItemsInnerItem {
    /**
     * The ID of the product
     * @type {number}
     * @memberof SearchProductsResponse200AllOfDataItemsInnerItem
     */
    'id'?: number;
    /**
     * The type of the item
     * @type {string}
     * @memberof SearchProductsResponse200AllOfDataItemsInnerItem
     */
    'type'?: string;
    /**
     * The name of the product
     * @type {string}
     * @memberof SearchProductsResponse200AllOfDataItemsInnerItem
     */
    'name'?: string;
    /**
     * The code of the product
     * @type {number}
     * @memberof SearchProductsResponse200AllOfDataItemsInnerItem
     */
    'code'?: number;
    /**
     * The visibility of the product
     * @type {number}
     * @memberof SearchProductsResponse200AllOfDataItemsInnerItem
     */
    'visible_to'?: number;
    /**
     *
     * @type {SearchProductsResponse200AllOfDataItemsInnerItemOwner}
     * @memberof SearchProductsResponse200AllOfDataItemsInnerItem
     */
    'owner'?: SearchProductsResponse200AllOfDataItemsInnerItemOwner;
    /**
     * The custom fields
     * @type {Array<string>}
     * @memberof SearchProductsResponse200AllOfDataItemsInnerItem
     */
    'custom_fields'?: Array<string>;
}
/**
 *
 * @export
 * @interface SearchProductsResponse200AllOfDataItemsInnerItemOwner
 */
export interface SearchProductsResponse200AllOfDataItemsInnerItemOwner {
    /**
     * The ID of the owner of the product
     * @type {number}
     * @memberof SearchProductsResponse200AllOfDataItemsInnerItemOwner
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface SinglePermissionSetResponse200
 */
export interface SinglePermissionSetResponse200 {
    /**
     * The ID of user permission set
     * @type {string}
     * @memberof SinglePermissionSetResponse200
     */
    'id'?: string;
    /**
     * The name of the permission set
     * @type {string}
     * @memberof SinglePermissionSetResponse200
     */
    'name'?: string;
    /**
     * The description of the permission set
     * @type {string}
     * @memberof SinglePermissionSetResponse200
     */
    'description'?: string;
    /**
     * The app that permission set belongs to
     * @type {string}
     * @memberof SinglePermissionSetResponse200
     */
    'app'?: SinglePermissionSetResponse200AppConst;
    /**
     * The type of permission set
     * @type {string}
     * @memberof SinglePermissionSetResponse200
     */
    'type'?: SinglePermissionSetResponse200TypeConst;
    /**
     * The number of users assigned to this permission set
     * @type {number}
     * @memberof SinglePermissionSetResponse200
     */
    'assignment_count'?: number;
    /**
     * A permission assigned to this permission set
     * @type {Array<string>}
     * @memberof SinglePermissionSetResponse200
     */
    'contents'?: Array<string>;
}

export const SinglePermissionSetResponse200AppConst = {
    sales: 'sales',
    projects: 'projects',
    campaigns: 'campaigns',
    global: 'global',
    account_settings: 'account_settings'
} as const;

export type SinglePermissionSetResponse200AppConst = typeof SinglePermissionSetResponse200AppConst[keyof typeof SinglePermissionSetResponse200AppConst];
export const SinglePermissionSetResponse200TypeConst = {
    admin: 'admin',
    manager: 'manager',
    regular: 'regular',
    custom: 'custom'
} as const;

export type SinglePermissionSetResponse200TypeConst = typeof SinglePermissionSetResponse200TypeConst[keyof typeof SinglePermissionSetResponse200TypeConst];

/**
 *
 * @export
 * @interface SinglePermissionSetResponse200AllOf
 */
export interface SinglePermissionSetResponse200AllOf {
    /**
     * A permission assigned to this permission set
     * @type {Array<string>}
     * @memberof SinglePermissionSetResponse200AllOf
     */
    'contents'?: Array<string>;
}
/**
 *
 * @export
 * @interface StageResponse200
 */
export interface StageResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof StageResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {StageResponse200Data}
     * @memberof StageResponse200
     */
    'data'?: StageResponse200Data;
}
/**
 * Updated stage object
 * @export
 * @interface StageResponse200Data
 */
export interface StageResponse200Data {
    /**
     * The ID of the stage
     * @type {number}
     * @memberof StageResponse200Data
     */
    'id'?: number;
    /**
     * Defines the order of the stage
     * @type {number}
     * @memberof StageResponse200Data
     */
    'order_nr'?: number;
    /**
     * The name of the stage
     * @type {string}
     * @memberof StageResponse200Data
     */
    'name'?: string;
    /**
     * Whether the stage is active or deleted
     * @type {boolean}
     * @memberof StageResponse200Data
     */
    'active_flag'?: boolean;
    /**
     * The success probability percentage of the deal. Used/shown when the deal weighted values are used.
     * @type {number}
     * @memberof StageResponse200Data
     */
    'deal_probability'?: number;
    /**
     * The ID of the pipeline to add the stage to
     * @type {number}
     * @memberof StageResponse200Data
     */
    'pipeline_id'?: number;
    /**
     * Whether deals in this stage can become rotten
     * @type {boolean}
     * @memberof StageResponse200Data
     */
    'rotten_flag'?: boolean;
    /**
     * The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
     * @type {number}
     * @memberof StageResponse200Data
     */
    'rotten_days'?: number;
    /**
     * The stage creation time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof StageResponse200Data
     */
    'add_time'?: string;
    /**
     * The stage update time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof StageResponse200Data
     */
    'update_time'?: string;
}
/**
 * The details of the sub-role
 * @export
 * @interface SubRole
 */
export interface SubRole {
    /**
     * The ID of the parent role
     * @type {number}
     * @memberof SubRole
     */
    'parent_role_id'?: number;
    /**
     * The name of the role
     * @type {string}
     * @memberof SubRole
     */
    'name'?: string;
    /**
     * The ID of the role
     * @type {number}
     * @memberof SubRole
     */
    'id'?: number;
    /**
     * Whether the role is active or not
     * @type {boolean}
     * @memberof SubRole
     */
    'active_flag'?: boolean;
    /**
     * The number of users assigned to this role
     * @type {string}
     * @memberof SubRole
     */
    'assignment_count'?: string;
    /**
     * The number of sub-roles
     * @type {string}
     * @memberof SubRole
     */
    'sub_role_count'?: string;
}
/**
 *
 * @export
 * @interface SubRoleAllOf
 */
export interface SubRoleAllOf {
    /**
     * The ID of the role
     * @type {number}
     * @memberof SubRoleAllOf
     */
    'id'?: number;
    /**
     * Whether the role is active or not
     * @type {boolean}
     * @memberof SubRoleAllOf
     */
    'active_flag'?: boolean;
    /**
     * The number of users assigned to this role
     * @type {string}
     * @memberof SubRoleAllOf
     */
    'assignment_count'?: string;
    /**
     * The number of sub-roles
     * @type {string}
     * @memberof SubRoleAllOf
     */
    'sub_role_count'?: string;
}
/**
 *
 * @export
 * @interface SubscriptionAddonsResponse200
 */
export interface SubscriptionAddonsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof SubscriptionAddonsResponse200
     */
    'success'?: boolean;
    /**
     * An array of add-ons that the company has.
     * @type {Array<object>}
     * @memberof SubscriptionAddonsResponse200
     */
    'data'?: Array<object>;
}
/**
 *
 * @export
 * @interface SubscriptionAddonsResponse200AllOf
 */
export interface SubscriptionAddonsResponse200AllOf {
    /**
     * An array of add-ons that the company has.
     * @type {Array<object>}
     * @memberof SubscriptionAddonsResponse200AllOf
     */
    'data'?: Array<object>;
}
/**
 *
 * @export
 * @interface SubscriptionsIdResponse200
 */
export interface SubscriptionsIdResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof SubscriptionsIdResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {SubscriptionsIdResponse200AllOfData}
     * @memberof SubscriptionsIdResponse200
     */
    'data'?: SubscriptionsIdResponse200AllOfData;
}
/**
 *
 * @export
 * @interface SubscriptionsIdResponse200AllOf
 */
export interface SubscriptionsIdResponse200AllOf {
    /**
     *
     * @type {SubscriptionsIdResponse200AllOfData}
     * @memberof SubscriptionsIdResponse200AllOf
     */
    'data'?: SubscriptionsIdResponse200AllOfData;
}
/**
 *
 * @export
 * @interface SubscriptionsIdResponse200AllOfData
 */
export interface SubscriptionsIdResponse200AllOfData {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'id'?: number;
    /**
     * The ID of the user who created the subscription
     * @type {number}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'user_id'?: number;
    /**
     * The ID of the deal this subscription is associated with
     * @type {number}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'deal_id'?: number;
    /**
     * The description of the recurring subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'description'?: string;
    /**
     * The subscription status
     * @type {boolean}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'is_active'?: boolean;
    /**
     * Shows how many payments a recurring subscription has
     * @type {number}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'cycles_count'?: number;
    /**
     * The amount of each payment
     * @type {number}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'cycle_amount'?: number;
    /**
     * Indicates that the recurring subscription will last until it is manually canceled or deleted
     * @type {boolean}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'infinite'?: boolean;
    /**
     * The currency of the subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'currency'?: string;
    /**
     * The interval between payments
     * @type {string}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'cadence_type'?: string;
    /**
     * The start date of the recurring subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'start_date'?: string;
    /**
     * The end date of the subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'end_date'?: string;
    /**
     * The total value of all payments
     * @type {number}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'lifetime_value'?: number;
    /**
     * The final status of the subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'final_status'?: string | null;
    /**
     * The creation time of the subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'add_time'?: string;
    /**
     * The update time of the subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200AllOfData
     */
    'update_time'?: string;
}
/**
 *
 * @export
 * @interface TaskResponseObject
 */
export interface TaskResponseObject {
    /**
     * The ID of the task, generated when the task was created
     * @type {number}
     * @memberof TaskResponseObject
     */
    'id'?: number;
    /**
     * The title of the task
     * @type {string}
     * @memberof TaskResponseObject
     */
    'title'?: string;
    /**
     * The ID of the project this task is associated with
     * @type {number}
     * @memberof TaskResponseObject
     */
    'project_id'?: number;
    /**
     * The description of the task
     * @type {string}
     * @memberof TaskResponseObject
     */
    'description'?: string;
    /**
     * The ID of a parent task. Can not be ID of a task which is already a subtask.
     * @type {number}
     * @memberof TaskResponseObject
     */
    'parent_task_id'?: number;
    /**
     * The ID of the user who will be the assignee of the task
     * @type {number}
     * @memberof TaskResponseObject
     */
    'assignee_id'?: number;
    /**
     *
     * @type {number}
     * @memberof TaskResponseObject
     */
    'done'?: TaskResponseObjectDoneConst;
    /**
     * The due date of the task. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof TaskResponseObject
     */
    'due_date'?: string;
    /**
     * The creator of a task
     * @type {number}
     * @memberof TaskResponseObject
     */
    'creator_id'?: number;
    /**
     * The creation date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof TaskResponseObject
     */
    'add_time'?: string;
    /**
     * The update date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof TaskResponseObject
     */
    'update_time'?: string;
    /**
     * The marked as done date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof TaskResponseObject
     */
    'marked_as_done_time'?: string;
}

export const TaskResponseObjectDoneConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type TaskResponseObjectDoneConst = typeof TaskResponseObjectDoneConst[keyof typeof TaskResponseObjectDoneConst];

/**
 *
 * @export
 * @interface TaskResponseObjectAllOf
 */
export interface TaskResponseObjectAllOf {
    /**
     * The ID of the task, generated when the task was created
     * @type {number}
     * @memberof TaskResponseObjectAllOf
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface TeamId
 */
export interface TeamId {
    /**
     * The team ID
     * @type {number}
     * @memberof TeamId
     */
    'id'?: number;
}
/**
 *
 * @export
 * @interface TeamResponse200
 */
export interface TeamResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof TeamResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {BaseTeam}
     * @memberof TeamResponse200
     */
    'data'?: BaseTeam;
}
/**
 *
 * @export
 * @interface TeamResponse200AllOf
 */
export interface TeamResponse200AllOf {
    /**
     *
     * @type {BaseTeam}
     * @memberof TeamResponse200AllOf
     */
    'data'?: BaseTeam;
}
/**
 *
 * @export
 * @interface TeamsResponse200
 */
export interface TeamsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof TeamsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<BaseTeam>}
     * @memberof TeamsResponse200
     */
    'data'?: Array<BaseTeam>;
}
/**
 *
 * @export
 * @interface TeamsResponse200AllOf
 */
export interface TeamsResponse200AllOf {
    /**
     *
     * @type {Array<BaseTeam>}
     * @memberof TeamsResponse200AllOf
     */
    'data'?: Array<BaseTeam>;
}
/**
 *
 * @export
 * @interface TemplateResponseObject
 */
export interface TemplateResponseObject {
    /**
     * The ID of a template
     * @type {number}
     * @memberof TemplateResponseObject
     */
    'id'?: number;
    /**
     * The title of a template
     * @type {string}
     * @memberof TemplateResponseObject
     */
    'title'?: string;
    /**
     * The description of a template
     * @type {string}
     * @memberof TemplateResponseObject
     */
    'description'?: string;
    /**
     * The ID of the project board this template is associated with
     * @type {number}
     * @memberof TemplateResponseObject
     */
    'projects_board_id'?: number;
    /**
     * The ID of a template owner
     * @type {number}
     * @memberof TemplateResponseObject
     */
    'owner_id'?: number;
    /**
     * The creation date and time of the template in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof TemplateResponseObject
     */
    'add_time'?: string;
    /**
     * The update date and time of the template in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof TemplateResponseObject
     */
    'update_time'?: string;
}
/**
 *
 * @export
 * @interface TemplateResponseObjectAllOf
 */
export interface TemplateResponseObjectAllOf {
    /**
     * The ID of a template
     * @type {number}
     * @memberof TemplateResponseObjectAllOf
     */
    'id'?: number;
    /**
     * The title of a template
     * @type {string}
     * @memberof TemplateResponseObjectAllOf
     */
    'title'?: string;
    /**
     * The description of a template
     * @type {string}
     * @memberof TemplateResponseObjectAllOf
     */
    'description'?: string;
    /**
     * The ID of the project board this template is associated with
     * @type {number}
     * @memberof TemplateResponseObjectAllOf
     */
    'projects_board_id'?: number;
    /**
     * The ID of a template owner
     * @type {number}
     * @memberof TemplateResponseObjectAllOf
     */
    'owner_id'?: number;
    /**
     * The creation date and time of the template in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof TemplateResponseObjectAllOf
     */
    'add_time'?: string;
    /**
     * The update date and time of the template in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof TemplateResponseObjectAllOf
     */
    'update_time'?: string;
}
/**
 *
 * @export
 * @interface UnathorizedResponse
 */
export interface UnathorizedResponse {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UnathorizedResponse
     */
    'success'?: boolean;
    /**
     * The error message
     * @type {string}
     * @memberof UnathorizedResponse
     */
    'error'?: string;
    /**
     * The response error code
     * @type {number}
     * @memberof UnathorizedResponse
     */
    'errorCode'?: number;
}
/**
 *
 * @export
 * @interface UpdateActivityRequest
 */
export interface UpdateActivityRequest {
    /**
     * The due date of the activity. Format: YYYY-MM-DD
     * @type {string}
     * @memberof UpdateActivityRequest
     */
    'due_date'?: string;
    /**
     * The due time of the activity in UTC. Format: HH:MM
     * @type {string}
     * @memberof UpdateActivityRequest
     */
    'due_time'?: string;
    /**
     * The duration of the activity. Format: HH:MM
     * @type {string}
     * @memberof UpdateActivityRequest
     */
    'duration'?: string;
    /**
     * The ID of the deal this activity is associated with
     * @type {number}
     * @memberof UpdateActivityRequest
     */
    'deal_id'?: number;
    /**
     * The ID of the lead in the UUID format this activity is associated with
     * @type {string}
     * @memberof UpdateActivityRequest
     */
    'lead_id'?: string | null;
    /**
     * The ID of the person this activity is associated with
     * @type {number}
     * @memberof UpdateActivityRequest
     */
    'person_id'?: number;
    /**
     * The ID of the project this activity is associated with
     * @type {number}
     * @memberof UpdateActivityRequest
     */
    'project_id'?: number | null;
    /**
     * The ID of the organization this activity is associated with
     * @type {number}
     * @memberof UpdateActivityRequest
     */
    'org_id'?: number;
    /**
     * The address of the activity. Pipedrive will automatically check if the location matches a geo-location on Google maps.
     * @type {string}
     * @memberof UpdateActivityRequest
     */
    'location'?: string;
    /**
     * Additional details about the activity that is synced to your external calendar. Unlike the note added to the activity, the description is publicly visible to any guests added to the activity.
     * @type {string}
     * @memberof UpdateActivityRequest
     */
    'public_description'?: string;
    /**
     * The note of the activity (HTML format)
     * @type {string}
     * @memberof UpdateActivityRequest
     */
    'note'?: string;
    /**
     * The subject of the activity
     * @type {string}
     * @memberof UpdateActivityRequest
     */
    'subject'?: string;
    /**
     * The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
     * @type {string}
     * @memberof UpdateActivityRequest
     */
    'type'?: string;
    /**
     * The ID of the user whom the activity is assigned to
     * @type {number}
     * @memberof UpdateActivityRequest
     */
    'user_id'?: number;
    /**
     * List of multiple persons (participants) this activity is associated with. It requires a structure as follows: `[{\"person_id\":1,\"primary_flag\":true}]`
     * @type {Array<object>}
     * @memberof UpdateActivityRequest
     */
    'participants'?: Array<object>;
    /**
     * Set the activity as \'Busy\' or \'Free\'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset by never setting it or overriding it with `null`. When the value of the flag is unset (`null`), the flag defaults to \'Busy\' if it has a time set, and \'Free\' if it is an all-day event without specified time.
     * @type {boolean}
     * @memberof UpdateActivityRequest
     */
    'busy_flag'?: boolean;
    /**
     * The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address. It requires a structure as follows: `[{\"email_address\":\"mail@example.org\"}]` or `[{\"person_id\":1, \"email_address\":\"mail@example.org\"}]`
     * @type {Array<object>}
     * @memberof UpdateActivityRequest
     */
    'attendees'?: Array<object>;
    /**
     *
     * @type {number}
     * @memberof UpdateActivityRequest
     */
    'done'?: UpdateActivityRequestDoneConst;
}

export const UpdateActivityRequestDoneConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UpdateActivityRequestDoneConst = typeof UpdateActivityRequestDoneConst[keyof typeof UpdateActivityRequestDoneConst];

/**
 *
 * @export
 * @interface UpdateActivityRequestAllOf
 */
export interface UpdateActivityRequestAllOf {
    /**
     * The note of the activity (HTML format)
     * @type {string}
     * @memberof UpdateActivityRequestAllOf
     */
    'note'?: string;
    /**
     * The subject of the activity
     * @type {string}
     * @memberof UpdateActivityRequestAllOf
     */
    'subject'?: string;
    /**
     * The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
     * @type {string}
     * @memberof UpdateActivityRequestAllOf
     */
    'type'?: string;
    /**
     * The ID of the user whom the activity is assigned to
     * @type {number}
     * @memberof UpdateActivityRequestAllOf
     */
    'user_id'?: number;
    /**
     * List of multiple persons (participants) this activity is associated with. It requires a structure as follows: `[{\"person_id\":1,\"primary_flag\":true}]`
     * @type {Array<object>}
     * @memberof UpdateActivityRequestAllOf
     */
    'participants'?: Array<object>;
    /**
     * Set the activity as \'Busy\' or \'Free\'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset by never setting it or overriding it with `null`. When the value of the flag is unset (`null`), the flag defaults to \'Busy\' if it has a time set, and \'Free\' if it is an all-day event without specified time.
     * @type {boolean}
     * @memberof UpdateActivityRequestAllOf
     */
    'busy_flag'?: boolean;
    /**
     * The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address. It requires a structure as follows: `[{\"email_address\":\"mail@example.org\"}]` or `[{\"person_id\":1, \"email_address\":\"mail@example.org\"}]`
     * @type {Array<object>}
     * @memberof UpdateActivityRequestAllOf
     */
    'attendees'?: Array<object>;
    /**
     *
     * @type {number}
     * @memberof UpdateActivityRequestAllOf
     */
    'done'?: UpdateActivityRequestAllOfDoneConst;
}

export const UpdateActivityRequestAllOfDoneConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UpdateActivityRequestAllOfDoneConst = typeof UpdateActivityRequestAllOfDoneConst[keyof typeof UpdateActivityRequestAllOfDoneConst];

/**
 *
 * @export
 * @interface UpdateActivityResponse200
 */
export interface UpdateActivityResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof UpdateActivityResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {ActivityResponseObject}
     * @memberof UpdateActivityResponse200
     */
    'data'?: ActivityResponseObject;
    /**
     *
     * @type {AddActivityResponse200RelatedObjects}
     * @memberof UpdateActivityResponse200
     */
    'related_objects'?: AddActivityResponse200RelatedObjects;
}
/**
 *
 * @export
 * @interface UpdateActivityTypeRequest
 */
export interface UpdateActivityTypeRequest {
    /**
     * The name of the activity type
     * @type {string}
     * @memberof UpdateActivityTypeRequest
     */
    'name'?: string;
    /**
     * Icon graphic to use for representing this activity type
     * @type {string}
     * @memberof UpdateActivityTypeRequest
     */
    'icon_key'?: UpdateActivityTypeRequestIconKeyConst;
    /**
     * A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
     * @type {string}
     * @memberof UpdateActivityTypeRequest
     */
    'color'?: string;
    /**
     * An order number for this activity type. Order numbers should be used to order the types in the activity type selections.
     * @type {number}
     * @memberof UpdateActivityTypeRequest
     */
    'order_nr'?: number;
}

export const UpdateActivityTypeRequestIconKeyConst = {
    task: 'task',
    email: 'email',
    meeting: 'meeting',
    deadline: 'deadline',
    call: 'call',
    lunch: 'lunch',
    calendar: 'calendar',
    downarrow: 'downarrow',
    document: 'document',
    smartphone: 'smartphone',
    camera: 'camera',
    scissors: 'scissors',
    cogs: 'cogs',
    bubble: 'bubble',
    uparrow: 'uparrow',
    checkbox: 'checkbox',
    signpost: 'signpost',
    shuffle: 'shuffle',
    addressbook: 'addressbook',
    linegraph: 'linegraph',
    picture: 'picture',
    car: 'car',
    world: 'world',
    search: 'search',
    clip: 'clip',
    sound: 'sound',
    brush: 'brush',
    key: 'key',
    padlock: 'padlock',
    pricetag: 'pricetag',
    suitcase: 'suitcase',
    finish: 'finish',
    plane: 'plane',
    loop: 'loop',
    wifi: 'wifi',
    truck: 'truck',
    cart: 'cart',
    bulb: 'bulb',
    bell: 'bell',
    presentation: 'presentation'
} as const;

export type UpdateActivityTypeRequestIconKeyConst = typeof UpdateActivityTypeRequestIconKeyConst[keyof typeof UpdateActivityTypeRequestIconKeyConst];

/**
 *
 * @export
 * @interface UpdateDealParameters
 */
export interface UpdateDealParameters {
    /**
     * The value of the deal.
     * @type {string}
     * @memberof UpdateDealParameters
     */
    'value'?: string;
    /**
     * Array of the deal labels IDs.
     * @type {Array<number>}
     * @memberof UpdateDealParameters
     */
    'label'?: Array<number>;
    /**
     * The currency of the deal. Accepts a 3-character currency code.
     * @type {string}
     * @memberof UpdateDealParameters
     */
    'currency'?: string;
    /**
     * The ID of the user which will be the new owner of the deal.
     * @type {number}
     * @memberof UpdateDealParameters
     */
    'user_id'?: number;
    /**
     * The ID of a person which this deal will be linked to. If the person does not exist yet, it needs to be created first.
     * @type {number}
     * @memberof UpdateDealParameters
     */
    'person_id'?: number;
    /**
     * The ID of an organization which this deal will be linked to. If the organization does not exist yet, it needs to be created first.
     * @type {number}
     * @memberof UpdateDealParameters
     */
    'org_id'?: number;
    /**
     * The ID of the pipeline this deal will be added to. By default, the deal will be added to the first stage of the specified pipeline. Please note that `pipeline_id` and `stage_id` should not be used together as `pipeline_id` will be ignored.
     * @type {number}
     * @memberof UpdateDealParameters
     */
    'pipeline_id'?: number;
    /**
     * The ID of the stage this deal will be added to. Please note that a pipeline will be assigned automatically based on the `stage_id`.
     * @type {number}
     * @memberof UpdateDealParameters
     */
    'stage_id'?: number;
    /**
     * open = Open, won = Won, lost = Lost, deleted = Deleted.
     * @type {string}
     * @memberof UpdateDealParameters
     */
    'status'?: UpdateDealParametersStatusConst;
}

export const UpdateDealParametersStatusConst = {
    open: 'open',
    won: 'won',
    lost: 'lost',
    deleted: 'deleted'
} as const;

export type UpdateDealParametersStatusConst = typeof UpdateDealParametersStatusConst[keyof typeof UpdateDealParametersStatusConst];

/**
 *
 * @export
 * @interface UpdateDealProductRequest
 */
export interface UpdateDealProductRequest {
    /**
     * The ID of the product to use
     * @type {number}
     * @memberof UpdateDealProductRequest
     */
    'product_id'?: number;
    /**
     * The price at which this product will be added to the deal
     * @type {number}
     * @memberof UpdateDealProductRequest
     */
    'item_price'?: number;
    /**
     * How many items of this product will be added to the deal
     * @type {number}
     * @memberof UpdateDealProductRequest
     */
    'quantity'?: number;
    /**
     * The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage.
     * @type {number}
     * @memberof UpdateDealProductRequest
     */
    'discount'?: number;
    /**
     * The type of the discount\'s value.
     * @type {string}
     * @memberof UpdateDealProductRequest
     */
    'discount_type'?: UpdateDealProductRequestDiscountTypeConst;
    /**
     * The duration of the product
     * @type {number}
     * @memberof UpdateDealProductRequest
     */
    'duration'?: number;
    /**
     *
     * @type {string}
     * @memberof UpdateDealProductRequest
     */
    'duration_unit'?: UpdateDealProductRequestDurationUnitConst;
    /**
     * The ID of the product variation to use. When omitted, no variation will be used.
     * @type {number}
     * @memberof UpdateDealProductRequest
     */
    'product_variation_id'?: number;
    /**
     * A textual comment associated with this product-deal attachment
     * @type {string}
     * @memberof UpdateDealProductRequest
     */
    'comments'?: string;
    /**
     * The tax percentage
     * @type {number}
     * @memberof UpdateDealProductRequest
     */
    'tax'?: number;
    /**
     * The tax option to be applied to the products. When using `inclusive`, the tax percentage will already be included in the price. When using `exclusive`, the tax will not be included in the price. When using `none`, no tax will be added. Use the `tax` field for defining the tax percentage amount.
     * @type {string}
     * @memberof UpdateDealProductRequest
     */
    'tax_method'?: UpdateDealProductRequestTaxMethodConst;
    /**
     * Whether the product is enabled for a deal or not. This makes it possible to add products to a deal with a specific price and discount criteria, but keep them disabled, which refrains them from being included in the deal value calculation. When omitted, the product will be marked as enabled by default.
     * @type {boolean}
     * @memberof UpdateDealProductRequest
     */
    'enabled_flag'?: boolean;
}

export const UpdateDealProductRequestDiscountTypeConst = {
    percentage: 'percentage',
    amount: 'amount'
} as const;

export type UpdateDealProductRequestDiscountTypeConst = typeof UpdateDealProductRequestDiscountTypeConst[keyof typeof UpdateDealProductRequestDiscountTypeConst];
export const UpdateDealProductRequestDurationUnitConst = {
    hourly: 'hourly',
    daily: 'daily',
    weekly: 'weekly',
    monthly: 'monthly',
    yearly: 'yearly'
} as const;

export type UpdateDealProductRequestDurationUnitConst = typeof UpdateDealProductRequestDurationUnitConst[keyof typeof UpdateDealProductRequestDurationUnitConst];
export const UpdateDealProductRequestTaxMethodConst = {
    exclusive: 'exclusive',
    inclusive: 'inclusive',
    none: 'none'
} as const;

export type UpdateDealProductRequestTaxMethodConst = typeof UpdateDealProductRequestTaxMethodConst[keyof typeof UpdateDealProductRequestTaxMethodConst];

/**
 *
 * @export
 * @interface UpdateDealRequest
 */
export interface UpdateDealRequest {
    /**
     * The title of the deal
     * @type {string}
     * @memberof UpdateDealRequest
     */
    'title'?: string;
    /**
     * The value of the deal.
     * @type {string}
     * @memberof UpdateDealRequest
     */
    'value'?: string;
    /**
     * Array of the deal labels IDs.
     * @type {Array<number>}
     * @memberof UpdateDealRequest
     */
    'label'?: Array<number>;
    /**
     * The currency of the deal. Accepts a 3-character currency code.
     * @type {string}
     * @memberof UpdateDealRequest
     */
    'currency'?: string;
    /**
     * The ID of the user which will be the new owner of the deal.
     * @type {number}
     * @memberof UpdateDealRequest
     */
    'user_id'?: number;
    /**
     * The ID of a person which this deal will be linked to. If the person does not exist yet, it needs to be created first.
     * @type {number}
     * @memberof UpdateDealRequest
     */
    'person_id'?: number;
    /**
     * The ID of an organization which this deal will be linked to. If the organization does not exist yet, it needs to be created first.
     * @type {number}
     * @memberof UpdateDealRequest
     */
    'org_id'?: number;
    /**
     * The ID of the pipeline this deal will be added to. By default, the deal will be added to the first stage of the specified pipeline. Please note that `pipeline_id` and `stage_id` should not be used together as `pipeline_id` will be ignored.
     * @type {number}
     * @memberof UpdateDealRequest
     */
    'pipeline_id'?: number;
    /**
     * The ID of the stage this deal will be added to. Please note that a pipeline will be assigned automatically based on the `stage_id`.
     * @type {number}
     * @memberof UpdateDealRequest
     */
    'stage_id'?: number;
    /**
     * open = Open, won = Won, lost = Lost, deleted = Deleted.
     * @type {string}
     * @memberof UpdateDealRequest
     */
    'status'?: UpdateDealRequestStatusConst;
    /**
     * The expected close date of the deal. In ISO 8601 format: YYYY-MM-DD.
     * @type {string}
     * @memberof UpdateDealRequest
     */
    'expected_close_date'?: string;
    /**
     * The success probability percentage of the deal. Used/shown only when `deal_probability` for the pipeline of the deal is enabled.
     * @type {number}
     * @memberof UpdateDealRequest
     */
    'probability'?: number;
    /**
     * The optional message about why the deal was lost (to be used when status = lost)
     * @type {string}
     * @memberof UpdateDealRequest
     */
    'lost_reason'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateDealRequest
     */
    'visible_to'?: UpdateDealRequestVisibleToConst;
}

export const UpdateDealRequestStatusConst = {
    open: 'open',
    won: 'won',
    lost: 'lost',
    deleted: 'deleted'
} as const;

export type UpdateDealRequestStatusConst = typeof UpdateDealRequestStatusConst[keyof typeof UpdateDealRequestStatusConst];
export const UpdateDealRequestVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type UpdateDealRequestVisibleToConst = typeof UpdateDealRequestVisibleToConst[keyof typeof UpdateDealRequestVisibleToConst];

/**
 *
 * @export
 * @interface UpdateFieldRequest
 */
export interface UpdateFieldRequest {
    /**
     * The name of the field
     * @type {string}
     * @memberof UpdateFieldRequest
     */
    'name'?: string;
    /**
     * When `field_type` is either set or enum, possible options must be supplied as a JSON-encoded sequential array of objects. All active items must be supplied and already existing items must have their ID supplied. New items only require a label. Example: `[{\"id\":123,\"label\":\"Existing Item\"},{\"label\":\"New Item\"}]`
     * @type {Array<object>}
     * @memberof UpdateFieldRequest
     */
    'options'?: Array<object>;
    /**
     * Whether the field is available in \'add new\' modal or not (both in web and mobile app)
     * @type {boolean}
     * @memberof UpdateFieldRequest
     */
    'add_visible_flag'?: boolean;
}
/**
 *
 * @export
 * @interface UpdateFileResponse200
 */
export interface UpdateFileResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof UpdateFileResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetFilesResponse200DataInner}
     * @memberof UpdateFileResponse200
     */
    'data'?: GetFilesResponse200DataInner;
}
/**
 *
 * @export
 * @interface UpdateFilterRequest
 */
export interface UpdateFilterRequest {
    /**
     * The name of the filter
     * @type {string}
     * @memberof UpdateFilterRequest
     */
    'name'?: string;
    /**
     * The conditions of the filter as a JSON object. Please note that a maximum of 16 conditions is allowed per filter and `date` values must be supplied in the `YYYY-MM-DD` format. It requires a minimum structure as follows: `{\"glue\":\"and\",\"conditions\":[{\"glue\":\"and\",\"conditions\": [CONDITION_OBJECTS]},{\"glue\":\"or\",\"conditions\":[CONDITION_OBJECTS]}]}`. Replace `CONDITION_OBJECTS` with JSON objects of the following structure: `{\"object\":\"\",\"field_id\":\"\", \"operator\":\"\",\"value\":\"\", \"extra_value\":\"\"}` or leave the array empty. Depending on the object type you should use another API endpoint to get `field_id`. There are five types of objects you can choose from: `\"person\"`, `\"deal\"`, `\"organization\"`, `\"product\"`, `\"activity\"` and you can use these types of operators depending on what type of a field you have: `\"IS NOT NULL\"`, `\"IS NULL\"`, `\"<=\"`, `\">=\"`, `\"<\"`, `\">\"`, `\"!=\"`, `\"=\"`, `\"LIKE \'$%\'\"`, `\"LIKE \'%$%\'\"`, `\"NOT LIKE \'$%\'\"`. To get a better understanding of how filters work try creating them directly from the Pipedrive application.
     * @type {object}
     * @memberof UpdateFilterRequest
     */
    'conditions': object;
}
/**
 *
 * @export
 * @interface UpdateLeadLabelRequest
 */
export interface UpdateLeadLabelRequest {
    /**
     * The name of the lead label
     * @type {string}
     * @memberof UpdateLeadLabelRequest
     */
    'name'?: string;
    /**
     * The color of the label. Only a subset of colors can be used.
     * @type {string}
     * @memberof UpdateLeadLabelRequest
     */
    'color'?: UpdateLeadLabelRequestColorConst;
}

export const UpdateLeadLabelRequestColorConst = {
    green: 'green',
    blue: 'blue',
    red: 'red',
    yellow: 'yellow',
    purple: 'purple',
    gray: 'gray'
} as const;

export type UpdateLeadLabelRequestColorConst = typeof UpdateLeadLabelRequestColorConst[keyof typeof UpdateLeadLabelRequestColorConst];

/**
 *
 * @export
 * @interface UpdateLeadRequest
 */
export interface UpdateLeadRequest {
    /**
     * The name of the lead
     * @type {string}
     * @memberof UpdateLeadRequest
     */
    'title'?: string | null;
    /**
     * The ID of the user which will be the owner of the created lead. If not provided, the user making the request will be used.
     * @type {number}
     * @memberof UpdateLeadRequest
     */
    'owner_id'?: number;
    /**
     * The IDs of the lead labels which will be associated with the lead
     * @type {Array<string>}
     * @memberof UpdateLeadRequest
     */
    'label_ids'?: Array<string>;
    /**
     * The ID of a person which this lead will be linked to. If the person does not exist yet, it needs to be created first. A lead always has to be linked to a person or organization or both.
     * @type {number}
     * @memberof UpdateLeadRequest
     */
    'person_id'?: number | null;
    /**
     * The ID of an organization which this lead will be linked to. If the organization does not exist yet, it needs to be created first. A lead always has to be linked to a person or organization or both.
     * @type {number}
     * @memberof UpdateLeadRequest
     */
    'organization_id'?: number | null;
    /**
     * A flag indicating whether the lead is archived or not
     * @type {boolean}
     * @memberof UpdateLeadRequest
     */
    'is_archived'?: boolean;
    /**
     *
     * @type {UpdateLeadRequestValue}
     * @memberof UpdateLeadRequest
     */
    'value'?: UpdateLeadRequestValue | null;
    /**
     * The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
     * @type {string}
     * @memberof UpdateLeadRequest
     */
    'expected_close_date'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateLeadRequest
     */
    'visible_to'?: UpdateLeadRequestVisibleToConst;
    /**
     * A flag indicating whether the lead was seen by someone in the Pipedrive UI
     * @type {boolean}
     * @memberof UpdateLeadRequest
     */
    'was_seen'?: boolean;
}

export const UpdateLeadRequestVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type UpdateLeadRequestVisibleToConst = typeof UpdateLeadRequestVisibleToConst[keyof typeof UpdateLeadRequestVisibleToConst];

/**
 * The potential value of the lead as a JSON object. It requires the following JSON structure: `{ \"amount\": 200, \"currency\": \"EUR\" }`. Both amount and currency are required.
 * @export
 * @interface UpdateLeadRequestValue
 */
export interface UpdateLeadRequestValue {
    /**
     *
     * @type {number}
     * @memberof UpdateLeadRequestValue
     */
    'amount': number;
    /**
     *
     * @type {string}
     * @memberof UpdateLeadRequestValue
     */
    'currency': string;
}
/**
 *
 * @export
 * @interface UpdateMailThreadDetailsResponse200
 */
export interface UpdateMailThreadDetailsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UpdateMailThreadDetailsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {BaseMailThread1}
     * @memberof UpdateMailThreadDetailsResponse200
     */
    'data'?: BaseMailThread1;
}
/**
 *
 * @export
 * @interface UpdateMailThreadDetailsResponse200AllOf
 */
export interface UpdateMailThreadDetailsResponse200AllOf {
    /**
     *
     * @type {BaseMailThread1}
     * @memberof UpdateMailThreadDetailsResponse200AllOf
     */
    'data'?: BaseMailThread1;
}
/**
 *
 * @export
 * @interface UpdateOrganizationRelationshipResponse200
 */
export interface UpdateOrganizationRelationshipResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UpdateOrganizationRelationshipResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {OrganizationRelationshipWithCalculatedFieldsAllOf}
     * @memberof UpdateOrganizationRelationshipResponse200
     */
    'data'?: OrganizationRelationshipWithCalculatedFieldsAllOf;
    /**
     *
     * @type {GetOrganizationRelationshipsResponse200AllOfRelatedObjects}
     * @memberof UpdateOrganizationRelationshipResponse200
     */
    'related_objects'?: GetOrganizationRelationshipsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface UpdateOrganizationRequest
 */
export interface UpdateOrganizationRequest {
    /**
     * The name of the organization
     * @type {string}
     * @memberof UpdateOrganizationRequest
     */
    'name'?: string;
    /**
     * The ID of the user who will be marked as the owner of this organization. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof UpdateOrganizationRequest
     */
    'owner_id'?: number;
    /**
     * The ID of the label.
     * @type {number}
     * @memberof UpdateOrganizationRequest
     */
    'label'?: number;
    /**
     *
     * @type {string}
     * @memberof UpdateOrganizationRequest
     */
    'visible_to'?: UpdateOrganizationRequestVisibleToConst;
}

export const UpdateOrganizationRequestVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type UpdateOrganizationRequestVisibleToConst = typeof UpdateOrganizationRequestVisibleToConst[keyof typeof UpdateOrganizationRequestVisibleToConst];

/**
 *
 * @export
 * @interface UpdateOrganizationRequestAllOf
 */
export interface UpdateOrganizationRequestAllOf {
    /**
     * The name of the organization
     * @type {string}
     * @memberof UpdateOrganizationRequestAllOf
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface UpdateOrganizationResponse200
 */
export interface UpdateOrganizationResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UpdateOrganizationResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {BaseOrganizationItem}
     * @memberof UpdateOrganizationResponse200
     */
    'data'?: BaseOrganizationItem;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjects}
     * @memberof UpdateOrganizationResponse200
     */
    'related_objects'?: GetOrganizationsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface UpdateOrganizationResponse200AllOf
 */
export interface UpdateOrganizationResponse200AllOf {
    /**
     *
     * @type {BaseOrganizationItem}
     * @memberof UpdateOrganizationResponse200AllOf
     */
    'data'?: BaseOrganizationItem;
    /**
     *
     * @type {GetOrganizationsResponse200AllOfRelatedObjects}
     * @memberof UpdateOrganizationResponse200AllOf
     */
    'related_objects'?: GetOrganizationsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface UpdatePersonRequest
 */
export interface UpdatePersonRequest {
    /**
     * The name of the person
     * @type {string}
     * @memberof UpdatePersonRequest
     */
    'name'?: string;
    /**
     * The ID of the user who will be marked as the owner of this person. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof UpdatePersonRequest
     */
    'owner_id'?: number;
    /**
     * The ID of the organization this person will belong to
     * @type {number}
     * @memberof UpdatePersonRequest
     */
    'org_id'?: number;
    /**
     * An email address as a string or an array of email objects related to the person. The structure of the array is as follows: `[{ \"value\": \"mail@example.com\", \"primary\": \"true\", \"label\": \"main\" }]`. Please note that only `value` is required.
     * @type {Array<BasicPersonRequestEmailInner>}
     * @memberof UpdatePersonRequest
     */
    'email'?: Array<BasicPersonRequestEmailInner>;
    /**
     * A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ \"value\": \"12345\", \"primary\": \"true\", \"label\": \"mobile\" }]`. Please note that only `value` is required.
     * @type {Array<PersonItemAllOfPhoneInner>}
     * @memberof UpdatePersonRequest
     */
    'phone'?: Array<PersonItemAllOfPhoneInner>;
    /**
     * The ID of the label.
     * @type {number}
     * @memberof UpdatePersonRequest
     */
    'label'?: number;
    /**
     *
     * @type {string}
     * @memberof UpdatePersonRequest
     */
    'visible_to'?: UpdatePersonRequestVisibleToConst;
    /**
     *
     * @type {string}
     * @memberof UpdatePersonRequest
     */
    'marketing_status'?: UpdatePersonRequestMarketingStatusConst;
    /**
     * The optional creation date & time of the person in UTC. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof UpdatePersonRequest
     */
    'add_time'?: string;
}

export const UpdatePersonRequestVisibleToConst = {
    _1: '1',
    _3: '3',
    _5: '5',
    _7: '7'
} as const;

export type UpdatePersonRequestVisibleToConst = typeof UpdatePersonRequestVisibleToConst[keyof typeof UpdatePersonRequestVisibleToConst];
export const UpdatePersonRequestMarketingStatusConst = {
    no_consent: 'no_consent',
    unsubscribed: 'unsubscribed',
    subscribed: 'subscribed',
    archived: 'archived'
} as const;

export type UpdatePersonRequestMarketingStatusConst = typeof UpdatePersonRequestMarketingStatusConst[keyof typeof UpdatePersonRequestMarketingStatusConst];

/**
 *
 * @export
 * @interface UpdatePersonRequestAllOf
 */
export interface UpdatePersonRequestAllOf {
    /**
     * The name of the person
     * @type {string}
     * @memberof UpdatePersonRequestAllOf
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface UpdatePersonResponse200
 */
export interface UpdatePersonResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UpdatePersonResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {PersonItem}
     * @memberof UpdatePersonResponse200
     */
    'data'?: PersonItem;
    /**
     *
     * @type {ListProductsResponse200AllOfRelatedObjects}
     * @memberof UpdatePersonResponse200
     */
    'related_objects'?: ListProductsResponse200AllOfRelatedObjects;
}
/**
 *
 * @export
 * @interface UpdatePipelineResponse200
 */
export interface UpdatePipelineResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UpdatePipelineResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {UpdatePipelineResponse200AllOfData}
     * @memberof UpdatePipelineResponse200
     */
    'data'?: UpdatePipelineResponse200AllOfData;
}
/**
 *
 * @export
 * @interface UpdatePipelineResponse200AllOf
 */
export interface UpdatePipelineResponse200AllOf {
    /**
     *
     * @type {UpdatePipelineResponse200AllOfData}
     * @memberof UpdatePipelineResponse200AllOf
     */
    'data'?: UpdatePipelineResponse200AllOfData;
}
/**
 * The pipeline object
 * @export
 * @interface UpdatePipelineResponse200AllOfData
 */
export interface UpdatePipelineResponse200AllOfData {
    /**
     * The ID of the pipeline
     * @type {number}
     * @memberof UpdatePipelineResponse200AllOfData
     */
    'id'?: number;
    /**
     * The name of the pipeline
     * @type {string}
     * @memberof UpdatePipelineResponse200AllOfData
     */
    'name'?: string;
    /**
     * The pipeline title displayed in the URL
     * @type {string}
     * @memberof UpdatePipelineResponse200AllOfData
     */
    'url_title'?: string;
    /**
     * Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
     * @type {number}
     * @memberof UpdatePipelineResponse200AllOfData
     */
    'order_nr'?: number;
    /**
     * Whether this pipeline will be made inactive (hidden) or active
     * @type {boolean}
     * @memberof UpdatePipelineResponse200AllOfData
     */
    'active'?: boolean;
    /**
     * Whether deal probability is disabled or enabled for this pipeline
     * @type {boolean}
     * @memberof UpdatePipelineResponse200AllOfData
     */
    'deal_probability'?: boolean;
    /**
     * The pipeline creation time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof UpdatePipelineResponse200AllOfData
     */
    'add_time'?: string;
    /**
     * The pipeline update time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof UpdatePipelineResponse200AllOfData
     */
    'update_time'?: string;
    /**
     * A boolean that shows if the pipeline is selected from a filter or not
     * @type {boolean}
     * @memberof UpdatePipelineResponse200AllOfData
     */
    'selected'?: boolean;
}
/**
 *
 * @export
 * @interface UpdateProductFieldResponse200
 */
export interface UpdateProductFieldResponse200 {
    /**
     * The name of the field
     * @type {string}
     * @memberof UpdateProductFieldResponse200
     */
    'name'?: string;
    /**
     * When `field_type` is either set or enum, possible options on update must be supplied as an array of objects each containing id and label, for example: [{\"id\":1, \"label\":\"red\"},{\"id\":2, \"label\":\"blue\"},{\"id\":3, \"label\":\"lilac\"}]
     * @type {Array<object>}
     * @memberof UpdateProductFieldResponse200
     */
    'options'?: Array<object>;
}
/**
 *
 * @export
 * @interface UpdateProductResponse200
 */
export interface UpdateProductResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UpdateProductResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {ListProductsResponse200AllOfDataInnerProduct}
     * @memberof UpdateProductResponse200
     */
    'data'?: ListProductsResponse200AllOfDataInnerProduct;
    /**
     *
     * @type {GetActivitiesResponse200RelatedObjects}
     * @memberof UpdateProductResponse200
     */
    'related_objects'?: GetActivitiesResponse200RelatedObjects;
}
/**
 *
 * @export
 * @interface UpdateProjectRequest
 */
export interface UpdateProjectRequest {
    /**
     * The title of the project
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'title'?: string;
    /**
     * The ID of the board this project is associated with
     * @type {number}
     * @memberof UpdateProjectRequest
     */
    'board_id'?: number;
    /**
     * The ID of the phase this project is associated with
     * @type {number}
     * @memberof UpdateProjectRequest
     */
    'phase_id'?: number;
    /**
     * The description of the project
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'description'?: string;
    /**
     * The status of the project
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'status'?: string;
    /**
     * The ID of a project owner
     * @type {number}
     * @memberof UpdateProjectRequest
     */
    'owner_id'?: number;
    /**
     * The start date of the project. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'start_date'?: string;
    /**
     * The end date of the project. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'end_date'?: string;
    /**
     * An array of IDs of the deals this project is associated with
     * @type {Array<number>}
     * @memberof UpdateProjectRequest
     */
    'deal_ids'?: Array<number>;
    /**
     * The ID of the organization this project is associated with
     * @type {number}
     * @memberof UpdateProjectRequest
     */
    'org_id'?: number;
    /**
     * The ID of the person this project is associated with
     * @type {number}
     * @memberof UpdateProjectRequest
     */
    'person_id'?: number;
    /**
     * An array of IDs of the labels this project has
     * @type {Array<number>}
     * @memberof UpdateProjectRequest
     */
    'labels'?: Array<number>;
}
/**
 *
 * @export
 * @interface UpdateProjectRequest1
 */
export interface UpdateProjectRequest1 {
    /**
     * The title of the task
     * @type {string}
     * @memberof UpdateProjectRequest1
     */
    'title'?: string;
    /**
     * The ID of the project this task is associated with
     * @type {number}
     * @memberof UpdateProjectRequest1
     */
    'project_id'?: number;
    /**
     * The description of the task
     * @type {string}
     * @memberof UpdateProjectRequest1
     */
    'description'?: string;
    /**
     * The ID of a parent task. Can not be ID of a task which is already a subtask.
     * @type {number}
     * @memberof UpdateProjectRequest1
     */
    'parent_task_id'?: number;
    /**
     * The ID of the user who will be the assignee of the task
     * @type {number}
     * @memberof UpdateProjectRequest1
     */
    'assignee_id'?: number;
    /**
     *
     * @type {number}
     * @memberof UpdateProjectRequest1
     */
    'done'?: UpdateProjectRequest1DoneConst;
    /**
     * The due date of the task. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof UpdateProjectRequest1
     */
    'due_date'?: string;
    /**
     * The creator of a task
     * @type {number}
     * @memberof UpdateProjectRequest1
     */
    'creator_id'?: number;
    /**
     * The creation date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof UpdateProjectRequest1
     */
    'add_time'?: string;
    /**
     * The update date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof UpdateProjectRequest1
     */
    'update_time'?: string;
    /**
     * The marked as done date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof UpdateProjectRequest1
     */
    'marked_as_done_time'?: string;
}

export const UpdateProjectRequest1DoneConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UpdateProjectRequest1DoneConst = typeof UpdateProjectRequest1DoneConst[keyof typeof UpdateProjectRequest1DoneConst];

/**
 *
 * @export
 * @interface UpdateProjectRequest1AllOf
 */
export interface UpdateProjectRequest1AllOf {
    /**
     * The title of the task
     * @type {string}
     * @memberof UpdateProjectRequest1AllOf
     */
    'title'?: string;
    /**
     * The ID of the project this task is associated with
     * @type {number}
     * @memberof UpdateProjectRequest1AllOf
     */
    'project_id'?: number;
}
/**
 *
 * @export
 * @interface UpdateProjectRequest1AllOf1
 */
export interface UpdateProjectRequest1AllOf1 {
    /**
     * The description of the task
     * @type {string}
     * @memberof UpdateProjectRequest1AllOf1
     */
    'description'?: string;
    /**
     * The ID of a parent task. Can not be ID of a task which is already a subtask.
     * @type {number}
     * @memberof UpdateProjectRequest1AllOf1
     */
    'parent_task_id'?: number;
    /**
     * The ID of the user who will be the assignee of the task
     * @type {number}
     * @memberof UpdateProjectRequest1AllOf1
     */
    'assignee_id'?: number;
    /**
     *
     * @type {number}
     * @memberof UpdateProjectRequest1AllOf1
     */
    'done'?: UpdateProjectRequest1AllOf1DoneConst;
    /**
     * The due date of the task. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof UpdateProjectRequest1AllOf1
     */
    'due_date'?: string;
}

export const UpdateProjectRequest1AllOf1DoneConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UpdateProjectRequest1AllOf1DoneConst = typeof UpdateProjectRequest1AllOf1DoneConst[keyof typeof UpdateProjectRequest1AllOf1DoneConst];

/**
 *
 * @export
 * @interface UpdateProjectRequest1AllOf2
 */
export interface UpdateProjectRequest1AllOf2 {
    /**
     * The creator of a task
     * @type {number}
     * @memberof UpdateProjectRequest1AllOf2
     */
    'creator_id'?: number;
    /**
     * The creation date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof UpdateProjectRequest1AllOf2
     */
    'add_time'?: string;
    /**
     * The update date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof UpdateProjectRequest1AllOf2
     */
    'update_time'?: string;
    /**
     * The marked as done date and time of the task in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof UpdateProjectRequest1AllOf2
     */
    'marked_as_done_time'?: string;
}
/**
 *
 * @export
 * @interface UpdateProjectRequest2
 */
export interface UpdateProjectRequest2 {
    /**
     * The title of the task
     * @type {string}
     * @memberof UpdateProjectRequest2
     */
    'title'?: string;
    /**
     * The ID of the project this task is associated with
     * @type {number}
     * @memberof UpdateProjectRequest2
     */
    'project_id'?: number;
    /**
     * The description of the task
     * @type {string}
     * @memberof UpdateProjectRequest2
     */
    'description'?: string;
    /**
     * The ID of a parent task. Can not be ID of a task which is already a subtask.
     * @type {number}
     * @memberof UpdateProjectRequest2
     */
    'parent_task_id'?: number;
    /**
     * The ID of the user who will be the assignee of the task
     * @type {number}
     * @memberof UpdateProjectRequest2
     */
    'assignee_id'?: number;
    /**
     *
     * @type {number}
     * @memberof UpdateProjectRequest2
     */
    'done'?: UpdateProjectRequest2DoneConst;
    /**
     * The due date of the task. Format: YYYY-MM-DD.
     * @type {string}
     * @memberof UpdateProjectRequest2
     */
    'due_date'?: string;
}

export const UpdateProjectRequest2DoneConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UpdateProjectRequest2DoneConst = typeof UpdateProjectRequest2DoneConst[keyof typeof UpdateProjectRequest2DoneConst];

/**
 *
 * @export
 * @interface UpdateProjectResponse200
 */
export interface UpdateProjectResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof UpdateProjectResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {ProjectResponseObject}
     * @memberof UpdateProjectResponse200
     */
    'data'?: ProjectResponseObject;
    /**
     *
     * @type {object}
     * @memberof UpdateProjectResponse200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface UpdateRecurringSubscriptionRequest
 */
export interface UpdateRecurringSubscriptionRequest {
    /**
     * The description of the recurring subscription
     * @type {string}
     * @memberof UpdateRecurringSubscriptionRequest
     */
    'description'?: string;
    /**
     * The amount of each payment
     * @type {number}
     * @memberof UpdateRecurringSubscriptionRequest
     */
    'cycle_amount'?: number;
    /**
     * Array of additional payments. It requires a minimum structure as follows: [{ amount:SUM, description:DESCRIPTION, due_at:PAYMENT_DATE }]. Replace SUM with a payment amount, DESCRIPTION with an explanation string, PAYMENT_DATE with a date (format YYYY-MM-DD).
     * @type {Array<object>}
     * @memberof UpdateRecurringSubscriptionRequest
     */
    'payments'?: Array<object>;
    /**
     * Indicates that the deal value must be set to recurring subscription\'s MRR value
     * @type {boolean}
     * @memberof UpdateRecurringSubscriptionRequest
     */
    'update_deal_value'?: boolean;
    /**
     * All payments after that date will be affected. Format: YYYY-MM-DD
     * @type {string}
     * @memberof UpdateRecurringSubscriptionRequest
     */
    'effective_date': string;
}
/**
 *
 * @export
 * @interface UpdateRoleResponse200
 */
export interface UpdateRoleResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UpdateRoleResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {AddRoleResponse200AllOfData}
     * @memberof UpdateRoleResponse200
     */
    'data'?: AddRoleResponse200AllOfData;
}
/**
 *
 * @export
 * @interface UpdateStageRequest
 */
export interface UpdateStageRequest {
    /**
     * The name of the stage
     * @type {string}
     * @memberof UpdateStageRequest
     */
    'name'?: string;
    /**
     * The ID of the pipeline to add stage to
     * @type {number}
     * @memberof UpdateStageRequest
     */
    'pipeline_id'?: number;
    /**
     * The success probability percentage of the deal. Used/shown when deal weighted values are used.
     * @type {number}
     * @memberof UpdateStageRequest
     */
    'deal_probability'?: number;
    /**
     * Whether deals in this stage can become rotten
     * @type {boolean}
     * @memberof UpdateStageRequest
     */
    'rotten_flag'?: boolean;
    /**
     * The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
     * @type {number}
     * @memberof UpdateStageRequest
     */
    'rotten_days'?: number;
    /**
     * An order number for this stage. Order numbers should be used to order the stages in the pipeline.
     * @type {number}
     * @memberof UpdateStageRequest
     */
    'order_nr'?: number;
}
/**
 *
 * @export
 * @interface UpdateStageRequestAllOf
 */
export interface UpdateStageRequestAllOf {
    /**
     * The name of the stage
     * @type {string}
     * @memberof UpdateStageRequestAllOf
     */
    'name'?: string;
    /**
     * The ID of the pipeline to add stage to
     * @type {number}
     * @memberof UpdateStageRequestAllOf
     */
    'pipeline_id'?: number;
    /**
     * The success probability percentage of the deal. Used/shown when deal weighted values are used.
     * @type {number}
     * @memberof UpdateStageRequestAllOf
     */
    'deal_probability'?: number;
    /**
     * Whether deals in this stage can become rotten
     * @type {boolean}
     * @memberof UpdateStageRequestAllOf
     */
    'rotten_flag'?: boolean;
    /**
     * The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
     * @type {number}
     * @memberof UpdateStageRequestAllOf
     */
    'rotten_days'?: number;
}
/**
 *
 * @export
 * @interface UpdateStageRequestAllOf1
 */
export interface UpdateStageRequestAllOf1 {
    /**
     * An order number for this stage. Order numbers should be used to order the stages in the pipeline.
     * @type {number}
     * @memberof UpdateStageRequestAllOf1
     */
    'order_nr'?: number;
}
/**
 *
 * @export
 * @interface UpdateSubscriptionInstallmentRequest
 */
export interface UpdateSubscriptionInstallmentRequest {
    /**
     * Array of payments. It requires a minimum structure as follows: [{ amount:SUM, description:DESCRIPTION, due_at:PAYMENT_DATE }]. Replace SUM with a payment amount, DESCRIPTION with a explanation string, PAYMENT_DATE with a date (format YYYY-MM-DD).
     * @type {Array<object>}
     * @memberof UpdateSubscriptionInstallmentRequest
     */
    'payments': Array<object>;
    /**
     * Indicates that the deal value must be set to installment subscription\'s total value
     * @type {boolean}
     * @memberof UpdateSubscriptionInstallmentRequest
     */
    'update_deal_value'?: boolean;
}
/**
 *
 * @export
 * @interface UpdateTaskResponse200
 */
export interface UpdateTaskResponse200 {
    /**
     *
     * @type {boolean}
     * @memberof UpdateTaskResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {TaskResponseObject}
     * @memberof UpdateTaskResponse200
     */
    'data'?: TaskResponseObject;
    /**
     *
     * @type {object}
     * @memberof UpdateTaskResponse200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface UpdateTeamRequest
 */
export interface UpdateTeamRequest {
    /**
     * The team name
     * @type {string}
     * @memberof UpdateTeamRequest
     */
    'name'?: string;
    /**
     * The team description
     * @type {string}
     * @memberof UpdateTeamRequest
     */
    'description'?: string;
    /**
     * The team manager ID
     * @type {number}
     * @memberof UpdateTeamRequest
     */
    'manager_id'?: number;
    /**
     * The IDs of the users that belong to the team
     * @type {Array<number>}
     * @memberof UpdateTeamRequest
     */
    'users'?: Array<number>;
    /**
     *
     * @type {number}
     * @memberof UpdateTeamRequest
     */
    'active_flag'?: UpdateTeamRequestActiveFlagConst;
    /**
     *
     * @type {number}
     * @memberof UpdateTeamRequest
     */
    'deleted_flag'?: UpdateTeamRequestDeletedFlagConst;
}

export const UpdateTeamRequestActiveFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UpdateTeamRequestActiveFlagConst = typeof UpdateTeamRequestActiveFlagConst[keyof typeof UpdateTeamRequestActiveFlagConst];
export const UpdateTeamRequestDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UpdateTeamRequestDeletedFlagConst = typeof UpdateTeamRequestDeletedFlagConst[keyof typeof UpdateTeamRequestDeletedFlagConst];

/**
 *
 * @export
 * @interface UpdateTeamRequestAllOf
 */
export interface UpdateTeamRequestAllOf {
    /**
     *
     * @type {number}
     * @memberof UpdateTeamRequestAllOf
     */
    'active_flag'?: UpdateTeamRequestAllOfActiveFlagConst;
    /**
     *
     * @type {number}
     * @memberof UpdateTeamRequestAllOf
     */
    'deleted_flag'?: UpdateTeamRequestAllOfDeletedFlagConst;
}

export const UpdateTeamRequestAllOfActiveFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UpdateTeamRequestAllOfActiveFlagConst = typeof UpdateTeamRequestAllOfActiveFlagConst[keyof typeof UpdateTeamRequestAllOfActiveFlagConst];
export const UpdateTeamRequestAllOfDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UpdateTeamRequestAllOfDeletedFlagConst = typeof UpdateTeamRequestAllOfDeletedFlagConst[keyof typeof UpdateTeamRequestAllOfDeletedFlagConst];

/**
 *
 * @export
 * @interface UpdateTeamWithAdditionalProperties
 */
export interface UpdateTeamWithAdditionalProperties {
    /**
     * The team name
     * @type {string}
     * @memberof UpdateTeamWithAdditionalProperties
     */
    'name'?: string;
    /**
     * The team description
     * @type {string}
     * @memberof UpdateTeamWithAdditionalProperties
     */
    'description'?: string;
    /**
     * The team manager ID
     * @type {number}
     * @memberof UpdateTeamWithAdditionalProperties
     */
    'manager_id'?: number;
    /**
     * The IDs of the users that belong to the team
     * @type {Array<number>}
     * @memberof UpdateTeamWithAdditionalProperties
     */
    'users'?: Array<number>;
    /**
     *
     * @type {number}
     * @memberof UpdateTeamWithAdditionalProperties
     */
    'active_flag'?: UpdateTeamWithAdditionalPropertiesActiveFlagConst;
    /**
     *
     * @type {number}
     * @memberof UpdateTeamWithAdditionalProperties
     */
    'deleted_flag'?: UpdateTeamWithAdditionalPropertiesDeletedFlagConst;
    /**
     * The team creation time. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof UpdateTeamWithAdditionalProperties
     */
    'add_time'?: string;
    /**
     * The ID of the user who created the team
     * @type {number}
     * @memberof UpdateTeamWithAdditionalProperties
     */
    'created_by_user_id'?: number;
}

export const UpdateTeamWithAdditionalPropertiesActiveFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UpdateTeamWithAdditionalPropertiesActiveFlagConst = typeof UpdateTeamWithAdditionalPropertiesActiveFlagConst[keyof typeof UpdateTeamWithAdditionalPropertiesActiveFlagConst];
export const UpdateTeamWithAdditionalPropertiesDeletedFlagConst = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UpdateTeamWithAdditionalPropertiesDeletedFlagConst = typeof UpdateTeamWithAdditionalPropertiesDeletedFlagConst[keyof typeof UpdateTeamWithAdditionalPropertiesDeletedFlagConst];

/**
 *
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * Whether the user is active or not. `false` = Not activated, `true` = Activated
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'active_flag': boolean;
}
/**
 *
 * @export
 * @interface UpdatedActivityPlanItem200
 */
export interface UpdatedActivityPlanItem200 {
    /**
     *
     * @type {boolean}
     * @memberof UpdatedActivityPlanItem200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetProjectPlanResponse200DataInner}
     * @memberof UpdatedActivityPlanItem200
     */
    'data'?: GetProjectPlanResponse200DataInner;
    /**
     *
     * @type {object}
     * @memberof UpdatedActivityPlanItem200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface UpdatedTaskPlanItem200
 */
export interface UpdatedTaskPlanItem200 {
    /**
     *
     * @type {boolean}
     * @memberof UpdatedTaskPlanItem200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetProjectPlanResponse200DataInner}
     * @memberof UpdatedTaskPlanItem200
     */
    'data'?: GetProjectPlanResponse200DataInner;
    /**
     *
     * @type {object}
     * @memberof UpdatedTaskPlanItem200
     */
    'additional_data'?: object | null;
}
/**
 *
 * @export
 * @interface UserAssignmentsToPermissionSetResponse200
 */
export interface UserAssignmentsToPermissionSetResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UserAssignmentsToPermissionSetResponse200
     */
    'success'?: boolean;
    /**
     * An array of the assignments of the user
     * @type {Array<UserAssignmentsToPermissionSetResponse200AllOfDataInner>}
     * @memberof UserAssignmentsToPermissionSetResponse200
     */
    'data'?: Array<UserAssignmentsToPermissionSetResponse200AllOfDataInner>;
}
/**
 *
 * @export
 * @interface UserAssignmentsToPermissionSetResponse200AllOf
 */
export interface UserAssignmentsToPermissionSetResponse200AllOf {
    /**
     * An array of the assignments of the user
     * @type {Array<UserAssignmentsToPermissionSetResponse200AllOfDataInner>}
     * @memberof UserAssignmentsToPermissionSetResponse200AllOf
     */
    'data'?: Array<UserAssignmentsToPermissionSetResponse200AllOfDataInner>;
}
/**
 *
 * @export
 * @interface UserAssignmentsToPermissionSetResponse200AllOfDataInner
 */
export interface UserAssignmentsToPermissionSetResponse200AllOfDataInner {
    /**
     * The ID of the user in the permission set
     * @type {number}
     * @memberof UserAssignmentsToPermissionSetResponse200AllOfDataInner
     */
    'user_id'?: number;
    /**
     * The ID of the permission set
     * @type {string}
     * @memberof UserAssignmentsToPermissionSetResponse200AllOfDataInner
     */
    'permission_set_id'?: string;
    /**
     * The name of the permission set
     * @type {string}
     * @memberof UserAssignmentsToPermissionSetResponse200AllOfDataInner
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface UserConnectionsResponse200
 */
export interface UserConnectionsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UserConnectionsResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {UserConnectionsResponse200AllOfData}
     * @memberof UserConnectionsResponse200
     */
    'data'?: UserConnectionsResponse200AllOfData;
}
/**
 *
 * @export
 * @interface UserConnectionsResponse200AllOf
 */
export interface UserConnectionsResponse200AllOf {
    /**
     *
     * @type {UserConnectionsResponse200AllOfData}
     * @memberof UserConnectionsResponse200AllOf
     */
    'data'?: UserConnectionsResponse200AllOfData;
}
/**
 * The object of UserConnections
 * @export
 * @interface UserConnectionsResponse200AllOfData
 */
export interface UserConnectionsResponse200AllOfData {
    /**
     * The third party ID or false in case the ID is not found
     * @type {string}
     * @memberof UserConnectionsResponse200AllOfData
     */
    'google'?: string;
}
/**
 *
 * @export
 * @interface UserDataWithId
 */
export interface UserDataWithId {
    /**
     * The ID of the user
     * @type {number}
     * @memberof UserDataWithId
     */
    'id'?: number;
    /**
     * The name of the user
     * @type {string}
     * @memberof UserDataWithId
     */
    'name'?: string;
    /**
     * The email of the user
     * @type {string}
     * @memberof UserDataWithId
     */
    'email'?: string;
    /**
     * Whether the user has picture or not. 0 = No picture, 1 = Has picture.
     * @type {number}
     * @memberof UserDataWithId
     */
    'has_pic'?: number;
    /**
     * The user picture hash
     * @type {string}
     * @memberof UserDataWithId
     */
    'pic_hash'?: string | null;
    /**
     * Whether the user is active or not
     * @type {boolean}
     * @memberof UserDataWithId
     */
    'active_flag'?: boolean;
}
/**
 *
 * @export
 * @interface UserDataWithIdAllOf
 */
export interface UserDataWithIdAllOf {
    /**
     * The ID of the user
     * @type {number}
     * @memberof UserDataWithIdAllOf
     */
    'id'?: number;
    /**
     * The name of the user
     * @type {string}
     * @memberof UserDataWithIdAllOf
     */
    'name'?: string;
    /**
     * The email of the user
     * @type {string}
     * @memberof UserDataWithIdAllOf
     */
    'email'?: string;
    /**
     * Whether the user has picture or not. 0 = No picture, 1 = Has picture.
     * @type {number}
     * @memberof UserDataWithIdAllOf
     */
    'has_pic'?: number;
    /**
     * The user picture hash
     * @type {string}
     * @memberof UserDataWithIdAllOf
     */
    'pic_hash'?: string | null;
    /**
     * Whether the user is active or not
     * @type {boolean}
     * @memberof UserDataWithIdAllOf
     */
    'active_flag'?: boolean;
}
/**
 *
 * @export
 * @interface UserIds
 */
export interface UserIds {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UserIds
     */
    'success'?: boolean;
    /**
     * The list of user IDs
     * @type {Array<number>}
     * @memberof UserIds
     */
    'data'?: Array<number>;
}
/**
 *
 * @export
 * @interface UserIdsAllOf
 */
export interface UserIdsAllOf {
    /**
     * The list of user IDs
     * @type {Array<number>}
     * @memberof UserIdsAllOf
     */
    'data'?: Array<number>;
}
/**
 *
 * @export
 * @interface UserResponse200
 */
export interface UserResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UserResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {GetRecentsResponse200DataInnerAnyOf11Data}
     * @memberof UserResponse200
     */
    'data'?: GetRecentsResponse200DataInnerAnyOf11Data;
}
/**
 *
 * @export
 * @interface UserResponse200AllOf
 */
export interface UserResponse200AllOf {
    /**
     *
     * @type {GetRecentsResponse200DataInnerAnyOf11Data}
     * @memberof UserResponse200AllOf
     */
    'data'?: GetRecentsResponse200DataInnerAnyOf11Data;
}
/**
 *
 * @export
 * @interface UsersResponse200
 */
export interface UsersResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UsersResponse200
     */
    'success'?: boolean;
    /**
     *
     * @type {Array<GetRecentsResponse200DataInnerAnyOf11Data>}
     * @memberof UsersResponse200
     */
    'data'?: Array<GetRecentsResponse200DataInnerAnyOf11Data>;
}
/**
 *
 * @export
 * @interface UsersResponse200AllOf
 */
export interface UsersResponse200AllOf {
    /**
     *
     * @type {Array<GetRecentsResponse200DataInnerAnyOf11Data>}
     * @memberof UsersResponse200AllOf
     */
    'data'?: Array<GetRecentsResponse200DataInnerAnyOf11Data>;
}
/**
 *
 * @export
 * @interface WebhookResponse200
 */
export interface WebhookResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof WebhookResponse200
     */
    'success'?: boolean;
    /**
     * The status of the response
     * @type {string}
     * @memberof WebhookResponse200
     */
    'status'?: string;
    /**
     *
     * @type {GetWebhooksResponse200AllOfDataInner}
     * @memberof WebhookResponse200
     */
    'data'?: GetWebhooksResponse200AllOfDataInner;
}
/**
 *
 * @export
 * @interface WebhookResponse200AllOf
 */
export interface WebhookResponse200AllOf {
    /**
     *
     * @type {GetWebhooksResponse200AllOfDataInner}
     * @memberof WebhookResponse200AllOf
     */
    'data'?: GetWebhooksResponse200AllOfDataInner;
}
/**
 *
 * @export
 * @interface WebhooksBadRequestResponse
 */
export interface WebhooksBadRequestResponse {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof WebhooksBadRequestResponse
     */
    'success'?: boolean;
    /**
     * The status of the response
     * @type {string}
     * @memberof WebhooksBadRequestResponse
     */
    'status'?: string;
    /**
     * List of errors
     * @type {object}
     * @memberof WebhooksBadRequestResponse
     */
    'errors'?: object;
}
/**
 *
 * @export
 * @interface WebhooksBadRequestResponseAllOf
 */
export interface WebhooksBadRequestResponseAllOf {
    /**
     * List of errors
     * @type {object}
     * @memberof WebhooksBadRequestResponseAllOf
     */
    'errors'?: object;
}

/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
export const ActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new activity. Includes `more_activities_scheduled_in_context` property in response\'s `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data). For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-activity\" target=\"_blank\" rel=\"noopener noreferrer\">adding an activity</a>.
         * @summary Add an activity
         * @param {AddActivityRequest} [AddActivityRequest]

         * @throws {RequiredError}
         */
        addActivity: async (AddActivityRequest?: AddActivityRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddActivityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple activities as deleted. After 30 days, the activities will be permanently deleted.
         * @summary Delete multiple activities in bulk
         * @param {string} ids The comma-separated IDs of activities that will be deleted

         * @throws {RequiredError}
         */
        deleteActivities: async (ids: string, ): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteActivities', 'ids', ids)
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:full"], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
         * @summary Delete an activity
         * @param {number} id The ID of the activity

         * @throws {RequiredError}
         */
        deleteActivity: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteActivity', 'id', id)
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all activities assigned to a particular user.
         * @summary Get all activities assigned to a particular user
         * @param {number} [user_id] The ID of the user whose activities will be fetched. If omitted, the user associated with the API token will be used. If 0, activities for all company users will be fetched based on the permission sets.
         * @param {number} [filter_id] The ID of the filter to use (will narrow down results if used together with &#x60;user_id&#x60; parameter)
         * @param {string} [type] The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the &#x60;key_string&#x60; parameter of ActivityTypes.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
         * @param {number} [start] For pagination, the position that represents the first result for the page
         * @param {string} [start_date] Use the activity due date where you wish to begin fetching activities from. Insert due date in YYYY-MM-DD format.
         * @param {string} [end_date] Use the activity due date where you wish to stop fetching activities from. Insert due date in YYYY-MM-DD format.
         * @param {0 | 1} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both done and not done activities.

         * @throws {RequiredError}
         */
        getActivities: async (user_id?: number, filter_id?: number, type?: string, limit?: number, start?: number, start_date?: string, end_date?: string, done?: 0 | 1, ): Promise<RequestArgs> => {
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:read", "activities:full"], configuration)

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['start_date'] = (start_date as any instanceof Date) ?
                    (start_date as any).toISOString().substr(0,10) :
                    start_date;
            }

            if (end_date !== undefined) {
                localVarQueryParameter['end_date'] = (end_date as any instanceof Date) ?
                    (end_date as any).toISOString().substr(0,10) :
                    end_date;
            }

            if (done !== undefined) {
                localVarQueryParameter['done'] = done;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all activities. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all activities (BETA)
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [since] The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {string} [until] The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {number} [user_id] The ID of the user whose activities will be fetched. If omitted, all activities are returned.
         * @param {boolean} [done] Whether the activity is done or not. &#x60;false&#x60; &#x3D; Not done, &#x60;true&#x60; &#x3D; Done. If omitted, returns both done and not done activities.
         * @param {string} [type] The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the &#x60;key_string&#x60; parameter of ActivityTypes.

         * @throws {RequiredError}
         */
        getActivitiesCollection: async (cursor?: string, limit?: number, since?: string, until?: string, user_id?: number, done?: boolean, type?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/activities/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:read", "activities:full"], configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (done !== undefined) {
                localVarQueryParameter['done'] = done;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific activity.
         * @summary Get details of an activity
         * @param {number} id The ID of the activity

         * @throws {RequiredError}
         */
        getActivity: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getActivity', 'id', id)
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:read", "activities:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an activity. Includes `more_activities_scheduled_in_context` property in response\'s `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data).
         * @summary Update an activity
         * @param {number} id The ID of the activity
         * @param {UpdateActivityRequest} [UpdateActivityRequest]

         * @throws {RequiredError}
         */
        updateActivity: async (id: number, UpdateActivityRequest?: UpdateActivityRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateActivity', 'id', id)
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateActivityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new activity. Includes `more_activities_scheduled_in_context` property in response\'s `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data). For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-activity\" target=\"_blank\" rel=\"noopener noreferrer\">adding an activity</a>.
         * @summary Add an activity
         * @param {AddActivityRequest} [AddActivityRequest]

         * @throws {RequiredError}
         */
        async addActivity(AddActivityRequest?: AddActivityRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddActivityResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addActivity(AddActivityRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks multiple activities as deleted. After 30 days, the activities will be permanently deleted.
         * @summary Delete multiple activities in bulk
         * @param {string} ids The comma-separated IDs of activities that will be deleted

         * @throws {RequiredError}
         */
        async deleteActivities(ids: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteActivitiesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteActivities(ids, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
         * @summary Delete an activity
         * @param {number} id The ID of the activity

         * @throws {RequiredError}
         */
        async deleteActivity(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteActivityResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteActivity(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all activities assigned to a particular user.
         * @summary Get all activities assigned to a particular user
         * @param {number} [user_id] The ID of the user whose activities will be fetched. If omitted, the user associated with the API token will be used. If 0, activities for all company users will be fetched based on the permission sets.
         * @param {number} [filter_id] The ID of the filter to use (will narrow down results if used together with &#x60;user_id&#x60; parameter)
         * @param {string} [type] The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the &#x60;key_string&#x60; parameter of ActivityTypes.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
         * @param {number} [start] For pagination, the position that represents the first result for the page
         * @param {string} [start_date] Use the activity due date where you wish to begin fetching activities from. Insert due date in YYYY-MM-DD format.
         * @param {string} [end_date] Use the activity due date where you wish to stop fetching activities from. Insert due date in YYYY-MM-DD format.
         * @param {0 | 1} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both done and not done activities.

         * @throws {RequiredError}
         */
        async getActivities(user_id?: number, filter_id?: number, type?: string, limit?: number, start?: number, start_date?: string, end_date?: string, done?: 0 | 1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetActivitiesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(user_id, filter_id, type, limit, start, start_date, end_date, done, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all activities. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all activities (BETA)
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [since] The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {string} [until] The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {number} [user_id] The ID of the user whose activities will be fetched. If omitted, all activities are returned.
         * @param {boolean} [done] Whether the activity is done or not. &#x60;false&#x60; &#x3D; Not done, &#x60;true&#x60; &#x3D; Done. If omitted, returns both done and not done activities.
         * @param {string} [type] The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the &#x60;key_string&#x60; parameter of ActivityTypes.

         * @throws {RequiredError}
         */
        async getActivitiesCollection(cursor?: string, limit?: number, since?: string, until?: string, user_id?: number, done?: boolean, type?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetActivitiesCollectionResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivitiesCollection(cursor, limit, since, until, user_id, done, type, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a specific activity.
         * @summary Get details of an activity
         * @param {number} id The ID of the activity

         * @throws {RequiredError}
         */
        async getActivity(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetActivityResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an activity. Includes `more_activities_scheduled_in_context` property in response\'s `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data).
         * @summary Update an activity
         * @param {number} id The ID of the activity
         * @param {UpdateActivityRequest} [UpdateActivityRequest]

         * @throws {RequiredError}
         */
        async updateActivity(id: number, UpdateActivityRequest?: UpdateActivityRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdateActivityResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateActivity(id, UpdateActivityRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivitiesApiFp(configuration)
    return {
        /**
         * Adds a new activity. Includes `more_activities_scheduled_in_context` property in response\'s `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data). For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-activity\" target=\"_blank\" rel=\"noopener noreferrer\">adding an activity</a>.
         * @summary Add an activity
         * @param {ActivitiesApiAddActivityRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addActivity(requestParameters: ActivitiesApiAddActivityRequest = {}, ): Promise<AddActivityResponse200> {
            return localVarFp.addActivity(requestParameters.AddActivityRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks multiple activities as deleted. After 30 days, the activities will be permanently deleted.
         * @summary Delete multiple activities in bulk
         * @param {ActivitiesApiDeleteActivitiesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteActivities(requestParameters: ActivitiesApiDeleteActivitiesRequest, ): Promise<DeleteActivitiesResponse200> {
            return localVarFp.deleteActivities(requestParameters.ids, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
         * @summary Delete an activity
         * @param {ActivitiesApiDeleteActivityRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteActivity(requestParameters: ActivitiesApiDeleteActivityRequest, ): Promise<DeleteActivityResponse200> {
            return localVarFp.deleteActivity(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all activities assigned to a particular user.
         * @summary Get all activities assigned to a particular user
         * @param {ActivitiesApiGetActivitiesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getActivities(requestParameters: ActivitiesApiGetActivitiesRequest = {}, ): Promise<GetActivitiesResponse200> {
            return localVarFp.getActivities(requestParameters.user_id, requestParameters.filter_id, requestParameters.type, requestParameters.limit, requestParameters.start, requestParameters.start_date, requestParameters.end_date, requestParameters.done, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all activities. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all activities (BETA)
         * @param {ActivitiesApiGetActivitiesCollectionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getActivitiesCollection(requestParameters: ActivitiesApiGetActivitiesCollectionRequest = {}, ): Promise<GetActivitiesCollectionResponse200> {
            return localVarFp.getActivitiesCollection(requestParameters.cursor, requestParameters.limit, requestParameters.since, requestParameters.until, requestParameters.user_id, requestParameters.done, requestParameters.type, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific activity.
         * @summary Get details of an activity
         * @param {ActivitiesApiGetActivityRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getActivity(requestParameters: ActivitiesApiGetActivityRequest, ): Promise<GetActivityResponse200> {
            return localVarFp.getActivity(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates an activity. Includes `more_activities_scheduled_in_context` property in response\'s `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data).
         * @summary Update an activity
         * @param {ActivitiesApiUpdateActivityRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateActivity(requestParameters: ActivitiesApiUpdateActivityRequest, ): Promise<UpdateActivityResponse200> {
            return localVarFp.updateActivity(requestParameters.id, requestParameters.UpdateActivityRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addActivity operation in ActivitiesApi.
 * @export
 * @interface ActivitiesApiAddActivityRequest
 */
export interface ActivitiesApiAddActivityRequest {
    /**
     *
     * @type {AddActivityRequest}
     * @memberof ActivitiesApiAddActivity
     */
    readonly AddActivityRequest?: AddActivityRequest
}

/**
 * Request parameters for deleteActivities operation in ActivitiesApi.
 * @export
 * @interface ActivitiesApiDeleteActivitiesRequest
 */
export interface ActivitiesApiDeleteActivitiesRequest {
    /**
     * The comma-separated IDs of activities that will be deleted
     * @type {string}
     * @memberof ActivitiesApiDeleteActivities
     */
    readonly ids: string
}

/**
 * Request parameters for deleteActivity operation in ActivitiesApi.
 * @export
 * @interface ActivitiesApiDeleteActivityRequest
 */
export interface ActivitiesApiDeleteActivityRequest {
    /**
     * The ID of the activity
     * @type {number}
     * @memberof ActivitiesApiDeleteActivity
     */
    readonly id: number
}

/**
 * Request parameters for getActivities operation in ActivitiesApi.
 * @export
 * @interface ActivitiesApiGetActivitiesRequest
 */
export interface ActivitiesApiGetActivitiesRequest {
    /**
     * The ID of the user whose activities will be fetched. If omitted, the user associated with the API token will be used. If 0, activities for all company users will be fetched based on the permission sets.
     * @type {number}
     * @memberof ActivitiesApiGetActivities
     */
    readonly user_id?: number

    /**
     * The ID of the filter to use (will narrow down results if used together with &#x60;user_id&#x60; parameter)
     * @type {number}
     * @memberof ActivitiesApiGetActivities
     */
    readonly filter_id?: number

    /**
     * The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the &#x60;key_string&#x60; parameter of ActivityTypes.
     * @type {string}
     * @memberof ActivitiesApiGetActivities
     */
    readonly type?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
     * @type {number}
     * @memberof ActivitiesApiGetActivities
     */
    readonly limit?: number

    /**
     * For pagination, the position that represents the first result for the page
     * @type {number}
     * @memberof ActivitiesApiGetActivities
     */
    readonly start?: number

    /**
     * Use the activity due date where you wish to begin fetching activities from. Insert due date in YYYY-MM-DD format.
     * @type {string}
     * @memberof ActivitiesApiGetActivities
     */
    readonly start_date?: string

    /**
     * Use the activity due date where you wish to stop fetching activities from. Insert due date in YYYY-MM-DD format.
     * @type {string}
     * @memberof ActivitiesApiGetActivities
     */
    readonly end_date?: string

    /**
     * Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both done and not done activities.
     * @type {0 | 1}
     * @memberof ActivitiesApiGetActivities
     */
    readonly done?: 0 | 1
}

/**
 * Request parameters for getActivitiesCollection operation in ActivitiesApi.
 * @export
 * @interface ActivitiesApiGetActivitiesCollectionRequest
 */
export interface ActivitiesApiGetActivitiesCollectionRequest {
    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof ActivitiesApiGetActivitiesCollection
     */
    readonly cursor?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof ActivitiesApiGetActivitiesCollection
     */
    readonly limit?: number

    /**
     * The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
     * @type {string}
     * @memberof ActivitiesApiGetActivitiesCollection
     */
    readonly since?: string

    /**
     * The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
     * @type {string}
     * @memberof ActivitiesApiGetActivitiesCollection
     */
    readonly until?: string

    /**
     * The ID of the user whose activities will be fetched. If omitted, all activities are returned.
     * @type {number}
     * @memberof ActivitiesApiGetActivitiesCollection
     */
    readonly user_id?: number

    /**
     * Whether the activity is done or not. &#x60;false&#x60; &#x3D; Not done, &#x60;true&#x60; &#x3D; Done. If omitted, returns both done and not done activities.
     * @type {boolean}
     * @memberof ActivitiesApiGetActivitiesCollection
     */
    readonly done?: boolean

    /**
     * The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the &#x60;key_string&#x60; parameter of ActivityTypes.
     * @type {string}
     * @memberof ActivitiesApiGetActivitiesCollection
     */
    readonly type?: string
}

/**
 * Request parameters for getActivity operation in ActivitiesApi.
 * @export
 * @interface ActivitiesApiGetActivityRequest
 */
export interface ActivitiesApiGetActivityRequest {
    /**
     * The ID of the activity
     * @type {number}
     * @memberof ActivitiesApiGetActivity
     */
    readonly id: number
}

/**
 * Request parameters for updateActivity operation in ActivitiesApi.
 * @export
 * @interface ActivitiesApiUpdateActivityRequest
 */
export interface ActivitiesApiUpdateActivityRequest {
    /**
     * The ID of the activity
     * @type {number}
     * @memberof ActivitiesApiUpdateActivity
     */
    readonly id: number

    /**
     *
     * @type {UpdateActivityRequest}
     * @memberof ActivitiesApiUpdateActivity
     */
    readonly UpdateActivityRequest?: UpdateActivityRequest
}

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * Adds a new activity. Includes `more_activities_scheduled_in_context` property in response\'s `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data). For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-activity\" target=\"_blank\" rel=\"noopener noreferrer\">adding an activity</a>.
     * @summary Add an activity
     * @param {ActivitiesApiAddActivityRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public addActivity(requestParameters: ActivitiesApiAddActivityRequest = {}, ) {
        return ActivitiesApiFp(this.configuration).addActivity(requestParameters.AddActivityRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks multiple activities as deleted. After 30 days, the activities will be permanently deleted.
     * @summary Delete multiple activities in bulk
     * @param {ActivitiesApiDeleteActivitiesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public deleteActivities(requestParameters: ActivitiesApiDeleteActivitiesRequest, ) {
        return ActivitiesApiFp(this.configuration).deleteActivities(requestParameters.ids, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
     * @summary Delete an activity
     * @param {ActivitiesApiDeleteActivityRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public deleteActivity(requestParameters: ActivitiesApiDeleteActivityRequest, ) {
        return ActivitiesApiFp(this.configuration).deleteActivity(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all activities assigned to a particular user.
     * @summary Get all activities assigned to a particular user
     * @param {ActivitiesApiGetActivitiesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getActivities(requestParameters: ActivitiesApiGetActivitiesRequest = {}, ) {
        return ActivitiesApiFp(this.configuration).getActivities(requestParameters.user_id, requestParameters.filter_id, requestParameters.type, requestParameters.limit, requestParameters.start, requestParameters.start_date, requestParameters.end_date, requestParameters.done, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all activities. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
     * @summary Get all activities (BETA)
     * @param {ActivitiesApiGetActivitiesCollectionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getActivitiesCollection(requestParameters: ActivitiesApiGetActivitiesCollectionRequest = {}, ) {
        return ActivitiesApiFp(this.configuration).getActivitiesCollection(requestParameters.cursor, requestParameters.limit, requestParameters.since, requestParameters.until, requestParameters.user_id, requestParameters.done, requestParameters.type, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a specific activity.
     * @summary Get details of an activity
     * @param {ActivitiesApiGetActivityRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getActivity(requestParameters: ActivitiesApiGetActivityRequest, ) {
        return ActivitiesApiFp(this.configuration).getActivity(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an activity. Includes `more_activities_scheduled_in_context` property in response\'s `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data).
     * @summary Update an activity
     * @param {ActivitiesApiUpdateActivityRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public updateActivity(requestParameters: ActivitiesApiUpdateActivityRequest, ) {
        return ActivitiesApiFp(this.configuration).updateActivity(requestParameters.id, requestParameters.UpdateActivityRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ActivityFieldsApi - axios parameter creator
 * @export
 */
export const ActivityFieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all activity fields.
         * @summary Get all activity fields

         * @throws {RequiredError}
         */
        getActivityFields: async (): Promise<RequestArgs> => {
            const localVarPath = `/activityFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:read", "activities:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityFieldsApi - functional programming interface
 * @export
 */
export const ActivityFieldsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = ActivityFieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all activity fields.
         * @summary Get all activity fields

         * @throws {RequiredError}
         */
        async getActivityFields(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<FieldsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityFields();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivityFieldsApi - factory interface
 * @export
 */
export const ActivityFieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityFieldsApiFp(configuration)
    return {
        /**
         * Returns all activity fields.
         * @summary Get all activity fields

         * @throws {RequiredError}
         */
        getActivityFields(): Promise<FieldsResponse200> {
            return localVarFp.getActivityFields().then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityFieldsApi - object-oriented interface
 * @export
 * @class ActivityFieldsApi
 * @extends {BaseAPI}
 */
export class ActivityFieldsApi extends BaseAPI {
    /**
     * Returns all activity fields.
     * @summary Get all activity fields

     * @throws {RequiredError}
     * @memberof ActivityFieldsApi
     */
    public getActivityFields() {
        return ActivityFieldsApiFp(this.configuration).getActivityFields().then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ActivityTypesApi - axios parameter creator
 * @export
 */
export const ActivityTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new activity type.
         * @summary Add new activity type
         * @param {AddActivityTypeRequest} [AddActivityTypeRequest]

         * @throws {RequiredError}
         */
        addActivityType: async (AddActivityTypeRequest?: AddActivityTypeRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/activityTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddActivityTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an activity type as deleted.
         * @summary Delete an activity type
         * @param {number} id The ID of the activity type

         * @throws {RequiredError}
         */
        deleteActivityType: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteActivityType', 'id', id)
            const localVarPath = `/activityTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple activity types as deleted.
         * @summary Delete multiple activity types in bulk
         * @param {string} ids The comma-separated activity type IDs

         * @throws {RequiredError}
         */
        deleteActivityTypes: async (ids: string, ): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteActivityTypes', 'ids', ids)
            const localVarPath = `/activityTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all activity types.
         * @summary Get all activity types

         * @throws {RequiredError}
         */
        getActivityTypes: async (): Promise<RequestArgs> => {
            const localVarPath = `/activityTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:read", "activities:full", "admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an activity type.
         * @summary Update an activity type
         * @param {number} id The ID of the activity type
         * @param {UpdateActivityTypeRequest} [UpdateActivityTypeRequest]

         * @throws {RequiredError}
         */
        updateActivityType: async (id: number, UpdateActivityTypeRequest?: UpdateActivityTypeRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateActivityType', 'id', id)
            const localVarPath = `/activityTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateActivityTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityTypesApi - functional programming interface
 * @export
 */
export const ActivityTypesApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = ActivityTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new activity type.
         * @summary Add new activity type
         * @param {AddActivityTypeRequest} [AddActivityTypeRequest]

         * @throws {RequiredError}
         */
        async addActivityType(AddActivityTypeRequest?: AddActivityTypeRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<CreateUpdateDeleteActivityTypeResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addActivityType(AddActivityTypeRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks an activity type as deleted.
         * @summary Delete an activity type
         * @param {number} id The ID of the activity type

         * @throws {RequiredError}
         */
        async deleteActivityType(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<CreateUpdateDeleteActivityTypeResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteActivityType(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks multiple activity types as deleted.
         * @summary Delete multiple activity types in bulk
         * @param {string} ids The comma-separated activity type IDs

         * @throws {RequiredError}
         */
        async deleteActivityTypes(ids: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteActivityTypesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteActivityTypes(ids, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all activity types.
         * @summary Get all activity types

         * @throws {RequiredError}
         */
        async getActivityTypes(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetActivityTypesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityTypes();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an activity type.
         * @summary Update an activity type
         * @param {number} id The ID of the activity type
         * @param {UpdateActivityTypeRequest} [UpdateActivityTypeRequest]

         * @throws {RequiredError}
         */
        async updateActivityType(id: number, UpdateActivityTypeRequest?: UpdateActivityTypeRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<CreateUpdateDeleteActivityTypeResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateActivityType(id, UpdateActivityTypeRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivityTypesApi - factory interface
 * @export
 */
export const ActivityTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityTypesApiFp(configuration)
    return {
        /**
         * Adds a new activity type.
         * @summary Add new activity type
         * @param {ActivityTypesApiAddActivityTypeRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addActivityType(requestParameters: ActivityTypesApiAddActivityTypeRequest = {}, ): Promise<CreateUpdateDeleteActivityTypeResponse200> {
            return localVarFp.addActivityType(requestParameters.AddActivityTypeRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks an activity type as deleted.
         * @summary Delete an activity type
         * @param {ActivityTypesApiDeleteActivityTypeRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteActivityType(requestParameters: ActivityTypesApiDeleteActivityTypeRequest, ): Promise<CreateUpdateDeleteActivityTypeResponse200> {
            return localVarFp.deleteActivityType(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks multiple activity types as deleted.
         * @summary Delete multiple activity types in bulk
         * @param {ActivityTypesApiDeleteActivityTypesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteActivityTypes(requestParameters: ActivityTypesApiDeleteActivityTypesRequest, ): Promise<DeleteActivityTypesResponse200> {
            return localVarFp.deleteActivityTypes(requestParameters.ids, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all activity types.
         * @summary Get all activity types

         * @throws {RequiredError}
         */
        getActivityTypes(): Promise<GetActivityTypesResponse200> {
            return localVarFp.getActivityTypes().then((request) => request(axios, basePath));
        },
        /**
         * Updates an activity type.
         * @summary Update an activity type
         * @param {ActivityTypesApiUpdateActivityTypeRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateActivityType(requestParameters: ActivityTypesApiUpdateActivityTypeRequest, ): Promise<CreateUpdateDeleteActivityTypeResponse200> {
            return localVarFp.updateActivityType(requestParameters.id, requestParameters.UpdateActivityTypeRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addActivityType operation in ActivityTypesApi.
 * @export
 * @interface ActivityTypesApiAddActivityTypeRequest
 */
export interface ActivityTypesApiAddActivityTypeRequest {
    /**
     *
     * @type {AddActivityTypeRequest}
     * @memberof ActivityTypesApiAddActivityType
     */
    readonly AddActivityTypeRequest?: AddActivityTypeRequest
}

/**
 * Request parameters for deleteActivityType operation in ActivityTypesApi.
 * @export
 * @interface ActivityTypesApiDeleteActivityTypeRequest
 */
export interface ActivityTypesApiDeleteActivityTypeRequest {
    /**
     * The ID of the activity type
     * @type {number}
     * @memberof ActivityTypesApiDeleteActivityType
     */
    readonly id: number
}

/**
 * Request parameters for deleteActivityTypes operation in ActivityTypesApi.
 * @export
 * @interface ActivityTypesApiDeleteActivityTypesRequest
 */
export interface ActivityTypesApiDeleteActivityTypesRequest {
    /**
     * The comma-separated activity type IDs
     * @type {string}
     * @memberof ActivityTypesApiDeleteActivityTypes
     */
    readonly ids: string
}

/**
 * Request parameters for updateActivityType operation in ActivityTypesApi.
 * @export
 * @interface ActivityTypesApiUpdateActivityTypeRequest
 */
export interface ActivityTypesApiUpdateActivityTypeRequest {
    /**
     * The ID of the activity type
     * @type {number}
     * @memberof ActivityTypesApiUpdateActivityType
     */
    readonly id: number

    /**
     *
     * @type {UpdateActivityTypeRequest}
     * @memberof ActivityTypesApiUpdateActivityType
     */
    readonly UpdateActivityTypeRequest?: UpdateActivityTypeRequest
}

/**
 * ActivityTypesApi - object-oriented interface
 * @export
 * @class ActivityTypesApi
 * @extends {BaseAPI}
 */
export class ActivityTypesApi extends BaseAPI {
    /**
     * Adds a new activity type.
     * @summary Add new activity type
     * @param {ActivityTypesApiAddActivityTypeRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ActivityTypesApi
     */
    public addActivityType(requestParameters: ActivityTypesApiAddActivityTypeRequest = {}, ) {
        return ActivityTypesApiFp(this.configuration).addActivityType(requestParameters.AddActivityTypeRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks an activity type as deleted.
     * @summary Delete an activity type
     * @param {ActivityTypesApiDeleteActivityTypeRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ActivityTypesApi
     */
    public deleteActivityType(requestParameters: ActivityTypesApiDeleteActivityTypeRequest, ) {
        return ActivityTypesApiFp(this.configuration).deleteActivityType(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks multiple activity types as deleted.
     * @summary Delete multiple activity types in bulk
     * @param {ActivityTypesApiDeleteActivityTypesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ActivityTypesApi
     */
    public deleteActivityTypes(requestParameters: ActivityTypesApiDeleteActivityTypesRequest, ) {
        return ActivityTypesApiFp(this.configuration).deleteActivityTypes(requestParameters.ids, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all activity types.
     * @summary Get all activity types

     * @throws {RequiredError}
     * @memberof ActivityTypesApi
     */
    public getActivityTypes() {
        return ActivityTypesApiFp(this.configuration).getActivityTypes().then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an activity type.
     * @summary Update an activity type
     * @param {ActivityTypesApiUpdateActivityTypeRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ActivityTypesApi
     */
    public updateActivityType(requestParameters: ActivityTypesApiUpdateActivityTypeRequest, ) {
        return ActivityTypesApiFp(this.configuration).updateActivityType(requestParameters.id, requestParameters.UpdateActivityTypeRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the add-ons for a single company.
         * @summary Get all add-ons for a single company

         * @throws {RequiredError}
         */
        getCompanyAddons: async (): Promise<RequestArgs> => {
            const localVarPath = `/billing/subscriptions/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["users:read"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the add-ons for a single company.
         * @summary Get all add-ons for a single company

         * @throws {RequiredError}
         */
        async getCompanyAddons(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SubscriptionAddonsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanyAddons();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * Returns the add-ons for a single company.
         * @summary Get all add-ons for a single company

         * @throws {RequiredError}
         */
        getCompanyAddons(): Promise<SubscriptionAddonsResponse200> {
            return localVarFp.getCompanyAddons().then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * Returns the add-ons for a single company.
     * @summary Get all add-ons for a single company

     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getCompanyAddons() {
        return BillingApiFp(this.configuration).getCompanyAddons().then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CallLogsApi - axios parameter creator
 * @export
 */
export const CallLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new call log.
         * @summary Add a call log
         * @param {AddCallLogRequest} [AddCallLogRequest]

         * @throws {RequiredError}
         */
        addCallLog: async (AddCallLogRequest?: AddCallLogRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/callLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["phone-integration"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddCallLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an audio recording to the call log. That audio can be played by those who have access to the call log object.
         * @summary Attach an audio file to the call log
         * @param {string} id The ID received when you create the call log
         * @param {File} file Audio file supported by the HTML5 specification

         * @throws {RequiredError}
         */
        addCallLogAudioFile: async (id: string, file: File, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addCallLogAudioFile', 'id', id)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('addCallLogAudioFile', 'file', file)
            const localVarPath = `/callLogs/{id}/recordings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["phone-integration"], configuration)


            if (file !== undefined) {
                localVarFormParams.append('file', file as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a call log. If there is an audio recording attached to it, it will also be deleted. The related activity will not be removed by this request. If you want to remove the related activities, please use the endpoint which is specific for activities.
         * @summary Delete a call log
         * @param {string} id The ID received when you create the call log

         * @throws {RequiredError}
         */
        deleteCallLog: async (id: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCallLog', 'id', id)
            const localVarPath = `/callLogs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["phone-integration"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a specific call log.
         * @summary Get details of a call log
         * @param {string} id The ID received when you create the call log

         * @throws {RequiredError}
         */
        getCallLog: async (id: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCallLog', 'id', id)
            const localVarPath = `/callLogs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["phone-integration"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all call logs assigned to a particular user.
         * @summary Get all call logs assigned to a particular user
         * @param {number} [start] Pagination start
         * @param {number} [limit] For pagination, the limit of entries to be returned. The upper limit is 50.

         * @throws {RequiredError}
         */
        getUserCallLogs: async (start?: number, limit?: number, ): Promise<RequestArgs> => {
            const localVarPath = `/callLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["phone-integration"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallLogsApi - functional programming interface
 * @export
 */
export const CallLogsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = CallLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new call log.
         * @summary Add a call log
         * @param {AddCallLogRequest} [AddCallLogRequest]

         * @throws {RequiredError}
         */
        async addCallLog(AddCallLogRequest?: AddCallLogRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<CallLogResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCallLog(AddCallLogRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds an audio recording to the call log. That audio can be played by those who have access to the call log object.
         * @summary Attach an audio file to the call log
         * @param {string} id The ID received when you create the call log
         * @param {File} file Audio file supported by the HTML5 specification

         * @throws {RequiredError}
         */
        async addCallLogAudioFile(id: string, file: File, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<BaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCallLogAudioFile(id, file, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a call log. If there is an audio recording attached to it, it will also be deleted. The related activity will not be removed by this request. If you want to remove the related activities, please use the endpoint which is specific for activities.
         * @summary Delete a call log
         * @param {string} id The ID received when you create the call log

         * @throws {RequiredError}
         */
        async deleteCallLog(id: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<BaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCallLog(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns details of a specific call log.
         * @summary Get details of a call log
         * @param {string} id The ID received when you create the call log

         * @throws {RequiredError}
         */
        async getCallLog(id: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<CallLogResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCallLog(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all call logs assigned to a particular user.
         * @summary Get all call logs assigned to a particular user
         * @param {number} [start] Pagination start
         * @param {number} [limit] For pagination, the limit of entries to be returned. The upper limit is 50.

         * @throws {RequiredError}
         */
        async getUserCallLogs(start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<CallLogsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCallLogs(start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CallLogsApi - factory interface
 * @export
 */
export const CallLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallLogsApiFp(configuration)
    return {
        /**
         * Adds a new call log.
         * @summary Add a call log
         * @param {CallLogsApiAddCallLogRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addCallLog(requestParameters: CallLogsApiAddCallLogRequest = {}, ): Promise<CallLogResponse200> {
            return localVarFp.addCallLog(requestParameters.AddCallLogRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds an audio recording to the call log. That audio can be played by those who have access to the call log object.
         * @summary Attach an audio file to the call log
         * @param {CallLogsApiAddCallLogAudioFileRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addCallLogAudioFile(requestParameters: CallLogsApiAddCallLogAudioFileRequest, ): Promise<BaseResponse> {
            return localVarFp.addCallLogAudioFile(requestParameters.id, requestParameters.file, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a call log. If there is an audio recording attached to it, it will also be deleted. The related activity will not be removed by this request. If you want to remove the related activities, please use the endpoint which is specific for activities.
         * @summary Delete a call log
         * @param {CallLogsApiDeleteCallLogRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteCallLog(requestParameters: CallLogsApiDeleteCallLogRequest, ): Promise<BaseResponse> {
            return localVarFp.deleteCallLog(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of a specific call log.
         * @summary Get details of a call log
         * @param {CallLogsApiGetCallLogRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getCallLog(requestParameters: CallLogsApiGetCallLogRequest, ): Promise<CallLogResponse200> {
            return localVarFp.getCallLog(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all call logs assigned to a particular user.
         * @summary Get all call logs assigned to a particular user
         * @param {CallLogsApiGetUserCallLogsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getUserCallLogs(requestParameters: CallLogsApiGetUserCallLogsRequest = {}, ): Promise<CallLogsResponse> {
            return localVarFp.getUserCallLogs(requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addCallLog operation in CallLogsApi.
 * @export
 * @interface CallLogsApiAddCallLogRequest
 */
export interface CallLogsApiAddCallLogRequest {
    /**
     *
     * @type {AddCallLogRequest}
     * @memberof CallLogsApiAddCallLog
     */
    readonly AddCallLogRequest?: AddCallLogRequest
}

/**
 * Request parameters for addCallLogAudioFile operation in CallLogsApi.
 * @export
 * @interface CallLogsApiAddCallLogAudioFileRequest
 */
export interface CallLogsApiAddCallLogAudioFileRequest {
    /**
     * The ID received when you create the call log
     * @type {string}
     * @memberof CallLogsApiAddCallLogAudioFile
     */
    readonly id: string

    /**
     * Audio file supported by the HTML5 specification
     * @type {File}
     * @memberof CallLogsApiAddCallLogAudioFile
     */
    readonly file: File
}

/**
 * Request parameters for deleteCallLog operation in CallLogsApi.
 * @export
 * @interface CallLogsApiDeleteCallLogRequest
 */
export interface CallLogsApiDeleteCallLogRequest {
    /**
     * The ID received when you create the call log
     * @type {string}
     * @memberof CallLogsApiDeleteCallLog
     */
    readonly id: string
}

/**
 * Request parameters for getCallLog operation in CallLogsApi.
 * @export
 * @interface CallLogsApiGetCallLogRequest
 */
export interface CallLogsApiGetCallLogRequest {
    /**
     * The ID received when you create the call log
     * @type {string}
     * @memberof CallLogsApiGetCallLog
     */
    readonly id: string
}

/**
 * Request parameters for getUserCallLogs operation in CallLogsApi.
 * @export
 * @interface CallLogsApiGetUserCallLogsRequest
 */
export interface CallLogsApiGetUserCallLogsRequest {
    /**
     * Pagination start
     * @type {number}
     * @memberof CallLogsApiGetUserCallLogs
     */
    readonly start?: number

    /**
     * For pagination, the limit of entries to be returned. The upper limit is 50.
     * @type {number}
     * @memberof CallLogsApiGetUserCallLogs
     */
    readonly limit?: number
}

/**
 * CallLogsApi - object-oriented interface
 * @export
 * @class CallLogsApi
 * @extends {BaseAPI}
 */
export class CallLogsApi extends BaseAPI {
    /**
     * Adds a new call log.
     * @summary Add a call log
     * @param {CallLogsApiAddCallLogRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof CallLogsApi
     */
    public addCallLog(requestParameters: CallLogsApiAddCallLogRequest = {}, ) {
        return CallLogsApiFp(this.configuration).addCallLog(requestParameters.AddCallLogRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds an audio recording to the call log. That audio can be played by those who have access to the call log object.
     * @summary Attach an audio file to the call log
     * @param {CallLogsApiAddCallLogAudioFileRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof CallLogsApi
     */
    public addCallLogAudioFile(requestParameters: CallLogsApiAddCallLogAudioFileRequest, ) {
        return CallLogsApiFp(this.configuration).addCallLogAudioFile(requestParameters.id, requestParameters.file, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a call log. If there is an audio recording attached to it, it will also be deleted. The related activity will not be removed by this request. If you want to remove the related activities, please use the endpoint which is specific for activities.
     * @summary Delete a call log
     * @param {CallLogsApiDeleteCallLogRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof CallLogsApi
     */
    public deleteCallLog(requestParameters: CallLogsApiDeleteCallLogRequest, ) {
        return CallLogsApiFp(this.configuration).deleteCallLog(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details of a specific call log.
     * @summary Get details of a call log
     * @param {CallLogsApiGetCallLogRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof CallLogsApi
     */
    public getCallLog(requestParameters: CallLogsApiGetCallLogRequest, ) {
        return CallLogsApiFp(this.configuration).getCallLog(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all call logs assigned to a particular user.
     * @summary Get all call logs assigned to a particular user
     * @param {CallLogsApiGetUserCallLogsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof CallLogsApi
     */
    public getUserCallLogs(requestParameters: CallLogsApiGetUserCallLogsRequest = {}, ) {
        return CallLogsApiFp(this.configuration).getUserCallLogs(requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChannelsApi - axios parameter creator
 * @export
 */
export const ChannelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new messaging channel, only admins are able to register new channels. It will use the getConversations endpoint to fetch conversations, participants and messages afterward. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Add a channel
         * @param {AddChannelRequest} [AddChannelRequest]

         * @throws {RequiredError}
         */
        addChannel: async (AddChannelRequest?: AddChannelRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["messengers-integration"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddChannelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing messenger’s channel and all related entities (conversations and messages). To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Delete a channel
         * @param {string} id The ID of the channel provided by the integration

         * @throws {RequiredError}
         */
        deleteChannel: async (id: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteChannel', 'id', id)
            const localVarPath = `/channels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["messengers-integration"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Delete a conversation
         * @param {string} channel_id The ID of the channel provided by the integration
         * @param {string} conversation_id The ID of the conversation provided by the integration

         * @throws {RequiredError}
         */
        deleteConversation: async (channel_id: string, conversation_id: string, ): Promise<RequestArgs> => {
            // verify required parameter 'channel_id' is not null or undefined
            assertParamExists('deleteConversation', 'channel_id', channel_id)
            // verify required parameter 'conversation_id' is not null or undefined
            assertParamExists('deleteConversation', 'conversation_id', conversation_id)
            const localVarPath = `/channels/{channel-id}/conversations/{conversation-id}`
                .replace(`{${"channel-id"}}`, encodeURIComponent(String(channel_id)))
                .replace(`{${"conversation-id"}}`, encodeURIComponent(String(conversation_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["messengers-integration"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a message to a conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Receives an incoming message
         * @param {ReceiveMessageRequest} [ReceiveMessageRequest]

         * @throws {RequiredError}
         */
        receiveMessage: async (ReceiveMessageRequest?: ReceiveMessageRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/channels/messages/receive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["messengers-integration"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(ReceiveMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelsApi - functional programming interface
 * @export
 */
export const ChannelsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = ChannelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new messaging channel, only admins are able to register new channels. It will use the getConversations endpoint to fetch conversations, participants and messages afterward. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Add a channel
         * @param {AddChannelRequest} [AddChannelRequest]

         * @throws {RequiredError}
         */
        async addChannel(AddChannelRequest?: AddChannelRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddChannel200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addChannel(AddChannelRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an existing messenger’s channel and all related entities (conversations and messages). To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Delete a channel
         * @param {string} id The ID of the channel provided by the integration

         * @throws {RequiredError}
         */
        async deleteChannel(id: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteChannel200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChannel(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an existing conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Delete a conversation
         * @param {string} channel_id The ID of the channel provided by the integration
         * @param {string} conversation_id The ID of the conversation provided by the integration

         * @throws {RequiredError}
         */
        async deleteConversation(channel_id: string, conversation_id: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteChannel200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConversation(channel_id, conversation_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a message to a conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Receives an incoming message
         * @param {ReceiveMessageRequest} [ReceiveMessageRequest]

         * @throws {RequiredError}
         */
        async receiveMessage(ReceiveMessageRequest?: ReceiveMessageRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ReceiveMessage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiveMessage(ReceiveMessageRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChannelsApi - factory interface
 * @export
 */
export const ChannelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChannelsApiFp(configuration)
    return {
        /**
         * Adds a new messaging channel, only admins are able to register new channels. It will use the getConversations endpoint to fetch conversations, participants and messages afterward. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Add a channel
         * @param {ChannelsApiAddChannelRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addChannel(requestParameters: ChannelsApiAddChannelRequest = {}, ): Promise<AddChannel200Response> {
            return localVarFp.addChannel(requestParameters.AddChannelRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing messenger’s channel and all related entities (conversations and messages). To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Delete a channel
         * @param {ChannelsApiDeleteChannelRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteChannel(requestParameters: ChannelsApiDeleteChannelRequest, ): Promise<DeleteChannel200Response> {
            return localVarFp.deleteChannel(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Delete a conversation
         * @param {ChannelsApiDeleteConversationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteConversation(requestParameters: ChannelsApiDeleteConversationRequest, ): Promise<DeleteChannel200Response> {
            return localVarFp.deleteConversation(requestParameters.channel_id, requestParameters.conversation_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a message to a conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Receives an incoming message
         * @param {ChannelsApiReceiveMessageRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        receiveMessage(requestParameters: ChannelsApiReceiveMessageRequest = {}, ): Promise<ReceiveMessage200Response> {
            return localVarFp.receiveMessage(requestParameters.ReceiveMessageRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addChannel operation in ChannelsApi.
 * @export
 * @interface ChannelsApiAddChannelRequest
 */
export interface ChannelsApiAddChannelRequest {
    /**
     *
     * @type {AddChannelRequest}
     * @memberof ChannelsApiAddChannel
     */
    readonly AddChannelRequest?: AddChannelRequest
}

/**
 * Request parameters for deleteChannel operation in ChannelsApi.
 * @export
 * @interface ChannelsApiDeleteChannelRequest
 */
export interface ChannelsApiDeleteChannelRequest {
    /**
     * The ID of the channel provided by the integration
     * @type {string}
     * @memberof ChannelsApiDeleteChannel
     */
    readonly id: string
}

/**
 * Request parameters for deleteConversation operation in ChannelsApi.
 * @export
 * @interface ChannelsApiDeleteConversationRequest
 */
export interface ChannelsApiDeleteConversationRequest {
    /**
     * The ID of the channel provided by the integration
     * @type {string}
     * @memberof ChannelsApiDeleteConversation
     */
    readonly channel_id: string

    /**
     * The ID of the conversation provided by the integration
     * @type {string}
     * @memberof ChannelsApiDeleteConversation
     */
    readonly conversation_id: string
}

/**
 * Request parameters for receiveMessage operation in ChannelsApi.
 * @export
 * @interface ChannelsApiReceiveMessageRequest
 */
export interface ChannelsApiReceiveMessageRequest {
    /**
     *
     * @type {ReceiveMessageRequest}
     * @memberof ChannelsApiReceiveMessage
     */
    readonly ReceiveMessageRequest?: ReceiveMessageRequest
}

/**
 * ChannelsApi - object-oriented interface
 * @export
 * @class ChannelsApi
 * @extends {BaseAPI}
 */
export class ChannelsApi extends BaseAPI {
    /**
     * Adds a new messaging channel, only admins are able to register new channels. It will use the getConversations endpoint to fetch conversations, participants and messages afterward. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     * @summary Add a channel
     * @param {ChannelsApiAddChannelRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public addChannel(requestParameters: ChannelsApiAddChannelRequest = {}, ) {
        return ChannelsApiFp(this.configuration).addChannel(requestParameters.AddChannelRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing messenger’s channel and all related entities (conversations and messages). To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     * @summary Delete a channel
     * @param {ChannelsApiDeleteChannelRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public deleteChannel(requestParameters: ChannelsApiDeleteChannelRequest, ) {
        return ChannelsApiFp(this.configuration).deleteChannel(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     * @summary Delete a conversation
     * @param {ChannelsApiDeleteConversationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public deleteConversation(requestParameters: ChannelsApiDeleteConversationRequest, ) {
        return ChannelsApiFp(this.configuration).deleteConversation(requestParameters.channel_id, requestParameters.conversation_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a message to a conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     * @summary Receives an incoming message
     * @param {ChannelsApiReceiveMessageRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public receiveMessage(requestParameters: ChannelsApiReceiveMessageRequest = {}, ) {
        return ChannelsApiFp(this.configuration).receiveMessage(requestParameters.ReceiveMessageRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CurrenciesApi - axios parameter creator
 * @export
 */
export const CurrenciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all supported currencies in given account which should be used when saving monetary values with other objects. The `code` parameter of the returning objects is the currency code according to ISO 4217 for all non-custom currencies.
         * @summary Get all supported currencies
         * @param {string} [term] Optional search term that is searched for from currency\&#39;s name and/or code

         * @throws {RequiredError}
         */
        getCurrencies: async (term?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["base"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrenciesApi - functional programming interface
 * @export
 */
export const CurrenciesApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = CurrenciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all supported currencies in given account which should be used when saving monetary values with other objects. The `code` parameter of the returning objects is the currency code according to ISO 4217 for all non-custom currencies.
         * @summary Get all supported currencies
         * @param {string} [term] Optional search term that is searched for from currency\&#39;s name and/or code

         * @throws {RequiredError}
         */
        async getCurrencies(term?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCurrenciesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencies(term, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CurrenciesApi - factory interface
 * @export
 */
export const CurrenciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrenciesApiFp(configuration)
    return {
        /**
         * Returns all supported currencies in given account which should be used when saving monetary values with other objects. The `code` parameter of the returning objects is the currency code according to ISO 4217 for all non-custom currencies.
         * @summary Get all supported currencies
         * @param {CurrenciesApiGetCurrenciesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getCurrencies(requestParameters: CurrenciesApiGetCurrenciesRequest = {}, ): Promise<GetCurrenciesResponse200> {
            return localVarFp.getCurrencies(requestParameters.term, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCurrencies operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiGetCurrenciesRequest
 */
export interface CurrenciesApiGetCurrenciesRequest {
    /**
     * Optional search term that is searched for from currency\&#39;s name and/or code
     * @type {string}
     * @memberof CurrenciesApiGetCurrencies
     */
    readonly term?: string
}

/**
 * CurrenciesApi - object-oriented interface
 * @export
 * @class CurrenciesApi
 * @extends {BaseAPI}
 */
export class CurrenciesApi extends BaseAPI {
    /**
     * Returns all supported currencies in given account which should be used when saving monetary values with other objects. The `code` parameter of the returning objects is the currency code according to ISO 4217 for all non-custom currencies.
     * @summary Get all supported currencies
     * @param {CurrenciesApiGetCurrenciesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public getCurrencies(requestParameters: CurrenciesApiGetCurrenciesRequest = {}, ) {
        return CurrenciesApiFp(this.configuration).getCurrencies(requestParameters.term, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DealFieldsApi - axios parameter creator
 * @export
 */
export const DealFieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new deal field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new deal field
         * @param {CreateFieldRequest} [CreateFieldRequest]

         * @throws {RequiredError}
         */
        addDealField: async (CreateFieldRequest?: CreateFieldRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/dealFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(CreateFieldRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a deal field
         * @param {number} id The ID of the field

         * @throws {RequiredError}
         */
        deleteDealField: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDealField', 'id', id)
            const localVarPath = `/dealFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple deal fields as deleted.
         * @summary Delete multiple deal fields in bulk
         * @param {string} ids The comma-separated field IDs to delete

         * @throws {RequiredError}
         */
        deleteDealFields: async (ids: string, ): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteDealFields', 'ids', ids)
            const localVarPath = `/dealFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific deal field.
         * @summary Get one deal field
         * @param {number} id The ID of the field

         * @throws {RequiredError}
         */
        getDealField: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDealField', 'id', id)
            const localVarPath = `/dealFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all deal fields.
         * @summary Get all deal fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getDealFields: async (start?: number, limit?: number, ): Promise<RequestArgs> => {
            const localVarPath = `/dealFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "admin"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a deal field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
         * @summary Update a deal field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest} [UpdateFieldRequest]

         * @throws {RequiredError}
         */
        updateDealField: async (id: number, UpdateFieldRequest?: UpdateFieldRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDealField', 'id', id)
            const localVarPath = `/dealFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateFieldRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DealFieldsApi - functional programming interface
 * @export
 */
export const DealFieldsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = DealFieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new deal field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new deal field
         * @param {CreateFieldRequest} [CreateFieldRequest]

         * @throws {RequiredError}
         */
        async addDealField(CreateFieldRequest?: CreateFieldRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<FieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDealField(CreateFieldRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a deal field
         * @param {number} id The ID of the field

         * @throws {RequiredError}
         */
        async deleteDealField(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteFieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDealField(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks multiple deal fields as deleted.
         * @summary Delete multiple deal fields in bulk
         * @param {string} ids The comma-separated field IDs to delete

         * @throws {RequiredError}
         */
        async deleteDealFields(ids: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteFieldsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDealFields(ids, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about a specific deal field.
         * @summary Get one deal field
         * @param {number} id The ID of the field

         * @throws {RequiredError}
         */
        async getDealField(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<FieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealField(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all deal fields.
         * @summary Get all deal fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getDealFields(start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<FieldsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealFields(start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a deal field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
         * @summary Update a deal field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest} [UpdateFieldRequest]

         * @throws {RequiredError}
         */
        async updateDealField(id: number, UpdateFieldRequest?: UpdateFieldRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<FieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDealField(id, UpdateFieldRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DealFieldsApi - factory interface
 * @export
 */
export const DealFieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DealFieldsApiFp(configuration)
    return {
        /**
         * Adds a new deal field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new deal field
         * @param {DealFieldsApiAddDealFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addDealField(requestParameters: DealFieldsApiAddDealFieldRequest = {}, ): Promise<FieldResponse200> {
            return localVarFp.addDealField(requestParameters.CreateFieldRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a deal field
         * @param {DealFieldsApiDeleteDealFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteDealField(requestParameters: DealFieldsApiDeleteDealFieldRequest, ): Promise<DeleteFieldResponse200> {
            return localVarFp.deleteDealField(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks multiple deal fields as deleted.
         * @summary Delete multiple deal fields in bulk
         * @param {DealFieldsApiDeleteDealFieldsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteDealFields(requestParameters: DealFieldsApiDeleteDealFieldsRequest, ): Promise<DeleteFieldsResponse200> {
            return localVarFp.deleteDealFields(requestParameters.ids, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about a specific deal field.
         * @summary Get one deal field
         * @param {DealFieldsApiGetDealFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealField(requestParameters: DealFieldsApiGetDealFieldRequest, ): Promise<FieldResponse200> {
            return localVarFp.getDealField(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all deal fields.
         * @summary Get all deal fields
         * @param {DealFieldsApiGetDealFieldsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealFields(requestParameters: DealFieldsApiGetDealFieldsRequest = {}, ): Promise<FieldsResponse200> {
            return localVarFp.getDealFields(requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates a deal field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
         * @summary Update a deal field
         * @param {DealFieldsApiUpdateDealFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateDealField(requestParameters: DealFieldsApiUpdateDealFieldRequest, ): Promise<FieldResponse200> {
            return localVarFp.updateDealField(requestParameters.id, requestParameters.UpdateFieldRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addDealField operation in DealFieldsApi.
 * @export
 * @interface DealFieldsApiAddDealFieldRequest
 */
export interface DealFieldsApiAddDealFieldRequest {
    /**
     *
     * @type {CreateFieldRequest}
     * @memberof DealFieldsApiAddDealField
     */
    readonly CreateFieldRequest?: CreateFieldRequest
}

/**
 * Request parameters for deleteDealField operation in DealFieldsApi.
 * @export
 * @interface DealFieldsApiDeleteDealFieldRequest
 */
export interface DealFieldsApiDeleteDealFieldRequest {
    /**
     * The ID of the field
     * @type {number}
     * @memberof DealFieldsApiDeleteDealField
     */
    readonly id: number
}

/**
 * Request parameters for deleteDealFields operation in DealFieldsApi.
 * @export
 * @interface DealFieldsApiDeleteDealFieldsRequest
 */
export interface DealFieldsApiDeleteDealFieldsRequest {
    /**
     * The comma-separated field IDs to delete
     * @type {string}
     * @memberof DealFieldsApiDeleteDealFields
     */
    readonly ids: string
}

/**
 * Request parameters for getDealField operation in DealFieldsApi.
 * @export
 * @interface DealFieldsApiGetDealFieldRequest
 */
export interface DealFieldsApiGetDealFieldRequest {
    /**
     * The ID of the field
     * @type {number}
     * @memberof DealFieldsApiGetDealField
     */
    readonly id: number
}

/**
 * Request parameters for getDealFields operation in DealFieldsApi.
 * @export
 * @interface DealFieldsApiGetDealFieldsRequest
 */
export interface DealFieldsApiGetDealFieldsRequest {
    /**
     * Pagination start
     * @type {number}
     * @memberof DealFieldsApiGetDealFields
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof DealFieldsApiGetDealFields
     */
    readonly limit?: number
}

/**
 * Request parameters for updateDealField operation in DealFieldsApi.
 * @export
 * @interface DealFieldsApiUpdateDealFieldRequest
 */
export interface DealFieldsApiUpdateDealFieldRequest {
    /**
     * The ID of the field
     * @type {number}
     * @memberof DealFieldsApiUpdateDealField
     */
    readonly id: number

    /**
     *
     * @type {UpdateFieldRequest}
     * @memberof DealFieldsApiUpdateDealField
     */
    readonly UpdateFieldRequest?: UpdateFieldRequest
}

/**
 * DealFieldsApi - object-oriented interface
 * @export
 * @class DealFieldsApi
 * @extends {BaseAPI}
 */
export class DealFieldsApi extends BaseAPI {
    /**
     * Adds a new deal field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
     * @summary Add a new deal field
     * @param {DealFieldsApiAddDealFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealFieldsApi
     */
    public addDealField(requestParameters: DealFieldsApiAddDealFieldRequest = {}, ) {
        return DealFieldsApiFp(this.configuration).addDealField(requestParameters.CreateFieldRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
     * @summary Delete a deal field
     * @param {DealFieldsApiDeleteDealFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealFieldsApi
     */
    public deleteDealField(requestParameters: DealFieldsApiDeleteDealFieldRequest, ) {
        return DealFieldsApiFp(this.configuration).deleteDealField(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks multiple deal fields as deleted.
     * @summary Delete multiple deal fields in bulk
     * @param {DealFieldsApiDeleteDealFieldsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealFieldsApi
     */
    public deleteDealFields(requestParameters: DealFieldsApiDeleteDealFieldsRequest, ) {
        return DealFieldsApiFp(this.configuration).deleteDealFields(requestParameters.ids, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about a specific deal field.
     * @summary Get one deal field
     * @param {DealFieldsApiGetDealFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealFieldsApi
     */
    public getDealField(requestParameters: DealFieldsApiGetDealFieldRequest, ) {
        return DealFieldsApiFp(this.configuration).getDealField(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all deal fields.
     * @summary Get all deal fields
     * @param {DealFieldsApiGetDealFieldsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealFieldsApi
     */
    public getDealFields(requestParameters: DealFieldsApiGetDealFieldsRequest = {}, ) {
        return DealFieldsApiFp(this.configuration).getDealFields(requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a deal field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
     * @summary Update a deal field
     * @param {DealFieldsApiUpdateDealFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealFieldsApi
     */
    public updateDealField(requestParameters: DealFieldsApiUpdateDealFieldRequest, ) {
        return DealFieldsApiFp(this.configuration).updateDealField(requestParameters.id, requestParameters.UpdateFieldRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DealsApi - axios parameter creator
 * @export
 */
export const DealsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new deal. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the dealFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/creating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">adding a deal</a>.
         * @summary Add a deal
         * @param {AddDealRequest} [AddDealRequest]

         * @throws {RequiredError}
         */
        addDeal: async (AddDealRequest?: AddDealRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/deals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddDealRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a follower to a deal.
         * @summary Add a follower to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealFollowerRequest} [AddDealFollowerRequest]

         * @throws {RequiredError}
         */
        addDealFollower: async (id: number, AddDealFollowerRequest?: AddDealFollowerRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addDealFollower', 'id', id)
            const localVarPath = `/deals/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddDealFollowerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a participant to a deal.
         * @summary Add a participant to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealParticipantRequest} [AddDealParticipantRequest]

         * @throws {RequiredError}
         */
        addDealParticipant: async (id: number, AddDealParticipantRequest?: AddDealParticipantRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addDealParticipant', 'id', id)
            const localVarPath = `/deals/{id}/participants`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddDealParticipantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a product to a deal, creating a new item called a deal-product.
         * @summary Add a product to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealProductRequest} [AddDealProductRequest]

         * @throws {RequiredError}
         */
        addDealProduct: async (id: number, AddDealProductRequest?: AddDealProductRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addDealProduct', 'id', id)
            const localVarPath = `/deals/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "products:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddDealProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
         * @summary Delete a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        deleteDeal: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDeal', 'id', id)
            const localVarPath = `/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a follower from a deal.
         * @summary Delete a follower from a deal
         * @param {number} id The ID of the deal
         * @param {number} follower_id The ID of the follower

         * @throws {RequiredError}
         */
        deleteDealFollower: async (id: number, follower_id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDealFollower', 'id', id)
            // verify required parameter 'follower_id' is not null or undefined
            assertParamExists('deleteDealFollower', 'follower_id', follower_id)
            const localVarPath = `/deals/{id}/followers/{follower_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"follower_id"}}`, encodeURIComponent(String(follower_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a participant from a deal.
         * @summary Delete a participant from a deal
         * @param {number} id The ID of the deal
         * @param {number} deal_participant_id The ID of the participant of the deal

         * @throws {RequiredError}
         */
        deleteDealParticipant: async (id: number, deal_participant_id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDealParticipant', 'id', id)
            // verify required parameter 'deal_participant_id' is not null or undefined
            assertParamExists('deleteDealParticipant', 'deal_participant_id', deal_participant_id)
            const localVarPath = `/deals/{id}/participants/{deal_participant_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"deal_participant_id"}}`, encodeURIComponent(String(deal_participant_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a product attachment from a deal, using the `product_attachment_id`.
         * @summary Delete an attached product from a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The product attachment ID

         * @throws {RequiredError}
         */
        deleteDealProduct: async (id: number, product_attachment_id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDealProduct', 'id', id)
            // verify required parameter 'product_attachment_id' is not null or undefined
            assertParamExists('deleteDealProduct', 'product_attachment_id', product_attachment_id)
            const localVarPath = `/deals/{id}/products/{product_attachment_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"product_attachment_id"}}`, encodeURIComponent(String(product_attachment_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "products:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple deals as deleted. After 30 days, the deals will be permanently deleted.
         * @summary Delete multiple deals in bulk
         * @param {string} ids The comma-separated IDs that will be deleted

         * @throws {RequiredError}
         */
        deleteDeals: async (ids: string, ): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteDeals', 'ids', ids)
            const localVarPath = `/deals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Duplicates a deal.
         * @summary Duplicate deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        duplicateDeal: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('duplicateDeal', 'id', id)
            const localVarPath = `/deals/{id}/duplicate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific deal. Note that this also returns some additional fields which are not present when asking for all deals – such as deal age and stay in pipeline stages. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of dealFields. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-details-of-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">getting details of a deal</a>.
         * @summary Get details of a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        getDeal: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeal', 'id', id)
            const localVarPath = `/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists activities associated with a deal.
         * @summary List activities associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {0 | 1} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result

         * @throws {RequiredError}
         */
        getDealActivities: async (id: number, start?: number, limit?: number, done?: 0 | 1, exclude?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDealActivities', 'id', id)
            const localVarPath = `/deals/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:read", "activities:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (done !== undefined) {
                localVarQueryParameter['done'] = done;
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists files associated with a deal.
         * @summary List files attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.

         * @throws {RequiredError}
         */
        getDealFiles: async (id: number, start?: number, limit?: number, sort?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDealFiles', 'id', id)
            const localVarPath = `/deals/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the followers of a deal.
         * @summary List followers of a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        getDealFollowers: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDealFollowers', 'id', id)
            const localVarPath = `/deals/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists mail messages associated with a deal.
         * @summary List mail messages associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getDealMailMessages: async (id: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDealMailMessages', 'id', id)
            const localVarPath = `/deals/{id}/mailMessages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["mail:read", "mail:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the participants associated with a deal.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List participants of a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getDealParticipants: async (id: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDealParticipants', 'id', id)
            const localVarPath = `/deals/{id}/participants`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all persons associated with a deal, regardless of whether the person is the primary contact of the deal, or added as a participant.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List all persons associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getDealPersons: async (id: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDealPersons', 'id', id)
            const localVarPath = `/deals/{id}/persons`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists products attached to a deal.
         * @summary List products attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {0 | 1} [include_product_data] Whether to fetch product data along with each attached product (1) or not (0, default)

         * @throws {RequiredError}
         */
        getDealProducts: async (id: number, start?: number, limit?: number, include_product_data?: 0 | 1, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDealProducts', 'id', id)
            const localVarPath = `/deals/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:read", "products:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (include_product_data !== undefined) {
                localVarQueryParameter['include_product_data'] = include_product_data;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists updates about a deal.
         * @summary List updates about a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)

         * @throws {RequiredError}
         */
        getDealUpdates: async (id: number, start?: number, limit?: number, all_changes?: string, items?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDealUpdates', 'id', id)
            const localVarPath = `/deals/{id}/flow`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["recents:read"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (all_changes !== undefined) {
                localVarQueryParameter['all_changes'] = all_changes;
            }

            if (items !== undefined) {
                localVarQueryParameter['items'] = items;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the users permitted to access a deal.
         * @summary List permitted users
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        getDealUsers: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDealUsers', 'id', id)
            const localVarPath = `/deals/{id}/permittedUsers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all deals. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-all-deals\" target=\"_blank\" rel=\"noopener noreferrer\">getting all deals</a>.
         * @summary Get all deals
         * @param {number} [user_id] If supplied, only deals matching the given user will be returned. However, &#x60;filter_id&#x60; and &#x60;owned_by_you&#x60; takes precedence over &#x60;user_id&#x60; when supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
         * @param {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {0 | 1} [owned_by_you] When supplied, only deals owned by you are returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owned_by_you&#x60; when both are supplied.

         * @throws {RequiredError}
         */
        getDeals: async (user_id?: number, filter_id?: number, stage_id?: number, status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted', start?: number, limit?: number, sort?: string, owned_by_you?: 0 | 1, ): Promise<RequestArgs> => {
            const localVarPath = `/deals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (stage_id !== undefined) {
                localVarQueryParameter['stage_id'] = stage_id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (owned_by_you !== undefined) {
                localVarQueryParameter['owned_by_you'] = owned_by_you;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all deals. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all deals (BETA)
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [since] The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {string} [until] The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {number} [user_id] If supplied, only deals matching the given user will be returned
         * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
         * @param {'open' | 'won' | 'lost' | 'deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.

         * @throws {RequiredError}
         */
        getDealsCollection: async (cursor?: string, limit?: number, since?: string, until?: string, user_id?: number, stage_id?: number, status?: 'open' | 'won' | 'lost' | 'deleted', ): Promise<RequestArgs> => {
            const localVarPath = `/deals/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (stage_id !== undefined) {
                localVarQueryParameter['stage_id'] = stage_id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a summary of all the deals.
         * @summary Get deals summary
         * @param {'open' | 'won' | 'lost'} [status] Only fetch deals with a specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost
         * @param {number} [filter_id] &lt;code&gt;user_id&lt;/code&gt; will not be considered. Only deals matching the given filter will be returned.
         * @param {number} [user_id] Only deals matching the given user will be returned. &#x60;user_id&#x60; will not be considered if you use &#x60;filter_id&#x60;.
         * @param {number} [stage_id] Only deals within the given stage will be returned

         * @throws {RequiredError}
         */
        getDealsSummary: async (status?: 'open' | 'won' | 'lost', filter_id?: number, user_id?: number, stage_id?: number, ): Promise<RequestArgs> => {
            const localVarPath = `/deals/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (stage_id !== undefined) {
                localVarQueryParameter['stage_id'] = stage_id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns open and won deals, grouped by a defined interval of time set in a date-type dealField (`field_key`) — e.g. when month is the chosen interval, and 3 months are asked starting from January 1st, 2012, deals are returned grouped into 3 groups — January, February and March — based on the value of the given `field_key`.
         * @summary Get deals timeline
         * @param {string} start_date The date when the first interval starts. Format: YYYY-MM-DD
         * @param {'day' | 'week' | 'month' | 'quarter'} interval The type of the interval&lt;table&gt;&lt;tr&gt;&lt;th&gt;Value&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;day&#x60;&lt;/td&gt;&lt;td&gt;Day&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;week&#x60;&lt;/td&gt;&lt;td&gt;A full week (7 days) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;month&#x60;&lt;/td&gt;&lt;td&gt;A full month (depending on the number of days in given month) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;quarter&#x60;&lt;/td&gt;&lt;td&gt;A full quarter (3 months) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
         * @param {number} amount The number of given intervals, starting from &#x60;start_date&#x60;, to fetch. E.g. 3 (months).
         * @param {string} field_key The date field key which deals will be retrieved from
         * @param {number} [user_id] If supplied, only deals matching the given user will be returned
         * @param {number} [pipeline_id] If supplied, only deals matching the given pipeline will be returned
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {0 | 1} [exclude_deals] Whether to exclude deals list (1) or not (0). Note that when deals are excluded, the timeline summary (counts and values) is still returned.
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;totals_converted&#x60; is returned per each interval which contains the currency-converted total amounts in the given currency. You may also set this parameter to &#x60;default_currency&#x60; in which case the user\&#39;s default currency is used.

         * @throws {RequiredError}
         */
        getDealsTimeline: async (start_date: string, interval: 'day' | 'week' | 'month' | 'quarter', amount: number, field_key: string, user_id?: number, pipeline_id?: number, filter_id?: number, exclude_deals?: 0 | 1, totals_convert_currency?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'start_date' is not null or undefined
            assertParamExists('getDealsTimeline', 'start_date', start_date)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getDealsTimeline', 'interval', interval)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('getDealsTimeline', 'amount', amount)
            // verify required parameter 'field_key' is not null or undefined
            assertParamExists('getDealsTimeline', 'field_key', field_key)
            const localVarPath = `/deals/timeline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (start_date !== undefined) {
                localVarQueryParameter['start_date'] = (start_date as any instanceof Date) ?
                    (start_date as any).toISOString().substr(0,10) :
                    start_date;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (field_key !== undefined) {
                localVarQueryParameter['field_key'] = field_key;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (pipeline_id !== undefined) {
                localVarQueryParameter['pipeline_id'] = pipeline_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (exclude_deals !== undefined) {
                localVarQueryParameter['exclude_deals'] = exclude_deals;
            }

            if (totals_convert_currency !== undefined) {
                localVarQueryParameter['totals_convert_currency'] = totals_convert_currency;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merges a deal with another deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-deals\" target=\"_blank\" rel=\"noopener noreferrer\">merging two deals</a>.
         * @summary Merge two deals
         * @param {number} id The ID of the deal
         * @param {MergeDealsRequest} [MergeDealsRequest]

         * @throws {RequiredError}
         */
        mergeDeals: async (id: number, MergeDealsRequest?: MergeDealsRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeDeals', 'id', id)
            const localVarPath = `/deals/{id}/merge`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(MergeDealsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
         * @summary Search deals
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'notes' | 'title'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
         * @param {number} [organization_id] Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
         * @param {'open' | 'won' | 'lost'} [status] Will filter deals by the provided specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost. The upper limit of found deals associated with the status is 2000.
         * @param {'deal.cc_email'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        searchDeals: async (term: string, fields?: 'custom_fields' | 'notes' | 'title', exact_match?: boolean, person_id?: number, organization_id?: number, status?: 'open' | 'won' | 'lost', include_fields?: 'deal.cc_email', start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchDeals', 'term', term)
            const localVarPath = `/deals/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }

            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">updating a deal</a>.
         * @summary Update a deal
         * @param {number} id The ID of the deal
         * @param {UpdateDealRequest} [UpdateDealRequest]

         * @throws {RequiredError}
         */
        updateDeal: async (id: number, UpdateDealRequest?: UpdateDealRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDeal', 'id', id)
            const localVarPath = `/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateDealRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the details of the product that has been attached to a deal.
         * @summary Update the product attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The ID of the deal-product (the ID of the product attached to the deal)
         * @param {UpdateDealProductRequest} [UpdateDealProductRequest]

         * @throws {RequiredError}
         */
        updateDealProduct: async (id: number, product_attachment_id: number, UpdateDealProductRequest?: UpdateDealProductRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDealProduct', 'id', id)
            // verify required parameter 'product_attachment_id' is not null or undefined
            assertParamExists('updateDealProduct', 'product_attachment_id', product_attachment_id)
            const localVarPath = `/deals/{id}/products/{product_attachment_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"product_attachment_id"}}`, encodeURIComponent(String(product_attachment_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateDealProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DealsApi - functional programming interface
 * @export
 */
export const DealsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = DealsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new deal. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the dealFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/creating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">adding a deal</a>.
         * @summary Add a deal
         * @param {AddDealRequest} [AddDealRequest]

         * @throws {RequiredError}
         */
        async addDeal(AddDealRequest?: AddDealRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DealResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDeal(AddDealRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a follower to a deal.
         * @summary Add a follower to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealFollowerRequest} [AddDealFollowerRequest]

         * @throws {RequiredError}
         */
        async addDealFollower(id: number, AddDealFollowerRequest?: AddDealFollowerRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddDealFollowerResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDealFollower(id, AddDealFollowerRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a participant to a deal.
         * @summary Add a participant to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealParticipantRequest} [AddDealParticipantRequest]

         * @throws {RequiredError}
         */
        async addDealParticipant(id: number, AddDealParticipantRequest?: AddDealParticipantRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddDealParticipantResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDealParticipant(id, AddDealParticipantRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a product to a deal, creating a new item called a deal-product.
         * @summary Add a product to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealProductRequest} [AddDealProductRequest]

         * @throws {RequiredError}
         */
        async addDealProduct(id: number, AddDealProductRequest?: AddDealProductRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAddProductAttachementResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDealProduct(id, AddDealProductRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
         * @summary Delete a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        async deleteDeal(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteDealResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeal(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a follower from a deal.
         * @summary Delete a follower from a deal
         * @param {number} id The ID of the deal
         * @param {number} follower_id The ID of the follower

         * @throws {RequiredError}
         */
        async deleteDealFollower(id: number, follower_id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteDealFollowerResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDealFollower(id, follower_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a participant from a deal.
         * @summary Delete a participant from a deal
         * @param {number} id The ID of the deal
         * @param {number} deal_participant_id The ID of the participant of the deal

         * @throws {RequiredError}
         */
        async deleteDealParticipant(id: number, deal_participant_id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteDealParticipantResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDealParticipant(id, deal_participant_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a product attachment from a deal, using the `product_attachment_id`.
         * @summary Delete an attached product from a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The product attachment ID

         * @throws {RequiredError}
         */
        async deleteDealProduct(id: number, product_attachment_id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteDealProductResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDealProduct(id, product_attachment_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks multiple deals as deleted. After 30 days, the deals will be permanently deleted.
         * @summary Delete multiple deals in bulk
         * @param {string} ids The comma-separated IDs that will be deleted

         * @throws {RequiredError}
         */
        async deleteDeals(ids: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteDealsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeals(ids, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Duplicates a deal.
         * @summary Duplicate deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        async duplicateDeal(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DuplicateDealResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.duplicateDeal(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a specific deal. Note that this also returns some additional fields which are not present when asking for all deals – such as deal age and stay in pipeline stages. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of dealFields. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-details-of-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">getting details of a deal</a>.
         * @summary Get details of a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        async getDeal(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetDealResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeal(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists activities associated with a deal.
         * @summary List activities associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {0 | 1} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result

         * @throws {RequiredError}
         */
        async getDealActivities(id: number, start?: number, limit?: number, done?: 0 | 1, exclude?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetDealActivitiesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealActivities(id, start, limit, done, exclude, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists files associated with a deal.
         * @summary List files attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.

         * @throws {RequiredError}
         */
        async getDealFiles(id: number, start?: number, limit?: number, sort?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedFilesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealFiles(id, start, limit, sort, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the followers of a deal.
         * @summary List followers of a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        async getDealFollowers(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedFollowersResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealFollowers(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists mail messages associated with a deal.
         * @summary List mail messages associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getDealMailMessages(id: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedMailMessagesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealMailMessages(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the participants associated with a deal.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List participants of a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getDealParticipants(id: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetDealParticipantsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealParticipants(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all persons associated with a deal, regardless of whether the person is the primary contact of the deal, or added as a participant.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List all persons associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getDealPersons(id: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListPersonsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealPersons(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists products attached to a deal.
         * @summary List products attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {0 | 1} [include_product_data] Whether to fetch product data along with each attached product (1) or not (0, default)

         * @throws {RequiredError}
         */
        async getDealProducts(id: number, start?: number, limit?: number, include_product_data?: 0 | 1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListProductsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealProducts(id, start, limit, include_product_data, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists updates about a deal.
         * @summary List updates about a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)

         * @throws {RequiredError}
         */
        async getDealUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetDealUpdatesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealUpdates(id, start, limit, all_changes, items, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the users permitted to access a deal.
         * @summary List permitted users
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        async getDealUsers(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListPermittedUsersResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealUsers(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all deals. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-all-deals\" target=\"_blank\" rel=\"noopener noreferrer\">getting all deals</a>.
         * @summary Get all deals
         * @param {number} [user_id] If supplied, only deals matching the given user will be returned. However, &#x60;filter_id&#x60; and &#x60;owned_by_you&#x60; takes precedence over &#x60;user_id&#x60; when supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
         * @param {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {0 | 1} [owned_by_you] When supplied, only deals owned by you are returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owned_by_you&#x60; when both are supplied.

         * @throws {RequiredError}
         */
        async getDeals(user_id?: number, filter_id?: number, stage_id?: number, status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted', start?: number, limit?: number, sort?: string, owned_by_you?: 0 | 1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetDealsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeals(user_id, filter_id, stage_id, status, start, limit, sort, owned_by_you, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all deals. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all deals (BETA)
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [since] The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {string} [until] The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {number} [user_id] If supplied, only deals matching the given user will be returned
         * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
         * @param {'open' | 'won' | 'lost' | 'deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.

         * @throws {RequiredError}
         */
        async getDealsCollection(cursor?: string, limit?: number, since?: string, until?: string, user_id?: number, stage_id?: number, status?: 'open' | 'won' | 'lost' | 'deleted', ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetDealsCollectionResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealsCollection(cursor, limit, since, until, user_id, stage_id, status, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a summary of all the deals.
         * @summary Get deals summary
         * @param {'open' | 'won' | 'lost'} [status] Only fetch deals with a specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost
         * @param {number} [filter_id] &lt;code&gt;user_id&lt;/code&gt; will not be considered. Only deals matching the given filter will be returned.
         * @param {number} [user_id] Only deals matching the given user will be returned. &#x60;user_id&#x60; will not be considered if you use &#x60;filter_id&#x60;.
         * @param {number} [stage_id] Only deals within the given stage will be returned

         * @throws {RequiredError}
         */
        async getDealsSummary(status?: 'open' | 'won' | 'lost', filter_id?: number, user_id?: number, stage_id?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetDealsSummaryResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealsSummary(status, filter_id, user_id, stage_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns open and won deals, grouped by a defined interval of time set in a date-type dealField (`field_key`) — e.g. when month is the chosen interval, and 3 months are asked starting from January 1st, 2012, deals are returned grouped into 3 groups — January, February and March — based on the value of the given `field_key`.
         * @summary Get deals timeline
         * @param {string} start_date The date when the first interval starts. Format: YYYY-MM-DD
         * @param {'day' | 'week' | 'month' | 'quarter'} interval The type of the interval&lt;table&gt;&lt;tr&gt;&lt;th&gt;Value&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;day&#x60;&lt;/td&gt;&lt;td&gt;Day&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;week&#x60;&lt;/td&gt;&lt;td&gt;A full week (7 days) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;month&#x60;&lt;/td&gt;&lt;td&gt;A full month (depending on the number of days in given month) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;quarter&#x60;&lt;/td&gt;&lt;td&gt;A full quarter (3 months) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
         * @param {number} amount The number of given intervals, starting from &#x60;start_date&#x60;, to fetch. E.g. 3 (months).
         * @param {string} field_key The date field key which deals will be retrieved from
         * @param {number} [user_id] If supplied, only deals matching the given user will be returned
         * @param {number} [pipeline_id] If supplied, only deals matching the given pipeline will be returned
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {0 | 1} [exclude_deals] Whether to exclude deals list (1) or not (0). Note that when deals are excluded, the timeline summary (counts and values) is still returned.
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;totals_converted&#x60; is returned per each interval which contains the currency-converted total amounts in the given currency. You may also set this parameter to &#x60;default_currency&#x60; in which case the user\&#39;s default currency is used.

         * @throws {RequiredError}
         */
        async getDealsTimeline(start_date: string, interval: 'day' | 'week' | 'month' | 'quarter', amount: number, field_key: string, user_id?: number, pipeline_id?: number, filter_id?: number, exclude_deals?: 0 | 1, totals_convert_currency?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetDealsTimelineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDealsTimeline(start_date, interval, amount, field_key, user_id, pipeline_id, filter_id, exclude_deals, totals_convert_currency, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Merges a deal with another deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-deals\" target=\"_blank\" rel=\"noopener noreferrer\">merging two deals</a>.
         * @summary Merge two deals
         * @param {number} id The ID of the deal
         * @param {MergeDealsRequest} [MergeDealsRequest]

         * @throws {RequiredError}
         */
        async mergeDeals(id: number, MergeDealsRequest?: MergeDealsRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<MergeDealsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeDeals(id, MergeDealsRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
         * @summary Search deals
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'notes' | 'title'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
         * @param {number} [organization_id] Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
         * @param {'open' | 'won' | 'lost'} [status] Will filter deals by the provided specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost. The upper limit of found deals associated with the status is 2000.
         * @param {'deal.cc_email'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async searchDeals(term: string, fields?: 'custom_fields' | 'notes' | 'title', exact_match?: boolean, person_id?: number, organization_id?: number, status?: 'open' | 'won' | 'lost', include_fields?: 'deal.cc_email', start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SearchDealsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDeals(term, fields, exact_match, person_id, organization_id, status, include_fields, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of a deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">updating a deal</a>.
         * @summary Update a deal
         * @param {number} id The ID of the deal
         * @param {UpdateDealRequest} [UpdateDealRequest]

         * @throws {RequiredError}
         */
        async updateDeal(id: number, UpdateDealRequest?: UpdateDealRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DealResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeal(id, UpdateDealRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the details of the product that has been attached to a deal.
         * @summary Update the product attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The ID of the deal-product (the ID of the product attached to the deal)
         * @param {UpdateDealProductRequest} [UpdateDealProductRequest]

         * @throws {RequiredError}
         */
        async updateDealProduct(id: number, product_attachment_id: number, UpdateDealProductRequest?: UpdateDealProductRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProductAttachementResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDealProduct(id, product_attachment_id, UpdateDealProductRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DealsApi - factory interface
 * @export
 */
export const DealsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DealsApiFp(configuration)
    return {
        /**
         * Adds a new deal. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the dealFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/creating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">adding a deal</a>.
         * @summary Add a deal
         * @param {DealsApiAddDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addDeal(requestParameters: DealsApiAddDealRequest = {}, ): Promise<DealResponse200> {
            return localVarFp.addDeal(requestParameters.AddDealRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a follower to a deal.
         * @summary Add a follower to a deal
         * @param {DealsApiAddDealFollowerRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addDealFollower(requestParameters: DealsApiAddDealFollowerRequest, ): Promise<AddDealFollowerResponse200> {
            return localVarFp.addDealFollower(requestParameters.id, requestParameters.AddDealFollowerRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a participant to a deal.
         * @summary Add a participant to a deal
         * @param {DealsApiAddDealParticipantRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addDealParticipant(requestParameters: DealsApiAddDealParticipantRequest, ): Promise<AddDealParticipantResponse200> {
            return localVarFp.addDealParticipant(requestParameters.id, requestParameters.AddDealParticipantRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a product to a deal, creating a new item called a deal-product.
         * @summary Add a product to a deal
         * @param {DealsApiAddDealProductRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addDealProduct(requestParameters: DealsApiAddDealProductRequest, ): Promise<GetAddProductAttachementResponse200> {
            return localVarFp.addDealProduct(requestParameters.id, requestParameters.AddDealProductRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
         * @summary Delete a deal
         * @param {DealsApiDeleteDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteDeal(requestParameters: DealsApiDeleteDealRequest, ): Promise<DeleteDealResponse200> {
            return localVarFp.deleteDeal(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a follower from a deal.
         * @summary Delete a follower from a deal
         * @param {DealsApiDeleteDealFollowerRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteDealFollower(requestParameters: DealsApiDeleteDealFollowerRequest, ): Promise<DeleteDealFollowerResponse200> {
            return localVarFp.deleteDealFollower(requestParameters.id, requestParameters.follower_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a participant from a deal.
         * @summary Delete a participant from a deal
         * @param {DealsApiDeleteDealParticipantRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteDealParticipant(requestParameters: DealsApiDeleteDealParticipantRequest, ): Promise<DeleteDealParticipantResponse200> {
            return localVarFp.deleteDealParticipant(requestParameters.id, requestParameters.deal_participant_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a product attachment from a deal, using the `product_attachment_id`.
         * @summary Delete an attached product from a deal
         * @param {DealsApiDeleteDealProductRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteDealProduct(requestParameters: DealsApiDeleteDealProductRequest, ): Promise<DeleteDealProductResponse200> {
            return localVarFp.deleteDealProduct(requestParameters.id, requestParameters.product_attachment_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks multiple deals as deleted. After 30 days, the deals will be permanently deleted.
         * @summary Delete multiple deals in bulk
         * @param {DealsApiDeleteDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteDeals(requestParameters: DealsApiDeleteDealsRequest, ): Promise<DeleteDealsResponse200> {
            return localVarFp.deleteDeals(requestParameters.ids, ).then((request) => request(axios, basePath));
        },
        /**
         * Duplicates a deal.
         * @summary Duplicate deal
         * @param {DealsApiDuplicateDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        duplicateDeal(requestParameters: DealsApiDuplicateDealRequest, ): Promise<DuplicateDealResponse200> {
            return localVarFp.duplicateDeal(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific deal. Note that this also returns some additional fields which are not present when asking for all deals – such as deal age and stay in pipeline stages. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of dealFields. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-details-of-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">getting details of a deal</a>.
         * @summary Get details of a deal
         * @param {DealsApiGetDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDeal(requestParameters: DealsApiGetDealRequest, ): Promise<GetDealResponse200> {
            return localVarFp.getDeal(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists activities associated with a deal.
         * @summary List activities associated with a deal
         * @param {DealsApiGetDealActivitiesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealActivities(requestParameters: DealsApiGetDealActivitiesRequest, ): Promise<GetDealActivitiesResponse200> {
            return localVarFp.getDealActivities(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.done, requestParameters.exclude, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists files associated with a deal.
         * @summary List files attached to a deal
         * @param {DealsApiGetDealFilesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealFiles(requestParameters: DealsApiGetDealFilesRequest, ): Promise<GetAssociatedFilesResponse200> {
            return localVarFp.getDealFiles(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists the followers of a deal.
         * @summary List followers of a deal
         * @param {DealsApiGetDealFollowersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealFollowers(requestParameters: DealsApiGetDealFollowersRequest, ): Promise<GetAssociatedFollowersResponse200> {
            return localVarFp.getDealFollowers(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists mail messages associated with a deal.
         * @summary List mail messages associated with a deal
         * @param {DealsApiGetDealMailMessagesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealMailMessages(requestParameters: DealsApiGetDealMailMessagesRequest, ): Promise<GetAssociatedMailMessagesResponse200> {
            return localVarFp.getDealMailMessages(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists the participants associated with a deal.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List participants of a deal
         * @param {DealsApiGetDealParticipantsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealParticipants(requestParameters: DealsApiGetDealParticipantsRequest, ): Promise<GetDealParticipantsResponse200> {
            return localVarFp.getDealParticipants(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists all persons associated with a deal, regardless of whether the person is the primary contact of the deal, or added as a participant.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List all persons associated with a deal
         * @param {DealsApiGetDealPersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealPersons(requestParameters: DealsApiGetDealPersonsRequest, ): Promise<ListPersonsResponse200> {
            return localVarFp.getDealPersons(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists products attached to a deal.
         * @summary List products attached to a deal
         * @param {DealsApiGetDealProductsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealProducts(requestParameters: DealsApiGetDealProductsRequest, ): Promise<ListProductsResponse200> {
            return localVarFp.getDealProducts(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.include_product_data, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists updates about a deal.
         * @summary List updates about a deal
         * @param {DealsApiGetDealUpdatesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealUpdates(requestParameters: DealsApiGetDealUpdatesRequest, ): Promise<GetDealUpdatesResponse200> {
            return localVarFp.getDealUpdates(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.all_changes, requestParameters.items, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists the users permitted to access a deal.
         * @summary List permitted users
         * @param {DealsApiGetDealUsersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealUsers(requestParameters: DealsApiGetDealUsersRequest, ): Promise<ListPermittedUsersResponse200> {
            return localVarFp.getDealUsers(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all deals. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-all-deals\" target=\"_blank\" rel=\"noopener noreferrer\">getting all deals</a>.
         * @summary Get all deals
         * @param {DealsApiGetDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDeals(requestParameters: DealsApiGetDealsRequest = {}, ): Promise<GetDealsResponse200> {
            return localVarFp.getDeals(requestParameters.user_id, requestParameters.filter_id, requestParameters.stage_id, requestParameters.status, requestParameters.start, requestParameters.limit, requestParameters.sort, requestParameters.owned_by_you, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all deals. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all deals (BETA)
         * @param {DealsApiGetDealsCollectionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealsCollection(requestParameters: DealsApiGetDealsCollectionRequest = {}, ): Promise<GetDealsCollectionResponse200> {
            return localVarFp.getDealsCollection(requestParameters.cursor, requestParameters.limit, requestParameters.since, requestParameters.until, requestParameters.user_id, requestParameters.stage_id, requestParameters.status, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns a summary of all the deals.
         * @summary Get deals summary
         * @param {DealsApiGetDealsSummaryRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealsSummary(requestParameters: DealsApiGetDealsSummaryRequest = {}, ): Promise<GetDealsSummaryResponse200> {
            return localVarFp.getDealsSummary(requestParameters.status, requestParameters.filter_id, requestParameters.user_id, requestParameters.stage_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns open and won deals, grouped by a defined interval of time set in a date-type dealField (`field_key`) — e.g. when month is the chosen interval, and 3 months are asked starting from January 1st, 2012, deals are returned grouped into 3 groups — January, February and March — based on the value of the given `field_key`.
         * @summary Get deals timeline
         * @param {DealsApiGetDealsTimelineRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealsTimeline(requestParameters: DealsApiGetDealsTimelineRequest, ): Promise<GetDealsTimelineResponse200> {
            return localVarFp.getDealsTimeline(requestParameters.start_date, requestParameters.interval, requestParameters.amount, requestParameters.field_key, requestParameters.user_id, requestParameters.pipeline_id, requestParameters.filter_id, requestParameters.exclude_deals, requestParameters.totals_convert_currency, ).then((request) => request(axios, basePath));
        },
        /**
         * Merges a deal with another deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-deals\" target=\"_blank\" rel=\"noopener noreferrer\">merging two deals</a>.
         * @summary Merge two deals
         * @param {DealsApiMergeDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        mergeDeals(requestParameters: DealsApiMergeDealsRequest, ): Promise<MergeDealsResponse200> {
            return localVarFp.mergeDeals(requestParameters.id, requestParameters.MergeDealsRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
         * @summary Search deals
         * @param {DealsApiSearchDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchDeals(requestParameters: DealsApiSearchDealsRequest, ): Promise<SearchDealsResponse200> {
            return localVarFp.searchDeals(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.person_id, requestParameters.organization_id, requestParameters.status, requestParameters.include_fields, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">updating a deal</a>.
         * @summary Update a deal
         * @param {DealsApiUpdateDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateDeal(requestParameters: DealsApiUpdateDealRequest, ): Promise<DealResponse200> {
            return localVarFp.updateDeal(requestParameters.id, requestParameters.UpdateDealRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the details of the product that has been attached to a deal.
         * @summary Update the product attached to a deal
         * @param {DealsApiUpdateDealProductRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateDealProduct(requestParameters: DealsApiUpdateDealProductRequest, ): Promise<GetProductAttachementResponse200> {
            return localVarFp.updateDealProduct(requestParameters.id, requestParameters.product_attachment_id, requestParameters.UpdateDealProductRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addDeal operation in DealsApi.
 * @export
 * @interface DealsApiAddDealRequest
 */
export interface DealsApiAddDealRequest {
    /**
     *
     * @type {AddDealRequest}
     * @memberof DealsApiAddDeal
     */
    readonly AddDealRequest?: AddDealRequest
}

/**
 * Request parameters for addDealFollower operation in DealsApi.
 * @export
 * @interface DealsApiAddDealFollowerRequest
 */
export interface DealsApiAddDealFollowerRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiAddDealFollower
     */
    readonly id: number

    /**
     *
     * @type {AddDealFollowerRequest}
     * @memberof DealsApiAddDealFollower
     */
    readonly AddDealFollowerRequest?: AddDealFollowerRequest
}

/**
 * Request parameters for addDealParticipant operation in DealsApi.
 * @export
 * @interface DealsApiAddDealParticipantRequest
 */
export interface DealsApiAddDealParticipantRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiAddDealParticipant
     */
    readonly id: number

    /**
     *
     * @type {AddDealParticipantRequest}
     * @memberof DealsApiAddDealParticipant
     */
    readonly AddDealParticipantRequest?: AddDealParticipantRequest
}

/**
 * Request parameters for addDealProduct operation in DealsApi.
 * @export
 * @interface DealsApiAddDealProductRequest
 */
export interface DealsApiAddDealProductRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiAddDealProduct
     */
    readonly id: number

    /**
     *
     * @type {AddDealProductRequest}
     * @memberof DealsApiAddDealProduct
     */
    readonly AddDealProductRequest?: AddDealProductRequest
}

/**
 * Request parameters for deleteDeal operation in DealsApi.
 * @export
 * @interface DealsApiDeleteDealRequest
 */
export interface DealsApiDeleteDealRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiDeleteDeal
     */
    readonly id: number
}

/**
 * Request parameters for deleteDealFollower operation in DealsApi.
 * @export
 * @interface DealsApiDeleteDealFollowerRequest
 */
export interface DealsApiDeleteDealFollowerRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiDeleteDealFollower
     */
    readonly id: number

    /**
     * The ID of the follower
     * @type {number}
     * @memberof DealsApiDeleteDealFollower
     */
    readonly follower_id: number
}

/**
 * Request parameters for deleteDealParticipant operation in DealsApi.
 * @export
 * @interface DealsApiDeleteDealParticipantRequest
 */
export interface DealsApiDeleteDealParticipantRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiDeleteDealParticipant
     */
    readonly id: number

    /**
     * The ID of the participant of the deal
     * @type {number}
     * @memberof DealsApiDeleteDealParticipant
     */
    readonly deal_participant_id: number
}

/**
 * Request parameters for deleteDealProduct operation in DealsApi.
 * @export
 * @interface DealsApiDeleteDealProductRequest
 */
export interface DealsApiDeleteDealProductRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiDeleteDealProduct
     */
    readonly id: number

    /**
     * The product attachment ID
     * @type {number}
     * @memberof DealsApiDeleteDealProduct
     */
    readonly product_attachment_id: number
}

/**
 * Request parameters for deleteDeals operation in DealsApi.
 * @export
 * @interface DealsApiDeleteDealsRequest
 */
export interface DealsApiDeleteDealsRequest {
    /**
     * The comma-separated IDs that will be deleted
     * @type {string}
     * @memberof DealsApiDeleteDeals
     */
    readonly ids: string
}

/**
 * Request parameters for duplicateDeal operation in DealsApi.
 * @export
 * @interface DealsApiDuplicateDealRequest
 */
export interface DealsApiDuplicateDealRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiDuplicateDeal
     */
    readonly id: number
}

/**
 * Request parameters for getDeal operation in DealsApi.
 * @export
 * @interface DealsApiGetDealRequest
 */
export interface DealsApiGetDealRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiGetDeal
     */
    readonly id: number
}

/**
 * Request parameters for getDealActivities operation in DealsApi.
 * @export
 * @interface DealsApiGetDealActivitiesRequest
 */
export interface DealsApiGetDealActivitiesRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiGetDealActivities
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof DealsApiGetDealActivities
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof DealsApiGetDealActivities
     */
    readonly limit?: number

    /**
     * Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
     * @type {0 | 1}
     * @memberof DealsApiGetDealActivities
     */
    readonly done?: 0 | 1

    /**
     * A comma-separated string of activity IDs to exclude from result
     * @type {string}
     * @memberof DealsApiGetDealActivities
     */
    readonly exclude?: string
}

/**
 * Request parameters for getDealFiles operation in DealsApi.
 * @export
 * @interface DealsApiGetDealFilesRequest
 */
export interface DealsApiGetDealFilesRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiGetDealFiles
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof DealsApiGetDealFiles
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof DealsApiGetDealFiles
     */
    readonly limit?: number

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @type {string}
     * @memberof DealsApiGetDealFiles
     */
    readonly sort?: string
}

/**
 * Request parameters for getDealFollowers operation in DealsApi.
 * @export
 * @interface DealsApiGetDealFollowersRequest
 */
export interface DealsApiGetDealFollowersRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiGetDealFollowers
     */
    readonly id: number
}

/**
 * Request parameters for getDealMailMessages operation in DealsApi.
 * @export
 * @interface DealsApiGetDealMailMessagesRequest
 */
export interface DealsApiGetDealMailMessagesRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiGetDealMailMessages
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof DealsApiGetDealMailMessages
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof DealsApiGetDealMailMessages
     */
    readonly limit?: number
}

/**
 * Request parameters for getDealParticipants operation in DealsApi.
 * @export
 * @interface DealsApiGetDealParticipantsRequest
 */
export interface DealsApiGetDealParticipantsRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiGetDealParticipants
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof DealsApiGetDealParticipants
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof DealsApiGetDealParticipants
     */
    readonly limit?: number
}

/**
 * Request parameters for getDealPersons operation in DealsApi.
 * @export
 * @interface DealsApiGetDealPersonsRequest
 */
export interface DealsApiGetDealPersonsRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiGetDealPersons
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof DealsApiGetDealPersons
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof DealsApiGetDealPersons
     */
    readonly limit?: number
}

/**
 * Request parameters for getDealProducts operation in DealsApi.
 * @export
 * @interface DealsApiGetDealProductsRequest
 */
export interface DealsApiGetDealProductsRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiGetDealProducts
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof DealsApiGetDealProducts
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof DealsApiGetDealProducts
     */
    readonly limit?: number

    /**
     * Whether to fetch product data along with each attached product (1) or not (0, default)
     * @type {0 | 1}
     * @memberof DealsApiGetDealProducts
     */
    readonly include_product_data?: 0 | 1
}

/**
 * Request parameters for getDealUpdates operation in DealsApi.
 * @export
 * @interface DealsApiGetDealUpdatesRequest
 */
export interface DealsApiGetDealUpdatesRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiGetDealUpdates
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof DealsApiGetDealUpdates
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof DealsApiGetDealUpdates
     */
    readonly limit?: number

    /**
     * Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
     * @type {string}
     * @memberof DealsApiGetDealUpdates
     */
    readonly all_changes?: string

    /**
     * A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)
     * @type {string}
     * @memberof DealsApiGetDealUpdates
     */
    readonly items?: string
}

/**
 * Request parameters for getDealUsers operation in DealsApi.
 * @export
 * @interface DealsApiGetDealUsersRequest
 */
export interface DealsApiGetDealUsersRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiGetDealUsers
     */
    readonly id: number
}

/**
 * Request parameters for getDeals operation in DealsApi.
 * @export
 * @interface DealsApiGetDealsRequest
 */
export interface DealsApiGetDealsRequest {
    /**
     * If supplied, only deals matching the given user will be returned. However, &#x60;filter_id&#x60; and &#x60;owned_by_you&#x60; takes precedence over &#x60;user_id&#x60; when supplied.
     * @type {number}
     * @memberof DealsApiGetDeals
     */
    readonly user_id?: number

    /**
     * The ID of the filter to use
     * @type {number}
     * @memberof DealsApiGetDeals
     */
    readonly filter_id?: number

    /**
     * If supplied, only deals within the given stage will be returned
     * @type {number}
     * @memberof DealsApiGetDeals
     */
    readonly stage_id?: number

    /**
     * Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
     * @type {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'}
     * @memberof DealsApiGetDeals
     */
    readonly status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'

    /**
     * Pagination start
     * @type {number}
     * @memberof DealsApiGetDeals
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof DealsApiGetDeals
     */
    readonly limit?: number

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @type {string}
     * @memberof DealsApiGetDeals
     */
    readonly sort?: string

    /**
     * When supplied, only deals owned by you are returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owned_by_you&#x60; when both are supplied.
     * @type {0 | 1}
     * @memberof DealsApiGetDeals
     */
    readonly owned_by_you?: 0 | 1
}

/**
 * Request parameters for getDealsCollection operation in DealsApi.
 * @export
 * @interface DealsApiGetDealsCollectionRequest
 */
export interface DealsApiGetDealsCollectionRequest {
    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof DealsApiGetDealsCollection
     */
    readonly cursor?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof DealsApiGetDealsCollection
     */
    readonly limit?: number

    /**
     * The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
     * @type {string}
     * @memberof DealsApiGetDealsCollection
     */
    readonly since?: string

    /**
     * The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
     * @type {string}
     * @memberof DealsApiGetDealsCollection
     */
    readonly until?: string

    /**
     * If supplied, only deals matching the given user will be returned
     * @type {number}
     * @memberof DealsApiGetDealsCollection
     */
    readonly user_id?: number

    /**
     * If supplied, only deals within the given stage will be returned
     * @type {number}
     * @memberof DealsApiGetDealsCollection
     */
    readonly stage_id?: number

    /**
     * Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
     * @type {'open' | 'won' | 'lost' | 'deleted'}
     * @memberof DealsApiGetDealsCollection
     */
    readonly status?: 'open' | 'won' | 'lost' | 'deleted'
}

/**
 * Request parameters for getDealsSummary operation in DealsApi.
 * @export
 * @interface DealsApiGetDealsSummaryRequest
 */
export interface DealsApiGetDealsSummaryRequest {
    /**
     * Only fetch deals with a specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost
     * @type {'open' | 'won' | 'lost'}
     * @memberof DealsApiGetDealsSummary
     */
    readonly status?: 'open' | 'won' | 'lost'

    /**
     * &lt;code&gt;user_id&lt;/code&gt; will not be considered. Only deals matching the given filter will be returned.
     * @type {number}
     * @memberof DealsApiGetDealsSummary
     */
    readonly filter_id?: number

    /**
     * Only deals matching the given user will be returned. &#x60;user_id&#x60; will not be considered if you use &#x60;filter_id&#x60;.
     * @type {number}
     * @memberof DealsApiGetDealsSummary
     */
    readonly user_id?: number

    /**
     * Only deals within the given stage will be returned
     * @type {number}
     * @memberof DealsApiGetDealsSummary
     */
    readonly stage_id?: number
}

/**
 * Request parameters for getDealsTimeline operation in DealsApi.
 * @export
 * @interface DealsApiGetDealsTimelineRequest
 */
export interface DealsApiGetDealsTimelineRequest {
    /**
     * The date when the first interval starts. Format: YYYY-MM-DD
     * @type {string}
     * @memberof DealsApiGetDealsTimeline
     */
    readonly start_date: string

    /**
     * The type of the interval&lt;table&gt;&lt;tr&gt;&lt;th&gt;Value&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;day&#x60;&lt;/td&gt;&lt;td&gt;Day&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;week&#x60;&lt;/td&gt;&lt;td&gt;A full week (7 days) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;month&#x60;&lt;/td&gt;&lt;td&gt;A full month (depending on the number of days in given month) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;quarter&#x60;&lt;/td&gt;&lt;td&gt;A full quarter (3 months) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
     * @type {'day' | 'week' | 'month' | 'quarter'}
     * @memberof DealsApiGetDealsTimeline
     */
    readonly interval: 'day' | 'week' | 'month' | 'quarter'

    /**
     * The number of given intervals, starting from &#x60;start_date&#x60;, to fetch. E.g. 3 (months).
     * @type {number}
     * @memberof DealsApiGetDealsTimeline
     */
    readonly amount: number

    /**
     * The date field key which deals will be retrieved from
     * @type {string}
     * @memberof DealsApiGetDealsTimeline
     */
    readonly field_key: string

    /**
     * If supplied, only deals matching the given user will be returned
     * @type {number}
     * @memberof DealsApiGetDealsTimeline
     */
    readonly user_id?: number

    /**
     * If supplied, only deals matching the given pipeline will be returned
     * @type {number}
     * @memberof DealsApiGetDealsTimeline
     */
    readonly pipeline_id?: number

    /**
     * If supplied, only deals matching the given filter will be returned
     * @type {number}
     * @memberof DealsApiGetDealsTimeline
     */
    readonly filter_id?: number

    /**
     * Whether to exclude deals list (1) or not (0). Note that when deals are excluded, the timeline summary (counts and values) is still returned.
     * @type {0 | 1}
     * @memberof DealsApiGetDealsTimeline
     */
    readonly exclude_deals?: 0 | 1

    /**
     * The 3-letter currency code of any of the supported currencies. When supplied, &#x60;totals_converted&#x60; is returned per each interval which contains the currency-converted total amounts in the given currency. You may also set this parameter to &#x60;default_currency&#x60; in which case the user\&#39;s default currency is used.
     * @type {string}
     * @memberof DealsApiGetDealsTimeline
     */
    readonly totals_convert_currency?: string
}

/**
 * Request parameters for mergeDeals operation in DealsApi.
 * @export
 * @interface DealsApiMergeDealsRequest
 */
export interface DealsApiMergeDealsRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiMergeDeals
     */
    readonly id: number

    /**
     *
     * @type {MergeDealsRequest}
     * @memberof DealsApiMergeDeals
     */
    readonly MergeDealsRequest?: MergeDealsRequest
}

/**
 * Request parameters for searchDeals operation in DealsApi.
 * @export
 * @interface DealsApiSearchDealsRequest
 */
export interface DealsApiSearchDealsRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof DealsApiSearchDeals
     */
    readonly term: string

    /**
     * A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
     * @type {'custom_fields' | 'notes' | 'title'}
     * @memberof DealsApiSearchDeals
     */
    readonly fields?: 'custom_fields' | 'notes' | 'title'

    /**
     * When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @type {boolean}
     * @memberof DealsApiSearchDeals
     */
    readonly exact_match?: boolean

    /**
     * Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
     * @type {number}
     * @memberof DealsApiSearchDeals
     */
    readonly person_id?: number

    /**
     * Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
     * @type {number}
     * @memberof DealsApiSearchDeals
     */
    readonly organization_id?: number

    /**
     * Will filter deals by the provided specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost. The upper limit of found deals associated with the status is 2000.
     * @type {'open' | 'won' | 'lost'}
     * @memberof DealsApiSearchDeals
     */
    readonly status?: 'open' | 'won' | 'lost'

    /**
     * Supports including optional fields in the results which are not provided by default
     * @type {'deal.cc_email'}
     * @memberof DealsApiSearchDeals
     */
    readonly include_fields?: 'deal.cc_email'

    /**
     * Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @type {number}
     * @memberof DealsApiSearchDeals
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof DealsApiSearchDeals
     */
    readonly limit?: number
}

/**
 * Request parameters for updateDeal operation in DealsApi.
 * @export
 * @interface DealsApiUpdateDealRequest
 */
export interface DealsApiUpdateDealRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiUpdateDeal
     */
    readonly id: number

    /**
     *
     * @type {UpdateDealRequest}
     * @memberof DealsApiUpdateDeal
     */
    readonly UpdateDealRequest?: UpdateDealRequest
}

/**
 * Request parameters for updateDealProduct operation in DealsApi.
 * @export
 * @interface DealsApiUpdateDealProductRequest
 */
export interface DealsApiUpdateDealProductRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof DealsApiUpdateDealProduct
     */
    readonly id: number

    /**
     * The ID of the deal-product (the ID of the product attached to the deal)
     * @type {number}
     * @memberof DealsApiUpdateDealProduct
     */
    readonly product_attachment_id: number

    /**
     *
     * @type {UpdateDealProductRequest}
     * @memberof DealsApiUpdateDealProduct
     */
    readonly UpdateDealProductRequest?: UpdateDealProductRequest
}

/**
 * DealsApi - object-oriented interface
 * @export
 * @class DealsApi
 * @extends {BaseAPI}
 */
export class DealsApi extends BaseAPI {
    /**
     * Adds a new deal. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the dealFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/creating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">adding a deal</a>.
     * @summary Add a deal
     * @param {DealsApiAddDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public addDeal(requestParameters: DealsApiAddDealRequest = {}, ) {
        return DealsApiFp(this.configuration).addDeal(requestParameters.AddDealRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a follower to a deal.
     * @summary Add a follower to a deal
     * @param {DealsApiAddDealFollowerRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public addDealFollower(requestParameters: DealsApiAddDealFollowerRequest, ) {
        return DealsApiFp(this.configuration).addDealFollower(requestParameters.id, requestParameters.AddDealFollowerRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a participant to a deal.
     * @summary Add a participant to a deal
     * @param {DealsApiAddDealParticipantRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public addDealParticipant(requestParameters: DealsApiAddDealParticipantRequest, ) {
        return DealsApiFp(this.configuration).addDealParticipant(requestParameters.id, requestParameters.AddDealParticipantRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a product to a deal, creating a new item called a deal-product.
     * @summary Add a product to a deal
     * @param {DealsApiAddDealProductRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public addDealProduct(requestParameters: DealsApiAddDealProductRequest, ) {
        return DealsApiFp(this.configuration).addDealProduct(requestParameters.id, requestParameters.AddDealProductRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
     * @summary Delete a deal
     * @param {DealsApiDeleteDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public deleteDeal(requestParameters: DealsApiDeleteDealRequest, ) {
        return DealsApiFp(this.configuration).deleteDeal(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a follower from a deal.
     * @summary Delete a follower from a deal
     * @param {DealsApiDeleteDealFollowerRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public deleteDealFollower(requestParameters: DealsApiDeleteDealFollowerRequest, ) {
        return DealsApiFp(this.configuration).deleteDealFollower(requestParameters.id, requestParameters.follower_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a participant from a deal.
     * @summary Delete a participant from a deal
     * @param {DealsApiDeleteDealParticipantRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public deleteDealParticipant(requestParameters: DealsApiDeleteDealParticipantRequest, ) {
        return DealsApiFp(this.configuration).deleteDealParticipant(requestParameters.id, requestParameters.deal_participant_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a product attachment from a deal, using the `product_attachment_id`.
     * @summary Delete an attached product from a deal
     * @param {DealsApiDeleteDealProductRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public deleteDealProduct(requestParameters: DealsApiDeleteDealProductRequest, ) {
        return DealsApiFp(this.configuration).deleteDealProduct(requestParameters.id, requestParameters.product_attachment_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks multiple deals as deleted. After 30 days, the deals will be permanently deleted.
     * @summary Delete multiple deals in bulk
     * @param {DealsApiDeleteDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public deleteDeals(requestParameters: DealsApiDeleteDealsRequest, ) {
        return DealsApiFp(this.configuration).deleteDeals(requestParameters.ids, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Duplicates a deal.
     * @summary Duplicate deal
     * @param {DealsApiDuplicateDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public duplicateDeal(requestParameters: DealsApiDuplicateDealRequest, ) {
        return DealsApiFp(this.configuration).duplicateDeal(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a specific deal. Note that this also returns some additional fields which are not present when asking for all deals – such as deal age and stay in pipeline stages. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of dealFields. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-details-of-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">getting details of a deal</a>.
     * @summary Get details of a deal
     * @param {DealsApiGetDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDeal(requestParameters: DealsApiGetDealRequest, ) {
        return DealsApiFp(this.configuration).getDeal(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists activities associated with a deal.
     * @summary List activities associated with a deal
     * @param {DealsApiGetDealActivitiesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealActivities(requestParameters: DealsApiGetDealActivitiesRequest, ) {
        return DealsApiFp(this.configuration).getDealActivities(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.done, requestParameters.exclude, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists files associated with a deal.
     * @summary List files attached to a deal
     * @param {DealsApiGetDealFilesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealFiles(requestParameters: DealsApiGetDealFilesRequest, ) {
        return DealsApiFp(this.configuration).getDealFiles(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the followers of a deal.
     * @summary List followers of a deal
     * @param {DealsApiGetDealFollowersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealFollowers(requestParameters: DealsApiGetDealFollowersRequest, ) {
        return DealsApiFp(this.configuration).getDealFollowers(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists mail messages associated with a deal.
     * @summary List mail messages associated with a deal
     * @param {DealsApiGetDealMailMessagesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealMailMessages(requestParameters: DealsApiGetDealMailMessagesRequest, ) {
        return DealsApiFp(this.configuration).getDealMailMessages(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the participants associated with a deal.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary List participants of a deal
     * @param {DealsApiGetDealParticipantsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealParticipants(requestParameters: DealsApiGetDealParticipantsRequest, ) {
        return DealsApiFp(this.configuration).getDealParticipants(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all persons associated with a deal, regardless of whether the person is the primary contact of the deal, or added as a participant.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary List all persons associated with a deal
     * @param {DealsApiGetDealPersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealPersons(requestParameters: DealsApiGetDealPersonsRequest, ) {
        return DealsApiFp(this.configuration).getDealPersons(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists products attached to a deal.
     * @summary List products attached to a deal
     * @param {DealsApiGetDealProductsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealProducts(requestParameters: DealsApiGetDealProductsRequest, ) {
        return DealsApiFp(this.configuration).getDealProducts(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.include_product_data, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists updates about a deal.
     * @summary List updates about a deal
     * @param {DealsApiGetDealUpdatesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealUpdates(requestParameters: DealsApiGetDealUpdatesRequest, ) {
        return DealsApiFp(this.configuration).getDealUpdates(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.all_changes, requestParameters.items, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the users permitted to access a deal.
     * @summary List permitted users
     * @param {DealsApiGetDealUsersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealUsers(requestParameters: DealsApiGetDealUsersRequest, ) {
        return DealsApiFp(this.configuration).getDealUsers(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all deals. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-all-deals\" target=\"_blank\" rel=\"noopener noreferrer\">getting all deals</a>.
     * @summary Get all deals
     * @param {DealsApiGetDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDeals(requestParameters: DealsApiGetDealsRequest = {}, ) {
        return DealsApiFp(this.configuration).getDeals(requestParameters.user_id, requestParameters.filter_id, requestParameters.stage_id, requestParameters.status, requestParameters.start, requestParameters.limit, requestParameters.sort, requestParameters.owned_by_you, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all deals. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
     * @summary Get all deals (BETA)
     * @param {DealsApiGetDealsCollectionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealsCollection(requestParameters: DealsApiGetDealsCollectionRequest = {}, ) {
        return DealsApiFp(this.configuration).getDealsCollection(requestParameters.cursor, requestParameters.limit, requestParameters.since, requestParameters.until, requestParameters.user_id, requestParameters.stage_id, requestParameters.status, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a summary of all the deals.
     * @summary Get deals summary
     * @param {DealsApiGetDealsSummaryRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealsSummary(requestParameters: DealsApiGetDealsSummaryRequest = {}, ) {
        return DealsApiFp(this.configuration).getDealsSummary(requestParameters.status, requestParameters.filter_id, requestParameters.user_id, requestParameters.stage_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns open and won deals, grouped by a defined interval of time set in a date-type dealField (`field_key`) — e.g. when month is the chosen interval, and 3 months are asked starting from January 1st, 2012, deals are returned grouped into 3 groups — January, February and March — based on the value of the given `field_key`.
     * @summary Get deals timeline
     * @param {DealsApiGetDealsTimelineRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealsTimeline(requestParameters: DealsApiGetDealsTimelineRequest, ) {
        return DealsApiFp(this.configuration).getDealsTimeline(requestParameters.start_date, requestParameters.interval, requestParameters.amount, requestParameters.field_key, requestParameters.user_id, requestParameters.pipeline_id, requestParameters.filter_id, requestParameters.exclude_deals, requestParameters.totals_convert_currency, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Merges a deal with another deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-deals\" target=\"_blank\" rel=\"noopener noreferrer\">merging two deals</a>.
     * @summary Merge two deals
     * @param {DealsApiMergeDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public mergeDeals(requestParameters: DealsApiMergeDealsRequest, ) {
        return DealsApiFp(this.configuration).mergeDeals(requestParameters.id, requestParameters.MergeDealsRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
     * @summary Search deals
     * @param {DealsApiSearchDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public searchDeals(requestParameters: DealsApiSearchDealsRequest, ) {
        return DealsApiFp(this.configuration).searchDeals(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.person_id, requestParameters.organization_id, requestParameters.status, requestParameters.include_fields, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of a deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">updating a deal</a>.
     * @summary Update a deal
     * @param {DealsApiUpdateDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public updateDeal(requestParameters: DealsApiUpdateDealRequest, ) {
        return DealsApiFp(this.configuration).updateDeal(requestParameters.id, requestParameters.UpdateDealRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the details of the product that has been attached to a deal.
     * @summary Update the product attached to a deal
     * @param {DealsApiUpdateDealProductRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public updateDealProduct(requestParameters: DealsApiUpdateDealProductRequest, ) {
        return DealsApiFp(this.configuration).updateDealProduct(requestParameters.id, requestParameters.product_attachment_id, requestParameters.UpdateDealProductRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lets you upload a file and associate it with a deal, person, organization, activity, product or lead. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a file</a>.
         * @summary Add file
         * @param {File} file A single file, supplied in the multipart/form-data encoding and contained within the given boundaries
         * @param {number} [deal_id] The ID of the deal to associate file(s) with
         * @param {number} [person_id] The ID of the person to associate file(s) with
         * @param {number} [org_id] The ID of the organization to associate file(s) with
         * @param {number} [product_id] The ID of the product to associate file(s) with
         * @param {number} [activity_id] The ID of the activity to associate file(s) with
         * @param {string} [lead_id] The ID of the lead to associate file(s) with

         * @throws {RequiredError}
         */
        addFile: async (file: File, deal_id?: number, person_id?: number, org_id?: number, product_id?: number, activity_id?: number, lead_id?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('addFile', 'file', file)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "activities:full", "contacts:full"], configuration)


            if (file !== undefined) {
                localVarFormParams.append('file', file as any);
            }

            if (deal_id !== undefined) {
                localVarFormParams.append('deal_id', deal_id as any);
            }

            if (person_id !== undefined) {
                localVarFormParams.append('person_id', person_id as any);
            }

            if (org_id !== undefined) {
                localVarFormParams.append('org_id', org_id as any);
            }

            if (product_id !== undefined) {
                localVarFormParams.append('product_id', product_id as any);
            }

            if (activity_id !== undefined) {
                localVarFormParams.append('activity_id', activity_id as any);
            }

            if (lead_id !== undefined) {
                localVarFormParams.append('lead_id', lead_id as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new empty file in the remote location (`googledrive`) that will be linked to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
         * @summary Create a remote file and link it to an item
         * @param {string} file_type The file type
         * @param {string} title The title of the file
         * @param {string} item_type The item type
         * @param {number} item_id The ID of the item to associate the file with
         * @param {string} remote_location The location type to send the file to. Only &#x60;googledrive&#x60; is supported at the moment.

         * @throws {RequiredError}
         */
        addFileAndLinkIt: async (file_type: string, title: string, item_type: string, item_id: number, remote_location: string, ): Promise<RequestArgs> => {
            // verify required parameter 'file_type' is not null or undefined
            assertParamExists('addFileAndLinkIt', 'file_type', file_type)
            // verify required parameter 'title' is not null or undefined
            assertParamExists('addFileAndLinkIt', 'title', title)
            // verify required parameter 'item_type' is not null or undefined
            assertParamExists('addFileAndLinkIt', 'item_type', item_type)
            // verify required parameter 'item_id' is not null or undefined
            assertParamExists('addFileAndLinkIt', 'item_id', item_id)
            // verify required parameter 'remote_location' is not null or undefined
            assertParamExists('addFileAndLinkIt', 'remote_location', remote_location)
            const localVarPath = `/files/remote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "activities:full", "contacts:full"], configuration)


            if (file_type !== undefined) {
                localVarFormParams.set('file_type', file_type as any);
            }

            if (title !== undefined) {
                localVarFormParams.set('title', title as any);
            }

            if (item_type !== undefined) {
                localVarFormParams.set('item_type', item_type as any);
            }

            if (item_id !== undefined) {
                localVarFormParams.set('item_id', item_id as any);
            }

            if (remote_location !== undefined) {
                localVarFormParams.set('remote_location', remote_location as any);
            }


            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a file as deleted. After 30 days, the file will be permanently deleted.
         * @summary Delete a file
         * @param {number} id The ID of the file

         * @throws {RequiredError}
         */
        deleteFile: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFile', 'id', id)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "activities:full", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initializes a file download.
         * @summary Download one file
         * @param {number} id The ID of the file

         * @throws {RequiredError}
         */
        downloadFile: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadFile', 'id', id)
            const localVarPath = `/files/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "activities:read", "activities:full", "contacts:read", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific file.
         * @summary Get one file
         * @param {number} id The ID of the file

         * @throws {RequiredError}
         */
        getFile: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFile', 'id', id)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "activities:read", "activities:full", "contacts:read", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all files.
         * @summary Get all files
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.

         * @throws {RequiredError}
         */
        getFiles: async (start?: number, limit?: number, sort?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "activities:read", "activities:full", "contacts:read", "contacts:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Links an existing remote file (`googledrive`) to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
         * @summary Link a remote file to an item
         * @param {string} item_type The item type
         * @param {number} item_id The ID of the item to associate the file with
         * @param {string} remote_id The remote item ID
         * @param {string} remote_location The location type to send the file to. Only &#x60;googledrive&#x60; is supported at the moment.

         * @throws {RequiredError}
         */
        linkFileToItem: async (item_type: string, item_id: number, remote_id: string, remote_location: string, ): Promise<RequestArgs> => {
            // verify required parameter 'item_type' is not null or undefined
            assertParamExists('linkFileToItem', 'item_type', item_type)
            // verify required parameter 'item_id' is not null or undefined
            assertParamExists('linkFileToItem', 'item_id', item_id)
            // verify required parameter 'remote_id' is not null or undefined
            assertParamExists('linkFileToItem', 'remote_id', remote_id)
            // verify required parameter 'remote_location' is not null or undefined
            assertParamExists('linkFileToItem', 'remote_location', remote_location)
            const localVarPath = `/files/remoteLink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "activities:full", "contacts:full"], configuration)


            if (item_type !== undefined) {
                localVarFormParams.set('item_type', item_type as any);
            }

            if (item_id !== undefined) {
                localVarFormParams.set('item_id', item_id as any);
            }

            if (remote_id !== undefined) {
                localVarFormParams.set('remote_id', remote_id as any);
            }

            if (remote_location !== undefined) {
                localVarFormParams.set('remote_location', remote_location as any);
            }


            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a file.
         * @summary Update file details
         * @param {number} id The ID of the file
         * @param {string} [name] The visible name of the file
         * @param {string} [description] The description of the file

         * @throws {RequiredError}
         */
        updateFile: async (id: number, name?: string, description?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFile', 'id', id)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "activities:full", "contacts:full"], configuration)


            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (description !== undefined) {
                localVarFormParams.set('description', description as any);
            }


            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Lets you upload a file and associate it with a deal, person, organization, activity, product or lead. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a file</a>.
         * @summary Add file
         * @param {File} file A single file, supplied in the multipart/form-data encoding and contained within the given boundaries
         * @param {number} [deal_id] The ID of the deal to associate file(s) with
         * @param {number} [person_id] The ID of the person to associate file(s) with
         * @param {number} [org_id] The ID of the organization to associate file(s) with
         * @param {number} [product_id] The ID of the product to associate file(s) with
         * @param {number} [activity_id] The ID of the activity to associate file(s) with
         * @param {string} [lead_id] The ID of the lead to associate file(s) with

         * @throws {RequiredError}
         */
        async addFile(file: File, deal_id?: number, person_id?: number, org_id?: number, product_id?: number, activity_id?: number, lead_id?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddFileResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFile(file, deal_id, person_id, org_id, product_id, activity_id, lead_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new empty file in the remote location (`googledrive`) that will be linked to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
         * @summary Create a remote file and link it to an item
         * @param {string} file_type The file type
         * @param {string} title The title of the file
         * @param {string} item_type The item type
         * @param {number} item_id The ID of the item to associate the file with
         * @param {string} remote_location The location type to send the file to. Only &#x60;googledrive&#x60; is supported at the moment.

         * @throws {RequiredError}
         */
        async addFileAndLinkIt(file_type: string, title: string, item_type: string, item_id: number, remote_location: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddFileAndLinkItResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFileAndLinkIt(file_type, title, item_type, item_id, remote_location, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a file as deleted. After 30 days, the file will be permanently deleted.
         * @summary Delete a file
         * @param {number} id The ID of the file

         * @throws {RequiredError}
         */
        async deleteFile(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteFileResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initializes a file download.
         * @summary Download one file
         * @param {number} id The ID of the file

         * @throws {RequiredError}
         */
        async downloadFile(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about a specific file.
         * @summary Get one file
         * @param {number} id The ID of the file

         * @throws {RequiredError}
         */
        async getFile(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFileResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all files.
         * @summary Get all files
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.

         * @throws {RequiredError}
         */
        async getFiles(start?: number, limit?: number, sort?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFilesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFiles(start, limit, sort, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Links an existing remote file (`googledrive`) to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
         * @summary Link a remote file to an item
         * @param {string} item_type The item type
         * @param {number} item_id The ID of the item to associate the file with
         * @param {string} remote_id The remote item ID
         * @param {string} remote_location The location type to send the file to. Only &#x60;googledrive&#x60; is supported at the moment.

         * @throws {RequiredError}
         */
        async linkFileToItem(item_type: string, item_id: number, remote_id: string, remote_location: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<LinkFileToItemResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkFileToItem(item_type, item_id, remote_id, remote_location, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of a file.
         * @summary Update file details
         * @param {number} id The ID of the file
         * @param {string} [name] The visible name of the file
         * @param {string} [description] The description of the file

         * @throws {RequiredError}
         */
        async updateFile(id: number, name?: string, description?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdateFileResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFile(id, name, description, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Lets you upload a file and associate it with a deal, person, organization, activity, product or lead. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a file</a>.
         * @summary Add file
         * @param {FilesApiAddFileRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addFile(requestParameters: FilesApiAddFileRequest, ): Promise<AddFileResponse200> {
            return localVarFp.addFile(requestParameters.file, requestParameters.deal_id, requestParameters.person_id, requestParameters.org_id, requestParameters.product_id, requestParameters.activity_id, requestParameters.lead_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new empty file in the remote location (`googledrive`) that will be linked to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
         * @summary Create a remote file and link it to an item
         * @param {FilesApiAddFileAndLinkItRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addFileAndLinkIt(requestParameters: FilesApiAddFileAndLinkItRequest, ): Promise<AddFileAndLinkItResponse200> {
            return localVarFp.addFileAndLinkIt(requestParameters.file_type, requestParameters.title, requestParameters.item_type, requestParameters.item_id, requestParameters.remote_location, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a file as deleted. After 30 days, the file will be permanently deleted.
         * @summary Delete a file
         * @param {FilesApiDeleteFileRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteFile(requestParameters: FilesApiDeleteFileRequest, ): Promise<DeleteFileResponse200> {
            return localVarFp.deleteFile(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Initializes a file download.
         * @summary Download one file
         * @param {FilesApiDownloadFileRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        downloadFile(requestParameters: FilesApiDownloadFileRequest, ): Promise<string> {
            return localVarFp.downloadFile(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about a specific file.
         * @summary Get one file
         * @param {FilesApiGetFileRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getFile(requestParameters: FilesApiGetFileRequest, ): Promise<GetFileResponse200> {
            return localVarFp.getFile(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all files.
         * @summary Get all files
         * @param {FilesApiGetFilesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getFiles(requestParameters: FilesApiGetFilesRequest = {}, ): Promise<GetFilesResponse200> {
            return localVarFp.getFiles(requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(axios, basePath));
        },
        /**
         * Links an existing remote file (`googledrive`) to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
         * @summary Link a remote file to an item
         * @param {FilesApiLinkFileToItemRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        linkFileToItem(requestParameters: FilesApiLinkFileToItemRequest, ): Promise<LinkFileToItemResponse200> {
            return localVarFp.linkFileToItem(requestParameters.item_type, requestParameters.item_id, requestParameters.remote_id, requestParameters.remote_location, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a file.
         * @summary Update file details
         * @param {FilesApiUpdateFileRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateFile(requestParameters: FilesApiUpdateFileRequest, ): Promise<UpdateFileResponse200> {
            return localVarFp.updateFile(requestParameters.id, requestParameters.name, requestParameters.description, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addFile operation in FilesApi.
 * @export
 * @interface FilesApiAddFileRequest
 */
export interface FilesApiAddFileRequest {
    /**
     * A single file, supplied in the multipart/form-data encoding and contained within the given boundaries
     * @type {File}
     * @memberof FilesApiAddFile
     */
    readonly file: File

    /**
     * The ID of the deal to associate file(s) with
     * @type {number}
     * @memberof FilesApiAddFile
     */
    readonly deal_id?: number

    /**
     * The ID of the person to associate file(s) with
     * @type {number}
     * @memberof FilesApiAddFile
     */
    readonly person_id?: number

    /**
     * The ID of the organization to associate file(s) with
     * @type {number}
     * @memberof FilesApiAddFile
     */
    readonly org_id?: number

    /**
     * The ID of the product to associate file(s) with
     * @type {number}
     * @memberof FilesApiAddFile
     */
    readonly product_id?: number

    /**
     * The ID of the activity to associate file(s) with
     * @type {number}
     * @memberof FilesApiAddFile
     */
    readonly activity_id?: number

    /**
     * The ID of the lead to associate file(s) with
     * @type {string}
     * @memberof FilesApiAddFile
     */
    readonly lead_id?: string
}

/**
 * Request parameters for addFileAndLinkIt operation in FilesApi.
 * @export
 * @interface FilesApiAddFileAndLinkItRequest
 */
export interface FilesApiAddFileAndLinkItRequest {
    /**
     * The file type
     * @type {string}
     * @memberof FilesApiAddFileAndLinkIt
     */
    readonly file_type: string

    /**
     * The title of the file
     * @type {string}
     * @memberof FilesApiAddFileAndLinkIt
     */
    readonly title: string

    /**
     * The item type
     * @type {string}
     * @memberof FilesApiAddFileAndLinkIt
     */
    readonly item_type: string

    /**
     * The ID of the item to associate the file with
     * @type {number}
     * @memberof FilesApiAddFileAndLinkIt
     */
    readonly item_id: number

    /**
     * The location type to send the file to. Only &#x60;googledrive&#x60; is supported at the moment.
     * @type {string}
     * @memberof FilesApiAddFileAndLinkIt
     */
    readonly remote_location: string
}

/**
 * Request parameters for deleteFile operation in FilesApi.
 * @export
 * @interface FilesApiDeleteFileRequest
 */
export interface FilesApiDeleteFileRequest {
    /**
     * The ID of the file
     * @type {number}
     * @memberof FilesApiDeleteFile
     */
    readonly id: number
}

/**
 * Request parameters for downloadFile operation in FilesApi.
 * @export
 * @interface FilesApiDownloadFileRequest
 */
export interface FilesApiDownloadFileRequest {
    /**
     * The ID of the file
     * @type {number}
     * @memberof FilesApiDownloadFile
     */
    readonly id: number
}

/**
 * Request parameters for getFile operation in FilesApi.
 * @export
 * @interface FilesApiGetFileRequest
 */
export interface FilesApiGetFileRequest {
    /**
     * The ID of the file
     * @type {number}
     * @memberof FilesApiGetFile
     */
    readonly id: number
}

/**
 * Request parameters for getFiles operation in FilesApi.
 * @export
 * @interface FilesApiGetFilesRequest
 */
export interface FilesApiGetFilesRequest {
    /**
     * Pagination start
     * @type {number}
     * @memberof FilesApiGetFiles
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof FilesApiGetFiles
     */
    readonly limit?: number

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @type {string}
     * @memberof FilesApiGetFiles
     */
    readonly sort?: string
}

/**
 * Request parameters for linkFileToItem operation in FilesApi.
 * @export
 * @interface FilesApiLinkFileToItemRequest
 */
export interface FilesApiLinkFileToItemRequest {
    /**
     * The item type
     * @type {string}
     * @memberof FilesApiLinkFileToItem
     */
    readonly item_type: string

    /**
     * The ID of the item to associate the file with
     * @type {number}
     * @memberof FilesApiLinkFileToItem
     */
    readonly item_id: number

    /**
     * The remote item ID
     * @type {string}
     * @memberof FilesApiLinkFileToItem
     */
    readonly remote_id: string

    /**
     * The location type to send the file to. Only &#x60;googledrive&#x60; is supported at the moment.
     * @type {string}
     * @memberof FilesApiLinkFileToItem
     */
    readonly remote_location: string
}

/**
 * Request parameters for updateFile operation in FilesApi.
 * @export
 * @interface FilesApiUpdateFileRequest
 */
export interface FilesApiUpdateFileRequest {
    /**
     * The ID of the file
     * @type {number}
     * @memberof FilesApiUpdateFile
     */
    readonly id: number

    /**
     * The visible name of the file
     * @type {string}
     * @memberof FilesApiUpdateFile
     */
    readonly name?: string

    /**
     * The description of the file
     * @type {string}
     * @memberof FilesApiUpdateFile
     */
    readonly description?: string
}

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Lets you upload a file and associate it with a deal, person, organization, activity, product or lead. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a file</a>.
     * @summary Add file
     * @param {FilesApiAddFileRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public addFile(requestParameters: FilesApiAddFileRequest, ) {
        return FilesApiFp(this.configuration).addFile(requestParameters.file, requestParameters.deal_id, requestParameters.person_id, requestParameters.org_id, requestParameters.product_id, requestParameters.activity_id, requestParameters.lead_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new empty file in the remote location (`googledrive`) that will be linked to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
     * @summary Create a remote file and link it to an item
     * @param {FilesApiAddFileAndLinkItRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public addFileAndLinkIt(requestParameters: FilesApiAddFileAndLinkItRequest, ) {
        return FilesApiFp(this.configuration).addFileAndLinkIt(requestParameters.file_type, requestParameters.title, requestParameters.item_type, requestParameters.item_id, requestParameters.remote_location, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a file as deleted. After 30 days, the file will be permanently deleted.
     * @summary Delete a file
     * @param {FilesApiDeleteFileRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFile(requestParameters: FilesApiDeleteFileRequest, ) {
        return FilesApiFp(this.configuration).deleteFile(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initializes a file download.
     * @summary Download one file
     * @param {FilesApiDownloadFileRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public downloadFile(requestParameters: FilesApiDownloadFileRequest, ) {
        return FilesApiFp(this.configuration).downloadFile(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about a specific file.
     * @summary Get one file
     * @param {FilesApiGetFileRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFile(requestParameters: FilesApiGetFileRequest, ) {
        return FilesApiFp(this.configuration).getFile(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all files.
     * @summary Get all files
     * @param {FilesApiGetFilesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFiles(requestParameters: FilesApiGetFilesRequest = {}, ) {
        return FilesApiFp(this.configuration).getFiles(requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Links an existing remote file (`googledrive`) to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
     * @summary Link a remote file to an item
     * @param {FilesApiLinkFileToItemRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public linkFileToItem(requestParameters: FilesApiLinkFileToItemRequest, ) {
        return FilesApiFp(this.configuration).linkFileToItem(requestParameters.item_type, requestParameters.item_id, requestParameters.remote_id, requestParameters.remote_location, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of a file.
     * @summary Update file details
     * @param {FilesApiUpdateFileRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public updateFile(requestParameters: FilesApiUpdateFileRequest, ) {
        return FilesApiFp(this.configuration).updateFile(requestParameters.id, requestParameters.name, requestParameters.description, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FiltersApi - axios parameter creator
 * @export
 */
export const FiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with \'AND\', and only two second level condition groups are supported of which one must be glued with \'AND\' and the second with \'OR\'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
         * @summary Add a new filter
         * @param {AddFilterRequest} [AddFilterRequest]

         * @throws {RequiredError}
         */
        addFilter: async (AddFilterRequest?: AddFilterRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "activities:full", "contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a filter as deleted.
         * @summary Delete a filter
         * @param {number} id The ID of the filter

         * @throws {RequiredError}
         */
        deleteFilter: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFilter', 'id', id)
            const localVarPath = `/filters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "activities:full", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple filters as deleted.
         * @summary Delete multiple filters in bulk
         * @param {string} ids The comma-separated filter IDs to delete

         * @throws {RequiredError}
         */
        deleteFilters: async (ids: string, ): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteFilters', 'ids', ids)
            const localVarPath = `/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "activities:full", "contacts:full"], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific filter. Note that this also returns the condition lines of the filter.
         * @summary Get one filter
         * @param {number} id The ID of the filter

         * @throws {RequiredError}
         */
        getFilter: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFilter', 'id', id)
            const localVarPath = `/filters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "activities:read", "activities:full", "contacts:read", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href=\"/docs/api/v1/Filters#addFilter\">add</a> or <a href=\"/docs/api/v1/Filters#updateFilter\">update</a> filters. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
         * @summary Get all filter helpers

         * @throws {RequiredError}
         */
        getFilterHelpers: async (): Promise<RequestArgs> => {
            const localVarPath = `/filters/helpers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all filters.
         * @summary Get all filters
         * @param {'deals' | 'leads' | 'org' | 'people' | 'products' | 'activity' | 'projects'} [type] The types of filters to fetch

         * @throws {RequiredError}
         */
        getFilters: async (type?: 'deals' | 'leads' | 'org' | 'people' | 'products' | 'activity' | 'projects', ): Promise<RequestArgs> => {
            const localVarPath = `/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "activities:read", "activities:full", "contacts:read", "contacts:full"], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing filter.
         * @summary Update filter
         * @param {number} id The ID of the filter
         * @param {UpdateFilterRequest} [UpdateFilterRequest]

         * @throws {RequiredError}
         */
        updateFilter: async (id: number, UpdateFilterRequest?: UpdateFilterRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFilter', 'id', id)
            const localVarPath = `/filters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "activities:full", "contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FiltersApi - functional programming interface
 * @export
 */
export const FiltersApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = FiltersApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with \'AND\', and only two second level condition groups are supported of which one must be glued with \'AND\' and the second with \'OR\'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
         * @summary Add a new filter
         * @param {AddFilterRequest} [AddFilterRequest]

         * @throws {RequiredError}
         */
        async addFilter(AddFilterRequest?: AddFilterRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<PostFilterResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFilter(AddFilterRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a filter as deleted.
         * @summary Delete a filter
         * @param {number} id The ID of the filter

         * @throws {RequiredError}
         */
        async deleteFilter(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteFilterResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFilter(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks multiple filters as deleted.
         * @summary Delete multiple filters in bulk
         * @param {string} ids The comma-separated filter IDs to delete

         * @throws {RequiredError}
         */
        async deleteFilters(ids: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteFiltersResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFilters(ids, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about a specific filter. Note that this also returns the condition lines of the filter.
         * @summary Get one filter
         * @param {number} id The ID of the filter

         * @throws {RequiredError}
         */
        async getFilter(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFilterResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilter(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href=\"/docs/api/v1/Filters#addFilter\">add</a> or <a href=\"/docs/api/v1/Filters#updateFilter\">update</a> filters. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
         * @summary Get all filter helpers

         * @throws {RequiredError}
         */
        async getFilterHelpers(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilterHelpers();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all filters.
         * @summary Get all filters
         * @param {'deals' | 'leads' | 'org' | 'people' | 'products' | 'activity' | 'projects'} [type] The types of filters to fetch

         * @throws {RequiredError}
         */
        async getFilters(type?: 'deals' | 'leads' | 'org' | 'people' | 'products' | 'activity' | 'projects', ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFiltersResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilters(type, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing filter.
         * @summary Update filter
         * @param {number} id The ID of the filter
         * @param {UpdateFilterRequest} [UpdateFilterRequest]

         * @throws {RequiredError}
         */
        async updateFilter(id: number, UpdateFilterRequest?: UpdateFilterRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<PostFilterResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFilter(id, UpdateFilterRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FiltersApi - factory interface
 * @export
 */
export const FiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FiltersApiFp(configuration)
    return {
        /**
         * Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with \'AND\', and only two second level condition groups are supported of which one must be glued with \'AND\' and the second with \'OR\'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
         * @summary Add a new filter
         * @param {FiltersApiAddFilterRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addFilter(requestParameters: FiltersApiAddFilterRequest = {}, ): Promise<PostFilterResponse200> {
            return localVarFp.addFilter(requestParameters.AddFilterRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a filter as deleted.
         * @summary Delete a filter
         * @param {FiltersApiDeleteFilterRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteFilter(requestParameters: FiltersApiDeleteFilterRequest, ): Promise<DeleteFilterResponse200> {
            return localVarFp.deleteFilter(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks multiple filters as deleted.
         * @summary Delete multiple filters in bulk
         * @param {FiltersApiDeleteFiltersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteFilters(requestParameters: FiltersApiDeleteFiltersRequest, ): Promise<DeleteFiltersResponse200> {
            return localVarFp.deleteFilters(requestParameters.ids, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about a specific filter. Note that this also returns the condition lines of the filter.
         * @summary Get one filter
         * @param {FiltersApiGetFilterRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getFilter(requestParameters: FiltersApiGetFilterRequest, ): Promise<GetFilterResponse200> {
            return localVarFp.getFilter(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href=\"/docs/api/v1/Filters#addFilter\">add</a> or <a href=\"/docs/api/v1/Filters#updateFilter\">update</a> filters. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
         * @summary Get all filter helpers

         * @throws {RequiredError}
         */
        getFilterHelpers(): Promise<object> {
            return localVarFp.getFilterHelpers().then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all filters.
         * @summary Get all filters
         * @param {FiltersApiGetFiltersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getFilters(requestParameters: FiltersApiGetFiltersRequest = {}, ): Promise<GetFiltersResponse200> {
            return localVarFp.getFilters(requestParameters.type, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing filter.
         * @summary Update filter
         * @param {FiltersApiUpdateFilterRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateFilter(requestParameters: FiltersApiUpdateFilterRequest, ): Promise<PostFilterResponse200> {
            return localVarFp.updateFilter(requestParameters.id, requestParameters.UpdateFilterRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addFilter operation in FiltersApi.
 * @export
 * @interface FiltersApiAddFilterRequest
 */
export interface FiltersApiAddFilterRequest {
    /**
     *
     * @type {AddFilterRequest}
     * @memberof FiltersApiAddFilter
     */
    readonly AddFilterRequest?: AddFilterRequest
}

/**
 * Request parameters for deleteFilter operation in FiltersApi.
 * @export
 * @interface FiltersApiDeleteFilterRequest
 */
export interface FiltersApiDeleteFilterRequest {
    /**
     * The ID of the filter
     * @type {number}
     * @memberof FiltersApiDeleteFilter
     */
    readonly id: number
}

/**
 * Request parameters for deleteFilters operation in FiltersApi.
 * @export
 * @interface FiltersApiDeleteFiltersRequest
 */
export interface FiltersApiDeleteFiltersRequest {
    /**
     * The comma-separated filter IDs to delete
     * @type {string}
     * @memberof FiltersApiDeleteFilters
     */
    readonly ids: string
}

/**
 * Request parameters for getFilter operation in FiltersApi.
 * @export
 * @interface FiltersApiGetFilterRequest
 */
export interface FiltersApiGetFilterRequest {
    /**
     * The ID of the filter
     * @type {number}
     * @memberof FiltersApiGetFilter
     */
    readonly id: number
}

/**
 * Request parameters for getFilters operation in FiltersApi.
 * @export
 * @interface FiltersApiGetFiltersRequest
 */
export interface FiltersApiGetFiltersRequest {
    /**
     * The types of filters to fetch
     * @type {'deals' | 'leads' | 'org' | 'people' | 'products' | 'activity' | 'projects'}
     * @memberof FiltersApiGetFilters
     */
    readonly type?: 'deals' | 'leads' | 'org' | 'people' | 'products' | 'activity' | 'projects'
}

/**
 * Request parameters for updateFilter operation in FiltersApi.
 * @export
 * @interface FiltersApiUpdateFilterRequest
 */
export interface FiltersApiUpdateFilterRequest {
    /**
     * The ID of the filter
     * @type {number}
     * @memberof FiltersApiUpdateFilter
     */
    readonly id: number

    /**
     *
     * @type {UpdateFilterRequest}
     * @memberof FiltersApiUpdateFilter
     */
    readonly UpdateFilterRequest?: UpdateFilterRequest
}

/**
 * FiltersApi - object-oriented interface
 * @export
 * @class FiltersApi
 * @extends {BaseAPI}
 */
export class FiltersApi extends BaseAPI {
    /**
     * Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with \'AND\', and only two second level condition groups are supported of which one must be glued with \'AND\' and the second with \'OR\'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
     * @summary Add a new filter
     * @param {FiltersApiAddFilterRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public addFilter(requestParameters: FiltersApiAddFilterRequest = {}, ) {
        return FiltersApiFp(this.configuration).addFilter(requestParameters.AddFilterRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a filter as deleted.
     * @summary Delete a filter
     * @param {FiltersApiDeleteFilterRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public deleteFilter(requestParameters: FiltersApiDeleteFilterRequest, ) {
        return FiltersApiFp(this.configuration).deleteFilter(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks multiple filters as deleted.
     * @summary Delete multiple filters in bulk
     * @param {FiltersApiDeleteFiltersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public deleteFilters(requestParameters: FiltersApiDeleteFiltersRequest, ) {
        return FiltersApiFp(this.configuration).deleteFilters(requestParameters.ids, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about a specific filter. Note that this also returns the condition lines of the filter.
     * @summary Get one filter
     * @param {FiltersApiGetFilterRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public getFilter(requestParameters: FiltersApiGetFilterRequest, ) {
        return FiltersApiFp(this.configuration).getFilter(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href=\"/docs/api/v1/Filters#addFilter\">add</a> or <a href=\"/docs/api/v1/Filters#updateFilter\">update</a> filters. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
     * @summary Get all filter helpers

     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public getFilterHelpers() {
        return FiltersApiFp(this.configuration).getFilterHelpers().then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all filters.
     * @summary Get all filters
     * @param {FiltersApiGetFiltersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public getFilters(requestParameters: FiltersApiGetFiltersRequest = {}, ) {
        return FiltersApiFp(this.configuration).getFilters(requestParameters.type, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing filter.
     * @summary Update filter
     * @param {FiltersApiUpdateFilterRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public updateFilter(requestParameters: FiltersApiUpdateFilterRequest, ) {
        return FiltersApiFp(this.configuration).updateFilter(requestParameters.id, requestParameters.UpdateFilterRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GoalsApi - axios parameter creator
 * @export
 */
export const GoalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
         * @summary Add a new goal
         * @param {AddGoalRequest} [AddGoalRequest]

         * @throws {RequiredError}
         */
        addGoal: async (AddGoalRequest?: AddGoalRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/goals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["goals:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddGoalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a goal as deleted.
         * @summary Delete existing goal
         * @param {string} id The ID of the goal

         * @throws {RequiredError}
         */
        deleteGoal: async (id: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGoal', 'id', id)
            const localVarPath = `/goals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["goals:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the progress of a goal for the specified period.
         * @summary Get result of a goal
         * @param {string} id The ID of the goal that the results are looked for
         * @param {string} period_start The start date of the period for which to find the goal\&#39;s progress. Format: YYYY-MM-DD. This date must be the same or after the goal duration start date.
         * @param {string} period_end The end date of the period for which to find the goal\&#39;s progress. Format: YYYY-MM-DD. This date must be the same or before the goal duration end date.

         * @throws {RequiredError}
         */
        getGoalResult: async (id: string, period_start: string, period_end: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGoalResult', 'id', id)
            // verify required parameter 'period_start' is not null or undefined
            assertParamExists('getGoalResult', 'period_start', period_start)
            // verify required parameter 'period_end' is not null or undefined
            assertParamExists('getGoalResult', 'period_end', period_end)
            const localVarPath = `/goals/{id}/results`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["goals:read", "goals:full"], configuration)

            if (period_start !== undefined) {
                localVarQueryParameter['period.start'] = (period_start as any instanceof Date) ?
                    (period_start as any).toISOString().substr(0,10) :
                    period_start;
            }

            if (period_end !== undefined) {
                localVarQueryParameter['period.end'] = (period_end as any instanceof Date) ?
                    (period_end as any).toISOString().substr(0,10) :
                    period_end;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
         * @summary Find goals
         * @param {'deals_won' | 'deals_progressed' | 'activities_completed' | 'activities_added' | 'deals_started'} [type_name] The type of the goal. If provided, everyone\&#39;s goals will be returned.
         * @param {string} [title] The title of the goal
         * @param {boolean} [is_active] Whether the goal is active or not
         * @param {number} [assignee_id] The ID of the user who\&#39;s goal to fetch. When omitted, only your goals will be returned.
         * @param {'person' | 'company' | 'team'} [assignee_type] The type of the goal\&#39;s assignee. If provided, everyone\&#39;s goals will be returned.
         * @param {number} [expected_outcome_target] The numeric value of the outcome. If provided, everyone\&#39;s goals will be returned.
         * @param {'quantity' | 'sum'} [expected_outcome_tracking_metric] The tracking metric of the expected outcome of the goal. If provided, everyone\&#39;s goals will be returned.
         * @param {number} [expected_outcome_currency_id] The numeric ID of the goal\&#39;s currency. Only applicable to goals with &#x60;expected_outcome.tracking_metric&#x60; with value &#x60;sum&#x60;. If provided, everyone\&#39;s goals will be returned.
         * @param {Array<number>} [type_params_pipeline_id] An array of pipeline IDs or &#x60;null&#x60; for all pipelines. If provided, everyone\&#39;s goals will be returned.
         * @param {number} [type_params_stage_id] The ID of the stage. Applicable to only &#x60;deals_progressed&#x60; type of goals. If provided, everyone\&#39;s goals will be returned.
         * @param {Array<number>} [type_params_activity_type_id] An array of IDs or &#x60;null&#x60; for all activity types. Only applicable for &#x60;activities_completed&#x60; and/or &#x60;activities_added&#x60; types of goals. If provided, everyone\&#39;s goals will be returned.
         * @param {string} [period_start] The start date of the period for which to find goals. Date in format of YYYY-MM-DD. When &#x60;period.start&#x60; is provided, &#x60;period.end&#x60; must be provided too.
         * @param {string} [period_end] The end date of the period for which to find goals. Date in format of YYYY-MM-DD.

         * @throws {RequiredError}
         */
        getGoals: async (type_name?: 'deals_won' | 'deals_progressed' | 'activities_completed' | 'activities_added' | 'deals_started', title?: string, is_active?: boolean, assignee_id?: number, assignee_type?: 'person' | 'company' | 'team', expected_outcome_target?: number, expected_outcome_tracking_metric?: 'quantity' | 'sum', expected_outcome_currency_id?: number, type_params_pipeline_id?: Array<number>, type_params_stage_id?: number, type_params_activity_type_id?: Array<number>, period_start?: string, period_end?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/goals/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["goals:read", "goals:full"], configuration)

            if (type_name !== undefined) {
                localVarQueryParameter['type.name'] = type_name;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (is_active !== undefined) {
                localVarQueryParameter['is_active'] = is_active;
            }

            if (assignee_id !== undefined) {
                localVarQueryParameter['assignee.id'] = assignee_id;
            }

            if (assignee_type !== undefined) {
                localVarQueryParameter['assignee.type'] = assignee_type;
            }

            if (expected_outcome_target !== undefined) {
                localVarQueryParameter['expected_outcome.target'] = expected_outcome_target;
            }

            if (expected_outcome_tracking_metric !== undefined) {
                localVarQueryParameter['expected_outcome.tracking_metric'] = expected_outcome_tracking_metric;
            }

            if (expected_outcome_currency_id !== undefined) {
                localVarQueryParameter['expected_outcome.currency_id'] = expected_outcome_currency_id;
            }

            if (type_params_pipeline_id) {
                localVarQueryParameter['type.params.pipeline_id'] = type_params_pipeline_id;
            }

            if (type_params_stage_id !== undefined) {
                localVarQueryParameter['type.params.stage_id'] = type_params_stage_id;
            }

            if (type_params_activity_type_id) {
                localVarQueryParameter['type.params.activity_type_id'] = type_params_activity_type_id;
            }

            if (period_start !== undefined) {
                localVarQueryParameter['period.start'] = (period_start as any instanceof Date) ?
                    (period_start as any).toISOString().substr(0,10) :
                    period_start;
            }

            if (period_end !== undefined) {
                localVarQueryParameter['period.end'] = (period_end as any instanceof Date) ?
                    (period_end as any).toISOString().substr(0,10) :
                    period_end;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing goal.
         * @summary Update existing goal
         * @param {string} id The ID of the goal
         * @param {BasicGoalRequest} [BasicGoalRequest]

         * @throws {RequiredError}
         */
        updateGoal: async (id: string, BasicGoalRequest?: BasicGoalRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGoal', 'id', id)
            const localVarPath = `/goals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["goals:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(BasicGoalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoalsApi - functional programming interface
 * @export
 */
export const GoalsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = GoalsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
         * @summary Add a new goal
         * @param {AddGoalRequest} [AddGoalRequest]

         * @throws {RequiredError}
         */
        async addGoal(AddGoalRequest?: AddGoalRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddOrUpdateGoalResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGoal(AddGoalRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a goal as deleted.
         * @summary Delete existing goal
         * @param {string} id The ID of the goal

         * @throws {RequiredError}
         */
        async deleteGoal(id: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteGoalResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGoal(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the progress of a goal for the specified period.
         * @summary Get result of a goal
         * @param {string} id The ID of the goal that the results are looked for
         * @param {string} period_start The start date of the period for which to find the goal\&#39;s progress. Format: YYYY-MM-DD. This date must be the same or after the goal duration start date.
         * @param {string} period_end The end date of the period for which to find the goal\&#39;s progress. Format: YYYY-MM-DD. This date must be the same or before the goal duration end date.

         * @throws {RequiredError}
         */
        async getGoalResult(id: string, period_start: string, period_end: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetGoalResultResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoalResult(id, period_start, period_end, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
         * @summary Find goals
         * @param {'deals_won' | 'deals_progressed' | 'activities_completed' | 'activities_added' | 'deals_started'} [type_name] The type of the goal. If provided, everyone\&#39;s goals will be returned.
         * @param {string} [title] The title of the goal
         * @param {boolean} [is_active] Whether the goal is active or not
         * @param {number} [assignee_id] The ID of the user who\&#39;s goal to fetch. When omitted, only your goals will be returned.
         * @param {'person' | 'company' | 'team'} [assignee_type] The type of the goal\&#39;s assignee. If provided, everyone\&#39;s goals will be returned.
         * @param {number} [expected_outcome_target] The numeric value of the outcome. If provided, everyone\&#39;s goals will be returned.
         * @param {'quantity' | 'sum'} [expected_outcome_tracking_metric] The tracking metric of the expected outcome of the goal. If provided, everyone\&#39;s goals will be returned.
         * @param {number} [expected_outcome_currency_id] The numeric ID of the goal\&#39;s currency. Only applicable to goals with &#x60;expected_outcome.tracking_metric&#x60; with value &#x60;sum&#x60;. If provided, everyone\&#39;s goals will be returned.
         * @param {Array<number>} [type_params_pipeline_id] An array of pipeline IDs or &#x60;null&#x60; for all pipelines. If provided, everyone\&#39;s goals will be returned.
         * @param {number} [type_params_stage_id] The ID of the stage. Applicable to only &#x60;deals_progressed&#x60; type of goals. If provided, everyone\&#39;s goals will be returned.
         * @param {Array<number>} [type_params_activity_type_id] An array of IDs or &#x60;null&#x60; for all activity types. Only applicable for &#x60;activities_completed&#x60; and/or &#x60;activities_added&#x60; types of goals. If provided, everyone\&#39;s goals will be returned.
         * @param {string} [period_start] The start date of the period for which to find goals. Date in format of YYYY-MM-DD. When &#x60;period.start&#x60; is provided, &#x60;period.end&#x60; must be provided too.
         * @param {string} [period_end] The end date of the period for which to find goals. Date in format of YYYY-MM-DD.

         * @throws {RequiredError}
         */
        async getGoals(type_name?: 'deals_won' | 'deals_progressed' | 'activities_completed' | 'activities_added' | 'deals_started', title?: string, is_active?: boolean, assignee_id?: number, assignee_type?: 'person' | 'company' | 'team', expected_outcome_target?: number, expected_outcome_tracking_metric?: 'quantity' | 'sum', expected_outcome_currency_id?: number, type_params_pipeline_id?: Array<number>, type_params_stage_id?: number, type_params_activity_type_id?: Array<number>, period_start?: string, period_end?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetGoalsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoals(type_name, title, is_active, assignee_id, assignee_type, expected_outcome_target, expected_outcome_tracking_metric, expected_outcome_currency_id, type_params_pipeline_id, type_params_stage_id, type_params_activity_type_id, period_start, period_end, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing goal.
         * @summary Update existing goal
         * @param {string} id The ID of the goal
         * @param {BasicGoalRequest} [BasicGoalRequest]

         * @throws {RequiredError}
         */
        async updateGoal(id: string, BasicGoalRequest?: BasicGoalRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddOrUpdateGoalResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoal(id, BasicGoalRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GoalsApi - factory interface
 * @export
 */
export const GoalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoalsApiFp(configuration)
    return {
        /**
         * Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
         * @summary Add a new goal
         * @param {GoalsApiAddGoalRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addGoal(requestParameters: GoalsApiAddGoalRequest = {}, ): Promise<AddOrUpdateGoalResponse200> {
            return localVarFp.addGoal(requestParameters.AddGoalRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a goal as deleted.
         * @summary Delete existing goal
         * @param {GoalsApiDeleteGoalRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteGoal(requestParameters: GoalsApiDeleteGoalRequest, ): Promise<DeleteGoalResponse200> {
            return localVarFp.deleteGoal(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Gets the progress of a goal for the specified period.
         * @summary Get result of a goal
         * @param {GoalsApiGetGoalResultRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getGoalResult(requestParameters: GoalsApiGetGoalResultRequest, ): Promise<GetGoalResultResponse200> {
            return localVarFp.getGoalResult(requestParameters.id, requestParameters.period_start, requestParameters.period_end, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
         * @summary Find goals
         * @param {GoalsApiGetGoalsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getGoals(requestParameters: GoalsApiGetGoalsRequest = {}, ): Promise<GetGoalsResponse200> {
            return localVarFp.getGoals(requestParameters.type_name, requestParameters.title, requestParameters.is_active, requestParameters.assignee_id, requestParameters.assignee_type, requestParameters.expected_outcome_target, requestParameters.expected_outcome_tracking_metric, requestParameters.expected_outcome_currency_id, requestParameters.type_params_pipeline_id, requestParameters.type_params_stage_id, requestParameters.type_params_activity_type_id, requestParameters.period_start, requestParameters.period_end, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing goal.
         * @summary Update existing goal
         * @param {GoalsApiUpdateGoalRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateGoal(requestParameters: GoalsApiUpdateGoalRequest, ): Promise<AddOrUpdateGoalResponse200> {
            return localVarFp.updateGoal(requestParameters.id, requestParameters.BasicGoalRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addGoal operation in GoalsApi.
 * @export
 * @interface GoalsApiAddGoalRequest
 */
export interface GoalsApiAddGoalRequest {
    /**
     *
     * @type {AddGoalRequest}
     * @memberof GoalsApiAddGoal
     */
    readonly AddGoalRequest?: AddGoalRequest
}

/**
 * Request parameters for deleteGoal operation in GoalsApi.
 * @export
 * @interface GoalsApiDeleteGoalRequest
 */
export interface GoalsApiDeleteGoalRequest {
    /**
     * The ID of the goal
     * @type {string}
     * @memberof GoalsApiDeleteGoal
     */
    readonly id: string
}

/**
 * Request parameters for getGoalResult operation in GoalsApi.
 * @export
 * @interface GoalsApiGetGoalResultRequest
 */
export interface GoalsApiGetGoalResultRequest {
    /**
     * The ID of the goal that the results are looked for
     * @type {string}
     * @memberof GoalsApiGetGoalResult
     */
    readonly id: string

    /**
     * The start date of the period for which to find the goal\&#39;s progress. Format: YYYY-MM-DD. This date must be the same or after the goal duration start date.
     * @type {string}
     * @memberof GoalsApiGetGoalResult
     */
    readonly period_start: string

    /**
     * The end date of the period for which to find the goal\&#39;s progress. Format: YYYY-MM-DD. This date must be the same or before the goal duration end date.
     * @type {string}
     * @memberof GoalsApiGetGoalResult
     */
    readonly period_end: string
}

/**
 * Request parameters for getGoals operation in GoalsApi.
 * @export
 * @interface GoalsApiGetGoalsRequest
 */
export interface GoalsApiGetGoalsRequest {
    /**
     * The type of the goal. If provided, everyone\&#39;s goals will be returned.
     * @type {'deals_won' | 'deals_progressed' | 'activities_completed' | 'activities_added' | 'deals_started'}
     * @memberof GoalsApiGetGoals
     */
    readonly type_name?: 'deals_won' | 'deals_progressed' | 'activities_completed' | 'activities_added' | 'deals_started'

    /**
     * The title of the goal
     * @type {string}
     * @memberof GoalsApiGetGoals
     */
    readonly title?: string

    /**
     * Whether the goal is active or not
     * @type {boolean}
     * @memberof GoalsApiGetGoals
     */
    readonly is_active?: boolean

    /**
     * The ID of the user who\&#39;s goal to fetch. When omitted, only your goals will be returned.
     * @type {number}
     * @memberof GoalsApiGetGoals
     */
    readonly assignee_id?: number

    /**
     * The type of the goal\&#39;s assignee. If provided, everyone\&#39;s goals will be returned.
     * @type {'person' | 'company' | 'team'}
     * @memberof GoalsApiGetGoals
     */
    readonly assignee_type?: 'person' | 'company' | 'team'

    /**
     * The numeric value of the outcome. If provided, everyone\&#39;s goals will be returned.
     * @type {number}
     * @memberof GoalsApiGetGoals
     */
    readonly expected_outcome_target?: number

    /**
     * The tracking metric of the expected outcome of the goal. If provided, everyone\&#39;s goals will be returned.
     * @type {'quantity' | 'sum'}
     * @memberof GoalsApiGetGoals
     */
    readonly expected_outcome_tracking_metric?: 'quantity' | 'sum'

    /**
     * The numeric ID of the goal\&#39;s currency. Only applicable to goals with &#x60;expected_outcome.tracking_metric&#x60; with value &#x60;sum&#x60;. If provided, everyone\&#39;s goals will be returned.
     * @type {number}
     * @memberof GoalsApiGetGoals
     */
    readonly expected_outcome_currency_id?: number

    /**
     * An array of pipeline IDs or &#x60;null&#x60; for all pipelines. If provided, everyone\&#39;s goals will be returned.
     * @type {Array<number>}
     * @memberof GoalsApiGetGoals
     */
    readonly type_params_pipeline_id?: Array<number>

    /**
     * The ID of the stage. Applicable to only &#x60;deals_progressed&#x60; type of goals. If provided, everyone\&#39;s goals will be returned.
     * @type {number}
     * @memberof GoalsApiGetGoals
     */
    readonly type_params_stage_id?: number

    /**
     * An array of IDs or &#x60;null&#x60; for all activity types. Only applicable for &#x60;activities_completed&#x60; and/or &#x60;activities_added&#x60; types of goals. If provided, everyone\&#39;s goals will be returned.
     * @type {Array<number>}
     * @memberof GoalsApiGetGoals
     */
    readonly type_params_activity_type_id?: Array<number>

    /**
     * The start date of the period for which to find goals. Date in format of YYYY-MM-DD. When &#x60;period.start&#x60; is provided, &#x60;period.end&#x60; must be provided too.
     * @type {string}
     * @memberof GoalsApiGetGoals
     */
    readonly period_start?: string

    /**
     * The end date of the period for which to find goals. Date in format of YYYY-MM-DD.
     * @type {string}
     * @memberof GoalsApiGetGoals
     */
    readonly period_end?: string
}

/**
 * Request parameters for updateGoal operation in GoalsApi.
 * @export
 * @interface GoalsApiUpdateGoalRequest
 */
export interface GoalsApiUpdateGoalRequest {
    /**
     * The ID of the goal
     * @type {string}
     * @memberof GoalsApiUpdateGoal
     */
    readonly id: string

    /**
     *
     * @type {BasicGoalRequest}
     * @memberof GoalsApiUpdateGoal
     */
    readonly BasicGoalRequest?: BasicGoalRequest
}

/**
 * GoalsApi - object-oriented interface
 * @export
 * @class GoalsApi
 * @extends {BaseAPI}
 */
export class GoalsApi extends BaseAPI {
    /**
     * Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
     * @summary Add a new goal
     * @param {GoalsApiAddGoalRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public addGoal(requestParameters: GoalsApiAddGoalRequest = {}, ) {
        return GoalsApiFp(this.configuration).addGoal(requestParameters.AddGoalRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a goal as deleted.
     * @summary Delete existing goal
     * @param {GoalsApiDeleteGoalRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public deleteGoal(requestParameters: GoalsApiDeleteGoalRequest, ) {
        return GoalsApiFp(this.configuration).deleteGoal(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the progress of a goal for the specified period.
     * @summary Get result of a goal
     * @param {GoalsApiGetGoalResultRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public getGoalResult(requestParameters: GoalsApiGetGoalResultRequest, ) {
        return GoalsApiFp(this.configuration).getGoalResult(requestParameters.id, requestParameters.period_start, requestParameters.period_end, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
     * @summary Find goals
     * @param {GoalsApiGetGoalsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public getGoals(requestParameters: GoalsApiGetGoalsRequest = {}, ) {
        return GoalsApiFp(this.configuration).getGoals(requestParameters.type_name, requestParameters.title, requestParameters.is_active, requestParameters.assignee_id, requestParameters.assignee_type, requestParameters.expected_outcome_target, requestParameters.expected_outcome_tracking_metric, requestParameters.expected_outcome_currency_id, requestParameters.type_params_pipeline_id, requestParameters.type_params_stage_id, requestParameters.type_params_activity_type_id, requestParameters.period_start, requestParameters.period_end, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing goal.
     * @summary Update existing goal
     * @param {GoalsApiUpdateGoalRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public updateGoal(requestParameters: GoalsApiUpdateGoalRequest, ) {
        return GoalsApiFp(this.configuration).updateGoal(requestParameters.id, requestParameters.BasicGoalRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemSearchApi - axios parameter creator
 * @export
 */
export const ItemSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs a search from your choice of item types and fields.
         * @summary Perform a search from multiple item types
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project'} [item_types] A comma-separated string array. The type of items to perform the search from. Defaults to all.
         * @param {'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Project&lt;/td&gt;&lt;td&gt; &#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;, &#x60;description&#x60; &lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.&lt;br/&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
         * @param {boolean} [search_for_related_items] When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {'deal.cc_email' | 'person.picture' | 'product.price'} [include_fields] A comma-separated string array. Supports including optional fields in the results which are not provided by default.
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        searchItem: async (term: string, item_types?: 'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project', fields?: 'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description', search_for_related_items?: boolean, exact_match?: boolean, include_fields?: 'deal.cc_email' | 'person.picture' | 'product.price', start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchItem', 'term', term)
            const localVarPath = `/itemSearch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (item_types !== undefined) {
                localVarQueryParameter['item_types'] = item_types;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (search_for_related_items !== undefined) {
                localVarQueryParameter['search_for_related_items'] = search_for_related_items;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
         * @summary Perform a search using a specific field from an item type
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'dealField' | 'leadField' | 'personField' | 'organizationField' | 'productField' | 'projectField'} field_type The type of the field to perform the search from
         * @param {string} field_key The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields\&#39; API GET methods (dealFields, personFields, etc.). Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. The search &lt;b&gt;is&lt;/b&gt; case sensitive.
         * @param {boolean} [return_item_ids] Whether to return the IDs of the matching items or not. When not set or set to &#x60;0&#x60; or &#x60;false&#x60;, only distinct values of the searched field are returned. When set to &#x60;1&#x60; or &#x60;true&#x60;, the ID of each found item is returned.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        searchItemByField: async (term: string, field_type: 'dealField' | 'leadField' | 'personField' | 'organizationField' | 'productField' | 'projectField', field_key: string, exact_match?: boolean, return_item_ids?: boolean, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchItemByField', 'term', term)
            // verify required parameter 'field_type' is not null or undefined
            assertParamExists('searchItemByField', 'field_type', field_type)
            // verify required parameter 'field_key' is not null or undefined
            assertParamExists('searchItemByField', 'field_key', field_key)
            const localVarPath = `/itemSearch/field`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (field_type !== undefined) {
                localVarQueryParameter['field_type'] = field_type;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (field_key !== undefined) {
                localVarQueryParameter['field_key'] = field_key;
            }

            if (return_item_ids !== undefined) {
                localVarQueryParameter['return_item_ids'] = return_item_ids;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemSearchApi - functional programming interface
 * @export
 */
export const ItemSearchApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = ItemSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Performs a search from your choice of item types and fields.
         * @summary Perform a search from multiple item types
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project'} [item_types] A comma-separated string array. The type of items to perform the search from. Defaults to all.
         * @param {'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Project&lt;/td&gt;&lt;td&gt; &#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;, &#x60;description&#x60; &lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.&lt;br/&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
         * @param {boolean} [search_for_related_items] When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {'deal.cc_email' | 'person.picture' | 'product.price'} [include_fields] A comma-separated string array. Supports including optional fields in the results which are not provided by default.
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async searchItem(term: string, item_types?: 'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project', fields?: 'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description', search_for_related_items?: boolean, exact_match?: boolean, include_fields?: 'deal.cc_email' | 'person.picture' | 'product.price', start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SearchItemResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchItem(term, item_types, fields, search_for_related_items, exact_match, include_fields, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
         * @summary Perform a search using a specific field from an item type
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'dealField' | 'leadField' | 'personField' | 'organizationField' | 'productField' | 'projectField'} field_type The type of the field to perform the search from
         * @param {string} field_key The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields\&#39; API GET methods (dealFields, personFields, etc.). Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. The search &lt;b&gt;is&lt;/b&gt; case sensitive.
         * @param {boolean} [return_item_ids] Whether to return the IDs of the matching items or not. When not set or set to &#x60;0&#x60; or &#x60;false&#x60;, only distinct values of the searched field are returned. When set to &#x60;1&#x60; or &#x60;true&#x60;, the ID of each found item is returned.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async searchItemByField(term: string, field_type: 'dealField' | 'leadField' | 'personField' | 'organizationField' | 'productField' | 'projectField', field_key: string, exact_match?: boolean, return_item_ids?: boolean, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SearchItemByFieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchItemByField(term, field_type, field_key, exact_match, return_item_ids, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemSearchApi - factory interface
 * @export
 */
export const ItemSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemSearchApiFp(configuration)
    return {
        /**
         * Performs a search from your choice of item types and fields.
         * @summary Perform a search from multiple item types
         * @param {ItemSearchApiSearchItemRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchItem(requestParameters: ItemSearchApiSearchItemRequest, ): Promise<SearchItemResponse200> {
            return localVarFp.searchItem(requestParameters.term, requestParameters.item_types, requestParameters.fields, requestParameters.search_for_related_items, requestParameters.exact_match, requestParameters.include_fields, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
         * @summary Perform a search using a specific field from an item type
         * @param {ItemSearchApiSearchItemByFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchItemByField(requestParameters: ItemSearchApiSearchItemByFieldRequest, ): Promise<SearchItemByFieldResponse200> {
            return localVarFp.searchItemByField(requestParameters.term, requestParameters.field_type, requestParameters.field_key, requestParameters.exact_match, requestParameters.return_item_ids, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for searchItem operation in ItemSearchApi.
 * @export
 * @interface ItemSearchApiSearchItemRequest
 */
export interface ItemSearchApiSearchItemRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof ItemSearchApiSearchItem
     */
    readonly term: string

    /**
     * A comma-separated string array. The type of items to perform the search from. Defaults to all.
     * @type {'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project'}
     * @memberof ItemSearchApiSearchItem
     */
    readonly item_types?: 'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project'

    /**
     * A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Project&lt;/td&gt;&lt;td&gt; &#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;, &#x60;description&#x60; &lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.&lt;br/&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
     * @type {'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description'}
     * @memberof ItemSearchApiSearchItem
     */
    readonly fields?: 'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description'

    /**
     * When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization.
     * @type {boolean}
     * @memberof ItemSearchApiSearchItem
     */
    readonly search_for_related_items?: boolean

    /**
     * When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @type {boolean}
     * @memberof ItemSearchApiSearchItem
     */
    readonly exact_match?: boolean

    /**
     * A comma-separated string array. Supports including optional fields in the results which are not provided by default.
     * @type {'deal.cc_email' | 'person.picture' | 'product.price'}
     * @memberof ItemSearchApiSearchItem
     */
    readonly include_fields?: 'deal.cc_email' | 'person.picture' | 'product.price'

    /**
     * Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @type {number}
     * @memberof ItemSearchApiSearchItem
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof ItemSearchApiSearchItem
     */
    readonly limit?: number
}

/**
 * Request parameters for searchItemByField operation in ItemSearchApi.
 * @export
 * @interface ItemSearchApiSearchItemByFieldRequest
 */
export interface ItemSearchApiSearchItemByFieldRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof ItemSearchApiSearchItemByField
     */
    readonly term: string

    /**
     * The type of the field to perform the search from
     * @type {'dealField' | 'leadField' | 'personField' | 'organizationField' | 'productField' | 'projectField'}
     * @memberof ItemSearchApiSearchItemByField
     */
    readonly field_type: 'dealField' | 'leadField' | 'personField' | 'organizationField' | 'productField' | 'projectField'

    /**
     * The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields\&#39; API GET methods (dealFields, personFields, etc.). Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
     * @type {string}
     * @memberof ItemSearchApiSearchItemByField
     */
    readonly field_key: string

    /**
     * When enabled, only full exact matches against the given term are returned. The search &lt;b&gt;is&lt;/b&gt; case sensitive.
     * @type {boolean}
     * @memberof ItemSearchApiSearchItemByField
     */
    readonly exact_match?: boolean

    /**
     * Whether to return the IDs of the matching items or not. When not set or set to &#x60;0&#x60; or &#x60;false&#x60;, only distinct values of the searched field are returned. When set to &#x60;1&#x60; or &#x60;true&#x60;, the ID of each found item is returned.
     * @type {boolean}
     * @memberof ItemSearchApiSearchItemByField
     */
    readonly return_item_ids?: boolean

    /**
     * Pagination start
     * @type {number}
     * @memberof ItemSearchApiSearchItemByField
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof ItemSearchApiSearchItemByField
     */
    readonly limit?: number
}

/**
 * ItemSearchApi - object-oriented interface
 * @export
 * @class ItemSearchApi
 * @extends {BaseAPI}
 */
export class ItemSearchApi extends BaseAPI {
    /**
     * Performs a search from your choice of item types and fields.
     * @summary Perform a search from multiple item types
     * @param {ItemSearchApiSearchItemRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ItemSearchApi
     */
    public searchItem(requestParameters: ItemSearchApiSearchItemRequest, ) {
        return ItemSearchApiFp(this.configuration).searchItem(requestParameters.term, requestParameters.item_types, requestParameters.fields, requestParameters.search_for_related_items, requestParameters.exact_match, requestParameters.include_fields, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
     * @summary Perform a search using a specific field from an item type
     * @param {ItemSearchApiSearchItemByFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ItemSearchApi
     */
    public searchItemByField(requestParameters: ItemSearchApiSearchItemByFieldRequest, ) {
        return ItemSearchApiFp(this.configuration).searchItemByField(requestParameters.term, requestParameters.field_type, requestParameters.field_key, requestParameters.exact_match, requestParameters.return_item_ids, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LeadLabelsApi - axios parameter creator
 * @export
 */
export const LeadLabelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a lead label.
         * @summary Add a lead label
         * @param {AddLeadLabelRequest} [AddLeadLabelRequest]

         * @throws {RequiredError}
         */
        addLeadLabel: async (AddLeadLabelRequest?: AddLeadLabelRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/leadLabels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["leads:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddLeadLabelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific lead label.
         * @summary Delete a lead label
         * @param {string} id The ID of the lead label

         * @throws {RequiredError}
         */
        deleteLeadLabel: async (id: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLeadLabel', 'id', id)
            const localVarPath = `/leadLabels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["leads:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of all lead labels. This endpoint does not support pagination and all labels are always returned.
         * @summary Get all lead labels

         * @throws {RequiredError}
         */
        getLeadLabels: async (): Promise<RequestArgs> => {
            const localVarPath = `/leadLabels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["leads:read", "leads:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates one or more properties of a lead label. Only properties included in the request will be updated.
         * @summary Update a lead label
         * @param {string} id The ID of the lead label
         * @param {UpdateLeadLabelRequest} [UpdateLeadLabelRequest]

         * @throws {RequiredError}
         */
        updateLeadLabel: async (id: string, UpdateLeadLabelRequest?: UpdateLeadLabelRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateLeadLabel', 'id', id)
            const localVarPath = `/leadLabels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["leads:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateLeadLabelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeadLabelsApi - functional programming interface
 * @export
 */
export const LeadLabelsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = LeadLabelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a lead label.
         * @summary Add a lead label
         * @param {AddLeadLabelRequest} [AddLeadLabelRequest]

         * @throws {RequiredError}
         */
        async addLeadLabel(AddLeadLabelRequest?: AddLeadLabelRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddOrUpdateLeadLabelResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addLeadLabel(AddLeadLabelRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific lead label.
         * @summary Delete a lead label
         * @param {string} id The ID of the lead label

         * @throws {RequiredError}
         */
        async deleteLeadLabel(id: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<LeadIdResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLeadLabel(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns details of all lead labels. This endpoint does not support pagination and all labels are always returned.
         * @summary Get all lead labels

         * @throws {RequiredError}
         */
        async getLeadLabels(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLeadLabelsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeadLabels();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates one or more properties of a lead label. Only properties included in the request will be updated.
         * @summary Update a lead label
         * @param {string} id The ID of the lead label
         * @param {UpdateLeadLabelRequest} [UpdateLeadLabelRequest]

         * @throws {RequiredError}
         */
        async updateLeadLabel(id: string, UpdateLeadLabelRequest?: UpdateLeadLabelRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddOrUpdateLeadLabelResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLeadLabel(id, UpdateLeadLabelRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LeadLabelsApi - factory interface
 * @export
 */
export const LeadLabelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeadLabelsApiFp(configuration)
    return {
        /**
         * Creates a lead label.
         * @summary Add a lead label
         * @param {LeadLabelsApiAddLeadLabelRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addLeadLabel(requestParameters: LeadLabelsApiAddLeadLabelRequest = {}, ): Promise<AddOrUpdateLeadLabelResponse200> {
            return localVarFp.addLeadLabel(requestParameters.AddLeadLabelRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific lead label.
         * @summary Delete a lead label
         * @param {LeadLabelsApiDeleteLeadLabelRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteLeadLabel(requestParameters: LeadLabelsApiDeleteLeadLabelRequest, ): Promise<LeadIdResponse200> {
            return localVarFp.deleteLeadLabel(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of all lead labels. This endpoint does not support pagination and all labels are always returned.
         * @summary Get all lead labels

         * @throws {RequiredError}
         */
        getLeadLabels(): Promise<GetLeadLabelsResponse200> {
            return localVarFp.getLeadLabels().then((request) => request(axios, basePath));
        },
        /**
         * Updates one or more properties of a lead label. Only properties included in the request will be updated.
         * @summary Update a lead label
         * @param {LeadLabelsApiUpdateLeadLabelRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateLeadLabel(requestParameters: LeadLabelsApiUpdateLeadLabelRequest, ): Promise<AddOrUpdateLeadLabelResponse200> {
            return localVarFp.updateLeadLabel(requestParameters.id, requestParameters.UpdateLeadLabelRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addLeadLabel operation in LeadLabelsApi.
 * @export
 * @interface LeadLabelsApiAddLeadLabelRequest
 */
export interface LeadLabelsApiAddLeadLabelRequest {
    /**
     *
     * @type {AddLeadLabelRequest}
     * @memberof LeadLabelsApiAddLeadLabel
     */
    readonly AddLeadLabelRequest?: AddLeadLabelRequest
}

/**
 * Request parameters for deleteLeadLabel operation in LeadLabelsApi.
 * @export
 * @interface LeadLabelsApiDeleteLeadLabelRequest
 */
export interface LeadLabelsApiDeleteLeadLabelRequest {
    /**
     * The ID of the lead label
     * @type {string}
     * @memberof LeadLabelsApiDeleteLeadLabel
     */
    readonly id: string
}

/**
 * Request parameters for updateLeadLabel operation in LeadLabelsApi.
 * @export
 * @interface LeadLabelsApiUpdateLeadLabelRequest
 */
export interface LeadLabelsApiUpdateLeadLabelRequest {
    /**
     * The ID of the lead label
     * @type {string}
     * @memberof LeadLabelsApiUpdateLeadLabel
     */
    readonly id: string

    /**
     *
     * @type {UpdateLeadLabelRequest}
     * @memberof LeadLabelsApiUpdateLeadLabel
     */
    readonly UpdateLeadLabelRequest?: UpdateLeadLabelRequest
}

/**
 * LeadLabelsApi - object-oriented interface
 * @export
 * @class LeadLabelsApi
 * @extends {BaseAPI}
 */
export class LeadLabelsApi extends BaseAPI {
    /**
     * Creates a lead label.
     * @summary Add a lead label
     * @param {LeadLabelsApiAddLeadLabelRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof LeadLabelsApi
     */
    public addLeadLabel(requestParameters: LeadLabelsApiAddLeadLabelRequest = {}, ) {
        return LeadLabelsApiFp(this.configuration).addLeadLabel(requestParameters.AddLeadLabelRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific lead label.
     * @summary Delete a lead label
     * @param {LeadLabelsApiDeleteLeadLabelRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof LeadLabelsApi
     */
    public deleteLeadLabel(requestParameters: LeadLabelsApiDeleteLeadLabelRequest, ) {
        return LeadLabelsApiFp(this.configuration).deleteLeadLabel(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details of all lead labels. This endpoint does not support pagination and all labels are always returned.
     * @summary Get all lead labels

     * @throws {RequiredError}
     * @memberof LeadLabelsApi
     */
    public getLeadLabels() {
        return LeadLabelsApiFp(this.configuration).getLeadLabels().then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates one or more properties of a lead label. Only properties included in the request will be updated.
     * @summary Update a lead label
     * @param {LeadLabelsApiUpdateLeadLabelRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof LeadLabelsApi
     */
    public updateLeadLabel(requestParameters: LeadLabelsApiUpdateLeadLabelRequest, ) {
        return LeadLabelsApiFp(this.configuration).updateLeadLabel(requestParameters.id, requestParameters.UpdateLeadLabelRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LeadSourcesApi - axios parameter creator
 * @export
 */
export const LeadSourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all lead sources. Please note that the list of lead sources is fixed, it cannot be modified. All leads created through the Pipedrive API will have a lead source `API` assigned.
         * @summary Get all lead sources

         * @throws {RequiredError}
         */
        getLeadSources: async (): Promise<RequestArgs> => {
            const localVarPath = `/leadSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["leads:read", "leads:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeadSourcesApi - functional programming interface
 * @export
 */
export const LeadSourcesApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = LeadSourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all lead sources. Please note that the list of lead sources is fixed, it cannot be modified. All leads created through the Pipedrive API will have a lead source `API` assigned.
         * @summary Get all lead sources

         * @throws {RequiredError}
         */
        async getLeadSources(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLeadSourcesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeadSources();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LeadSourcesApi - factory interface
 * @export
 */
export const LeadSourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeadSourcesApiFp(configuration)
    return {
        /**
         * Returns all lead sources. Please note that the list of lead sources is fixed, it cannot be modified. All leads created through the Pipedrive API will have a lead source `API` assigned.
         * @summary Get all lead sources

         * @throws {RequiredError}
         */
        getLeadSources(): Promise<GetLeadSourcesResponse200> {
            return localVarFp.getLeadSources().then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeadSourcesApi - object-oriented interface
 * @export
 * @class LeadSourcesApi
 * @extends {BaseAPI}
 */
export class LeadSourcesApi extends BaseAPI {
    /**
     * Returns all lead sources. Please note that the list of lead sources is fixed, it cannot be modified. All leads created through the Pipedrive API will have a lead source `API` assigned.
     * @summary Get all lead sources

     * @throws {RequiredError}
     * @memberof LeadSourcesApi
     */
    public getLeadSources() {
        return LeadSourcesApiFp(this.configuration).getLeadSources().then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LeadsApi - axios parameter creator
 * @export
 */
export const LeadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a lead. A lead always has to be linked to a person or an organization or both. All leads created through the Pipedrive API will have a lead source `API` assigned. Here\'s the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-lead\" target=\"_blank\" rel=\"noopener noreferrer\">adding a lead</a>. If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields\' structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values tutorial</a>.
         * @summary Add a lead
         * @param {AddLeadRequest} [AddLeadRequest]

         * @throws {RequiredError}
         */
        addLead: async (AddLeadRequest?: AddLeadRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/leads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["leads:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddLeadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific lead.
         * @summary Delete a lead
         * @param {string} id The ID of the lead

         * @throws {RequiredError}
         */
        deleteLead: async (id: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLead', 'id', id)
            const localVarPath = `/leads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["leads:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a specific lead. If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields’ structure from deals.
         * @summary Get one lead
         * @param {string} id The ID of the lead

         * @throws {RequiredError}
         */
        getLead: async (id: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLead', 'id', id)
            const localVarPath = `/leads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["leads:read", "leads:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the users permitted to access a lead.
         * @summary List permitted users
         * @param {string} id The ID of the lead

         * @throws {RequiredError}
         */
        getLeadUsers: async (id: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLeadUsers', 'id', id)
            const localVarPath = `/leads/{id}/permittedUsers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns multiple leads. Leads are sorted by the time they were created, from oldest to newest. Pagination can be controlled using `limit` and `start` query parameters. If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields\' structure from deals.
         * @summary Get all leads
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
         * @param {number} [start] For pagination, the position that represents the first result for the page
         * @param {'archived' | 'not_archived' | 'all'} [archived_status] Filtering based on the archived status of a lead. If not provided, &#x60;All&#x60; is used.
         * @param {number} [owner_id] If supplied, only leads matching the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owner_id&#x60; when supplied.
         * @param {number} [person_id] If supplied, only leads matching the given person will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;person_id&#x60; when supplied.
         * @param {number} [organization_id] If supplied, only leads matching the given organization will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;organization_id&#x60; when supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {'id' | 'title' | 'owner_id' | 'creator_id' | 'was_seen' | 'expected_close_date' | 'next_activity_id' | 'add_time' | 'update_time'} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).

         * @throws {RequiredError}
         */
        getLeads: async (limit?: number, start?: number, archived_status?: 'archived' | 'not_archived' | 'all', owner_id?: number, person_id?: number, organization_id?: number, filter_id?: number, sort?: 'id' | 'title' | 'owner_id' | 'creator_id' | 'was_seen' | 'expected_close_date' | 'next_activity_id' | 'add_time' | 'update_time', ): Promise<RequestArgs> => {
            const localVarPath = `/leads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["leads:read", "leads:full"], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (archived_status !== undefined) {
                localVarQueryParameter['archived_status'] = archived_status;
            }

            if (owner_id !== undefined) {
                localVarQueryParameter['owner_id'] = owner_id;
            }

            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }

            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
         * @summary Search leads
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'notes' | 'title'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
         * @param {number} [organization_id] Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
         * @param {'lead.was_seen'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        searchLeads: async (term: string, fields?: 'custom_fields' | 'notes' | 'title', exact_match?: boolean, person_id?: number, organization_id?: number, include_fields?: 'lead.was_seen', start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchLeads', 'term', term)
            const localVarPath = `/leads/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["leads:read", "leads:full", "search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }

            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates one or more properties of a lead. Only properties included in the request will be updated. Send `null` to unset a property (applicable for example for `value`, `person_id` or `organization_id`). If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields’ structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields’ values tutorial</a>.
         * @summary Update a lead
         * @param {string} id The ID of the lead
         * @param {UpdateLeadRequest} [UpdateLeadRequest]

         * @throws {RequiredError}
         */
        updateLead: async (id: string, UpdateLeadRequest?: UpdateLeadRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateLead', 'id', id)
            const localVarPath = `/leads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["leads:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateLeadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeadsApi - functional programming interface
 * @export
 */
export const LeadsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = LeadsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a lead. A lead always has to be linked to a person or an organization or both. All leads created through the Pipedrive API will have a lead source `API` assigned. Here\'s the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-lead\" target=\"_blank\" rel=\"noopener noreferrer\">adding a lead</a>. If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields\' structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values tutorial</a>.
         * @summary Add a lead
         * @param {AddLeadRequest} [AddLeadRequest]

         * @throws {RequiredError}
         */
        async addLead(AddLeadRequest?: AddLeadRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<OneLeadResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addLead(AddLeadRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific lead.
         * @summary Delete a lead
         * @param {string} id The ID of the lead

         * @throws {RequiredError}
         */
        async deleteLead(id: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<LeadIdResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLead(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns details of a specific lead. If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields’ structure from deals.
         * @summary Get one lead
         * @param {string} id The ID of the lead

         * @throws {RequiredError}
         */
        async getLead(id: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<OneLeadResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLead(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the users permitted to access a lead.
         * @summary List permitted users
         * @param {string} id The ID of the lead

         * @throws {RequiredError}
         */
        async getLeadUsers(id: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UserIds>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeadUsers(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns multiple leads. Leads are sorted by the time they were created, from oldest to newest. Pagination can be controlled using `limit` and `start` query parameters. If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields\' structure from deals.
         * @summary Get all leads
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
         * @param {number} [start] For pagination, the position that represents the first result for the page
         * @param {'archived' | 'not_archived' | 'all'} [archived_status] Filtering based on the archived status of a lead. If not provided, &#x60;All&#x60; is used.
         * @param {number} [owner_id] If supplied, only leads matching the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owner_id&#x60; when supplied.
         * @param {number} [person_id] If supplied, only leads matching the given person will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;person_id&#x60; when supplied.
         * @param {number} [organization_id] If supplied, only leads matching the given organization will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;organization_id&#x60; when supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {'id' | 'title' | 'owner_id' | 'creator_id' | 'was_seen' | 'expected_close_date' | 'next_activity_id' | 'add_time' | 'update_time'} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).

         * @throws {RequiredError}
         */
        async getLeads(limit?: number, start?: number, archived_status?: 'archived' | 'not_archived' | 'all', owner_id?: number, person_id?: number, organization_id?: number, filter_id?: number, sort?: 'id' | 'title' | 'owner_id' | 'creator_id' | 'was_seen' | 'expected_close_date' | 'next_activity_id' | 'add_time' | 'update_time', ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLeadsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeads(limit, start, archived_status, owner_id, person_id, organization_id, filter_id, sort, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
         * @summary Search leads
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'notes' | 'title'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
         * @param {number} [organization_id] Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
         * @param {'lead.was_seen'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async searchLeads(term: string, fields?: 'custom_fields' | 'notes' | 'title', exact_match?: boolean, person_id?: number, organization_id?: number, include_fields?: 'lead.was_seen', start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SearchLeadsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchLeads(term, fields, exact_match, person_id, organization_id, include_fields, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates one or more properties of a lead. Only properties included in the request will be updated. Send `null` to unset a property (applicable for example for `value`, `person_id` or `organization_id`). If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields’ structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields’ values tutorial</a>.
         * @summary Update a lead
         * @param {string} id The ID of the lead
         * @param {UpdateLeadRequest} [UpdateLeadRequest]

         * @throws {RequiredError}
         */
        async updateLead(id: string, UpdateLeadRequest?: UpdateLeadRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<OneLeadResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLead(id, UpdateLeadRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LeadsApi - factory interface
 * @export
 */
export const LeadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeadsApiFp(configuration)
    return {
        /**
         * Creates a lead. A lead always has to be linked to a person or an organization or both. All leads created through the Pipedrive API will have a lead source `API` assigned. Here\'s the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-lead\" target=\"_blank\" rel=\"noopener noreferrer\">adding a lead</a>. If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields\' structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values tutorial</a>.
         * @summary Add a lead
         * @param {LeadsApiAddLeadRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addLead(requestParameters: LeadsApiAddLeadRequest = {}, ): Promise<OneLeadResponse200> {
            return localVarFp.addLead(requestParameters.AddLeadRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific lead.
         * @summary Delete a lead
         * @param {LeadsApiDeleteLeadRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteLead(requestParameters: LeadsApiDeleteLeadRequest, ): Promise<LeadIdResponse200> {
            return localVarFp.deleteLead(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of a specific lead. If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields’ structure from deals.
         * @summary Get one lead
         * @param {LeadsApiGetLeadRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getLead(requestParameters: LeadsApiGetLeadRequest, ): Promise<OneLeadResponse200> {
            return localVarFp.getLead(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists the users permitted to access a lead.
         * @summary List permitted users
         * @param {LeadsApiGetLeadUsersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getLeadUsers(requestParameters: LeadsApiGetLeadUsersRequest, ): Promise<UserIds> {
            return localVarFp.getLeadUsers(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns multiple leads. Leads are sorted by the time they were created, from oldest to newest. Pagination can be controlled using `limit` and `start` query parameters. If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields\' structure from deals.
         * @summary Get all leads
         * @param {LeadsApiGetLeadsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getLeads(requestParameters: LeadsApiGetLeadsRequest = {}, ): Promise<GetLeadsResponse200> {
            return localVarFp.getLeads(requestParameters.limit, requestParameters.start, requestParameters.archived_status, requestParameters.owner_id, requestParameters.person_id, requestParameters.organization_id, requestParameters.filter_id, requestParameters.sort, ).then((request) => request(axios, basePath));
        },
        /**
         * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
         * @summary Search leads
         * @param {LeadsApiSearchLeadsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchLeads(requestParameters: LeadsApiSearchLeadsRequest, ): Promise<SearchLeadsResponse200> {
            return localVarFp.searchLeads(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.person_id, requestParameters.organization_id, requestParameters.include_fields, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates one or more properties of a lead. Only properties included in the request will be updated. Send `null` to unset a property (applicable for example for `value`, `person_id` or `organization_id`). If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields’ structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields’ values tutorial</a>.
         * @summary Update a lead
         * @param {LeadsApiUpdateLeadRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateLead(requestParameters: LeadsApiUpdateLeadRequest, ): Promise<OneLeadResponse200> {
            return localVarFp.updateLead(requestParameters.id, requestParameters.UpdateLeadRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addLead operation in LeadsApi.
 * @export
 * @interface LeadsApiAddLeadRequest
 */
export interface LeadsApiAddLeadRequest {
    /**
     *
     * @type {AddLeadRequest}
     * @memberof LeadsApiAddLead
     */
    readonly AddLeadRequest?: AddLeadRequest
}

/**
 * Request parameters for deleteLead operation in LeadsApi.
 * @export
 * @interface LeadsApiDeleteLeadRequest
 */
export interface LeadsApiDeleteLeadRequest {
    /**
     * The ID of the lead
     * @type {string}
     * @memberof LeadsApiDeleteLead
     */
    readonly id: string
}

/**
 * Request parameters for getLead operation in LeadsApi.
 * @export
 * @interface LeadsApiGetLeadRequest
 */
export interface LeadsApiGetLeadRequest {
    /**
     * The ID of the lead
     * @type {string}
     * @memberof LeadsApiGetLead
     */
    readonly id: string
}

/**
 * Request parameters for getLeadUsers operation in LeadsApi.
 * @export
 * @interface LeadsApiGetLeadUsersRequest
 */
export interface LeadsApiGetLeadUsersRequest {
    /**
     * The ID of the lead
     * @type {string}
     * @memberof LeadsApiGetLeadUsers
     */
    readonly id: string
}

/**
 * Request parameters for getLeads operation in LeadsApi.
 * @export
 * @interface LeadsApiGetLeadsRequest
 */
export interface LeadsApiGetLeadsRequest {
    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
     * @type {number}
     * @memberof LeadsApiGetLeads
     */
    readonly limit?: number

    /**
     * For pagination, the position that represents the first result for the page
     * @type {number}
     * @memberof LeadsApiGetLeads
     */
    readonly start?: number

    /**
     * Filtering based on the archived status of a lead. If not provided, &#x60;All&#x60; is used.
     * @type {'archived' | 'not_archived' | 'all'}
     * @memberof LeadsApiGetLeads
     */
    readonly archived_status?: 'archived' | 'not_archived' | 'all'

    /**
     * If supplied, only leads matching the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owner_id&#x60; when supplied.
     * @type {number}
     * @memberof LeadsApiGetLeads
     */
    readonly owner_id?: number

    /**
     * If supplied, only leads matching the given person will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;person_id&#x60; when supplied.
     * @type {number}
     * @memberof LeadsApiGetLeads
     */
    readonly person_id?: number

    /**
     * If supplied, only leads matching the given organization will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;organization_id&#x60; when supplied.
     * @type {number}
     * @memberof LeadsApiGetLeads
     */
    readonly organization_id?: number

    /**
     * The ID of the filter to use
     * @type {number}
     * @memberof LeadsApiGetLeads
     */
    readonly filter_id?: number

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @type {'id' | 'title' | 'owner_id' | 'creator_id' | 'was_seen' | 'expected_close_date' | 'next_activity_id' | 'add_time' | 'update_time'}
     * @memberof LeadsApiGetLeads
     */
    readonly sort?: 'id' | 'title' | 'owner_id' | 'creator_id' | 'was_seen' | 'expected_close_date' | 'next_activity_id' | 'add_time' | 'update_time'
}

/**
 * Request parameters for searchLeads operation in LeadsApi.
 * @export
 * @interface LeadsApiSearchLeadsRequest
 */
export interface LeadsApiSearchLeadsRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof LeadsApiSearchLeads
     */
    readonly term: string

    /**
     * A comma-separated string array. The fields to perform the search from. Defaults to all of them.
     * @type {'custom_fields' | 'notes' | 'title'}
     * @memberof LeadsApiSearchLeads
     */
    readonly fields?: 'custom_fields' | 'notes' | 'title'

    /**
     * When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @type {boolean}
     * @memberof LeadsApiSearchLeads
     */
    readonly exact_match?: boolean

    /**
     * Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
     * @type {number}
     * @memberof LeadsApiSearchLeads
     */
    readonly person_id?: number

    /**
     * Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
     * @type {number}
     * @memberof LeadsApiSearchLeads
     */
    readonly organization_id?: number

    /**
     * Supports including optional fields in the results which are not provided by default
     * @type {'lead.was_seen'}
     * @memberof LeadsApiSearchLeads
     */
    readonly include_fields?: 'lead.was_seen'

    /**
     * Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @type {number}
     * @memberof LeadsApiSearchLeads
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof LeadsApiSearchLeads
     */
    readonly limit?: number
}

/**
 * Request parameters for updateLead operation in LeadsApi.
 * @export
 * @interface LeadsApiUpdateLeadRequest
 */
export interface LeadsApiUpdateLeadRequest {
    /**
     * The ID of the lead
     * @type {string}
     * @memberof LeadsApiUpdateLead
     */
    readonly id: string

    /**
     *
     * @type {UpdateLeadRequest}
     * @memberof LeadsApiUpdateLead
     */
    readonly UpdateLeadRequest?: UpdateLeadRequest
}

/**
 * LeadsApi - object-oriented interface
 * @export
 * @class LeadsApi
 * @extends {BaseAPI}
 */
export class LeadsApi extends BaseAPI {
    /**
     * Creates a lead. A lead always has to be linked to a person or an organization or both. All leads created through the Pipedrive API will have a lead source `API` assigned. Here\'s the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-lead\" target=\"_blank\" rel=\"noopener noreferrer\">adding a lead</a>. If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields\' structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values tutorial</a>.
     * @summary Add a lead
     * @param {LeadsApiAddLeadRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public addLead(requestParameters: LeadsApiAddLeadRequest = {}, ) {
        return LeadsApiFp(this.configuration).addLead(requestParameters.AddLeadRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific lead.
     * @summary Delete a lead
     * @param {LeadsApiDeleteLeadRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public deleteLead(requestParameters: LeadsApiDeleteLeadRequest, ) {
        return LeadsApiFp(this.configuration).deleteLead(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details of a specific lead. If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields’ structure from deals.
     * @summary Get one lead
     * @param {LeadsApiGetLeadRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public getLead(requestParameters: LeadsApiGetLeadRequest, ) {
        return LeadsApiFp(this.configuration).getLead(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the users permitted to access a lead.
     * @summary List permitted users
     * @param {LeadsApiGetLeadUsersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public getLeadUsers(requestParameters: LeadsApiGetLeadUsersRequest, ) {
        return LeadsApiFp(this.configuration).getLeadUsers(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns multiple leads. Leads are sorted by the time they were created, from oldest to newest. Pagination can be controlled using `limit` and `start` query parameters. If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields\' structure from deals.
     * @summary Get all leads
     * @param {LeadsApiGetLeadsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public getLeads(requestParameters: LeadsApiGetLeadsRequest = {}, ) {
        return LeadsApiFp(this.configuration).getLeads(requestParameters.limit, requestParameters.start, requestParameters.archived_status, requestParameters.owner_id, requestParameters.person_id, requestParameters.organization_id, requestParameters.filter_id, requestParameters.sort, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
     * @summary Search leads
     * @param {LeadsApiSearchLeadsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public searchLeads(requestParameters: LeadsApiSearchLeadsRequest, ) {
        return LeadsApiFp(this.configuration).searchLeads(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.person_id, requestParameters.organization_id, requestParameters.include_fields, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates one or more properties of a lead. Only properties included in the request will be updated. Send `null` to unset a property (applicable for example for `value`, `person_id` or `organization_id`). If a lead contains custom fields, the fields\' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field\'s value hasn\'t been set for the lead, it won\'t appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields’ structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields’ values tutorial</a>.
     * @summary Update a lead
     * @param {LeadsApiUpdateLeadRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public updateLead(requestParameters: LeadsApiUpdateLeadRequest, ) {
        return LeadsApiFp(this.configuration).updateLead(requestParameters.id, requestParameters.UpdateLeadRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LegacyTeamsApi - axios parameter creator
 * @export
 */
export const LegacyTeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new team to the company and returns the created object.
         * @summary Add a new team
         * @param {AddTeamRequest1} [AddTeamRequest1]
         * @deprecated
         * @throws {RequiredError}
         */
        addTeam: async (AddTeamRequest1?: AddTeamRequest1, ): Promise<RequestArgs> => {
            const localVarPath = `/legacyTeams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddTeamRequest1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds users to an existing team.
         * @summary Add users to a team
         * @param {number} id The ID of the team
         * @param {AddTeamUserRequest} [AddTeamUserRequest]
         * @deprecated
         * @throws {RequiredError}
         */
        addTeamUser: async (id: number, AddTeamUserRequest?: AddTeamUserRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addTeamUser', 'id', id)
            const localVarPath = `/legacyTeams/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddTeamUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes users from an existing team.
         * @summary Delete users from a team
         * @param {number} id The ID of the team
         * @param {DeleteTeamUserRequest} [DeleteTeamUserRequest]
         * @deprecated
         * @throws {RequiredError}
         */
        deleteTeamUser: async (id: number, DeleteTeamUserRequest?: DeleteTeamUserRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTeamUser', 'id', id)
            const localVarPath = `/legacyTeams/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(DeleteTeamUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific team.
         * @summary Get a single team
         * @param {number} id The ID of the team
         * @param {0 | 1} [skip_users] When enabled, the teams will not include IDs of member users
         * @deprecated
         * @throws {RequiredError}
         */
        getTeam: async (id: number, skip_users?: 0 | 1, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTeam', 'id', id)
            const localVarPath = `/legacyTeams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["users:read"], configuration)

            if (skip_users !== undefined) {
                localVarQueryParameter['skip_users'] = skip_users;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all user IDs within a team.
         * @summary Get all users in a team
         * @param {number} id The ID of the team
         * @deprecated
         * @throws {RequiredError}
         */
        getTeamUsers: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTeamUsers', 'id', id)
            const localVarPath = `/legacyTeams/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["users:read"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about teams within the company.
         * @summary Get all teams
         * @param {'id' | 'name' | 'manager_id' | 'active_flag'} [order_by] The field name to sort returned teams by
         * @param {0 | 1} [skip_users] When enabled, the teams will not include IDs of member users
         * @deprecated
         * @throws {RequiredError}
         */
        getTeams: async (order_by?: 'id' | 'name' | 'manager_id' | 'active_flag', skip_users?: 0 | 1, ): Promise<RequestArgs> => {
            const localVarPath = `/legacyTeams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["users:read"], configuration)

            if (order_by !== undefined) {
                localVarQueryParameter['order_by'] = order_by;
            }

            if (skip_users !== undefined) {
                localVarQueryParameter['skip_users'] = skip_users;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all teams which have the specified user as a member.
         * @summary Get all teams of a user
         * @param {number} id The ID of the user
         * @param {'id' | 'name' | 'manager_id' | 'active_flag'} [order_by] The field name to sort returned teams by
         * @param {0 | 1} [skip_users] When enabled, the teams will not include IDs of member users
         * @deprecated
         * @throws {RequiredError}
         */
        getUserTeams: async (id: number, order_by?: 'id' | 'name' | 'manager_id' | 'active_flag', skip_users?: 0 | 1, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserTeams', 'id', id)
            const localVarPath = `/legacyTeams/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["users:read"], configuration)

            if (order_by !== undefined) {
                localVarQueryParameter['order_by'] = order_by;
            }

            if (skip_users !== undefined) {
                localVarQueryParameter['skip_users'] = skip_users;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing team and returns the updated object.
         * @summary Update a team
         * @param {number} id The ID of the team
         * @param {UpdateTeamRequest} [UpdateTeamRequest]
         * @deprecated
         * @throws {RequiredError}
         */
        updateTeam: async (id: number, UpdateTeamRequest?: UpdateTeamRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTeam', 'id', id)
            const localVarPath = `/legacyTeams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateTeamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LegacyTeamsApi - functional programming interface
 * @export
 */
export const LegacyTeamsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = LegacyTeamsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new team to the company and returns the created object.
         * @summary Add a new team
         * @param {AddTeamRequest1} [AddTeamRequest1]
         * @deprecated
         * @throws {RequiredError}
         */
        async addTeam(AddTeamRequest1?: AddTeamRequest1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<TeamResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTeam(AddTeamRequest1, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds users to an existing team.
         * @summary Add users to a team
         * @param {number} id The ID of the team
         * @param {AddTeamUserRequest} [AddTeamUserRequest]
         * @deprecated
         * @throws {RequiredError}
         */
        async addTeamUser(id: number, AddTeamUserRequest?: AddTeamUserRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UserIds>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTeamUser(id, AddTeamUserRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes users from an existing team.
         * @summary Delete users from a team
         * @param {number} id The ID of the team
         * @param {DeleteTeamUserRequest} [DeleteTeamUserRequest]
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteTeamUser(id: number, DeleteTeamUserRequest?: DeleteTeamUserRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UserIds>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeamUser(id, DeleteTeamUserRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about a specific team.
         * @summary Get a single team
         * @param {number} id The ID of the team
         * @param {0 | 1} [skip_users] When enabled, the teams will not include IDs of member users
         * @deprecated
         * @throws {RequiredError}
         */
        async getTeam(id: number, skip_users?: 0 | 1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<TeamResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeam(id, skip_users, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all user IDs within a team.
         * @summary Get all users in a team
         * @param {number} id The ID of the team
         * @deprecated
         * @throws {RequiredError}
         */
        async getTeamUsers(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UserIds>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamUsers(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about teams within the company.
         * @summary Get all teams
         * @param {'id' | 'name' | 'manager_id' | 'active_flag'} [order_by] The field name to sort returned teams by
         * @param {0 | 1} [skip_users] When enabled, the teams will not include IDs of member users
         * @deprecated
         * @throws {RequiredError}
         */
        async getTeams(order_by?: 'id' | 'name' | 'manager_id' | 'active_flag', skip_users?: 0 | 1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<TeamsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeams(order_by, skip_users, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all teams which have the specified user as a member.
         * @summary Get all teams of a user
         * @param {number} id The ID of the user
         * @param {'id' | 'name' | 'manager_id' | 'active_flag'} [order_by] The field name to sort returned teams by
         * @param {0 | 1} [skip_users] When enabled, the teams will not include IDs of member users
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserTeams(id: number, order_by?: 'id' | 'name' | 'manager_id' | 'active_flag', skip_users?: 0 | 1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<TeamsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTeams(id, order_by, skip_users, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing team and returns the updated object.
         * @summary Update a team
         * @param {number} id The ID of the team
         * @param {UpdateTeamRequest} [UpdateTeamRequest]
         * @deprecated
         * @throws {RequiredError}
         */
        async updateTeam(id: number, UpdateTeamRequest?: UpdateTeamRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<TeamResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeam(id, UpdateTeamRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LegacyTeamsApi - factory interface
 * @export
 */
export const LegacyTeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LegacyTeamsApiFp(configuration)
    return {
        /**
         * Adds a new team to the company and returns the created object.
         * @summary Add a new team
         * @param {LegacyTeamsApiAddTeamRequest} requestParameters Request parameters.
         * @deprecated
         * @throws {RequiredError}
         */
        addTeam(requestParameters: LegacyTeamsApiAddTeamRequest = {}, ): Promise<TeamResponse200> {
            return localVarFp.addTeam(requestParameters.AddTeamRequest1, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds users to an existing team.
         * @summary Add users to a team
         * @param {LegacyTeamsApiAddTeamUserRequest} requestParameters Request parameters.
         * @deprecated
         * @throws {RequiredError}
         */
        addTeamUser(requestParameters: LegacyTeamsApiAddTeamUserRequest, ): Promise<UserIds> {
            return localVarFp.addTeamUser(requestParameters.id, requestParameters.AddTeamUserRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes users from an existing team.
         * @summary Delete users from a team
         * @param {LegacyTeamsApiDeleteTeamUserRequest} requestParameters Request parameters.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteTeamUser(requestParameters: LegacyTeamsApiDeleteTeamUserRequest, ): Promise<UserIds> {
            return localVarFp.deleteTeamUser(requestParameters.id, requestParameters.DeleteTeamUserRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about a specific team.
         * @summary Get a single team
         * @param {LegacyTeamsApiGetTeamRequest} requestParameters Request parameters.
         * @deprecated
         * @throws {RequiredError}
         */
        getTeam(requestParameters: LegacyTeamsApiGetTeamRequest, ): Promise<TeamResponse200> {
            return localVarFp.getTeam(requestParameters.id, requestParameters.skip_users, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all user IDs within a team.
         * @summary Get all users in a team
         * @param {LegacyTeamsApiGetTeamUsersRequest} requestParameters Request parameters.
         * @deprecated
         * @throws {RequiredError}
         */
        getTeamUsers(requestParameters: LegacyTeamsApiGetTeamUsersRequest, ): Promise<UserIds> {
            return localVarFp.getTeamUsers(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about teams within the company.
         * @summary Get all teams
         * @param {LegacyTeamsApiGetTeamsRequest} requestParameters Request parameters.
         * @deprecated
         * @throws {RequiredError}
         */
        getTeams(requestParameters: LegacyTeamsApiGetTeamsRequest = {}, ): Promise<TeamsResponse200> {
            return localVarFp.getTeams(requestParameters.order_by, requestParameters.skip_users, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all teams which have the specified user as a member.
         * @summary Get all teams of a user
         * @param {LegacyTeamsApiGetUserTeamsRequest} requestParameters Request parameters.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserTeams(requestParameters: LegacyTeamsApiGetUserTeamsRequest, ): Promise<TeamsResponse200> {
            return localVarFp.getUserTeams(requestParameters.id, requestParameters.order_by, requestParameters.skip_users, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing team and returns the updated object.
         * @summary Update a team
         * @param {LegacyTeamsApiUpdateTeamRequest} requestParameters Request parameters.
         * @deprecated
         * @throws {RequiredError}
         */
        updateTeam(requestParameters: LegacyTeamsApiUpdateTeamRequest, ): Promise<TeamResponse200> {
            return localVarFp.updateTeam(requestParameters.id, requestParameters.UpdateTeamRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addTeam operation in LegacyTeamsApi.
 * @export
 * @interface LegacyTeamsApiAddTeamRequest
 */
export interface LegacyTeamsApiAddTeamRequest {
    /**
     *
     * @type {AddTeamRequest1}
     * @memberof LegacyTeamsApiAddTeam
     */
    readonly AddTeamRequest1?: AddTeamRequest1
}

/**
 * Request parameters for addTeamUser operation in LegacyTeamsApi.
 * @export
 * @interface LegacyTeamsApiAddTeamUserRequest
 */
export interface LegacyTeamsApiAddTeamUserRequest {
    /**
     * The ID of the team
     * @type {number}
     * @memberof LegacyTeamsApiAddTeamUser
     */
    readonly id: number

    /**
     *
     * @type {AddTeamUserRequest}
     * @memberof LegacyTeamsApiAddTeamUser
     */
    readonly AddTeamUserRequest?: AddTeamUserRequest
}

/**
 * Request parameters for deleteTeamUser operation in LegacyTeamsApi.
 * @export
 * @interface LegacyTeamsApiDeleteTeamUserRequest
 */
export interface LegacyTeamsApiDeleteTeamUserRequest {
    /**
     * The ID of the team
     * @type {number}
     * @memberof LegacyTeamsApiDeleteTeamUser
     */
    readonly id: number

    /**
     *
     * @type {DeleteTeamUserRequest}
     * @memberof LegacyTeamsApiDeleteTeamUser
     */
    readonly DeleteTeamUserRequest?: DeleteTeamUserRequest
}

/**
 * Request parameters for getTeam operation in LegacyTeamsApi.
 * @export
 * @interface LegacyTeamsApiGetTeamRequest
 */
export interface LegacyTeamsApiGetTeamRequest {
    /**
     * The ID of the team
     * @type {number}
     * @memberof LegacyTeamsApiGetTeam
     */
    readonly id: number

    /**
     * When enabled, the teams will not include IDs of member users
     * @type {0 | 1}
     * @memberof LegacyTeamsApiGetTeam
     */
    readonly skip_users?: 0 | 1
}

/**
 * Request parameters for getTeamUsers operation in LegacyTeamsApi.
 * @export
 * @interface LegacyTeamsApiGetTeamUsersRequest
 */
export interface LegacyTeamsApiGetTeamUsersRequest {
    /**
     * The ID of the team
     * @type {number}
     * @memberof LegacyTeamsApiGetTeamUsers
     */
    readonly id: number
}

/**
 * Request parameters for getTeams operation in LegacyTeamsApi.
 * @export
 * @interface LegacyTeamsApiGetTeamsRequest
 */
export interface LegacyTeamsApiGetTeamsRequest {
    /**
     * The field name to sort returned teams by
     * @type {'id' | 'name' | 'manager_id' | 'active_flag'}
     * @memberof LegacyTeamsApiGetTeams
     */
    readonly order_by?: 'id' | 'name' | 'manager_id' | 'active_flag'

    /**
     * When enabled, the teams will not include IDs of member users
     * @type {0 | 1}
     * @memberof LegacyTeamsApiGetTeams
     */
    readonly skip_users?: 0 | 1
}

/**
 * Request parameters for getUserTeams operation in LegacyTeamsApi.
 * @export
 * @interface LegacyTeamsApiGetUserTeamsRequest
 */
export interface LegacyTeamsApiGetUserTeamsRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof LegacyTeamsApiGetUserTeams
     */
    readonly id: number

    /**
     * The field name to sort returned teams by
     * @type {'id' | 'name' | 'manager_id' | 'active_flag'}
     * @memberof LegacyTeamsApiGetUserTeams
     */
    readonly order_by?: 'id' | 'name' | 'manager_id' | 'active_flag'

    /**
     * When enabled, the teams will not include IDs of member users
     * @type {0 | 1}
     * @memberof LegacyTeamsApiGetUserTeams
     */
    readonly skip_users?: 0 | 1
}

/**
 * Request parameters for updateTeam operation in LegacyTeamsApi.
 * @export
 * @interface LegacyTeamsApiUpdateTeamRequest
 */
export interface LegacyTeamsApiUpdateTeamRequest {
    /**
     * The ID of the team
     * @type {number}
     * @memberof LegacyTeamsApiUpdateTeam
     */
    readonly id: number

    /**
     *
     * @type {UpdateTeamRequest}
     * @memberof LegacyTeamsApiUpdateTeam
     */
    readonly UpdateTeamRequest?: UpdateTeamRequest
}

/**
 * LegacyTeamsApi - object-oriented interface
 * @export
 * @class LegacyTeamsApi
 * @extends {BaseAPI}
 */
export class LegacyTeamsApi extends BaseAPI {
    /**
     * Adds a new team to the company and returns the created object.
     * @summary Add a new team
     * @param {LegacyTeamsApiAddTeamRequest} requestParameters Request parameters.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public addTeam(requestParameters: LegacyTeamsApiAddTeamRequest = {}, ) {
        return LegacyTeamsApiFp(this.configuration).addTeam(requestParameters.AddTeamRequest1, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds users to an existing team.
     * @summary Add users to a team
     * @param {LegacyTeamsApiAddTeamUserRequest} requestParameters Request parameters.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public addTeamUser(requestParameters: LegacyTeamsApiAddTeamUserRequest, ) {
        return LegacyTeamsApiFp(this.configuration).addTeamUser(requestParameters.id, requestParameters.AddTeamUserRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes users from an existing team.
     * @summary Delete users from a team
     * @param {LegacyTeamsApiDeleteTeamUserRequest} requestParameters Request parameters.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public deleteTeamUser(requestParameters: LegacyTeamsApiDeleteTeamUserRequest, ) {
        return LegacyTeamsApiFp(this.configuration).deleteTeamUser(requestParameters.id, requestParameters.DeleteTeamUserRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about a specific team.
     * @summary Get a single team
     * @param {LegacyTeamsApiGetTeamRequest} requestParameters Request parameters.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public getTeam(requestParameters: LegacyTeamsApiGetTeamRequest, ) {
        return LegacyTeamsApiFp(this.configuration).getTeam(requestParameters.id, requestParameters.skip_users, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all user IDs within a team.
     * @summary Get all users in a team
     * @param {LegacyTeamsApiGetTeamUsersRequest} requestParameters Request parameters.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public getTeamUsers(requestParameters: LegacyTeamsApiGetTeamUsersRequest, ) {
        return LegacyTeamsApiFp(this.configuration).getTeamUsers(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about teams within the company.
     * @summary Get all teams
     * @param {LegacyTeamsApiGetTeamsRequest} requestParameters Request parameters.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public getTeams(requestParameters: LegacyTeamsApiGetTeamsRequest = {}, ) {
        return LegacyTeamsApiFp(this.configuration).getTeams(requestParameters.order_by, requestParameters.skip_users, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all teams which have the specified user as a member.
     * @summary Get all teams of a user
     * @param {LegacyTeamsApiGetUserTeamsRequest} requestParameters Request parameters.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public getUserTeams(requestParameters: LegacyTeamsApiGetUserTeamsRequest, ) {
        return LegacyTeamsApiFp(this.configuration).getUserTeams(requestParameters.id, requestParameters.order_by, requestParameters.skip_users, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing team and returns the updated object.
     * @summary Update a team
     * @param {LegacyTeamsApiUpdateTeamRequest} requestParameters Request parameters.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public updateTeam(requestParameters: LegacyTeamsApiUpdateTeamRequest, ) {
        return LegacyTeamsApiFp(this.configuration).updateTeam(requestParameters.id, requestParameters.UpdateTeamRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MailboxApi - axios parameter creator
 * @export
 */
export const MailboxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Marks a mail thread as deleted.
         * @summary Delete mail thread
         * @param {number} id The ID of the mail thread

         * @throws {RequiredError}
         */
        deleteMailThread: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteMailThread', 'id', id)
            const localVarPath = `/mailbox/mailThreads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["mail:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific mail message.
         * @summary Get one mail message
         * @param {number} id The ID of the mail message to fetch
         * @param {0 | 1} [include_body] Whether to include the full message body or not. &#x60;0&#x60; &#x3D; Don\&#39;t include, &#x60;1&#x60; &#x3D; Include

         * @throws {RequiredError}
         */
        getMailMessage: async (id: number, include_body?: 0 | 1, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMailMessage', 'id', id)
            const localVarPath = `/mailbox/mailMessages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["mail:read", "mail:full"], configuration)

            if (include_body !== undefined) {
                localVarQueryParameter['include_body'] = include_body;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific mail thread.
         * @summary Get one mail thread
         * @param {number} id The ID of the mail thread

         * @throws {RequiredError}
         */
        getMailThread: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMailThread', 'id', id)
            const localVarPath = `/mailbox/mailThreads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["mail:read", "mail:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the mail messages inside a specified mail thread.
         * @summary Get all mail messages of mail thread
         * @param {number} id The ID of the mail thread

         * @throws {RequiredError}
         */
        getMailThreadMessages: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMailThreadMessages', 'id', id)
            const localVarPath = `/mailbox/mailThreads/{id}/mailMessages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["mail:read", "mail:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns mail threads in a specified folder ordered by the most recent message within.
         * @summary Get mail threads
         * @param {'inbox' | 'drafts' | 'sent' | 'archive'} folder The type of folder to fetch
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getMailThreads: async (folder: 'inbox' | 'drafts' | 'sent' | 'archive', start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getMailThreads', 'folder', folder)
            const localVarPath = `/mailbox/mailThreads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["mail:read", "mail:full"], configuration)

            if (folder !== undefined) {
                localVarQueryParameter['folder'] = folder;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a mail thread.
         * @summary Update mail thread details
         * @param {number} id The ID of the mail thread
         * @param {number} [deal_id] The ID of the deal this thread is associated with
         * @param {string} [lead_id] The ID of the lead this thread is associated with
         * @param {number} [shared_flag]
         * @param {number} [read_flag]
         * @param {number} [archived_flag]

         * @throws {RequiredError}
         */
        updateMailThreadDetails: async (id: number, deal_id?: number, lead_id?: string, shared_flag?: number, read_flag?: number, archived_flag?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMailThreadDetails', 'id', id)
            const localVarPath = `/mailbox/mailThreads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["mail:full"], configuration)


            if (deal_id !== undefined) {
                localVarFormParams.set('deal_id', deal_id as any);
            }

            if (lead_id !== undefined) {
                localVarFormParams.set('lead_id', lead_id as any);
            }

            if (shared_flag !== undefined) {
                localVarFormParams.set('shared_flag', shared_flag as any);
            }

            if (read_flag !== undefined) {
                localVarFormParams.set('read_flag', read_flag as any);
            }

            if (archived_flag !== undefined) {
                localVarFormParams.set('archived_flag', archived_flag as any);
            }


            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MailboxApi - functional programming interface
 * @export
 */
export const MailboxApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = MailboxApiAxiosParamCreator(configuration)
    return {
        /**
         * Marks a mail thread as deleted.
         * @summary Delete mail thread
         * @param {number} id The ID of the mail thread

         * @throws {RequiredError}
         */
        async deleteMailThread(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteMailThreadResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMailThread(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about a specific mail message.
         * @summary Get one mail message
         * @param {number} id The ID of the mail message to fetch
         * @param {0 | 1} [include_body] Whether to include the full message body or not. &#x60;0&#x60; &#x3D; Don\&#39;t include, &#x60;1&#x60; &#x3D; Include

         * @throws {RequiredError}
         */
        async getMailMessage(id: number, include_body?: 0 | 1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<MailMessageResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMailMessage(id, include_body, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific mail thread.
         * @summary Get one mail thread
         * @param {number} id The ID of the mail thread

         * @throws {RequiredError}
         */
        async getMailThread(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOneMailThreadResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMailThread(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all the mail messages inside a specified mail thread.
         * @summary Get all mail messages of mail thread
         * @param {number} id The ID of the mail thread

         * @throws {RequiredError}
         */
        async getMailThreadMessages(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAllMailMessagesOfMailThreadResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMailThreadMessages(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns mail threads in a specified folder ordered by the most recent message within.
         * @summary Get mail threads
         * @param {'inbox' | 'drafts' | 'sent' | 'archive'} folder The type of folder to fetch
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getMailThreads(folder: 'inbox' | 'drafts' | 'sent' | 'archive', start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetMailThreadsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMailThreads(folder, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of a mail thread.
         * @summary Update mail thread details
         * @param {number} id The ID of the mail thread
         * @param {number} [deal_id] The ID of the deal this thread is associated with
         * @param {string} [lead_id] The ID of the lead this thread is associated with
         * @param {number} [shared_flag]
         * @param {number} [read_flag]
         * @param {number} [archived_flag]

         * @throws {RequiredError}
         */
        async updateMailThreadDetails(id: number, deal_id?: number, lead_id?: string, shared_flag?: number, read_flag?: number, archived_flag?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdateMailThreadDetailsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMailThreadDetails(id, deal_id, lead_id, shared_flag, read_flag, archived_flag, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MailboxApi - factory interface
 * @export
 */
export const MailboxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MailboxApiFp(configuration)
    return {
        /**
         * Marks a mail thread as deleted.
         * @summary Delete mail thread
         * @param {MailboxApiDeleteMailThreadRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteMailThread(requestParameters: MailboxApiDeleteMailThreadRequest, ): Promise<DeleteMailThreadResponse200> {
            return localVarFp.deleteMailThread(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about a specific mail message.
         * @summary Get one mail message
         * @param {MailboxApiGetMailMessageRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getMailMessage(requestParameters: MailboxApiGetMailMessageRequest, ): Promise<MailMessageResponse200> {
            return localVarFp.getMailMessage(requestParameters.id, requestParameters.include_body, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific mail thread.
         * @summary Get one mail thread
         * @param {MailboxApiGetMailThreadRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getMailThread(requestParameters: MailboxApiGetMailThreadRequest, ): Promise<GetOneMailThreadResponse200> {
            return localVarFp.getMailThread(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the mail messages inside a specified mail thread.
         * @summary Get all mail messages of mail thread
         * @param {MailboxApiGetMailThreadMessagesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getMailThreadMessages(requestParameters: MailboxApiGetMailThreadMessagesRequest, ): Promise<GetAllMailMessagesOfMailThreadResponse200> {
            return localVarFp.getMailThreadMessages(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns mail threads in a specified folder ordered by the most recent message within.
         * @summary Get mail threads
         * @param {MailboxApiGetMailThreadsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getMailThreads(requestParameters: MailboxApiGetMailThreadsRequest, ): Promise<GetMailThreadsResponse200> {
            return localVarFp.getMailThreads(requestParameters.folder, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a mail thread.
         * @summary Update mail thread details
         * @param {MailboxApiUpdateMailThreadDetailsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateMailThreadDetails(requestParameters: MailboxApiUpdateMailThreadDetailsRequest, ): Promise<UpdateMailThreadDetailsResponse200> {
            return localVarFp.updateMailThreadDetails(requestParameters.id, requestParameters.deal_id, requestParameters.lead_id, requestParameters.shared_flag, requestParameters.read_flag, requestParameters.archived_flag, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteMailThread operation in MailboxApi.
 * @export
 * @interface MailboxApiDeleteMailThreadRequest
 */
export interface MailboxApiDeleteMailThreadRequest {
    /**
     * The ID of the mail thread
     * @type {number}
     * @memberof MailboxApiDeleteMailThread
     */
    readonly id: number
}

/**
 * Request parameters for getMailMessage operation in MailboxApi.
 * @export
 * @interface MailboxApiGetMailMessageRequest
 */
export interface MailboxApiGetMailMessageRequest {
    /**
     * The ID of the mail message to fetch
     * @type {number}
     * @memberof MailboxApiGetMailMessage
     */
    readonly id: number

    /**
     * Whether to include the full message body or not. &#x60;0&#x60; &#x3D; Don\&#39;t include, &#x60;1&#x60; &#x3D; Include
     * @type {0 | 1}
     * @memberof MailboxApiGetMailMessage
     */
    readonly include_body?: 0 | 1
}

/**
 * Request parameters for getMailThread operation in MailboxApi.
 * @export
 * @interface MailboxApiGetMailThreadRequest
 */
export interface MailboxApiGetMailThreadRequest {
    /**
     * The ID of the mail thread
     * @type {number}
     * @memberof MailboxApiGetMailThread
     */
    readonly id: number
}

/**
 * Request parameters for getMailThreadMessages operation in MailboxApi.
 * @export
 * @interface MailboxApiGetMailThreadMessagesRequest
 */
export interface MailboxApiGetMailThreadMessagesRequest {
    /**
     * The ID of the mail thread
     * @type {number}
     * @memberof MailboxApiGetMailThreadMessages
     */
    readonly id: number
}

/**
 * Request parameters for getMailThreads operation in MailboxApi.
 * @export
 * @interface MailboxApiGetMailThreadsRequest
 */
export interface MailboxApiGetMailThreadsRequest {
    /**
     * The type of folder to fetch
     * @type {'inbox' | 'drafts' | 'sent' | 'archive'}
     * @memberof MailboxApiGetMailThreads
     */
    readonly folder: 'inbox' | 'drafts' | 'sent' | 'archive'

    /**
     * Pagination start
     * @type {number}
     * @memberof MailboxApiGetMailThreads
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof MailboxApiGetMailThreads
     */
    readonly limit?: number
}

/**
 * Request parameters for updateMailThreadDetails operation in MailboxApi.
 * @export
 * @interface MailboxApiUpdateMailThreadDetailsRequest
 */
export interface MailboxApiUpdateMailThreadDetailsRequest {
    /**
     * The ID of the mail thread
     * @type {number}
     * @memberof MailboxApiUpdateMailThreadDetails
     */
    readonly id: number

    /**
     * The ID of the deal this thread is associated with
     * @type {number}
     * @memberof MailboxApiUpdateMailThreadDetails
     */
    readonly deal_id?: number

    /**
     * The ID of the lead this thread is associated with
     * @type {string}
     * @memberof MailboxApiUpdateMailThreadDetails
     */
    readonly lead_id?: string

    /**
     *
     * @type {number}
     * @memberof MailboxApiUpdateMailThreadDetails
     */
    readonly shared_flag?: number

    /**
     *
     * @type {number}
     * @memberof MailboxApiUpdateMailThreadDetails
     */
    readonly read_flag?: number

    /**
     *
     * @type {number}
     * @memberof MailboxApiUpdateMailThreadDetails
     */
    readonly archived_flag?: number
}

/**
 * MailboxApi - object-oriented interface
 * @export
 * @class MailboxApi
 * @extends {BaseAPI}
 */
export class MailboxApi extends BaseAPI {
    /**
     * Marks a mail thread as deleted.
     * @summary Delete mail thread
     * @param {MailboxApiDeleteMailThreadRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof MailboxApi
     */
    public deleteMailThread(requestParameters: MailboxApiDeleteMailThreadRequest, ) {
        return MailboxApiFp(this.configuration).deleteMailThread(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about a specific mail message.
     * @summary Get one mail message
     * @param {MailboxApiGetMailMessageRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof MailboxApi
     */
    public getMailMessage(requestParameters: MailboxApiGetMailMessageRequest, ) {
        return MailboxApiFp(this.configuration).getMailMessage(requestParameters.id, requestParameters.include_body, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific mail thread.
     * @summary Get one mail thread
     * @param {MailboxApiGetMailThreadRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof MailboxApi
     */
    public getMailThread(requestParameters: MailboxApiGetMailThreadRequest, ) {
        return MailboxApiFp(this.configuration).getMailThread(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the mail messages inside a specified mail thread.
     * @summary Get all mail messages of mail thread
     * @param {MailboxApiGetMailThreadMessagesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof MailboxApi
     */
    public getMailThreadMessages(requestParameters: MailboxApiGetMailThreadMessagesRequest, ) {
        return MailboxApiFp(this.configuration).getMailThreadMessages(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns mail threads in a specified folder ordered by the most recent message within.
     * @summary Get mail threads
     * @param {MailboxApiGetMailThreadsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof MailboxApi
     */
    public getMailThreads(requestParameters: MailboxApiGetMailThreadsRequest, ) {
        return MailboxApiFp(this.configuration).getMailThreads(requestParameters.folder, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of a mail thread.
     * @summary Update mail thread details
     * @param {MailboxApiUpdateMailThreadDetailsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof MailboxApi
     */
    public updateMailThreadDetails(requestParameters: MailboxApiUpdateMailThreadDetailsRequest, ) {
        return MailboxApiFp(this.configuration).updateMailThreadDetails(requestParameters.id, requestParameters.deal_id, requestParameters.lead_id, requestParameters.shared_flag, requestParameters.read_flag, requestParameters.archived_flag, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NoteFieldsApi - axios parameter creator
 * @export
 */
export const NoteFieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns data about all note fields.
         * @summary Get all note fields

         * @throws {RequiredError}
         */
        getNoteFields: async (): Promise<RequestArgs> => {
            const localVarPath = `/noteFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "contacts:read", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NoteFieldsApi - functional programming interface
 * @export
 */
export const NoteFieldsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = NoteFieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns data about all note fields.
         * @summary Get all note fields

         * @throws {RequiredError}
         */
        async getNoteFields(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetNoteFieldsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNoteFields();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NoteFieldsApi - factory interface
 * @export
 */
export const NoteFieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NoteFieldsApiFp(configuration)
    return {
        /**
         * Returns data about all note fields.
         * @summary Get all note fields

         * @throws {RequiredError}
         */
        getNoteFields(): Promise<GetNoteFieldsResponse200> {
            return localVarFp.getNoteFields().then((request) => request(axios, basePath));
        },
    };
};

/**
 * NoteFieldsApi - object-oriented interface
 * @export
 * @class NoteFieldsApi
 * @extends {BaseAPI}
 */
export class NoteFieldsApi extends BaseAPI {
    /**
     * Returns data about all note fields.
     * @summary Get all note fields

     * @throws {RequiredError}
     * @memberof NoteFieldsApi
     */
    public getNoteFields() {
        return NoteFieldsApiFp(this.configuration).getNoteFields().then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotesApi - axios parameter creator
 * @export
 */
export const NotesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new note.
         * @summary Add a note
         * @param {AddNoteRequest} [AddNoteRequest]

         * @throws {RequiredError}
         */
        addNote: async (AddNoteRequest?: AddNoteRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddNoteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new comment to a note.
         * @summary Add a comment to a note
         * @param {number} id The ID of the note
         * @param {CommentPostPutObject} [CommentPostPutObject]

         * @throws {RequiredError}
         */
        addNoteComment: async (id: number, CommentPostPutObject?: CommentPostPutObject, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addNoteComment', 'id', id)
            const localVarPath = `/notes/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(CommentPostPutObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a comment.
         * @summary Delete a comment related to a note
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment

         * @throws {RequiredError}
         */
        deleteComment: async (id: number, commentId: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteComment', 'id', id)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('deleteComment', 'commentId', commentId)
            const localVarPath = `/notes/{id}/comments/{commentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific note.
         * @summary Delete a note
         * @param {number} id The ID of the note

         * @throws {RequiredError}
         */
        deleteNote: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNote', 'id', id)
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a comment.
         * @summary Get one comment
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment

         * @throws {RequiredError}
         */
        getComment: async (id: number, commentId: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getComment', 'id', id)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('getComment', 'commentId', commentId)
            const localVarPath = `/notes/{id}/comments/{commentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "contacts:read", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details about a specific note.
         * @summary Get one note
         * @param {number} id The ID of the note

         * @throws {RequiredError}
         */
        getNote: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNote', 'id', id)
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "contacts:read", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all comments associated with a note.
         * @summary Get all comments for a note
         * @param {number} id The ID of the note
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getNoteComments: async (id: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNoteComments', 'id', id)
            const localVarPath = `/notes/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "contacts:read", "contacts:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all notes.
         * @summary Get all notes
         * @param {number} [user_id] The ID of the user whose notes to fetch. If omitted, notes by all users will be returned.
         * @param {string} [lead_id] The ID of the lead which notes to fetch. If omitted, notes about all leads will be returned.
         * @param {number} [deal_id] The ID of the deal which notes to fetch. If omitted, notes about all deals will be returned.
         * @param {number} [person_id] The ID of the person whose notes to fetch. If omitted, notes about all persons will be returned.
         * @param {number} [org_id] The ID of the organization which notes to fetch. If omitted, notes about all organizations will be returned.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;content&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
         * @param {string} [start_date] The date in format of YYYY-MM-DD from which notes to fetch
         * @param {string} [end_date] The date in format of YYYY-MM-DD until which notes to fetch to
         * @param {0 | 1} [pinned_to_lead_flag] If set, the results are filtered by note to lead pinning state
         * @param {0 | 1} [pinned_to_deal_flag] If set, the results are filtered by note to deal pinning state
         * @param {0 | 1} [pinned_to_organization_flag] If set, the results are filtered by note to organization pinning state
         * @param {0 | 1} [pinned_to_person_flag] If set, the results are filtered by note to person pinning state

         * @throws {RequiredError}
         */
        getNotes: async (user_id?: number, lead_id?: string, deal_id?: number, person_id?: number, org_id?: number, start?: number, limit?: number, sort?: string, start_date?: string, end_date?: string, pinned_to_lead_flag?: 0 | 1, pinned_to_deal_flag?: 0 | 1, pinned_to_organization_flag?: 0 | 1, pinned_to_person_flag?: 0 | 1, ): Promise<RequestArgs> => {
            const localVarPath = `/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "contacts:read", "contacts:full"], configuration)

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (lead_id !== undefined) {
                localVarQueryParameter['lead_id'] = lead_id;
            }

            if (deal_id !== undefined) {
                localVarQueryParameter['deal_id'] = deal_id;
            }

            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }

            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['start_date'] = (start_date as any instanceof Date) ?
                    (start_date as any).toISOString().substr(0,10) :
                    start_date;
            }

            if (end_date !== undefined) {
                localVarQueryParameter['end_date'] = (end_date as any instanceof Date) ?
                    (end_date as any).toISOString().substr(0,10) :
                    end_date;
            }

            if (pinned_to_lead_flag !== undefined) {
                localVarQueryParameter['pinned_to_lead_flag'] = pinned_to_lead_flag;
            }

            if (pinned_to_deal_flag !== undefined) {
                localVarQueryParameter['pinned_to_deal_flag'] = pinned_to_deal_flag;
            }

            if (pinned_to_organization_flag !== undefined) {
                localVarQueryParameter['pinned_to_organization_flag'] = pinned_to_organization_flag;
            }

            if (pinned_to_person_flag !== undefined) {
                localVarQueryParameter['pinned_to_person_flag'] = pinned_to_person_flag;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a comment related to a note.
         * @summary Update a comment related to a note
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment
         * @param {CommentPostPutObject} [CommentPostPutObject]

         * @throws {RequiredError}
         */
        updateCommentForNote: async (id: number, commentId: string, CommentPostPutObject?: CommentPostPutObject, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCommentForNote', 'id', id)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('updateCommentForNote', 'commentId', commentId)
            const localVarPath = `/notes/{id}/comments/{commentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(CommentPostPutObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a note.
         * @summary Update a note
         * @param {number} id The ID of the note
         * @param {NoteRequest} [NoteRequest]

         * @throws {RequiredError}
         */
        updateNote: async (id: number, NoteRequest?: NoteRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateNote', 'id', id)
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(NoteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotesApi - functional programming interface
 * @export
 */
export const NotesApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = NotesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new note.
         * @summary Add a note
         * @param {AddNoteRequest} [AddNoteRequest]

         * @throws {RequiredError}
         */
        async addNote(AddNoteRequest?: AddNoteRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<OneNoteResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNote(AddNoteRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new comment to a note.
         * @summary Add a comment to a note
         * @param {number} id The ID of the note
         * @param {CommentPostPutObject} [CommentPostPutObject]

         * @throws {RequiredError}
         */
        async addNoteComment(id: number, CommentPostPutObject?: CommentPostPutObject, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<OneCommentResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNoteComment(id, CommentPostPutObject, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a comment.
         * @summary Delete a comment related to a note
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment

         * @throws {RequiredError}
         */
        async deleteComment(id: number, commentId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteCommentResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(id, commentId, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific note.
         * @summary Delete a note
         * @param {number} id The ID of the note

         * @throws {RequiredError}
         */
        async deleteNote(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteNoteResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNote(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a comment.
         * @summary Get one comment
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment

         * @throws {RequiredError}
         */
        async getComment(id: number, commentId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<OneCommentResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComment(id, commentId, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns details about a specific note.
         * @summary Get one note
         * @param {number} id The ID of the note

         * @throws {RequiredError}
         */
        async getNote(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<OneNoteResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNote(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all comments associated with a note.
         * @summary Get all comments for a note
         * @param {number} id The ID of the note
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getNoteComments(id: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCommentsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNoteComments(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all notes.
         * @summary Get all notes
         * @param {number} [user_id] The ID of the user whose notes to fetch. If omitted, notes by all users will be returned.
         * @param {string} [lead_id] The ID of the lead which notes to fetch. If omitted, notes about all leads will be returned.
         * @param {number} [deal_id] The ID of the deal which notes to fetch. If omitted, notes about all deals will be returned.
         * @param {number} [person_id] The ID of the person whose notes to fetch. If omitted, notes about all persons will be returned.
         * @param {number} [org_id] The ID of the organization which notes to fetch. If omitted, notes about all organizations will be returned.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;content&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
         * @param {string} [start_date] The date in format of YYYY-MM-DD from which notes to fetch
         * @param {string} [end_date] The date in format of YYYY-MM-DD until which notes to fetch to
         * @param {0 | 1} [pinned_to_lead_flag] If set, the results are filtered by note to lead pinning state
         * @param {0 | 1} [pinned_to_deal_flag] If set, the results are filtered by note to deal pinning state
         * @param {0 | 1} [pinned_to_organization_flag] If set, the results are filtered by note to organization pinning state
         * @param {0 | 1} [pinned_to_person_flag] If set, the results are filtered by note to person pinning state

         * @throws {RequiredError}
         */
        async getNotes(user_id?: number, lead_id?: string, deal_id?: number, person_id?: number, org_id?: number, start?: number, limit?: number, sort?: string, start_date?: string, end_date?: string, pinned_to_lead_flag?: 0 | 1, pinned_to_deal_flag?: 0 | 1, pinned_to_organization_flag?: 0 | 1, pinned_to_person_flag?: 0 | 1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetNotesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotes(user_id, lead_id, deal_id, person_id, org_id, start, limit, sort, start_date, end_date, pinned_to_lead_flag, pinned_to_deal_flag, pinned_to_organization_flag, pinned_to_person_flag, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a comment related to a note.
         * @summary Update a comment related to a note
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment
         * @param {CommentPostPutObject} [CommentPostPutObject]

         * @throws {RequiredError}
         */
        async updateCommentForNote(id: number, commentId: string, CommentPostPutObject?: CommentPostPutObject, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<OneCommentResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCommentForNote(id, commentId, CommentPostPutObject, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a note.
         * @summary Update a note
         * @param {number} id The ID of the note
         * @param {NoteRequest} [NoteRequest]

         * @throws {RequiredError}
         */
        async updateNote(id: number, NoteRequest?: NoteRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<OneNoteResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNote(id, NoteRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotesApi - factory interface
 * @export
 */
export const NotesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotesApiFp(configuration)
    return {
        /**
         * Adds a new note.
         * @summary Add a note
         * @param {NotesApiAddNoteRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addNote(requestParameters: NotesApiAddNoteRequest = {}, ): Promise<OneNoteResponse200> {
            return localVarFp.addNote(requestParameters.AddNoteRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new comment to a note.
         * @summary Add a comment to a note
         * @param {NotesApiAddNoteCommentRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addNoteComment(requestParameters: NotesApiAddNoteCommentRequest, ): Promise<OneCommentResponse200> {
            return localVarFp.addNoteComment(requestParameters.id, requestParameters.CommentPostPutObject, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a comment.
         * @summary Delete a comment related to a note
         * @param {NotesApiDeleteCommentRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteComment(requestParameters: NotesApiDeleteCommentRequest, ): Promise<DeleteCommentResponse200> {
            return localVarFp.deleteComment(requestParameters.id, requestParameters.commentId, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific note.
         * @summary Delete a note
         * @param {NotesApiDeleteNoteRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteNote(requestParameters: NotesApiDeleteNoteRequest, ): Promise<DeleteNoteResponse200> {
            return localVarFp.deleteNote(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a comment.
         * @summary Get one comment
         * @param {NotesApiGetCommentRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getComment(requestParameters: NotesApiGetCommentRequest, ): Promise<OneCommentResponse200> {
            return localVarFp.getComment(requestParameters.id, requestParameters.commentId, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns details about a specific note.
         * @summary Get one note
         * @param {NotesApiGetNoteRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getNote(requestParameters: NotesApiGetNoteRequest, ): Promise<OneNoteResponse200> {
            return localVarFp.getNote(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all comments associated with a note.
         * @summary Get all comments for a note
         * @param {NotesApiGetNoteCommentsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getNoteComments(requestParameters: NotesApiGetNoteCommentsRequest, ): Promise<GetCommentsResponse200> {
            return localVarFp.getNoteComments(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all notes.
         * @summary Get all notes
         * @param {NotesApiGetNotesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getNotes(requestParameters: NotesApiGetNotesRequest = {}, ): Promise<GetNotesResponse200> {
            return localVarFp.getNotes(requestParameters.user_id, requestParameters.lead_id, requestParameters.deal_id, requestParameters.person_id, requestParameters.org_id, requestParameters.start, requestParameters.limit, requestParameters.sort, requestParameters.start_date, requestParameters.end_date, requestParameters.pinned_to_lead_flag, requestParameters.pinned_to_deal_flag, requestParameters.pinned_to_organization_flag, requestParameters.pinned_to_person_flag, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates a comment related to a note.
         * @summary Update a comment related to a note
         * @param {NotesApiUpdateCommentForNoteRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateCommentForNote(requestParameters: NotesApiUpdateCommentForNoteRequest, ): Promise<OneCommentResponse200> {
            return localVarFp.updateCommentForNote(requestParameters.id, requestParameters.commentId, requestParameters.CommentPostPutObject, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates a note.
         * @summary Update a note
         * @param {NotesApiUpdateNoteRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateNote(requestParameters: NotesApiUpdateNoteRequest, ): Promise<OneNoteResponse200> {
            return localVarFp.updateNote(requestParameters.id, requestParameters.NoteRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addNote operation in NotesApi.
 * @export
 * @interface NotesApiAddNoteRequest
 */
export interface NotesApiAddNoteRequest {
    /**
     *
     * @type {AddNoteRequest}
     * @memberof NotesApiAddNote
     */
    readonly AddNoteRequest?: AddNoteRequest
}

/**
 * Request parameters for addNoteComment operation in NotesApi.
 * @export
 * @interface NotesApiAddNoteCommentRequest
 */
export interface NotesApiAddNoteCommentRequest {
    /**
     * The ID of the note
     * @type {number}
     * @memberof NotesApiAddNoteComment
     */
    readonly id: number

    /**
     *
     * @type {CommentPostPutObject}
     * @memberof NotesApiAddNoteComment
     */
    readonly CommentPostPutObject?: CommentPostPutObject
}

/**
 * Request parameters for deleteComment operation in NotesApi.
 * @export
 * @interface NotesApiDeleteCommentRequest
 */
export interface NotesApiDeleteCommentRequest {
    /**
     * The ID of the note
     * @type {number}
     * @memberof NotesApiDeleteComment
     */
    readonly id: number

    /**
     * The ID of the comment
     * @type {string}
     * @memberof NotesApiDeleteComment
     */
    readonly commentId: string
}

/**
 * Request parameters for deleteNote operation in NotesApi.
 * @export
 * @interface NotesApiDeleteNoteRequest
 */
export interface NotesApiDeleteNoteRequest {
    /**
     * The ID of the note
     * @type {number}
     * @memberof NotesApiDeleteNote
     */
    readonly id: number
}

/**
 * Request parameters for getComment operation in NotesApi.
 * @export
 * @interface NotesApiGetCommentRequest
 */
export interface NotesApiGetCommentRequest {
    /**
     * The ID of the note
     * @type {number}
     * @memberof NotesApiGetComment
     */
    readonly id: number

    /**
     * The ID of the comment
     * @type {string}
     * @memberof NotesApiGetComment
     */
    readonly commentId: string
}

/**
 * Request parameters for getNote operation in NotesApi.
 * @export
 * @interface NotesApiGetNoteRequest
 */
export interface NotesApiGetNoteRequest {
    /**
     * The ID of the note
     * @type {number}
     * @memberof NotesApiGetNote
     */
    readonly id: number
}

/**
 * Request parameters for getNoteComments operation in NotesApi.
 * @export
 * @interface NotesApiGetNoteCommentsRequest
 */
export interface NotesApiGetNoteCommentsRequest {
    /**
     * The ID of the note
     * @type {number}
     * @memberof NotesApiGetNoteComments
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof NotesApiGetNoteComments
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof NotesApiGetNoteComments
     */
    readonly limit?: number
}

/**
 * Request parameters for getNotes operation in NotesApi.
 * @export
 * @interface NotesApiGetNotesRequest
 */
export interface NotesApiGetNotesRequest {
    /**
     * The ID of the user whose notes to fetch. If omitted, notes by all users will be returned.
     * @type {number}
     * @memberof NotesApiGetNotes
     */
    readonly user_id?: number

    /**
     * The ID of the lead which notes to fetch. If omitted, notes about all leads will be returned.
     * @type {string}
     * @memberof NotesApiGetNotes
     */
    readonly lead_id?: string

    /**
     * The ID of the deal which notes to fetch. If omitted, notes about all deals will be returned.
     * @type {number}
     * @memberof NotesApiGetNotes
     */
    readonly deal_id?: number

    /**
     * The ID of the person whose notes to fetch. If omitted, notes about all persons will be returned.
     * @type {number}
     * @memberof NotesApiGetNotes
     */
    readonly person_id?: number

    /**
     * The ID of the organization which notes to fetch. If omitted, notes about all organizations will be returned.
     * @type {number}
     * @memberof NotesApiGetNotes
     */
    readonly org_id?: number

    /**
     * Pagination start
     * @type {number}
     * @memberof NotesApiGetNotes
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof NotesApiGetNotes
     */
    readonly limit?: number

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;content&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
     * @type {string}
     * @memberof NotesApiGetNotes
     */
    readonly sort?: string

    /**
     * The date in format of YYYY-MM-DD from which notes to fetch
     * @type {string}
     * @memberof NotesApiGetNotes
     */
    readonly start_date?: string

    /**
     * The date in format of YYYY-MM-DD until which notes to fetch to
     * @type {string}
     * @memberof NotesApiGetNotes
     */
    readonly end_date?: string

    /**
     * If set, the results are filtered by note to lead pinning state
     * @type {0 | 1}
     * @memberof NotesApiGetNotes
     */
    readonly pinned_to_lead_flag?: 0 | 1

    /**
     * If set, the results are filtered by note to deal pinning state
     * @type {0 | 1}
     * @memberof NotesApiGetNotes
     */
    readonly pinned_to_deal_flag?: 0 | 1

    /**
     * If set, the results are filtered by note to organization pinning state
     * @type {0 | 1}
     * @memberof NotesApiGetNotes
     */
    readonly pinned_to_organization_flag?: 0 | 1

    /**
     * If set, the results are filtered by note to person pinning state
     * @type {0 | 1}
     * @memberof NotesApiGetNotes
     */
    readonly pinned_to_person_flag?: 0 | 1
}

/**
 * Request parameters for updateCommentForNote operation in NotesApi.
 * @export
 * @interface NotesApiUpdateCommentForNoteRequest
 */
export interface NotesApiUpdateCommentForNoteRequest {
    /**
     * The ID of the note
     * @type {number}
     * @memberof NotesApiUpdateCommentForNote
     */
    readonly id: number

    /**
     * The ID of the comment
     * @type {string}
     * @memberof NotesApiUpdateCommentForNote
     */
    readonly commentId: string

    /**
     *
     * @type {CommentPostPutObject}
     * @memberof NotesApiUpdateCommentForNote
     */
    readonly CommentPostPutObject?: CommentPostPutObject
}

/**
 * Request parameters for updateNote operation in NotesApi.
 * @export
 * @interface NotesApiUpdateNoteRequest
 */
export interface NotesApiUpdateNoteRequest {
    /**
     * The ID of the note
     * @type {number}
     * @memberof NotesApiUpdateNote
     */
    readonly id: number

    /**
     *
     * @type {NoteRequest}
     * @memberof NotesApiUpdateNote
     */
    readonly NoteRequest?: NoteRequest
}

/**
 * NotesApi - object-oriented interface
 * @export
 * @class NotesApi
 * @extends {BaseAPI}
 */
export class NotesApi extends BaseAPI {
    /**
     * Adds a new note.
     * @summary Add a note
     * @param {NotesApiAddNoteRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public addNote(requestParameters: NotesApiAddNoteRequest = {}, ) {
        return NotesApiFp(this.configuration).addNote(requestParameters.AddNoteRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new comment to a note.
     * @summary Add a comment to a note
     * @param {NotesApiAddNoteCommentRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public addNoteComment(requestParameters: NotesApiAddNoteCommentRequest, ) {
        return NotesApiFp(this.configuration).addNoteComment(requestParameters.id, requestParameters.CommentPostPutObject, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a comment.
     * @summary Delete a comment related to a note
     * @param {NotesApiDeleteCommentRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public deleteComment(requestParameters: NotesApiDeleteCommentRequest, ) {
        return NotesApiFp(this.configuration).deleteComment(requestParameters.id, requestParameters.commentId, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific note.
     * @summary Delete a note
     * @param {NotesApiDeleteNoteRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public deleteNote(requestParameters: NotesApiDeleteNoteRequest, ) {
        return NotesApiFp(this.configuration).deleteNote(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a comment.
     * @summary Get one comment
     * @param {NotesApiGetCommentRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public getComment(requestParameters: NotesApiGetCommentRequest, ) {
        return NotesApiFp(this.configuration).getComment(requestParameters.id, requestParameters.commentId, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details about a specific note.
     * @summary Get one note
     * @param {NotesApiGetNoteRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public getNote(requestParameters: NotesApiGetNoteRequest, ) {
        return NotesApiFp(this.configuration).getNote(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all comments associated with a note.
     * @summary Get all comments for a note
     * @param {NotesApiGetNoteCommentsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public getNoteComments(requestParameters: NotesApiGetNoteCommentsRequest, ) {
        return NotesApiFp(this.configuration).getNoteComments(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all notes.
     * @summary Get all notes
     * @param {NotesApiGetNotesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public getNotes(requestParameters: NotesApiGetNotesRequest = {}, ) {
        return NotesApiFp(this.configuration).getNotes(requestParameters.user_id, requestParameters.lead_id, requestParameters.deal_id, requestParameters.person_id, requestParameters.org_id, requestParameters.start, requestParameters.limit, requestParameters.sort, requestParameters.start_date, requestParameters.end_date, requestParameters.pinned_to_lead_flag, requestParameters.pinned_to_deal_flag, requestParameters.pinned_to_organization_flag, requestParameters.pinned_to_person_flag, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a comment related to a note.
     * @summary Update a comment related to a note
     * @param {NotesApiUpdateCommentForNoteRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public updateCommentForNote(requestParameters: NotesApiUpdateCommentForNoteRequest, ) {
        return NotesApiFp(this.configuration).updateCommentForNote(requestParameters.id, requestParameters.commentId, requestParameters.CommentPostPutObject, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a note.
     * @summary Update a note
     * @param {NotesApiUpdateNoteRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public updateNote(requestParameters: NotesApiUpdateNoteRequest, ) {
        return NotesApiFp(this.configuration).updateNote(requestParameters.id, requestParameters.NoteRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationFieldsApi - axios parameter creator
 * @export
 */
export const OrganizationFieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new organization field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new organization field
         * @param {CreateFieldRequest} [CreateFieldRequest]

         * @throws {RequiredError}
         */
        addOrganizationField: async (CreateFieldRequest?: CreateFieldRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/organizationFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(CreateFieldRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete an organization field
         * @param {number} id The ID of the field

         * @throws {RequiredError}
         */
        deleteOrganizationField: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationField', 'id', id)
            const localVarPath = `/organizationFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple organization fields in bulk
         * @param {string} ids The comma-separated field IDs to delete

         * @throws {RequiredError}
         */
        deleteOrganizationFields: async (ids: string, ): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteOrganizationFields', 'ids', ids)
            const localVarPath = `/organizationFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific organization field.
         * @summary Get one organization field
         * @param {number} id The ID of the field

         * @throws {RequiredError}
         */
        getOrganizationField: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationField', 'id', id)
            const localVarPath = `/organizationFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full", "admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all organization fields.
         * @summary Get all organization fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getOrganizationFields: async (start?: number, limit?: number, ): Promise<RequestArgs> => {
            const localVarPath = `/organizationFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full", "admin"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an organization field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
         * @summary Update an organization field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest} [UpdateFieldRequest]

         * @throws {RequiredError}
         */
        updateOrganizationField: async (id: number, UpdateFieldRequest?: UpdateFieldRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOrganizationField', 'id', id)
            const localVarPath = `/organizationFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateFieldRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationFieldsApi - functional programming interface
 * @export
 */
export const OrganizationFieldsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = OrganizationFieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new organization field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new organization field
         * @param {CreateFieldRequest} [CreateFieldRequest]

         * @throws {RequiredError}
         */
        async addOrganizationField(CreateFieldRequest?: CreateFieldRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<FieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganizationField(CreateFieldRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete an organization field
         * @param {number} id The ID of the field

         * @throws {RequiredError}
         */
        async deleteOrganizationField(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteFieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationField(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple organization fields in bulk
         * @param {string} ids The comma-separated field IDs to delete

         * @throws {RequiredError}
         */
        async deleteOrganizationFields(ids: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteFieldsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationFields(ids, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about a specific organization field.
         * @summary Get one organization field
         * @param {number} id The ID of the field

         * @throws {RequiredError}
         */
        async getOrganizationField(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<FieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationField(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all organization fields.
         * @summary Get all organization fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getOrganizationFields(start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<FieldsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationFields(start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an organization field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
         * @summary Update an organization field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest} [UpdateFieldRequest]

         * @throws {RequiredError}
         */
        async updateOrganizationField(id: number, UpdateFieldRequest?: UpdateFieldRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<FieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationField(id, UpdateFieldRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationFieldsApi - factory interface
 * @export
 */
export const OrganizationFieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationFieldsApiFp(configuration)
    return {
        /**
         * Adds a new organization field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new organization field
         * @param {OrganizationFieldsApiAddOrganizationFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addOrganizationField(requestParameters: OrganizationFieldsApiAddOrganizationFieldRequest = {}, ): Promise<FieldResponse200> {
            return localVarFp.addOrganizationField(requestParameters.CreateFieldRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete an organization field
         * @param {OrganizationFieldsApiDeleteOrganizationFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteOrganizationField(requestParameters: OrganizationFieldsApiDeleteOrganizationFieldRequest, ): Promise<DeleteFieldResponse200> {
            return localVarFp.deleteOrganizationField(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple organization fields in bulk
         * @param {OrganizationFieldsApiDeleteOrganizationFieldsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteOrganizationFields(requestParameters: OrganizationFieldsApiDeleteOrganizationFieldsRequest, ): Promise<DeleteFieldsResponse200> {
            return localVarFp.deleteOrganizationFields(requestParameters.ids, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about a specific organization field.
         * @summary Get one organization field
         * @param {OrganizationFieldsApiGetOrganizationFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizationField(requestParameters: OrganizationFieldsApiGetOrganizationFieldRequest, ): Promise<FieldResponse200> {
            return localVarFp.getOrganizationField(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all organization fields.
         * @summary Get all organization fields
         * @param {OrganizationFieldsApiGetOrganizationFieldsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizationFields(requestParameters: OrganizationFieldsApiGetOrganizationFieldsRequest = {}, ): Promise<FieldsResponse200> {
            return localVarFp.getOrganizationFields(requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates an organization field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
         * @summary Update an organization field
         * @param {OrganizationFieldsApiUpdateOrganizationFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateOrganizationField(requestParameters: OrganizationFieldsApiUpdateOrganizationFieldRequest, ): Promise<FieldResponse200> {
            return localVarFp.updateOrganizationField(requestParameters.id, requestParameters.UpdateFieldRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addOrganizationField operation in OrganizationFieldsApi.
 * @export
 * @interface OrganizationFieldsApiAddOrganizationFieldRequest
 */
export interface OrganizationFieldsApiAddOrganizationFieldRequest {
    /**
     *
     * @type {CreateFieldRequest}
     * @memberof OrganizationFieldsApiAddOrganizationField
     */
    readonly CreateFieldRequest?: CreateFieldRequest
}

/**
 * Request parameters for deleteOrganizationField operation in OrganizationFieldsApi.
 * @export
 * @interface OrganizationFieldsApiDeleteOrganizationFieldRequest
 */
export interface OrganizationFieldsApiDeleteOrganizationFieldRequest {
    /**
     * The ID of the field
     * @type {number}
     * @memberof OrganizationFieldsApiDeleteOrganizationField
     */
    readonly id: number
}

/**
 * Request parameters for deleteOrganizationFields operation in OrganizationFieldsApi.
 * @export
 * @interface OrganizationFieldsApiDeleteOrganizationFieldsRequest
 */
export interface OrganizationFieldsApiDeleteOrganizationFieldsRequest {
    /**
     * The comma-separated field IDs to delete
     * @type {string}
     * @memberof OrganizationFieldsApiDeleteOrganizationFields
     */
    readonly ids: string
}

/**
 * Request parameters for getOrganizationField operation in OrganizationFieldsApi.
 * @export
 * @interface OrganizationFieldsApiGetOrganizationFieldRequest
 */
export interface OrganizationFieldsApiGetOrganizationFieldRequest {
    /**
     * The ID of the field
     * @type {number}
     * @memberof OrganizationFieldsApiGetOrganizationField
     */
    readonly id: number
}

/**
 * Request parameters for getOrganizationFields operation in OrganizationFieldsApi.
 * @export
 * @interface OrganizationFieldsApiGetOrganizationFieldsRequest
 */
export interface OrganizationFieldsApiGetOrganizationFieldsRequest {
    /**
     * Pagination start
     * @type {number}
     * @memberof OrganizationFieldsApiGetOrganizationFields
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof OrganizationFieldsApiGetOrganizationFields
     */
    readonly limit?: number
}

/**
 * Request parameters for updateOrganizationField operation in OrganizationFieldsApi.
 * @export
 * @interface OrganizationFieldsApiUpdateOrganizationFieldRequest
 */
export interface OrganizationFieldsApiUpdateOrganizationFieldRequest {
    /**
     * The ID of the field
     * @type {number}
     * @memberof OrganizationFieldsApiUpdateOrganizationField
     */
    readonly id: number

    /**
     *
     * @type {UpdateFieldRequest}
     * @memberof OrganizationFieldsApiUpdateOrganizationField
     */
    readonly UpdateFieldRequest?: UpdateFieldRequest
}

/**
 * OrganizationFieldsApi - object-oriented interface
 * @export
 * @class OrganizationFieldsApi
 * @extends {BaseAPI}
 */
export class OrganizationFieldsApi extends BaseAPI {
    /**
     * Adds a new organization field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
     * @summary Add a new organization field
     * @param {OrganizationFieldsApiAddOrganizationFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationFieldsApi
     */
    public addOrganizationField(requestParameters: OrganizationFieldsApiAddOrganizationFieldRequest = {}, ) {
        return OrganizationFieldsApiFp(this.configuration).addOrganizationField(requestParameters.CreateFieldRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
     * @summary Delete an organization field
     * @param {OrganizationFieldsApiDeleteOrganizationFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationFieldsApi
     */
    public deleteOrganizationField(requestParameters: OrganizationFieldsApiDeleteOrganizationFieldRequest, ) {
        return OrganizationFieldsApiFp(this.configuration).deleteOrganizationField(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks multiple fields as deleted.
     * @summary Delete multiple organization fields in bulk
     * @param {OrganizationFieldsApiDeleteOrganizationFieldsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationFieldsApi
     */
    public deleteOrganizationFields(requestParameters: OrganizationFieldsApiDeleteOrganizationFieldsRequest, ) {
        return OrganizationFieldsApiFp(this.configuration).deleteOrganizationFields(requestParameters.ids, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about a specific organization field.
     * @summary Get one organization field
     * @param {OrganizationFieldsApiGetOrganizationFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationFieldsApi
     */
    public getOrganizationField(requestParameters: OrganizationFieldsApiGetOrganizationFieldRequest, ) {
        return OrganizationFieldsApiFp(this.configuration).getOrganizationField(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all organization fields.
     * @summary Get all organization fields
     * @param {OrganizationFieldsApiGetOrganizationFieldsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationFieldsApi
     */
    public getOrganizationFields(requestParameters: OrganizationFieldsApiGetOrganizationFieldsRequest = {}, ) {
        return OrganizationFieldsApiFp(this.configuration).getOrganizationFields(requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an organization field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
     * @summary Update an organization field
     * @param {OrganizationFieldsApiUpdateOrganizationFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationFieldsApi
     */
    public updateOrganizationField(requestParameters: OrganizationFieldsApiUpdateOrganizationFieldRequest, ) {
        return OrganizationFieldsApiFp(this.configuration).updateOrganizationField(requestParameters.id, requestParameters.UpdateFieldRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationRelationshipsApi - axios parameter creator
 * @export
 */
export const OrganizationRelationshipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates and returns an organization relationship.
         * @summary Create an organization relationship
         * @param {AddOrganizationRelationshipRequest} [AddOrganizationRelationshipRequest]

         * @throws {RequiredError}
         */
        addOrganizationRelationship: async (AddOrganizationRelationshipRequest?: AddOrganizationRelationshipRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/organizationRelationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddOrganizationRelationshipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an organization relationship and returns the deleted ID.
         * @summary Delete an organization relationship
         * @param {number} id The ID of the organization relationship

         * @throws {RequiredError}
         */
        deleteOrganizationRelationship: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationRelationship', 'id', id)
            const localVarPath = `/organizationRelationships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds and returns an organization relationship from its ID.
         * @summary Get one organization relationship
         * @param {number} id The ID of the organization relationship
         * @param {number} [org_id] The ID of the base organization for the returned calculated values

         * @throws {RequiredError}
         */
        getOrganizationRelationship: async (id: number, org_id?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationRelationship', 'id', id)
            const localVarPath = `/organizationRelationships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all of the relationships for a supplied organization ID.
         * @summary Get all relationships for organization
         * @param {number} org_id The ID of the organization to get relationships for

         * @throws {RequiredError}
         */
        getOrganizationRelationships: async (org_id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'org_id' is not null or undefined
            assertParamExists('getOrganizationRelationships', 'org_id', org_id)
            const localVarPath = `/organizationRelationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates and returns an organization relationship.
         * @summary Update an organization relationship
         * @param {number} id The ID of the organization relationship
         * @param {OrganizationRelationship} [OrganizationRelationship]

         * @throws {RequiredError}
         */
        updateOrganizationRelationship: async (id: number, OrganizationRelationship?: OrganizationRelationship, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOrganizationRelationship', 'id', id)
            const localVarPath = `/organizationRelationships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(OrganizationRelationship, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationRelationshipsApi - functional programming interface
 * @export
 */
export const OrganizationRelationshipsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = OrganizationRelationshipsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates and returns an organization relationship.
         * @summary Create an organization relationship
         * @param {AddOrganizationRelationshipRequest} [AddOrganizationRelationshipRequest]

         * @throws {RequiredError}
         */
        async addOrganizationRelationship(AddOrganizationRelationshipRequest?: AddOrganizationRelationshipRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddOrganizationRelationshipResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganizationRelationship(AddOrganizationRelationshipRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an organization relationship and returns the deleted ID.
         * @summary Delete an organization relationship
         * @param {number} id The ID of the organization relationship

         * @throws {RequiredError}
         */
        async deleteOrganizationRelationship(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteOrganizationRelationshipResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationRelationship(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finds and returns an organization relationship from its ID.
         * @summary Get one organization relationship
         * @param {number} id The ID of the organization relationship
         * @param {number} [org_id] The ID of the base organization for the returned calculated values

         * @throws {RequiredError}
         */
        async getOrganizationRelationship(id: number, org_id?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOrganizationRelationshipResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationRelationship(id, org_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all of the relationships for a supplied organization ID.
         * @summary Get all relationships for organization
         * @param {number} org_id The ID of the organization to get relationships for

         * @throws {RequiredError}
         */
        async getOrganizationRelationships(org_id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOrganizationRelationshipsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationRelationships(org_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates and returns an organization relationship.
         * @summary Update an organization relationship
         * @param {number} id The ID of the organization relationship
         * @param {OrganizationRelationship} [OrganizationRelationship]

         * @throws {RequiredError}
         */
        async updateOrganizationRelationship(id: number, OrganizationRelationship?: OrganizationRelationship, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdateOrganizationRelationshipResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationRelationship(id, OrganizationRelationship, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationRelationshipsApi - factory interface
 * @export
 */
export const OrganizationRelationshipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationRelationshipsApiFp(configuration)
    return {
        /**
         * Creates and returns an organization relationship.
         * @summary Create an organization relationship
         * @param {OrganizationRelationshipsApiAddOrganizationRelationshipRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addOrganizationRelationship(requestParameters: OrganizationRelationshipsApiAddOrganizationRelationshipRequest = {}, ): Promise<AddOrganizationRelationshipResponse200> {
            return localVarFp.addOrganizationRelationship(requestParameters.AddOrganizationRelationshipRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an organization relationship and returns the deleted ID.
         * @summary Delete an organization relationship
         * @param {OrganizationRelationshipsApiDeleteOrganizationRelationshipRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteOrganizationRelationship(requestParameters: OrganizationRelationshipsApiDeleteOrganizationRelationshipRequest, ): Promise<DeleteOrganizationRelationshipResponse200> {
            return localVarFp.deleteOrganizationRelationship(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Finds and returns an organization relationship from its ID.
         * @summary Get one organization relationship
         * @param {OrganizationRelationshipsApiGetOrganizationRelationshipRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizationRelationship(requestParameters: OrganizationRelationshipsApiGetOrganizationRelationshipRequest, ): Promise<GetOrganizationRelationshipResponse200> {
            return localVarFp.getOrganizationRelationship(requestParameters.id, requestParameters.org_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Gets all of the relationships for a supplied organization ID.
         * @summary Get all relationships for organization
         * @param {OrganizationRelationshipsApiGetOrganizationRelationshipsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizationRelationships(requestParameters: OrganizationRelationshipsApiGetOrganizationRelationshipsRequest, ): Promise<GetOrganizationRelationshipsResponse200> {
            return localVarFp.getOrganizationRelationships(requestParameters.org_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates and returns an organization relationship.
         * @summary Update an organization relationship
         * @param {OrganizationRelationshipsApiUpdateOrganizationRelationshipRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateOrganizationRelationship(requestParameters: OrganizationRelationshipsApiUpdateOrganizationRelationshipRequest, ): Promise<UpdateOrganizationRelationshipResponse200> {
            return localVarFp.updateOrganizationRelationship(requestParameters.id, requestParameters.OrganizationRelationship, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addOrganizationRelationship operation in OrganizationRelationshipsApi.
 * @export
 * @interface OrganizationRelationshipsApiAddOrganizationRelationshipRequest
 */
export interface OrganizationRelationshipsApiAddOrganizationRelationshipRequest {
    /**
     *
     * @type {AddOrganizationRelationshipRequest}
     * @memberof OrganizationRelationshipsApiAddOrganizationRelationship
     */
    readonly AddOrganizationRelationshipRequest?: AddOrganizationRelationshipRequest
}

/**
 * Request parameters for deleteOrganizationRelationship operation in OrganizationRelationshipsApi.
 * @export
 * @interface OrganizationRelationshipsApiDeleteOrganizationRelationshipRequest
 */
export interface OrganizationRelationshipsApiDeleteOrganizationRelationshipRequest {
    /**
     * The ID of the organization relationship
     * @type {number}
     * @memberof OrganizationRelationshipsApiDeleteOrganizationRelationship
     */
    readonly id: number
}

/**
 * Request parameters for getOrganizationRelationship operation in OrganizationRelationshipsApi.
 * @export
 * @interface OrganizationRelationshipsApiGetOrganizationRelationshipRequest
 */
export interface OrganizationRelationshipsApiGetOrganizationRelationshipRequest {
    /**
     * The ID of the organization relationship
     * @type {number}
     * @memberof OrganizationRelationshipsApiGetOrganizationRelationship
     */
    readonly id: number

    /**
     * The ID of the base organization for the returned calculated values
     * @type {number}
     * @memberof OrganizationRelationshipsApiGetOrganizationRelationship
     */
    readonly org_id?: number
}

/**
 * Request parameters for getOrganizationRelationships operation in OrganizationRelationshipsApi.
 * @export
 * @interface OrganizationRelationshipsApiGetOrganizationRelationshipsRequest
 */
export interface OrganizationRelationshipsApiGetOrganizationRelationshipsRequest {
    /**
     * The ID of the organization to get relationships for
     * @type {number}
     * @memberof OrganizationRelationshipsApiGetOrganizationRelationships
     */
    readonly org_id: number
}

/**
 * Request parameters for updateOrganizationRelationship operation in OrganizationRelationshipsApi.
 * @export
 * @interface OrganizationRelationshipsApiUpdateOrganizationRelationshipRequest
 */
export interface OrganizationRelationshipsApiUpdateOrganizationRelationshipRequest {
    /**
     * The ID of the organization relationship
     * @type {number}
     * @memberof OrganizationRelationshipsApiUpdateOrganizationRelationship
     */
    readonly id: number

    /**
     *
     * @type {OrganizationRelationship}
     * @memberof OrganizationRelationshipsApiUpdateOrganizationRelationship
     */
    readonly OrganizationRelationship?: OrganizationRelationship
}

/**
 * OrganizationRelationshipsApi - object-oriented interface
 * @export
 * @class OrganizationRelationshipsApi
 * @extends {BaseAPI}
 */
export class OrganizationRelationshipsApi extends BaseAPI {
    /**
     * Creates and returns an organization relationship.
     * @summary Create an organization relationship
     * @param {OrganizationRelationshipsApiAddOrganizationRelationshipRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApi
     */
    public addOrganizationRelationship(requestParameters: OrganizationRelationshipsApiAddOrganizationRelationshipRequest = {}, ) {
        return OrganizationRelationshipsApiFp(this.configuration).addOrganizationRelationship(requestParameters.AddOrganizationRelationshipRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an organization relationship and returns the deleted ID.
     * @summary Delete an organization relationship
     * @param {OrganizationRelationshipsApiDeleteOrganizationRelationshipRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApi
     */
    public deleteOrganizationRelationship(requestParameters: OrganizationRelationshipsApiDeleteOrganizationRelationshipRequest, ) {
        return OrganizationRelationshipsApiFp(this.configuration).deleteOrganizationRelationship(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finds and returns an organization relationship from its ID.
     * @summary Get one organization relationship
     * @param {OrganizationRelationshipsApiGetOrganizationRelationshipRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApi
     */
    public getOrganizationRelationship(requestParameters: OrganizationRelationshipsApiGetOrganizationRelationshipRequest, ) {
        return OrganizationRelationshipsApiFp(this.configuration).getOrganizationRelationship(requestParameters.id, requestParameters.org_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all of the relationships for a supplied organization ID.
     * @summary Get all relationships for organization
     * @param {OrganizationRelationshipsApiGetOrganizationRelationshipsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApi
     */
    public getOrganizationRelationships(requestParameters: OrganizationRelationshipsApiGetOrganizationRelationshipsRequest, ) {
        return OrganizationRelationshipsApiFp(this.configuration).getOrganizationRelationships(requestParameters.org_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates and returns an organization relationship.
     * @summary Update an organization relationship
     * @param {OrganizationRelationshipsApiUpdateOrganizationRelationshipRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApi
     */
    public updateOrganizationRelationship(requestParameters: OrganizationRelationshipsApiUpdateOrganizationRelationshipRequest, ) {
        return OrganizationRelationshipsApiFp(this.configuration).updateOrganizationRelationship(requestParameters.id, requestParameters.OrganizationRelationship, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new organization. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the organizationFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-organization\" target=\"_blank\" rel=\"noopener noreferrer\">adding an organization</a>.
         * @summary Add an organization
         * @param {AddOrganizationRequest} [AddOrganizationRequest]

         * @throws {RequiredError}
         */
        addOrganization: async (AddOrganizationRequest?: AddOrganizationRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddOrganizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a follower to an organization.
         * @summary Add a follower to an organization
         * @param {number} id The ID of the organization
         * @param {AddOrganizationFollowerRequest} [AddOrganizationFollowerRequest]

         * @throws {RequiredError}
         */
        addOrganizationFollower: async (id: number, AddOrganizationFollowerRequest?: AddOrganizationFollowerRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addOrganizationFollower', 'id', id)
            const localVarPath = `/organizations/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddOrganizationFollowerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an organization as deleted. After 30 days, the organization will be permanently deleted.
         * @summary Delete an organization
         * @param {number} id The ID of the organization

         * @throws {RequiredError}
         */
        deleteOrganization: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganization', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a follower from an organization. You can retrieve the `follower_id` from the <a href=\"https://developers.pipedrive.com/docs/api/v1/Organizations#getOrganizationFollowers\">List followers of an organization</a> endpoint.
         * @summary Delete a follower from an organization
         * @param {number} id The ID of the organization
         * @param {number} follower_id The ID of the follower

         * @throws {RequiredError}
         */
        deleteOrganizationFollower: async (id: number, follower_id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationFollower', 'id', id)
            // verify required parameter 'follower_id' is not null or undefined
            assertParamExists('deleteOrganizationFollower', 'follower_id', follower_id)
            const localVarPath = `/organizations/{id}/followers/{follower_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"follower_id"}}`, encodeURIComponent(String(follower_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple organizations as deleted. After 30 days, the organizations will be permanently deleted.
         * @summary Delete multiple organizations in bulk
         * @param {string} ids The comma-separated IDs that will be deleted

         * @throws {RequiredError}
         */
        deleteOrganizations: async (ids: string, ): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteOrganizations', 'ids', ids)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of an organization. Note that this also returns some additional fields which are not present when asking for all organizations. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of organizationFields.
         * @summary Get details of an organization
         * @param {number} id The ID of the organization

         * @throws {RequiredError}
         */
        getOrganization: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganization', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists activities associated with an organization.
         * @summary List activities associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {0 | 1} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result

         * @throws {RequiredError}
         */
        getOrganizationActivities: async (id: number, start?: number, limit?: number, done?: 0 | 1, exclude?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationActivities', 'id', id)
            const localVarPath = `/organizations/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:read", "activities:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (done !== undefined) {
                localVarQueryParameter['done'] = done;
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists deals associated with an organization.
         * @summary List deals associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {0 | 1} [only_primary_association] If set, only deals that are directly associated to the organization are fetched. If not set (default), all deals are fetched that are either directly or indirectly related to the organization. Indirect relations include relations through custom, organization-type fields and through persons of the given organization.

         * @throws {RequiredError}
         */
        getOrganizationDeals: async (id: number, start?: number, limit?: number, status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted', sort?: string, only_primary_association?: 0 | 1, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationDeals', 'id', id)
            const localVarPath = `/organizations/{id}/deals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (only_primary_association !== undefined) {
                localVarQueryParameter['only_primary_association'] = only_primary_association;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists files associated with an organization.
         * @summary List files attached to an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.

         * @throws {RequiredError}
         */
        getOrganizationFiles: async (id: number, start?: number, limit?: number, sort?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationFiles', 'id', id)
            const localVarPath = `/organizations/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the followers of an organization.
         * @summary List followers of an organization
         * @param {number} id The ID of the organization

         * @throws {RequiredError}
         */
        getOrganizationFollowers: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationFollowers', 'id', id)
            const localVarPath = `/organizations/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists mail messages associated with an organization.
         * @summary List mail messages associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getOrganizationMailMessages: async (id: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationMailMessages', 'id', id)
            const localVarPath = `/organizations/{id}/mailMessages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["mail:read", "mail:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists persons associated with an organization.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List persons of an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getOrganizationPersons: async (id: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationPersons', 'id', id)
            const localVarPath = `/organizations/{id}/persons`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists updates about an organization.
         * @summary List updates about an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted, returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - activity, plannedActivity, note, file, change, deal, follower, participant, mailMessage, mailMessageWithAttachment, invoice, activityFile, document)

         * @throws {RequiredError}
         */
        getOrganizationUpdates: async (id: number, start?: number, limit?: number, all_changes?: string, items?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationUpdates', 'id', id)
            const localVarPath = `/organizations/{id}/flow`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["recents:read"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (all_changes !== undefined) {
                localVarQueryParameter['all_changes'] = all_changes;
            }

            if (items !== undefined) {
                localVarQueryParameter['items'] = items;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List users permitted to access an organization.
         * @summary List permitted users
         * @param {number} id The ID of the organization

         * @throws {RequiredError}
         */
        getOrganizationUsers: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationUsers', 'id', id)
            const localVarPath = `/organizations/{id}/permittedUsers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all organizations.
         * @summary Get all organizations
         * @param {number} [user_id] If supplied, only organizations owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [first_char] If supplied, only organizations whose name starts with the specified letter will be returned (case-insensitive)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).

         * @throws {RequiredError}
         */
        getOrganizations: async (user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (first_char !== undefined) {
                localVarQueryParameter['first_char'] = first_char;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all organizations. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all organizations (BETA)
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [since] The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {string} [until] The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {number} [owner_id] If supplied, only organizations owned by the given user will be returned
         * @param {string} [first_char] If supplied, only organizations whose name starts with the specified letter will be returned (case-insensitive)

         * @throws {RequiredError}
         */
        getOrganizationsCollection: async (cursor?: string, limit?: number, since?: string, until?: string, owner_id?: number, first_char?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/organizations/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }

            if (owner_id !== undefined) {
                localVarQueryParameter['owner_id'] = owner_id;
            }

            if (first_char !== undefined) {
                localVarQueryParameter['first_char'] = first_char;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merges an organization with another organization. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-organizations\" target=\"_blank\" rel=\"noopener noreferrer\">merging two organizations</a>.
         * @summary Merge two organizations
         * @param {number} id The ID of the organization
         * @param {MergeOrganizationsRequest} [MergeOrganizationsRequest]

         * @throws {RequiredError}
         */
        mergeOrganizations: async (id: number, MergeOrganizationsRequest?: MergeOrganizationsRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeOrganizations', 'id', id)
            const localVarPath = `/organizations/{id}/merge`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(MergeOrganizationsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search organizations
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'address' | 'custom_fields' | 'notes' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        searchOrganization: async (term: string, fields?: 'address' | 'custom_fields' | 'notes' | 'name', exact_match?: boolean, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchOrganization', 'term', term)
            const localVarPath = `/organizations/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full", "search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of an organization.
         * @summary Update an organization
         * @param {number} id The ID of the organization
         * @param {UpdateOrganizationRequest} [UpdateOrganizationRequest]

         * @throws {RequiredError}
         */
        updateOrganization: async (id: number, UpdateOrganizationRequest?: UpdateOrganizationRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOrganization', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateOrganizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new organization. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the organizationFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-organization\" target=\"_blank\" rel=\"noopener noreferrer\">adding an organization</a>.
         * @summary Add an organization
         * @param {AddOrganizationRequest} [AddOrganizationRequest]

         * @throws {RequiredError}
         */
        async addOrganization(AddOrganizationRequest?: AddOrganizationRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddOrganizationResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganization(AddOrganizationRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a follower to an organization.
         * @summary Add a follower to an organization
         * @param {number} id The ID of the organization
         * @param {AddOrganizationFollowerRequest} [AddOrganizationFollowerRequest]

         * @throws {RequiredError}
         */
        async addOrganizationFollower(id: number, AddOrganizationFollowerRequest?: AddOrganizationFollowerRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddOrganizationFollowerResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganizationFollower(id, AddOrganizationFollowerRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks an organization as deleted. After 30 days, the organization will be permanently deleted.
         * @summary Delete an organization
         * @param {number} id The ID of the organization

         * @throws {RequiredError}
         */
        async deleteOrganization(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteOrganizationResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a follower from an organization. You can retrieve the `follower_id` from the <a href=\"https://developers.pipedrive.com/docs/api/v1/Organizations#getOrganizationFollowers\">List followers of an organization</a> endpoint.
         * @summary Delete a follower from an organization
         * @param {number} id The ID of the organization
         * @param {number} follower_id The ID of the follower

         * @throws {RequiredError}
         */
        async deleteOrganizationFollower(id: number, follower_id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteOrganizationFollowerResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationFollower(id, follower_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks multiple organizations as deleted. After 30 days, the organizations will be permanently deleted.
         * @summary Delete multiple organizations in bulk
         * @param {string} ids The comma-separated IDs that will be deleted

         * @throws {RequiredError}
         */
        async deleteOrganizations(ids: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteOrganizationsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizations(ids, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of an organization. Note that this also returns some additional fields which are not present when asking for all organizations. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of organizationFields.
         * @summary Get details of an organization
         * @param {number} id The ID of the organization

         * @throws {RequiredError}
         */
        async getOrganization(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOrganizationResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists activities associated with an organization.
         * @summary List activities associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {0 | 1} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result

         * @throws {RequiredError}
         */
        async getOrganizationActivities(id: number, start?: number, limit?: number, done?: 0 | 1, exclude?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedActivitiesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationActivities(id, start, limit, done, exclude, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists deals associated with an organization.
         * @summary List deals associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {0 | 1} [only_primary_association] If set, only deals that are directly associated to the organization are fetched. If not set (default), all deals are fetched that are either directly or indirectly related to the organization. Indirect relations include relations through custom, organization-type fields and through persons of the given organization.

         * @throws {RequiredError}
         */
        async getOrganizationDeals(id: number, start?: number, limit?: number, status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted', sort?: string, only_primary_association?: 0 | 1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedDealsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationDeals(id, start, limit, status, sort, only_primary_association, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists files associated with an organization.
         * @summary List files attached to an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.

         * @throws {RequiredError}
         */
        async getOrganizationFiles(id: number, start?: number, limit?: number, sort?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedFilesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationFiles(id, start, limit, sort, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the followers of an organization.
         * @summary List followers of an organization
         * @param {number} id The ID of the organization

         * @throws {RequiredError}
         */
        async getOrganizationFollowers(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedFollowersResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationFollowers(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists mail messages associated with an organization.
         * @summary List mail messages associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getOrganizationMailMessages(id: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedMailMessagesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationMailMessages(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists persons associated with an organization.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List persons of an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getOrganizationPersons(id: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListPersonsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationPersons(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists updates about an organization.
         * @summary List updates about an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted, returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - activity, plannedActivity, note, file, change, deal, follower, participant, mailMessage, mailMessageWithAttachment, invoice, activityFile, document)

         * @throws {RequiredError}
         */
        async getOrganizationUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedUpdatesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationUpdates(id, start, limit, all_changes, items, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List users permitted to access an organization.
         * @summary List permitted users
         * @param {number} id The ID of the organization

         * @throws {RequiredError}
         */
        async getOrganizationUsers(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListPermittedUsersResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationUsers(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all organizations.
         * @summary Get all organizations
         * @param {number} [user_id] If supplied, only organizations owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [first_char] If supplied, only organizations whose name starts with the specified letter will be returned (case-insensitive)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).

         * @throws {RequiredError}
         */
        async getOrganizations(user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOrganizationsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizations(user_id, filter_id, first_char, start, limit, sort, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all organizations. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all organizations (BETA)
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [since] The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {string} [until] The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {number} [owner_id] If supplied, only organizations owned by the given user will be returned
         * @param {string} [first_char] If supplied, only organizations whose name starts with the specified letter will be returned (case-insensitive)

         * @throws {RequiredError}
         */
        async getOrganizationsCollection(cursor?: string, limit?: number, since?: string, until?: string, owner_id?: number, first_char?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOrganizationsCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationsCollection(cursor, limit, since, until, owner_id, first_char, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Merges an organization with another organization. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-organizations\" target=\"_blank\" rel=\"noopener noreferrer\">merging two organizations</a>.
         * @summary Merge two organizations
         * @param {number} id The ID of the organization
         * @param {MergeOrganizationsRequest} [MergeOrganizationsRequest]

         * @throws {RequiredError}
         */
        async mergeOrganizations(id: number, MergeOrganizationsRequest?: MergeOrganizationsRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<MergeOrganizationsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeOrganizations(id, MergeOrganizationsRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search organizations
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'address' | 'custom_fields' | 'notes' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async searchOrganization(term: string, fields?: 'address' | 'custom_fields' | 'notes' | 'name', exact_match?: boolean, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SearchOrganizationResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchOrganization(term, fields, exact_match, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of an organization.
         * @summary Update an organization
         * @param {number} id The ID of the organization
         * @param {UpdateOrganizationRequest} [UpdateOrganizationRequest]

         * @throws {RequiredError}
         */
        async updateOrganization(id: number, UpdateOrganizationRequest?: UpdateOrganizationRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdateOrganizationResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(id, UpdateOrganizationRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * Adds a new organization. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the organizationFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-organization\" target=\"_blank\" rel=\"noopener noreferrer\">adding an organization</a>.
         * @summary Add an organization
         * @param {OrganizationsApiAddOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addOrganization(requestParameters: OrganizationsApiAddOrganizationRequest = {}, ): Promise<AddOrganizationResponse200> {
            return localVarFp.addOrganization(requestParameters.AddOrganizationRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a follower to an organization.
         * @summary Add a follower to an organization
         * @param {OrganizationsApiAddOrganizationFollowerRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addOrganizationFollower(requestParameters: OrganizationsApiAddOrganizationFollowerRequest, ): Promise<AddOrganizationFollowerResponse200> {
            return localVarFp.addOrganizationFollower(requestParameters.id, requestParameters.AddOrganizationFollowerRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks an organization as deleted. After 30 days, the organization will be permanently deleted.
         * @summary Delete an organization
         * @param {OrganizationsApiDeleteOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteOrganization(requestParameters: OrganizationsApiDeleteOrganizationRequest, ): Promise<DeleteOrganizationResponse200> {
            return localVarFp.deleteOrganization(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a follower from an organization. You can retrieve the `follower_id` from the <a href=\"https://developers.pipedrive.com/docs/api/v1/Organizations#getOrganizationFollowers\">List followers of an organization</a> endpoint.
         * @summary Delete a follower from an organization
         * @param {OrganizationsApiDeleteOrganizationFollowerRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteOrganizationFollower(requestParameters: OrganizationsApiDeleteOrganizationFollowerRequest, ): Promise<DeleteOrganizationFollowerResponse200> {
            return localVarFp.deleteOrganizationFollower(requestParameters.id, requestParameters.follower_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks multiple organizations as deleted. After 30 days, the organizations will be permanently deleted.
         * @summary Delete multiple organizations in bulk
         * @param {OrganizationsApiDeleteOrganizationsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteOrganizations(requestParameters: OrganizationsApiDeleteOrganizationsRequest, ): Promise<DeleteOrganizationsResponse200> {
            return localVarFp.deleteOrganizations(requestParameters.ids, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of an organization. Note that this also returns some additional fields which are not present when asking for all organizations. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of organizationFields.
         * @summary Get details of an organization
         * @param {OrganizationsApiGetOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganization(requestParameters: OrganizationsApiGetOrganizationRequest, ): Promise<GetOrganizationResponse200> {
            return localVarFp.getOrganization(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists activities associated with an organization.
         * @summary List activities associated with an organization
         * @param {OrganizationsApiGetOrganizationActivitiesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizationActivities(requestParameters: OrganizationsApiGetOrganizationActivitiesRequest, ): Promise<GetAssociatedActivitiesResponse200> {
            return localVarFp.getOrganizationActivities(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.done, requestParameters.exclude, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists deals associated with an organization.
         * @summary List deals associated with an organization
         * @param {OrganizationsApiGetOrganizationDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizationDeals(requestParameters: OrganizationsApiGetOrganizationDealsRequest, ): Promise<GetAssociatedDealsResponse200> {
            return localVarFp.getOrganizationDeals(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.status, requestParameters.sort, requestParameters.only_primary_association, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists files associated with an organization.
         * @summary List files attached to an organization
         * @param {OrganizationsApiGetOrganizationFilesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizationFiles(requestParameters: OrganizationsApiGetOrganizationFilesRequest, ): Promise<GetAssociatedFilesResponse200> {
            return localVarFp.getOrganizationFiles(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists the followers of an organization.
         * @summary List followers of an organization
         * @param {OrganizationsApiGetOrganizationFollowersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizationFollowers(requestParameters: OrganizationsApiGetOrganizationFollowersRequest, ): Promise<GetAssociatedFollowersResponse2001> {
            return localVarFp.getOrganizationFollowers(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists mail messages associated with an organization.
         * @summary List mail messages associated with an organization
         * @param {OrganizationsApiGetOrganizationMailMessagesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizationMailMessages(requestParameters: OrganizationsApiGetOrganizationMailMessagesRequest, ): Promise<GetAssociatedMailMessagesResponse200> {
            return localVarFp.getOrganizationMailMessages(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists persons associated with an organization.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List persons of an organization
         * @param {OrganizationsApiGetOrganizationPersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizationPersons(requestParameters: OrganizationsApiGetOrganizationPersonsRequest, ): Promise<ListPersonsResponse200> {
            return localVarFp.getOrganizationPersons(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists updates about an organization.
         * @summary List updates about an organization
         * @param {OrganizationsApiGetOrganizationUpdatesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizationUpdates(requestParameters: OrganizationsApiGetOrganizationUpdatesRequest, ): Promise<GetAssociatedUpdatesResponse200> {
            return localVarFp.getOrganizationUpdates(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.all_changes, requestParameters.items, ).then((request) => request(axios, basePath));
        },
        /**
         * List users permitted to access an organization.
         * @summary List permitted users
         * @param {OrganizationsApiGetOrganizationUsersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizationUsers(requestParameters: OrganizationsApiGetOrganizationUsersRequest, ): Promise<ListPermittedUsersResponse2001> {
            return localVarFp.getOrganizationUsers(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all organizations.
         * @summary Get all organizations
         * @param {OrganizationsApiGetOrganizationsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizations(requestParameters: OrganizationsApiGetOrganizationsRequest = {}, ): Promise<GetOrganizationsResponse200> {
            return localVarFp.getOrganizations(requestParameters.user_id, requestParameters.filter_id, requestParameters.first_char, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all organizations. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all organizations (BETA)
         * @param {OrganizationsApiGetOrganizationsCollectionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizationsCollection(requestParameters: OrganizationsApiGetOrganizationsCollectionRequest = {}, ): Promise<GetOrganizationsCollection200Response> {
            return localVarFp.getOrganizationsCollection(requestParameters.cursor, requestParameters.limit, requestParameters.since, requestParameters.until, requestParameters.owner_id, requestParameters.first_char, ).then((request) => request(axios, basePath));
        },
        /**
         * Merges an organization with another organization. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-organizations\" target=\"_blank\" rel=\"noopener noreferrer\">merging two organizations</a>.
         * @summary Merge two organizations
         * @param {OrganizationsApiMergeOrganizationsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        mergeOrganizations(requestParameters: OrganizationsApiMergeOrganizationsRequest, ): Promise<MergeOrganizationsResponse200> {
            return localVarFp.mergeOrganizations(requestParameters.id, requestParameters.MergeOrganizationsRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search organizations
         * @param {OrganizationsApiSearchOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchOrganization(requestParameters: OrganizationsApiSearchOrganizationRequest, ): Promise<SearchOrganizationResponse200> {
            return localVarFp.searchOrganization(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of an organization.
         * @summary Update an organization
         * @param {OrganizationsApiUpdateOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateOrganization(requestParameters: OrganizationsApiUpdateOrganizationRequest, ): Promise<UpdateOrganizationResponse200> {
            return localVarFp.updateOrganization(requestParameters.id, requestParameters.UpdateOrganizationRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addOrganization operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiAddOrganizationRequest
 */
export interface OrganizationsApiAddOrganizationRequest {
    /**
     *
     * @type {AddOrganizationRequest}
     * @memberof OrganizationsApiAddOrganization
     */
    readonly AddOrganizationRequest?: AddOrganizationRequest
}

/**
 * Request parameters for addOrganizationFollower operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiAddOrganizationFollowerRequest
 */
export interface OrganizationsApiAddOrganizationFollowerRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiAddOrganizationFollower
     */
    readonly id: number

    /**
     *
     * @type {AddOrganizationFollowerRequest}
     * @memberof OrganizationsApiAddOrganizationFollower
     */
    readonly AddOrganizationFollowerRequest?: AddOrganizationFollowerRequest
}

/**
 * Request parameters for deleteOrganization operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiDeleteOrganizationRequest
 */
export interface OrganizationsApiDeleteOrganizationRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiDeleteOrganization
     */
    readonly id: number
}

/**
 * Request parameters for deleteOrganizationFollower operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiDeleteOrganizationFollowerRequest
 */
export interface OrganizationsApiDeleteOrganizationFollowerRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiDeleteOrganizationFollower
     */
    readonly id: number

    /**
     * The ID of the follower
     * @type {number}
     * @memberof OrganizationsApiDeleteOrganizationFollower
     */
    readonly follower_id: number
}

/**
 * Request parameters for deleteOrganizations operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiDeleteOrganizationsRequest
 */
export interface OrganizationsApiDeleteOrganizationsRequest {
    /**
     * The comma-separated IDs that will be deleted
     * @type {string}
     * @memberof OrganizationsApiDeleteOrganizations
     */
    readonly ids: string
}

/**
 * Request parameters for getOrganization operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiGetOrganizationRequest
 */
export interface OrganizationsApiGetOrganizationRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiGetOrganization
     */
    readonly id: number
}

/**
 * Request parameters for getOrganizationActivities operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiGetOrganizationActivitiesRequest
 */
export interface OrganizationsApiGetOrganizationActivitiesRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationActivities
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationActivities
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationActivities
     */
    readonly limit?: number

    /**
     * Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both Done and Not done activities.
     * @type {0 | 1}
     * @memberof OrganizationsApiGetOrganizationActivities
     */
    readonly done?: 0 | 1

    /**
     * A comma-separated string of activity IDs to exclude from result
     * @type {string}
     * @memberof OrganizationsApiGetOrganizationActivities
     */
    readonly exclude?: string
}

/**
 * Request parameters for getOrganizationDeals operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiGetOrganizationDealsRequest
 */
export interface OrganizationsApiGetOrganizationDealsRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationDeals
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationDeals
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationDeals
     */
    readonly limit?: number

    /**
     * Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
     * @type {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'}
     * @memberof OrganizationsApiGetOrganizationDeals
     */
    readonly status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @type {string}
     * @memberof OrganizationsApiGetOrganizationDeals
     */
    readonly sort?: string

    /**
     * If set, only deals that are directly associated to the organization are fetched. If not set (default), all deals are fetched that are either directly or indirectly related to the organization. Indirect relations include relations through custom, organization-type fields and through persons of the given organization.
     * @type {0 | 1}
     * @memberof OrganizationsApiGetOrganizationDeals
     */
    readonly only_primary_association?: 0 | 1
}

/**
 * Request parameters for getOrganizationFiles operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiGetOrganizationFilesRequest
 */
export interface OrganizationsApiGetOrganizationFilesRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationFiles
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationFiles
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationFiles
     */
    readonly limit?: number

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @type {string}
     * @memberof OrganizationsApiGetOrganizationFiles
     */
    readonly sort?: string
}

/**
 * Request parameters for getOrganizationFollowers operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiGetOrganizationFollowersRequest
 */
export interface OrganizationsApiGetOrganizationFollowersRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationFollowers
     */
    readonly id: number
}

/**
 * Request parameters for getOrganizationMailMessages operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiGetOrganizationMailMessagesRequest
 */
export interface OrganizationsApiGetOrganizationMailMessagesRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationMailMessages
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationMailMessages
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationMailMessages
     */
    readonly limit?: number
}

/**
 * Request parameters for getOrganizationPersons operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiGetOrganizationPersonsRequest
 */
export interface OrganizationsApiGetOrganizationPersonsRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationPersons
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationPersons
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationPersons
     */
    readonly limit?: number
}

/**
 * Request parameters for getOrganizationUpdates operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiGetOrganizationUpdatesRequest
 */
export interface OrganizationsApiGetOrganizationUpdatesRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationUpdates
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationUpdates
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationUpdates
     */
    readonly limit?: number

    /**
     * Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted, returns changes without custom field updates.
     * @type {string}
     * @memberof OrganizationsApiGetOrganizationUpdates
     */
    readonly all_changes?: string

    /**
     * A comma-separated string for filtering out item specific updates. (Possible values - activity, plannedActivity, note, file, change, deal, follower, participant, mailMessage, mailMessageWithAttachment, invoice, activityFile, document)
     * @type {string}
     * @memberof OrganizationsApiGetOrganizationUpdates
     */
    readonly items?: string
}

/**
 * Request parameters for getOrganizationUsers operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiGetOrganizationUsersRequest
 */
export interface OrganizationsApiGetOrganizationUsersRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationUsers
     */
    readonly id: number
}

/**
 * Request parameters for getOrganizations operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiGetOrganizationsRequest
 */
export interface OrganizationsApiGetOrganizationsRequest {
    /**
     * If supplied, only organizations owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
     * @type {number}
     * @memberof OrganizationsApiGetOrganizations
     */
    readonly user_id?: number

    /**
     * The ID of the filter to use
     * @type {number}
     * @memberof OrganizationsApiGetOrganizations
     */
    readonly filter_id?: number

    /**
     * If supplied, only organizations whose name starts with the specified letter will be returned (case-insensitive)
     * @type {string}
     * @memberof OrganizationsApiGetOrganizations
     */
    readonly first_char?: string

    /**
     * Pagination start
     * @type {number}
     * @memberof OrganizationsApiGetOrganizations
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof OrganizationsApiGetOrganizations
     */
    readonly limit?: number

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @type {string}
     * @memberof OrganizationsApiGetOrganizations
     */
    readonly sort?: string
}

/**
 * Request parameters for getOrganizationsCollection operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiGetOrganizationsCollectionRequest
 */
export interface OrganizationsApiGetOrganizationsCollectionRequest {
    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof OrganizationsApiGetOrganizationsCollection
     */
    readonly cursor?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationsCollection
     */
    readonly limit?: number

    /**
     * The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
     * @type {string}
     * @memberof OrganizationsApiGetOrganizationsCollection
     */
    readonly since?: string

    /**
     * The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
     * @type {string}
     * @memberof OrganizationsApiGetOrganizationsCollection
     */
    readonly until?: string

    /**
     * If supplied, only organizations owned by the given user will be returned
     * @type {number}
     * @memberof OrganizationsApiGetOrganizationsCollection
     */
    readonly owner_id?: number

    /**
     * If supplied, only organizations whose name starts with the specified letter will be returned (case-insensitive)
     * @type {string}
     * @memberof OrganizationsApiGetOrganizationsCollection
     */
    readonly first_char?: string
}

/**
 * Request parameters for mergeOrganizations operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiMergeOrganizationsRequest
 */
export interface OrganizationsApiMergeOrganizationsRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiMergeOrganizations
     */
    readonly id: number

    /**
     *
     * @type {MergeOrganizationsRequest}
     * @memberof OrganizationsApiMergeOrganizations
     */
    readonly MergeOrganizationsRequest?: MergeOrganizationsRequest
}

/**
 * Request parameters for searchOrganization operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiSearchOrganizationRequest
 */
export interface OrganizationsApiSearchOrganizationRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof OrganizationsApiSearchOrganization
     */
    readonly term: string

    /**
     * A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
     * @type {'address' | 'custom_fields' | 'notes' | 'name'}
     * @memberof OrganizationsApiSearchOrganization
     */
    readonly fields?: 'address' | 'custom_fields' | 'notes' | 'name'

    /**
     * When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @type {boolean}
     * @memberof OrganizationsApiSearchOrganization
     */
    readonly exact_match?: boolean

    /**
     * Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @type {number}
     * @memberof OrganizationsApiSearchOrganization
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof OrganizationsApiSearchOrganization
     */
    readonly limit?: number
}

/**
 * Request parameters for updateOrganization operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiUpdateOrganizationRequest
 */
export interface OrganizationsApiUpdateOrganizationRequest {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof OrganizationsApiUpdateOrganization
     */
    readonly id: number

    /**
     *
     * @type {UpdateOrganizationRequest}
     * @memberof OrganizationsApiUpdateOrganization
     */
    readonly UpdateOrganizationRequest?: UpdateOrganizationRequest
}

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * Adds a new organization. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the organizationFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-organization\" target=\"_blank\" rel=\"noopener noreferrer\">adding an organization</a>.
     * @summary Add an organization
     * @param {OrganizationsApiAddOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public addOrganization(requestParameters: OrganizationsApiAddOrganizationRequest = {}, ) {
        return OrganizationsApiFp(this.configuration).addOrganization(requestParameters.AddOrganizationRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a follower to an organization.
     * @summary Add a follower to an organization
     * @param {OrganizationsApiAddOrganizationFollowerRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public addOrganizationFollower(requestParameters: OrganizationsApiAddOrganizationFollowerRequest, ) {
        return OrganizationsApiFp(this.configuration).addOrganizationFollower(requestParameters.id, requestParameters.AddOrganizationFollowerRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks an organization as deleted. After 30 days, the organization will be permanently deleted.
     * @summary Delete an organization
     * @param {OrganizationsApiDeleteOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganization(requestParameters: OrganizationsApiDeleteOrganizationRequest, ) {
        return OrganizationsApiFp(this.configuration).deleteOrganization(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a follower from an organization. You can retrieve the `follower_id` from the <a href=\"https://developers.pipedrive.com/docs/api/v1/Organizations#getOrganizationFollowers\">List followers of an organization</a> endpoint.
     * @summary Delete a follower from an organization
     * @param {OrganizationsApiDeleteOrganizationFollowerRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationFollower(requestParameters: OrganizationsApiDeleteOrganizationFollowerRequest, ) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationFollower(requestParameters.id, requestParameters.follower_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks multiple organizations as deleted. After 30 days, the organizations will be permanently deleted.
     * @summary Delete multiple organizations in bulk
     * @param {OrganizationsApiDeleteOrganizationsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizations(requestParameters: OrganizationsApiDeleteOrganizationsRequest, ) {
        return OrganizationsApiFp(this.configuration).deleteOrganizations(requestParameters.ids, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of an organization. Note that this also returns some additional fields which are not present when asking for all organizations. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of organizationFields.
     * @summary Get details of an organization
     * @param {OrganizationsApiGetOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganization(requestParameters: OrganizationsApiGetOrganizationRequest, ) {
        return OrganizationsApiFp(this.configuration).getOrganization(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists activities associated with an organization.
     * @summary List activities associated with an organization
     * @param {OrganizationsApiGetOrganizationActivitiesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationActivities(requestParameters: OrganizationsApiGetOrganizationActivitiesRequest, ) {
        return OrganizationsApiFp(this.configuration).getOrganizationActivities(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.done, requestParameters.exclude, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists deals associated with an organization.
     * @summary List deals associated with an organization
     * @param {OrganizationsApiGetOrganizationDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationDeals(requestParameters: OrganizationsApiGetOrganizationDealsRequest, ) {
        return OrganizationsApiFp(this.configuration).getOrganizationDeals(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.status, requestParameters.sort, requestParameters.only_primary_association, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists files associated with an organization.
     * @summary List files attached to an organization
     * @param {OrganizationsApiGetOrganizationFilesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationFiles(requestParameters: OrganizationsApiGetOrganizationFilesRequest, ) {
        return OrganizationsApiFp(this.configuration).getOrganizationFiles(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the followers of an organization.
     * @summary List followers of an organization
     * @param {OrganizationsApiGetOrganizationFollowersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationFollowers(requestParameters: OrganizationsApiGetOrganizationFollowersRequest, ) {
        return OrganizationsApiFp(this.configuration).getOrganizationFollowers(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists mail messages associated with an organization.
     * @summary List mail messages associated with an organization
     * @param {OrganizationsApiGetOrganizationMailMessagesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationMailMessages(requestParameters: OrganizationsApiGetOrganizationMailMessagesRequest, ) {
        return OrganizationsApiFp(this.configuration).getOrganizationMailMessages(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists persons associated with an organization.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary List persons of an organization
     * @param {OrganizationsApiGetOrganizationPersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationPersons(requestParameters: OrganizationsApiGetOrganizationPersonsRequest, ) {
        return OrganizationsApiFp(this.configuration).getOrganizationPersons(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists updates about an organization.
     * @summary List updates about an organization
     * @param {OrganizationsApiGetOrganizationUpdatesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationUpdates(requestParameters: OrganizationsApiGetOrganizationUpdatesRequest, ) {
        return OrganizationsApiFp(this.configuration).getOrganizationUpdates(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.all_changes, requestParameters.items, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List users permitted to access an organization.
     * @summary List permitted users
     * @param {OrganizationsApiGetOrganizationUsersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationUsers(requestParameters: OrganizationsApiGetOrganizationUsersRequest, ) {
        return OrganizationsApiFp(this.configuration).getOrganizationUsers(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all organizations.
     * @summary Get all organizations
     * @param {OrganizationsApiGetOrganizationsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizations(requestParameters: OrganizationsApiGetOrganizationsRequest = {}, ) {
        return OrganizationsApiFp(this.configuration).getOrganizations(requestParameters.user_id, requestParameters.filter_id, requestParameters.first_char, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all organizations. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
     * @summary Get all organizations (BETA)
     * @param {OrganizationsApiGetOrganizationsCollectionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationsCollection(requestParameters: OrganizationsApiGetOrganizationsCollectionRequest = {}, ) {
        return OrganizationsApiFp(this.configuration).getOrganizationsCollection(requestParameters.cursor, requestParameters.limit, requestParameters.since, requestParameters.until, requestParameters.owner_id, requestParameters.first_char, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Merges an organization with another organization. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-organizations\" target=\"_blank\" rel=\"noopener noreferrer\">merging two organizations</a>.
     * @summary Merge two organizations
     * @param {OrganizationsApiMergeOrganizationsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public mergeOrganizations(requestParameters: OrganizationsApiMergeOrganizationsRequest, ) {
        return OrganizationsApiFp(this.configuration).mergeOrganizations(requestParameters.id, requestParameters.MergeOrganizationsRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
     * @summary Search organizations
     * @param {OrganizationsApiSearchOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public searchOrganization(requestParameters: OrganizationsApiSearchOrganizationRequest, ) {
        return OrganizationsApiFp(this.configuration).searchOrganization(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of an organization.
     * @summary Update an organization
     * @param {OrganizationsApiUpdateOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrganization(requestParameters: OrganizationsApiUpdateOrganizationRequest, ) {
        return OrganizationsApiFp(this.configuration).updateOrganization(requestParameters.id, requestParameters.UpdateOrganizationRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PermissionSetsApi - axios parameter creator
 * @export
 */
export const PermissionSetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns data about a specific permission set.
         * @summary Get one permission set
         * @param {string} id The ID of the permission set

         * @throws {RequiredError}
         */
        getPermissionSet: async (id: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPermissionSet', 'id', id)
            const localVarPath = `/permissionSets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of assignments for a permission set.
         * @summary List permission set assignments
         * @param {string} id The ID of the permission set
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getPermissionSetAssignments: async (id: string, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPermissionSetAssignments', 'id', id)
            const localVarPath = `/permissionSets/{id}/assignments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all permission sets.
         * @summary Get all permission sets
         * @param {'sales' | 'projects' | 'campaigns' | 'global' | 'account_settings'} [app] The app to filter the permission sets by

         * @throws {RequiredError}
         */
        getPermissionSets: async (app?: 'sales' | 'projects' | 'campaigns' | 'global' | 'account_settings', ): Promise<RequestArgs> => {
            const localVarPath = `/permissionSets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionSetsApi - functional programming interface
 * @export
 */
export const PermissionSetsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = PermissionSetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns data about a specific permission set.
         * @summary Get one permission set
         * @param {string} id The ID of the permission set

         * @throws {RequiredError}
         */
        async getPermissionSet(id: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SinglePermissionSetResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionSet(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of assignments for a permission set.
         * @summary List permission set assignments
         * @param {string} id The ID of the permission set
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getPermissionSetAssignments(id: string, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UserAssignmentsToPermissionSetResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionSetAssignments(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all permission sets.
         * @summary Get all permission sets
         * @param {'sales' | 'projects' | 'campaigns' | 'global' | 'account_settings'} [app] The app to filter the permission sets by

         * @throws {RequiredError}
         */
        async getPermissionSets(app?: 'sales' | 'projects' | 'campaigns' | 'global' | 'account_settings', ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPermissionSetsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionSets(app, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PermissionSetsApi - factory interface
 * @export
 */
export const PermissionSetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionSetsApiFp(configuration)
    return {
        /**
         * Returns data about a specific permission set.
         * @summary Get one permission set
         * @param {PermissionSetsApiGetPermissionSetRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPermissionSet(requestParameters: PermissionSetsApiGetPermissionSetRequest, ): Promise<SinglePermissionSetResponse200> {
            return localVarFp.getPermissionSet(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of assignments for a permission set.
         * @summary List permission set assignments
         * @param {PermissionSetsApiGetPermissionSetAssignmentsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPermissionSetAssignments(requestParameters: PermissionSetsApiGetPermissionSetAssignmentsRequest, ): Promise<UserAssignmentsToPermissionSetResponse200> {
            return localVarFp.getPermissionSetAssignments(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all permission sets.
         * @summary Get all permission sets
         * @param {PermissionSetsApiGetPermissionSetsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPermissionSets(requestParameters: PermissionSetsApiGetPermissionSetsRequest = {}, ): Promise<GetPermissionSetsResponse200> {
            return localVarFp.getPermissionSets(requestParameters.app, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPermissionSet operation in PermissionSetsApi.
 * @export
 * @interface PermissionSetsApiGetPermissionSetRequest
 */
export interface PermissionSetsApiGetPermissionSetRequest {
    /**
     * The ID of the permission set
     * @type {string}
     * @memberof PermissionSetsApiGetPermissionSet
     */
    readonly id: string
}

/**
 * Request parameters for getPermissionSetAssignments operation in PermissionSetsApi.
 * @export
 * @interface PermissionSetsApiGetPermissionSetAssignmentsRequest
 */
export interface PermissionSetsApiGetPermissionSetAssignmentsRequest {
    /**
     * The ID of the permission set
     * @type {string}
     * @memberof PermissionSetsApiGetPermissionSetAssignments
     */
    readonly id: string

    /**
     * Pagination start
     * @type {number}
     * @memberof PermissionSetsApiGetPermissionSetAssignments
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PermissionSetsApiGetPermissionSetAssignments
     */
    readonly limit?: number
}

/**
 * Request parameters for getPermissionSets operation in PermissionSetsApi.
 * @export
 * @interface PermissionSetsApiGetPermissionSetsRequest
 */
export interface PermissionSetsApiGetPermissionSetsRequest {
    /**
     * The app to filter the permission sets by
     * @type {'sales' | 'projects' | 'campaigns' | 'global' | 'account_settings'}
     * @memberof PermissionSetsApiGetPermissionSets
     */
    readonly app?: 'sales' | 'projects' | 'campaigns' | 'global' | 'account_settings'
}

/**
 * PermissionSetsApi - object-oriented interface
 * @export
 * @class PermissionSetsApi
 * @extends {BaseAPI}
 */
export class PermissionSetsApi extends BaseAPI {
    /**
     * Returns data about a specific permission set.
     * @summary Get one permission set
     * @param {PermissionSetsApiGetPermissionSetRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PermissionSetsApi
     */
    public getPermissionSet(requestParameters: PermissionSetsApiGetPermissionSetRequest, ) {
        return PermissionSetsApiFp(this.configuration).getPermissionSet(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of assignments for a permission set.
     * @summary List permission set assignments
     * @param {PermissionSetsApiGetPermissionSetAssignmentsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PermissionSetsApi
     */
    public getPermissionSetAssignments(requestParameters: PermissionSetsApiGetPermissionSetAssignmentsRequest, ) {
        return PermissionSetsApiFp(this.configuration).getPermissionSetAssignments(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all permission sets.
     * @summary Get all permission sets
     * @param {PermissionSetsApiGetPermissionSetsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PermissionSetsApi
     */
    public getPermissionSets(requestParameters: PermissionSetsApiGetPermissionSetsRequest = {}, ) {
        return PermissionSetsApiFp(this.configuration).getPermissionSets(requestParameters.app, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonFieldsApi - axios parameter creator
 * @export
 */
export const PersonFieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new person field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new person field
         * @param {CreateFieldRequest} [CreateFieldRequest]

         * @throws {RequiredError}
         */
        addPersonField: async (CreateFieldRequest?: CreateFieldRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/personFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(CreateFieldRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a person field
         * @param {number} id The ID of the field

         * @throws {RequiredError}
         */
        deletePersonField: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePersonField', 'id', id)
            const localVarPath = `/personFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple person fields in bulk
         * @param {string} ids The comma-separated field IDs to delete

         * @throws {RequiredError}
         */
        deletePersonFields: async (ids: string, ): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deletePersonFields', 'ids', ids)
            const localVarPath = `/personFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific person field.
         * @summary Get one person field
         * @param {number} id The ID of the field

         * @throws {RequiredError}
         */
        getPersonField: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonField', 'id', id)
            const localVarPath = `/personFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full", "admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all person fields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get all person fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getPersonFields: async (start?: number, limit?: number, ): Promise<RequestArgs> => {
            const localVarPath = `/personFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full", "admin"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a person field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
         * @summary Update a person field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest} [UpdateFieldRequest]

         * @throws {RequiredError}
         */
        updatePersonField: async (id: number, UpdateFieldRequest?: UpdateFieldRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePersonField', 'id', id)
            const localVarPath = `/personFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateFieldRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonFieldsApi - functional programming interface
 * @export
 */
export const PersonFieldsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = PersonFieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new person field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new person field
         * @param {CreateFieldRequest} [CreateFieldRequest]

         * @throws {RequiredError}
         */
        async addPersonField(CreateFieldRequest?: CreateFieldRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<FieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPersonField(CreateFieldRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a person field
         * @param {number} id The ID of the field

         * @throws {RequiredError}
         */
        async deletePersonField(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteFieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonField(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple person fields in bulk
         * @param {string} ids The comma-separated field IDs to delete

         * @throws {RequiredError}
         */
        async deletePersonFields(ids: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteFieldsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonFields(ids, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about a specific person field.
         * @summary Get one person field
         * @param {number} id The ID of the field

         * @throws {RequiredError}
         */
        async getPersonField(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<FieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonField(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all person fields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get all person fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getPersonFields(start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<FieldsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonFields(start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a person field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
         * @summary Update a person field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest} [UpdateFieldRequest]

         * @throws {RequiredError}
         */
        async updatePersonField(id: number, UpdateFieldRequest?: UpdateFieldRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<FieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePersonField(id, UpdateFieldRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonFieldsApi - factory interface
 * @export
 */
export const PersonFieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonFieldsApiFp(configuration)
    return {
        /**
         * Adds a new person field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new person field
         * @param {PersonFieldsApiAddPersonFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addPersonField(requestParameters: PersonFieldsApiAddPersonFieldRequest = {}, ): Promise<FieldResponse200> {
            return localVarFp.addPersonField(requestParameters.CreateFieldRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a person field
         * @param {PersonFieldsApiDeletePersonFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deletePersonField(requestParameters: PersonFieldsApiDeletePersonFieldRequest, ): Promise<DeleteFieldResponse200> {
            return localVarFp.deletePersonField(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple person fields in bulk
         * @param {PersonFieldsApiDeletePersonFieldsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deletePersonFields(requestParameters: PersonFieldsApiDeletePersonFieldsRequest, ): Promise<DeleteFieldsResponse200> {
            return localVarFp.deletePersonFields(requestParameters.ids, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about a specific person field.
         * @summary Get one person field
         * @param {PersonFieldsApiGetPersonFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonField(requestParameters: PersonFieldsApiGetPersonFieldRequest, ): Promise<FieldResponse200> {
            return localVarFp.getPersonField(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all person fields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get all person fields
         * @param {PersonFieldsApiGetPersonFieldsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonFields(requestParameters: PersonFieldsApiGetPersonFieldsRequest = {}, ): Promise<FieldsResponse200> {
            return localVarFp.getPersonFields(requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates a person field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
         * @summary Update a person field
         * @param {PersonFieldsApiUpdatePersonFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updatePersonField(requestParameters: PersonFieldsApiUpdatePersonFieldRequest, ): Promise<FieldResponse200> {
            return localVarFp.updatePersonField(requestParameters.id, requestParameters.UpdateFieldRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addPersonField operation in PersonFieldsApi.
 * @export
 * @interface PersonFieldsApiAddPersonFieldRequest
 */
export interface PersonFieldsApiAddPersonFieldRequest {
    /**
     *
     * @type {CreateFieldRequest}
     * @memberof PersonFieldsApiAddPersonField
     */
    readonly CreateFieldRequest?: CreateFieldRequest
}

/**
 * Request parameters for deletePersonField operation in PersonFieldsApi.
 * @export
 * @interface PersonFieldsApiDeletePersonFieldRequest
 */
export interface PersonFieldsApiDeletePersonFieldRequest {
    /**
     * The ID of the field
     * @type {number}
     * @memberof PersonFieldsApiDeletePersonField
     */
    readonly id: number
}

/**
 * Request parameters for deletePersonFields operation in PersonFieldsApi.
 * @export
 * @interface PersonFieldsApiDeletePersonFieldsRequest
 */
export interface PersonFieldsApiDeletePersonFieldsRequest {
    /**
     * The comma-separated field IDs to delete
     * @type {string}
     * @memberof PersonFieldsApiDeletePersonFields
     */
    readonly ids: string
}

/**
 * Request parameters for getPersonField operation in PersonFieldsApi.
 * @export
 * @interface PersonFieldsApiGetPersonFieldRequest
 */
export interface PersonFieldsApiGetPersonFieldRequest {
    /**
     * The ID of the field
     * @type {number}
     * @memberof PersonFieldsApiGetPersonField
     */
    readonly id: number
}

/**
 * Request parameters for getPersonFields operation in PersonFieldsApi.
 * @export
 * @interface PersonFieldsApiGetPersonFieldsRequest
 */
export interface PersonFieldsApiGetPersonFieldsRequest {
    /**
     * Pagination start
     * @type {number}
     * @memberof PersonFieldsApiGetPersonFields
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonFieldsApiGetPersonFields
     */
    readonly limit?: number
}

/**
 * Request parameters for updatePersonField operation in PersonFieldsApi.
 * @export
 * @interface PersonFieldsApiUpdatePersonFieldRequest
 */
export interface PersonFieldsApiUpdatePersonFieldRequest {
    /**
     * The ID of the field
     * @type {number}
     * @memberof PersonFieldsApiUpdatePersonField
     */
    readonly id: number

    /**
     *
     * @type {UpdateFieldRequest}
     * @memberof PersonFieldsApiUpdatePersonField
     */
    readonly UpdateFieldRequest?: UpdateFieldRequest
}

/**
 * PersonFieldsApi - object-oriented interface
 * @export
 * @class PersonFieldsApi
 * @extends {BaseAPI}
 */
export class PersonFieldsApi extends BaseAPI {
    /**
     * Adds a new person field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
     * @summary Add a new person field
     * @param {PersonFieldsApiAddPersonFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonFieldsApi
     */
    public addPersonField(requestParameters: PersonFieldsApiAddPersonFieldRequest = {}, ) {
        return PersonFieldsApiFp(this.configuration).addPersonField(requestParameters.CreateFieldRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
     * @summary Delete a person field
     * @param {PersonFieldsApiDeletePersonFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonFieldsApi
     */
    public deletePersonField(requestParameters: PersonFieldsApiDeletePersonFieldRequest, ) {
        return PersonFieldsApiFp(this.configuration).deletePersonField(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks multiple fields as deleted.
     * @summary Delete multiple person fields in bulk
     * @param {PersonFieldsApiDeletePersonFieldsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonFieldsApi
     */
    public deletePersonFields(requestParameters: PersonFieldsApiDeletePersonFieldsRequest, ) {
        return PersonFieldsApiFp(this.configuration).deletePersonFields(requestParameters.ids, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about a specific person field.
     * @summary Get one person field
     * @param {PersonFieldsApiGetPersonFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonFieldsApi
     */
    public getPersonField(requestParameters: PersonFieldsApiGetPersonFieldRequest, ) {
        return PersonFieldsApiFp(this.configuration).getPersonField(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all person fields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary Get all person fields
     * @param {PersonFieldsApiGetPersonFieldsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonFieldsApi
     */
    public getPersonFields(requestParameters: PersonFieldsApiGetPersonFieldsRequest = {}, ) {
        return PersonFieldsApiFp(this.configuration).getPersonFields(requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a person field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
     * @summary Update a person field
     * @param {PersonFieldsApiUpdatePersonFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonFieldsApi
     */
    public updatePersonField(requestParameters: PersonFieldsApiUpdatePersonFieldRequest, ) {
        return PersonFieldsApiFp(this.configuration).updatePersonField(requestParameters.id, requestParameters.UpdateFieldRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonsApi - axios parameter creator
 * @export
 */
export const PersonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Add a person
         * @param {AddPersonRequest} [AddPersonRequest]

         * @throws {RequiredError}
         */
        addPerson: async (AddPersonRequest?: AddPersonRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddPersonRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a follower to a person.
         * @summary Add a follower to a person
         * @param {number} id The ID of the person
         * @param {AddPersonFollowerRequest} [AddPersonFollowerRequest]

         * @throws {RequiredError}
         */
        addPersonFollower: async (id: number, AddPersonFollowerRequest?: AddPersonFollowerRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addPersonFollower', 'id', id)
            const localVarPath = `/persons/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddPersonFollowerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
         * @summary Add person picture
         * @param {number} id The ID of the person
         * @param {File} file One image supplied in the multipart/form-data encoding
         * @param {number} [crop_x] X coordinate to where start cropping form (in pixels)
         * @param {number} [crop_y] Y coordinate to where start cropping form (in pixels)
         * @param {number} [crop_width] The width of the cropping area (in pixels)
         * @param {number} [crop_height] The height of the cropping area (in pixels)

         * @throws {RequiredError}
         */
        addPersonPicture: async (id: number, file: File, crop_x?: number, crop_y?: number, crop_width?: number, crop_height?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addPersonPicture', 'id', id)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('addPersonPicture', 'file', file)
            const localVarPath = `/persons/{id}/picture`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


            if (file !== undefined) {
                localVarFormParams.append('file', file as any);
            }

            if (crop_x !== undefined) {
                localVarFormParams.append('crop_x', crop_x as any);
            }

            if (crop_y !== undefined) {
                localVarFormParams.append('crop_y', crop_y as any);
            }

            if (crop_width !== undefined) {
                localVarFormParams.append('crop_width', crop_width as any);
            }

            if (crop_height !== undefined) {
                localVarFormParams.append('crop_height', crop_height as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a person as deleted. After 30 days, the person will be permanently deleted.
         * @summary Delete a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        deletePerson: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePerson', 'id', id)
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a follower from a person.
         * @summary Delete a follower from a person
         * @param {number} id The ID of the person
         * @param {number} follower_id The ID of the follower

         * @throws {RequiredError}
         */
        deletePersonFollower: async (id: number, follower_id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePersonFollower', 'id', id)
            // verify required parameter 'follower_id' is not null or undefined
            assertParamExists('deletePersonFollower', 'follower_id', follower_id)
            const localVarPath = `/persons/{id}/followers/{follower_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"follower_id"}}`, encodeURIComponent(String(follower_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a person’s picture.
         * @summary Delete person picture
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        deletePersonPicture: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePersonPicture', 'id', id)
            const localVarPath = `/persons/{id}/picture`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple persons as deleted. After 30 days, the persons will be permanently deleted.
         * @summary Delete multiple persons in bulk
         * @param {string} ids The comma-separated IDs that will be deleted

         * @throws {RequiredError}
         */
        deletePersons: async (ids: string, ): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deletePersons', 'ids', ids)
            const localVarPath = `/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get details of a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        getPerson: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPerson', 'id', id)
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists activities associated with a person.
         * @summary List activities associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {0 | 1} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result

         * @throws {RequiredError}
         */
        getPersonActivities: async (id: number, start?: number, limit?: number, done?: 0 | 1, exclude?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonActivities', 'id', id)
            const localVarPath = `/persons/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:read", "activities:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (done !== undefined) {
                localVarQueryParameter['done'] = done;
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists deals associated with a person.
         * @summary List deals associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).

         * @throws {RequiredError}
         */
        getPersonDeals: async (id: number, start?: number, limit?: number, status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted', sort?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonDeals', 'id', id)
            const localVarPath = `/persons/{id}/deals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists files associated with a person.
         * @summary List files attached to a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.

         * @throws {RequiredError}
         */
        getPersonFiles: async (id: number, start?: number, limit?: number, sort?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonFiles', 'id', id)
            const localVarPath = `/persons/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the followers of a person.
         * @summary List followers of a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        getPersonFollowers: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonFollowers', 'id', id)
            const localVarPath = `/persons/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists mail messages associated with a person.
         * @summary List mail messages associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getPersonMailMessages: async (id: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonMailMessages', 'id', id)
            const localVarPath = `/persons/{id}/mailMessages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["mail:read", "mail:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists products associated with a person.
         * @summary List products associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getPersonProducts: async (id: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonProducts', 'id', id)
            const localVarPath = `/persons/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint\'s response will also include updates for the `marketing_status` field.
         * @summary List updates about a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)

         * @throws {RequiredError}
         */
        getPersonUpdates: async (id: number, start?: number, limit?: number, all_changes?: string, items?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonUpdates', 'id', id)
            const localVarPath = `/persons/{id}/flow`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["recents:read"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (all_changes !== undefined) {
                localVarQueryParameter['all_changes'] = all_changes;
            }

            if (items !== undefined) {
                localVarQueryParameter['items'] = items;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List users permitted to access a person.
         * @summary List permitted users
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        getPersonUsers: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonUsers', 'id', id)
            const localVarPath = `/persons/{id}/permittedUsers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all persons.
         * @summary Get all persons
         * @param {number} [user_id] If supplied, only persons owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [first_char] If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).

         * @throws {RequiredError}
         */
        getPersons: async (user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (first_char !== undefined) {
                localVarQueryParameter['first_char'] = first_char;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all persons. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all persons (BETA)
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [since] The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {string} [until] The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {number} [owner_id] If supplied, only persons owned by the given user will be returned
         * @param {string} [first_char] If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive)

         * @throws {RequiredError}
         */
        getPersonsCollection: async (cursor?: string, limit?: number, since?: string, until?: string, owner_id?: number, first_char?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/persons/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }

            if (owner_id !== undefined) {
                localVarQueryParameter['owner_id'] = owner_id;
            }

            if (first_char !== undefined) {
                localVarQueryParameter['first_char'] = first_char;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merges a person with another person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-persons\" target=\"_blank\" rel=\"noopener noreferrer\">merging two persons</a>.
         * @summary Merge two persons
         * @param {number} id The ID of the person
         * @param {MergePersonsRequest} [MergePersonsRequest]

         * @throws {RequiredError}
         */
        mergePersons: async (id: number, MergePersonsRequest?: MergePersonsRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergePersons', 'id', id)
            const localVarPath = `/persons/{id}/merge`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(MergePersonsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'email' | 'notes' | 'phone' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [organization_id] Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
         * @param {'person.picture'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        searchPersons: async (term: string, fields?: 'custom_fields' | 'email' | 'notes' | 'phone' | 'name', exact_match?: boolean, organization_id?: number, include_fields?: 'person.picture', start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchPersons', 'term', term)
            const localVarPath = `/persons/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full", "search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-person\" target=\"_blank\" rel=\"noopener noreferrer\">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Update a person
         * @param {number} id The ID of the person
         * @param {UpdatePersonRequest} [UpdatePersonRequest]

         * @throws {RequiredError}
         */
        updatePerson: async (id: number, UpdatePersonRequest?: UpdatePersonRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePerson', 'id', id)
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdatePersonRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonsApi - functional programming interface
 * @export
 */
export const PersonsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = PersonsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Add a person
         * @param {AddPersonRequest} [AddPersonRequest]

         * @throws {RequiredError}
         */
        async addPerson(AddPersonRequest?: AddPersonRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddPersonResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPerson(AddPersonRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a follower to a person.
         * @summary Add a follower to a person
         * @param {number} id The ID of the person
         * @param {AddPersonFollowerRequest} [AddPersonFollowerRequest]

         * @throws {RequiredError}
         */
        async addPersonFollower(id: number, AddPersonFollowerRequest?: AddPersonFollowerRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddPersonFollowerResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPersonFollower(id, AddPersonFollowerRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
         * @summary Add person picture
         * @param {number} id The ID of the person
         * @param {File} file One image supplied in the multipart/form-data encoding
         * @param {number} [crop_x] X coordinate to where start cropping form (in pixels)
         * @param {number} [crop_y] Y coordinate to where start cropping form (in pixels)
         * @param {number} [crop_width] The width of the cropping area (in pixels)
         * @param {number} [crop_height] The height of the cropping area (in pixels)

         * @throws {RequiredError}
         */
        async addPersonPicture(id: number, file: File, crop_x?: number, crop_y?: number, crop_width?: number, crop_height?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddPersonPictureResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPersonPicture(id, file, crop_x, crop_y, crop_width, crop_height, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a person as deleted. After 30 days, the person will be permanently deleted.
         * @summary Delete a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        async deletePerson(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeletePersonResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePerson(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a follower from a person.
         * @summary Delete a follower from a person
         * @param {number} id The ID of the person
         * @param {number} follower_id The ID of the follower

         * @throws {RequiredError}
         */
        async deletePersonFollower(id: number, follower_id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeletePersonResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonFollower(id, follower_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a person’s picture.
         * @summary Delete person picture
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        async deletePersonPicture(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeletePersonResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonPicture(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks multiple persons as deleted. After 30 days, the persons will be permanently deleted.
         * @summary Delete multiple persons in bulk
         * @param {string} ids The comma-separated IDs that will be deleted

         * @throws {RequiredError}
         */
        async deletePersons(ids: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeletePersonsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersons(ids, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get details of a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        async getPerson(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPersonResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPerson(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists activities associated with a person.
         * @summary List activities associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {0 | 1} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result

         * @throws {RequiredError}
         */
        async getPersonActivities(id: number, start?: number, limit?: number, done?: 0 | 1, exclude?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedActivitiesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonActivities(id, start, limit, done, exclude, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists deals associated with a person.
         * @summary List deals associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).

         * @throws {RequiredError}
         */
        async getPersonDeals(id: number, start?: number, limit?: number, status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted', sort?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedDealsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonDeals(id, start, limit, status, sort, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists files associated with a person.
         * @summary List files attached to a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.

         * @throws {RequiredError}
         */
        async getPersonFiles(id: number, start?: number, limit?: number, sort?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedFilesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonFiles(id, start, limit, sort, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the followers of a person.
         * @summary List followers of a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        async getPersonFollowers(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedFollowersResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonFollowers(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists mail messages associated with a person.
         * @summary List mail messages associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getPersonMailMessages(id: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedMailMessagesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonMailMessages(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists products associated with a person.
         * @summary List products associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getPersonProducts(id: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPersonProductsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonProducts(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint\'s response will also include updates for the `marketing_status` field.
         * @summary List updates about a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)

         * @throws {RequiredError}
         */
        async getPersonUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedPersonUpdatesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonUpdates(id, start, limit, all_changes, items, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List users permitted to access a person.
         * @summary List permitted users
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        async getPersonUsers(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListPermittedUsersResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonUsers(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all persons.
         * @summary Get all persons
         * @param {number} [user_id] If supplied, only persons owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [first_char] If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).

         * @throws {RequiredError}
         */
        async getPersons(user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPersonsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersons(user_id, filter_id, first_char, start, limit, sort, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all persons. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all persons (BETA)
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [since] The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {string} [until] The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {number} [owner_id] If supplied, only persons owned by the given user will be returned
         * @param {string} [first_char] If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive)

         * @throws {RequiredError}
         */
        async getPersonsCollection(cursor?: string, limit?: number, since?: string, until?: string, owner_id?: number, first_char?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPersonsCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonsCollection(cursor, limit, since, until, owner_id, first_char, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Merges a person with another person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-persons\" target=\"_blank\" rel=\"noopener noreferrer\">merging two persons</a>.
         * @summary Merge two persons
         * @param {number} id The ID of the person
         * @param {MergePersonsRequest} [MergePersonsRequest]

         * @throws {RequiredError}
         */
        async mergePersons(id: number, MergePersonsRequest?: MergePersonsRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<MergePersonsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergePersons(id, MergePersonsRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'email' | 'notes' | 'phone' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [organization_id] Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
         * @param {'person.picture'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async searchPersons(term: string, fields?: 'custom_fields' | 'email' | 'notes' | 'phone' | 'name', exact_match?: boolean, organization_id?: number, include_fields?: 'person.picture', start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SearchPersonsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPersons(term, fields, exact_match, organization_id, include_fields, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of a person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-person\" target=\"_blank\" rel=\"noopener noreferrer\">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Update a person
         * @param {number} id The ID of the person
         * @param {UpdatePersonRequest} [UpdatePersonRequest]

         * @throws {RequiredError}
         */
        async updatePerson(id: number, UpdatePersonRequest?: UpdatePersonRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdatePersonResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePerson(id, UpdatePersonRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonsApi - factory interface
 * @export
 */
export const PersonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonsApiFp(configuration)
    return {
        /**
         * Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Add a person
         * @param {PersonsApiAddPersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addPerson(requestParameters: PersonsApiAddPersonRequest = {}, ): Promise<AddPersonResponse200> {
            return localVarFp.addPerson(requestParameters.AddPersonRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a follower to a person.
         * @summary Add a follower to a person
         * @param {PersonsApiAddPersonFollowerRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addPersonFollower(requestParameters: PersonsApiAddPersonFollowerRequest, ): Promise<AddPersonFollowerResponse200> {
            return localVarFp.addPersonFollower(requestParameters.id, requestParameters.AddPersonFollowerRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
         * @summary Add person picture
         * @param {PersonsApiAddPersonPictureRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addPersonPicture(requestParameters: PersonsApiAddPersonPictureRequest, ): Promise<AddPersonPictureResponse200> {
            return localVarFp.addPersonPicture(requestParameters.id, requestParameters.file, requestParameters.crop_x, requestParameters.crop_y, requestParameters.crop_width, requestParameters.crop_height, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a person as deleted. After 30 days, the person will be permanently deleted.
         * @summary Delete a person
         * @param {PersonsApiDeletePersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deletePerson(requestParameters: PersonsApiDeletePersonRequest, ): Promise<DeletePersonResponse200> {
            return localVarFp.deletePerson(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a follower from a person.
         * @summary Delete a follower from a person
         * @param {PersonsApiDeletePersonFollowerRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deletePersonFollower(requestParameters: PersonsApiDeletePersonFollowerRequest, ): Promise<DeletePersonResponse200> {
            return localVarFp.deletePersonFollower(requestParameters.id, requestParameters.follower_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a person’s picture.
         * @summary Delete person picture
         * @param {PersonsApiDeletePersonPictureRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deletePersonPicture(requestParameters: PersonsApiDeletePersonPictureRequest, ): Promise<DeletePersonResponse200> {
            return localVarFp.deletePersonPicture(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks multiple persons as deleted. After 30 days, the persons will be permanently deleted.
         * @summary Delete multiple persons in bulk
         * @param {PersonsApiDeletePersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deletePersons(requestParameters: PersonsApiDeletePersonsRequest, ): Promise<DeletePersonsResponse200> {
            return localVarFp.deletePersons(requestParameters.ids, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get details of a person
         * @param {PersonsApiGetPersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPerson(requestParameters: PersonsApiGetPersonRequest, ): Promise<GetPersonResponse200> {
            return localVarFp.getPerson(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists activities associated with a person.
         * @summary List activities associated with a person
         * @param {PersonsApiGetPersonActivitiesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonActivities(requestParameters: PersonsApiGetPersonActivitiesRequest, ): Promise<GetAssociatedActivitiesResponse200> {
            return localVarFp.getPersonActivities(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.done, requestParameters.exclude, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists deals associated with a person.
         * @summary List deals associated with a person
         * @param {PersonsApiGetPersonDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonDeals(requestParameters: PersonsApiGetPersonDealsRequest, ): Promise<GetAssociatedDealsResponse200> {
            return localVarFp.getPersonDeals(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.status, requestParameters.sort, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists files associated with a person.
         * @summary List files attached to a person
         * @param {PersonsApiGetPersonFilesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonFiles(requestParameters: PersonsApiGetPersonFilesRequest, ): Promise<GetAssociatedFilesResponse200> {
            return localVarFp.getPersonFiles(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists the followers of a person.
         * @summary List followers of a person
         * @param {PersonsApiGetPersonFollowersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonFollowers(requestParameters: PersonsApiGetPersonFollowersRequest, ): Promise<GetAssociatedFollowersResponse200> {
            return localVarFp.getPersonFollowers(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists mail messages associated with a person.
         * @summary List mail messages associated with a person
         * @param {PersonsApiGetPersonMailMessagesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonMailMessages(requestParameters: PersonsApiGetPersonMailMessagesRequest, ): Promise<GetAssociatedMailMessagesResponse200> {
            return localVarFp.getPersonMailMessages(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists products associated with a person.
         * @summary List products associated with a person
         * @param {PersonsApiGetPersonProductsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonProducts(requestParameters: PersonsApiGetPersonProductsRequest, ): Promise<GetPersonProductsResponse200> {
            return localVarFp.getPersonProducts(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint\'s response will also include updates for the `marketing_status` field.
         * @summary List updates about a person
         * @param {PersonsApiGetPersonUpdatesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonUpdates(requestParameters: PersonsApiGetPersonUpdatesRequest, ): Promise<GetAssociatedPersonUpdatesResponse200> {
            return localVarFp.getPersonUpdates(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.all_changes, requestParameters.items, ).then((request) => request(axios, basePath));
        },
        /**
         * List users permitted to access a person.
         * @summary List permitted users
         * @param {PersonsApiGetPersonUsersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonUsers(requestParameters: PersonsApiGetPersonUsersRequest, ): Promise<ListPermittedUsersResponse2001> {
            return localVarFp.getPersonUsers(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all persons.
         * @summary Get all persons
         * @param {PersonsApiGetPersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersons(requestParameters: PersonsApiGetPersonsRequest = {}, ): Promise<GetPersonsResponse200> {
            return localVarFp.getPersons(requestParameters.user_id, requestParameters.filter_id, requestParameters.first_char, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all persons. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all persons (BETA)
         * @param {PersonsApiGetPersonsCollectionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonsCollection(requestParameters: PersonsApiGetPersonsCollectionRequest = {}, ): Promise<GetPersonsCollection200Response> {
            return localVarFp.getPersonsCollection(requestParameters.cursor, requestParameters.limit, requestParameters.since, requestParameters.until, requestParameters.owner_id, requestParameters.first_char, ).then((request) => request(axios, basePath));
        },
        /**
         * Merges a person with another person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-persons\" target=\"_blank\" rel=\"noopener noreferrer\">merging two persons</a>.
         * @summary Merge two persons
         * @param {PersonsApiMergePersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        mergePersons(requestParameters: PersonsApiMergePersonsRequest, ): Promise<MergePersonsResponse200> {
            return localVarFp.mergePersons(requestParameters.id, requestParameters.MergePersonsRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {PersonsApiSearchPersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchPersons(requestParameters: PersonsApiSearchPersonsRequest, ): Promise<SearchPersonsResponse200> {
            return localVarFp.searchPersons(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.organization_id, requestParameters.include_fields, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-person\" target=\"_blank\" rel=\"noopener noreferrer\">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Update a person
         * @param {PersonsApiUpdatePersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updatePerson(requestParameters: PersonsApiUpdatePersonRequest, ): Promise<UpdatePersonResponse200> {
            return localVarFp.updatePerson(requestParameters.id, requestParameters.UpdatePersonRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addPerson operation in PersonsApi.
 * @export
 * @interface PersonsApiAddPersonRequest
 */
export interface PersonsApiAddPersonRequest {
    /**
     *
     * @type {AddPersonRequest}
     * @memberof PersonsApiAddPerson
     */
    readonly AddPersonRequest?: AddPersonRequest
}

/**
 * Request parameters for addPersonFollower operation in PersonsApi.
 * @export
 * @interface PersonsApiAddPersonFollowerRequest
 */
export interface PersonsApiAddPersonFollowerRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiAddPersonFollower
     */
    readonly id: number

    /**
     *
     * @type {AddPersonFollowerRequest}
     * @memberof PersonsApiAddPersonFollower
     */
    readonly AddPersonFollowerRequest?: AddPersonFollowerRequest
}

/**
 * Request parameters for addPersonPicture operation in PersonsApi.
 * @export
 * @interface PersonsApiAddPersonPictureRequest
 */
export interface PersonsApiAddPersonPictureRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiAddPersonPicture
     */
    readonly id: number

    /**
     * One image supplied in the multipart/form-data encoding
     * @type {File}
     * @memberof PersonsApiAddPersonPicture
     */
    readonly file: File

    /**
     * X coordinate to where start cropping form (in pixels)
     * @type {number}
     * @memberof PersonsApiAddPersonPicture
     */
    readonly crop_x?: number

    /**
     * Y coordinate to where start cropping form (in pixels)
     * @type {number}
     * @memberof PersonsApiAddPersonPicture
     */
    readonly crop_y?: number

    /**
     * The width of the cropping area (in pixels)
     * @type {number}
     * @memberof PersonsApiAddPersonPicture
     */
    readonly crop_width?: number

    /**
     * The height of the cropping area (in pixels)
     * @type {number}
     * @memberof PersonsApiAddPersonPicture
     */
    readonly crop_height?: number
}

/**
 * Request parameters for deletePerson operation in PersonsApi.
 * @export
 * @interface PersonsApiDeletePersonRequest
 */
export interface PersonsApiDeletePersonRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiDeletePerson
     */
    readonly id: number
}

/**
 * Request parameters for deletePersonFollower operation in PersonsApi.
 * @export
 * @interface PersonsApiDeletePersonFollowerRequest
 */
export interface PersonsApiDeletePersonFollowerRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiDeletePersonFollower
     */
    readonly id: number

    /**
     * The ID of the follower
     * @type {number}
     * @memberof PersonsApiDeletePersonFollower
     */
    readonly follower_id: number
}

/**
 * Request parameters for deletePersonPicture operation in PersonsApi.
 * @export
 * @interface PersonsApiDeletePersonPictureRequest
 */
export interface PersonsApiDeletePersonPictureRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiDeletePersonPicture
     */
    readonly id: number
}

/**
 * Request parameters for deletePersons operation in PersonsApi.
 * @export
 * @interface PersonsApiDeletePersonsRequest
 */
export interface PersonsApiDeletePersonsRequest {
    /**
     * The comma-separated IDs that will be deleted
     * @type {string}
     * @memberof PersonsApiDeletePersons
     */
    readonly ids: string
}

/**
 * Request parameters for getPerson operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonRequest
 */
export interface PersonsApiGetPersonRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPerson
     */
    readonly id: number
}

/**
 * Request parameters for getPersonActivities operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonActivitiesRequest
 */
export interface PersonsApiGetPersonActivitiesRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonActivities
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersonActivities
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersonActivities
     */
    readonly limit?: number

    /**
     * Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
     * @type {0 | 1}
     * @memberof PersonsApiGetPersonActivities
     */
    readonly done?: 0 | 1

    /**
     * A comma-separated string of activity IDs to exclude from result
     * @type {string}
     * @memberof PersonsApiGetPersonActivities
     */
    readonly exclude?: string
}

/**
 * Request parameters for getPersonDeals operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonDealsRequest
 */
export interface PersonsApiGetPersonDealsRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonDeals
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersonDeals
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersonDeals
     */
    readonly limit?: number

    /**
     * Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
     * @type {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'}
     * @memberof PersonsApiGetPersonDeals
     */
    readonly status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @type {string}
     * @memberof PersonsApiGetPersonDeals
     */
    readonly sort?: string
}

/**
 * Request parameters for getPersonFiles operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonFilesRequest
 */
export interface PersonsApiGetPersonFilesRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonFiles
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersonFiles
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersonFiles
     */
    readonly limit?: number

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @type {string}
     * @memberof PersonsApiGetPersonFiles
     */
    readonly sort?: string
}

/**
 * Request parameters for getPersonFollowers operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonFollowersRequest
 */
export interface PersonsApiGetPersonFollowersRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonFollowers
     */
    readonly id: number
}

/**
 * Request parameters for getPersonMailMessages operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonMailMessagesRequest
 */
export interface PersonsApiGetPersonMailMessagesRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonMailMessages
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersonMailMessages
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersonMailMessages
     */
    readonly limit?: number
}

/**
 * Request parameters for getPersonProducts operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonProductsRequest
 */
export interface PersonsApiGetPersonProductsRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonProducts
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersonProducts
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersonProducts
     */
    readonly limit?: number
}

/**
 * Request parameters for getPersonUpdates operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonUpdatesRequest
 */
export interface PersonsApiGetPersonUpdatesRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonUpdates
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersonUpdates
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersonUpdates
     */
    readonly limit?: number

    /**
     * Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
     * @type {string}
     * @memberof PersonsApiGetPersonUpdates
     */
    readonly all_changes?: string

    /**
     * A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)
     * @type {string}
     * @memberof PersonsApiGetPersonUpdates
     */
    readonly items?: string
}

/**
 * Request parameters for getPersonUsers operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonUsersRequest
 */
export interface PersonsApiGetPersonUsersRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonUsers
     */
    readonly id: number
}

/**
 * Request parameters for getPersons operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonsRequest
 */
export interface PersonsApiGetPersonsRequest {
    /**
     * If supplied, only persons owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly user_id?: number

    /**
     * The ID of the filter to use
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly filter_id?: number

    /**
     * If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive)
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly first_char?: string

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly limit?: number

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly sort?: string
}

/**
 * Request parameters for getPersonsCollection operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonsCollectionRequest
 */
export interface PersonsApiGetPersonsCollectionRequest {
    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof PersonsApiGetPersonsCollection
     */
    readonly cursor?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof PersonsApiGetPersonsCollection
     */
    readonly limit?: number

    /**
     * The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
     * @type {string}
     * @memberof PersonsApiGetPersonsCollection
     */
    readonly since?: string

    /**
     * The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
     * @type {string}
     * @memberof PersonsApiGetPersonsCollection
     */
    readonly until?: string

    /**
     * If supplied, only persons owned by the given user will be returned
     * @type {number}
     * @memberof PersonsApiGetPersonsCollection
     */
    readonly owner_id?: number

    /**
     * If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive)
     * @type {string}
     * @memberof PersonsApiGetPersonsCollection
     */
    readonly first_char?: string
}

/**
 * Request parameters for mergePersons operation in PersonsApi.
 * @export
 * @interface PersonsApiMergePersonsRequest
 */
export interface PersonsApiMergePersonsRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiMergePersons
     */
    readonly id: number

    /**
     *
     * @type {MergePersonsRequest}
     * @memberof PersonsApiMergePersons
     */
    readonly MergePersonsRequest?: MergePersonsRequest
}

/**
 * Request parameters for searchPersons operation in PersonsApi.
 * @export
 * @interface PersonsApiSearchPersonsRequest
 */
export interface PersonsApiSearchPersonsRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof PersonsApiSearchPersons
     */
    readonly term: string

    /**
     * A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
     * @type {'custom_fields' | 'email' | 'notes' | 'phone' | 'name'}
     * @memberof PersonsApiSearchPersons
     */
    readonly fields?: 'custom_fields' | 'email' | 'notes' | 'phone' | 'name'

    /**
     * When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @type {boolean}
     * @memberof PersonsApiSearchPersons
     */
    readonly exact_match?: boolean

    /**
     * Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
     * @type {number}
     * @memberof PersonsApiSearchPersons
     */
    readonly organization_id?: number

    /**
     * Supports including optional fields in the results which are not provided by default
     * @type {'person.picture'}
     * @memberof PersonsApiSearchPersons
     */
    readonly include_fields?: 'person.picture'

    /**
     * Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @type {number}
     * @memberof PersonsApiSearchPersons
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiSearchPersons
     */
    readonly limit?: number
}

/**
 * Request parameters for updatePerson operation in PersonsApi.
 * @export
 * @interface PersonsApiUpdatePersonRequest
 */
export interface PersonsApiUpdatePersonRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiUpdatePerson
     */
    readonly id: number

    /**
     *
     * @type {UpdatePersonRequest}
     * @memberof PersonsApiUpdatePerson
     */
    readonly UpdatePersonRequest?: UpdatePersonRequest
}

/**
 * PersonsApi - object-oriented interface
 * @export
 * @class PersonsApi
 * @extends {BaseAPI}
 */
export class PersonsApi extends BaseAPI {
    /**
     * Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
     * @summary Add a person
     * @param {PersonsApiAddPersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public addPerson(requestParameters: PersonsApiAddPersonRequest = {}, ) {
        return PersonsApiFp(this.configuration).addPerson(requestParameters.AddPersonRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a follower to a person.
     * @summary Add a follower to a person
     * @param {PersonsApiAddPersonFollowerRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public addPersonFollower(requestParameters: PersonsApiAddPersonFollowerRequest, ) {
        return PersonsApiFp(this.configuration).addPersonFollower(requestParameters.id, requestParameters.AddPersonFollowerRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
     * @summary Add person picture
     * @param {PersonsApiAddPersonPictureRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public addPersonPicture(requestParameters: PersonsApiAddPersonPictureRequest, ) {
        return PersonsApiFp(this.configuration).addPersonPicture(requestParameters.id, requestParameters.file, requestParameters.crop_x, requestParameters.crop_y, requestParameters.crop_width, requestParameters.crop_height, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a person as deleted. After 30 days, the person will be permanently deleted.
     * @summary Delete a person
     * @param {PersonsApiDeletePersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public deletePerson(requestParameters: PersonsApiDeletePersonRequest, ) {
        return PersonsApiFp(this.configuration).deletePerson(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a follower from a person.
     * @summary Delete a follower from a person
     * @param {PersonsApiDeletePersonFollowerRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public deletePersonFollower(requestParameters: PersonsApiDeletePersonFollowerRequest, ) {
        return PersonsApiFp(this.configuration).deletePersonFollower(requestParameters.id, requestParameters.follower_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a person’s picture.
     * @summary Delete person picture
     * @param {PersonsApiDeletePersonPictureRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public deletePersonPicture(requestParameters: PersonsApiDeletePersonPictureRequest, ) {
        return PersonsApiFp(this.configuration).deletePersonPicture(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks multiple persons as deleted. After 30 days, the persons will be permanently deleted.
     * @summary Delete multiple persons in bulk
     * @param {PersonsApiDeletePersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public deletePersons(requestParameters: PersonsApiDeletePersonsRequest, ) {
        return PersonsApiFp(this.configuration).deletePersons(requestParameters.ids, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary Get details of a person
     * @param {PersonsApiGetPersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPerson(requestParameters: PersonsApiGetPersonRequest, ) {
        return PersonsApiFp(this.configuration).getPerson(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists activities associated with a person.
     * @summary List activities associated with a person
     * @param {PersonsApiGetPersonActivitiesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonActivities(requestParameters: PersonsApiGetPersonActivitiesRequest, ) {
        return PersonsApiFp(this.configuration).getPersonActivities(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.done, requestParameters.exclude, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists deals associated with a person.
     * @summary List deals associated with a person
     * @param {PersonsApiGetPersonDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonDeals(requestParameters: PersonsApiGetPersonDealsRequest, ) {
        return PersonsApiFp(this.configuration).getPersonDeals(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.status, requestParameters.sort, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists files associated with a person.
     * @summary List files attached to a person
     * @param {PersonsApiGetPersonFilesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonFiles(requestParameters: PersonsApiGetPersonFilesRequest, ) {
        return PersonsApiFp(this.configuration).getPersonFiles(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the followers of a person.
     * @summary List followers of a person
     * @param {PersonsApiGetPersonFollowersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonFollowers(requestParameters: PersonsApiGetPersonFollowersRequest, ) {
        return PersonsApiFp(this.configuration).getPersonFollowers(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists mail messages associated with a person.
     * @summary List mail messages associated with a person
     * @param {PersonsApiGetPersonMailMessagesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonMailMessages(requestParameters: PersonsApiGetPersonMailMessagesRequest, ) {
        return PersonsApiFp(this.configuration).getPersonMailMessages(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists products associated with a person.
     * @summary List products associated with a person
     * @param {PersonsApiGetPersonProductsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonProducts(requestParameters: PersonsApiGetPersonProductsRequest, ) {
        return PersonsApiFp(this.configuration).getPersonProducts(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint\'s response will also include updates for the `marketing_status` field.
     * @summary List updates about a person
     * @param {PersonsApiGetPersonUpdatesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonUpdates(requestParameters: PersonsApiGetPersonUpdatesRequest, ) {
        return PersonsApiFp(this.configuration).getPersonUpdates(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.all_changes, requestParameters.items, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List users permitted to access a person.
     * @summary List permitted users
     * @param {PersonsApiGetPersonUsersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonUsers(requestParameters: PersonsApiGetPersonUsersRequest, ) {
        return PersonsApiFp(this.configuration).getPersonUsers(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all persons.
     * @summary Get all persons
     * @param {PersonsApiGetPersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersons(requestParameters: PersonsApiGetPersonsRequest = {}, ) {
        return PersonsApiFp(this.configuration).getPersons(requestParameters.user_id, requestParameters.filter_id, requestParameters.first_char, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all persons. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
     * @summary Get all persons (BETA)
     * @param {PersonsApiGetPersonsCollectionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonsCollection(requestParameters: PersonsApiGetPersonsCollectionRequest = {}, ) {
        return PersonsApiFp(this.configuration).getPersonsCollection(requestParameters.cursor, requestParameters.limit, requestParameters.since, requestParameters.until, requestParameters.owner_id, requestParameters.first_char, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Merges a person with another person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-persons\" target=\"_blank\" rel=\"noopener noreferrer\">merging two persons</a>.
     * @summary Merge two persons
     * @param {PersonsApiMergePersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public mergePersons(requestParameters: PersonsApiMergePersonsRequest, ) {
        return PersonsApiFp(this.configuration).mergePersons(requestParameters.id, requestParameters.MergePersonsRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
     * @summary Search persons
     * @param {PersonsApiSearchPersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public searchPersons(requestParameters: PersonsApiSearchPersonsRequest, ) {
        return PersonsApiFp(this.configuration).searchPersons(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.organization_id, requestParameters.include_fields, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of a person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-person\" target=\"_blank\" rel=\"noopener noreferrer\">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
     * @summary Update a person
     * @param {PersonsApiUpdatePersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public updatePerson(requestParameters: PersonsApiUpdatePersonRequest, ) {
        return PersonsApiFp(this.configuration).updatePerson(requestParameters.id, requestParameters.UpdatePersonRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PipelinesApi - axios parameter creator
 * @export
 */
export const PipelinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new pipeline.
         * @summary Add a new pipeline
         * @param {PipelineRequest} [PipelineRequest]

         * @throws {RequiredError}
         */
        addPipeline: async (PipelineRequest?: PipelineRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/pipelines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(PipelineRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a pipeline as deleted.
         * @summary Delete a pipeline
         * @param {number} id The ID of the pipeline

         * @throws {RequiredError}
         */
        deletePipeline: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePipeline', 'id', id)
            const localVarPath = `/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific pipeline. Also returns the summary of the deals in this pipeline across its stages.
         * @summary Get one pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned in &#x60;deals_summary&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used.

         * @throws {RequiredError}
         */
        getPipeline: async (id: number, totals_convert_currency?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPipeline', 'id', id)
            const localVarPath = `/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "admin"], configuration)

            if (totals_convert_currency !== undefined) {
                localVarQueryParameter['totals_convert_currency'] = totals_convert_currency;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all stage-to-stage conversion and pipeline-to-close rates for the given time period.
         * @summary Get deals conversion rates in pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
         * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
         * @param {number} [user_id] The ID of the user who\&#39;s pipeline metrics statistics to fetch. If omitted, the authorized user will be used.

         * @throws {RequiredError}
         */
        getPipelineConversionStatistics: async (id: number, start_date: string, end_date: string, user_id?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPipelineConversionStatistics', 'id', id)
            // verify required parameter 'start_date' is not null or undefined
            assertParamExists('getPipelineConversionStatistics', 'start_date', start_date)
            // verify required parameter 'end_date' is not null or undefined
            assertParamExists('getPipelineConversionStatistics', 'end_date', end_date)
            const localVarPath = `/pipelines/{id}/conversion_statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (start_date !== undefined) {
                localVarQueryParameter['start_date'] = (start_date as any instanceof Date) ?
                    (start_date as any).toISOString().substr(0,10) :
                    start_date;
            }

            if (end_date !== undefined) {
                localVarQueryParameter['end_date'] = (end_date as any instanceof Date) ?
                    (end_date as any).toISOString().substr(0,10) :
                    end_date;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists deals in a specific pipeline across all its stages.
         * @summary Get deals in a pipeline
         * @param {number} id The ID of the pipeline
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
         * @param {0 | 1} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered – instead, deals owned by everyone will be returned
         * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {0 | 1} [get_summary] Whether to include a summary of the pipeline in the &#x60;additional_data&#x60; or not
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned inside &#x60;deals_summary&#x60; inside &#x60;additional_data&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used. Only works when &#x60;get_summary&#x60; parameter flag is enabled.

         * @throws {RequiredError}
         */
        getPipelineDeals: async (id: number, filter_id?: number, user_id?: number, everyone?: 0 | 1, stage_id?: number, start?: number, limit?: number, get_summary?: 0 | 1, totals_convert_currency?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPipelineDeals', 'id', id)
            const localVarPath = `/pipelines/{id}/deals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (everyone !== undefined) {
                localVarQueryParameter['everyone'] = everyone;
            }

            if (stage_id !== undefined) {
                localVarQueryParameter['stage_id'] = stage_id;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (get_summary !== undefined) {
                localVarQueryParameter['get_summary'] = get_summary;
            }

            if (totals_convert_currency !== undefined) {
                localVarQueryParameter['totals_convert_currency'] = totals_convert_currency;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns statistics for deals movements for the given time period.
         * @summary Get deals movements in pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
         * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
         * @param {number} [user_id] The ID of the user who\&#39;s pipeline statistics to fetch. If omitted, the authorized user will be used.

         * @throws {RequiredError}
         */
        getPipelineMovementStatistics: async (id: number, start_date: string, end_date: string, user_id?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPipelineMovementStatistics', 'id', id)
            // verify required parameter 'start_date' is not null or undefined
            assertParamExists('getPipelineMovementStatistics', 'start_date', start_date)
            // verify required parameter 'end_date' is not null or undefined
            assertParamExists('getPipelineMovementStatistics', 'end_date', end_date)
            const localVarPath = `/pipelines/{id}/movement_statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (start_date !== undefined) {
                localVarQueryParameter['start_date'] = (start_date as any instanceof Date) ?
                    (start_date as any).toISOString().substr(0,10) :
                    start_date;
            }

            if (end_date !== undefined) {
                localVarQueryParameter['end_date'] = (end_date as any instanceof Date) ?
                    (end_date as any).toISOString().substr(0,10) :
                    end_date;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all pipelines.
         * @summary Get all pipelines

         * @throws {RequiredError}
         */
        getPipelines: async (): Promise<RequestArgs> => {
            const localVarPath = `/pipelines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a pipeline.
         * @summary Update a pipeline
         * @param {number} id The ID of the pipeline
         * @param {PipelineRequest1} [PipelineRequest1]

         * @throws {RequiredError}
         */
        updatePipeline: async (id: number, PipelineRequest1?: PipelineRequest1, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePipeline', 'id', id)
            const localVarPath = `/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(PipelineRequest1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelinesApi - functional programming interface
 * @export
 */
export const PipelinesApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = PipelinesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new pipeline.
         * @summary Add a new pipeline
         * @param {PipelineRequest} [PipelineRequest]

         * @throws {RequiredError}
         */
        async addPipeline(PipelineRequest?: PipelineRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddPipelineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPipeline(PipelineRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a pipeline as deleted.
         * @summary Delete a pipeline
         * @param {number} id The ID of the pipeline

         * @throws {RequiredError}
         */
        async deletePipeline(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeletePipelineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipeline(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about a specific pipeline. Also returns the summary of the deals in this pipeline across its stages.
         * @summary Get one pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned in &#x60;deals_summary&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used.

         * @throws {RequiredError}
         */
        async getPipeline(id: number, totals_convert_currency?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPipelineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipeline(id, totals_convert_currency, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all stage-to-stage conversion and pipeline-to-close rates for the given time period.
         * @summary Get deals conversion rates in pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
         * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
         * @param {number} [user_id] The ID of the user who\&#39;s pipeline metrics statistics to fetch. If omitted, the authorized user will be used.

         * @throws {RequiredError}
         */
        async getPipelineConversionStatistics(id: number, start_date: string, end_date: string, user_id?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPipelineConversionStatisticsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineConversionStatistics(id, start_date, end_date, user_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists deals in a specific pipeline across all its stages.
         * @summary Get deals in a pipeline
         * @param {number} id The ID of the pipeline
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
         * @param {0 | 1} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered – instead, deals owned by everyone will be returned
         * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {0 | 1} [get_summary] Whether to include a summary of the pipeline in the &#x60;additional_data&#x60; or not
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned inside &#x60;deals_summary&#x60; inside &#x60;additional_data&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used. Only works when &#x60;get_summary&#x60; parameter flag is enabled.

         * @throws {RequiredError}
         */
        async getPipelineDeals(id: number, filter_id?: number, user_id?: number, everyone?: 0 | 1, stage_id?: number, start?: number, limit?: number, get_summary?: 0 | 1, totals_convert_currency?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStageDealsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineDeals(id, filter_id, user_id, everyone, stage_id, start, limit, get_summary, totals_convert_currency, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns statistics for deals movements for the given time period.
         * @summary Get deals movements in pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
         * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
         * @param {number} [user_id] The ID of the user who\&#39;s pipeline statistics to fetch. If omitted, the authorized user will be used.

         * @throws {RequiredError}
         */
        async getPipelineMovementStatistics(id: number, start_date: string, end_date: string, user_id?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPipelineMovementStatisticsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineMovementStatistics(id, start_date, end_date, user_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all pipelines.
         * @summary Get all pipelines

         * @throws {RequiredError}
         */
        async getPipelines(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPipelinesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelines();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of a pipeline.
         * @summary Update a pipeline
         * @param {number} id The ID of the pipeline
         * @param {PipelineRequest1} [PipelineRequest1]

         * @throws {RequiredError}
         */
        async updatePipeline(id: number, PipelineRequest1?: PipelineRequest1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdatePipelineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePipeline(id, PipelineRequest1, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PipelinesApi - factory interface
 * @export
 */
export const PipelinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelinesApiFp(configuration)
    return {
        /**
         * Adds a new pipeline.
         * @summary Add a new pipeline
         * @param {PipelinesApiAddPipelineRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addPipeline(requestParameters: PipelinesApiAddPipelineRequest = {}, ): Promise<AddPipelineResponse200> {
            return localVarFp.addPipeline(requestParameters.PipelineRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a pipeline as deleted.
         * @summary Delete a pipeline
         * @param {PipelinesApiDeletePipelineRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deletePipeline(requestParameters: PipelinesApiDeletePipelineRequest, ): Promise<DeletePipelineResponse200> {
            return localVarFp.deletePipeline(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about a specific pipeline. Also returns the summary of the deals in this pipeline across its stages.
         * @summary Get one pipeline
         * @param {PipelinesApiGetPipelineRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPipeline(requestParameters: PipelinesApiGetPipelineRequest, ): Promise<GetPipelineResponse200> {
            return localVarFp.getPipeline(requestParameters.id, requestParameters.totals_convert_currency, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all stage-to-stage conversion and pipeline-to-close rates for the given time period.
         * @summary Get deals conversion rates in pipeline
         * @param {PipelinesApiGetPipelineConversionStatisticsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPipelineConversionStatistics(requestParameters: PipelinesApiGetPipelineConversionStatisticsRequest, ): Promise<GetPipelineConversionStatisticsResponse200> {
            return localVarFp.getPipelineConversionStatistics(requestParameters.id, requestParameters.start_date, requestParameters.end_date, requestParameters.user_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists deals in a specific pipeline across all its stages.
         * @summary Get deals in a pipeline
         * @param {PipelinesApiGetPipelineDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPipelineDeals(requestParameters: PipelinesApiGetPipelineDealsRequest, ): Promise<GetStageDealsResponse200> {
            return localVarFp.getPipelineDeals(requestParameters.id, requestParameters.filter_id, requestParameters.user_id, requestParameters.everyone, requestParameters.stage_id, requestParameters.start, requestParameters.limit, requestParameters.get_summary, requestParameters.totals_convert_currency, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns statistics for deals movements for the given time period.
         * @summary Get deals movements in pipeline
         * @param {PipelinesApiGetPipelineMovementStatisticsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPipelineMovementStatistics(requestParameters: PipelinesApiGetPipelineMovementStatisticsRequest, ): Promise<GetPipelineMovementStatisticsResponse200> {
            return localVarFp.getPipelineMovementStatistics(requestParameters.id, requestParameters.start_date, requestParameters.end_date, requestParameters.user_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all pipelines.
         * @summary Get all pipelines

         * @throws {RequiredError}
         */
        getPipelines(): Promise<GetPipelinesResponse200> {
            return localVarFp.getPipelines().then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a pipeline.
         * @summary Update a pipeline
         * @param {PipelinesApiUpdatePipelineRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updatePipeline(requestParameters: PipelinesApiUpdatePipelineRequest, ): Promise<UpdatePipelineResponse200> {
            return localVarFp.updatePipeline(requestParameters.id, requestParameters.PipelineRequest1, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addPipeline operation in PipelinesApi.
 * @export
 * @interface PipelinesApiAddPipelineRequest
 */
export interface PipelinesApiAddPipelineRequest {
    /**
     *
     * @type {PipelineRequest}
     * @memberof PipelinesApiAddPipeline
     */
    readonly PipelineRequest?: PipelineRequest
}

/**
 * Request parameters for deletePipeline operation in PipelinesApi.
 * @export
 * @interface PipelinesApiDeletePipelineRequest
 */
export interface PipelinesApiDeletePipelineRequest {
    /**
     * The ID of the pipeline
     * @type {number}
     * @memberof PipelinesApiDeletePipeline
     */
    readonly id: number
}

/**
 * Request parameters for getPipeline operation in PipelinesApi.
 * @export
 * @interface PipelinesApiGetPipelineRequest
 */
export interface PipelinesApiGetPipelineRequest {
    /**
     * The ID of the pipeline
     * @type {number}
     * @memberof PipelinesApiGetPipeline
     */
    readonly id: number

    /**
     * The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned in &#x60;deals_summary&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used.
     * @type {string}
     * @memberof PipelinesApiGetPipeline
     */
    readonly totals_convert_currency?: string
}

/**
 * Request parameters for getPipelineConversionStatistics operation in PipelinesApi.
 * @export
 * @interface PipelinesApiGetPipelineConversionStatisticsRequest
 */
export interface PipelinesApiGetPipelineConversionStatisticsRequest {
    /**
     * The ID of the pipeline
     * @type {number}
     * @memberof PipelinesApiGetPipelineConversionStatistics
     */
    readonly id: number

    /**
     * The start of the period. Date in format of YYYY-MM-DD.
     * @type {string}
     * @memberof PipelinesApiGetPipelineConversionStatistics
     */
    readonly start_date: string

    /**
     * The end of the period. Date in format of YYYY-MM-DD.
     * @type {string}
     * @memberof PipelinesApiGetPipelineConversionStatistics
     */
    readonly end_date: string

    /**
     * The ID of the user who\&#39;s pipeline metrics statistics to fetch. If omitted, the authorized user will be used.
     * @type {number}
     * @memberof PipelinesApiGetPipelineConversionStatistics
     */
    readonly user_id?: number
}

/**
 * Request parameters for getPipelineDeals operation in PipelinesApi.
 * @export
 * @interface PipelinesApiGetPipelineDealsRequest
 */
export interface PipelinesApiGetPipelineDealsRequest {
    /**
     * The ID of the pipeline
     * @type {number}
     * @memberof PipelinesApiGetPipelineDeals
     */
    readonly id: number

    /**
     * If supplied, only deals matching the given filter will be returned
     * @type {number}
     * @memberof PipelinesApiGetPipelineDeals
     */
    readonly filter_id?: number

    /**
     * If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
     * @type {number}
     * @memberof PipelinesApiGetPipelineDeals
     */
    readonly user_id?: number

    /**
     * If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered – instead, deals owned by everyone will be returned
     * @type {0 | 1}
     * @memberof PipelinesApiGetPipelineDeals
     */
    readonly everyone?: 0 | 1

    /**
     * If supplied, only deals within the given stage will be returned
     * @type {number}
     * @memberof PipelinesApiGetPipelineDeals
     */
    readonly stage_id?: number

    /**
     * Pagination start
     * @type {number}
     * @memberof PipelinesApiGetPipelineDeals
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PipelinesApiGetPipelineDeals
     */
    readonly limit?: number

    /**
     * Whether to include a summary of the pipeline in the &#x60;additional_data&#x60; or not
     * @type {0 | 1}
     * @memberof PipelinesApiGetPipelineDeals
     */
    readonly get_summary?: 0 | 1

    /**
     * The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned inside &#x60;deals_summary&#x60; inside &#x60;additional_data&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used. Only works when &#x60;get_summary&#x60; parameter flag is enabled.
     * @type {string}
     * @memberof PipelinesApiGetPipelineDeals
     */
    readonly totals_convert_currency?: string
}

/**
 * Request parameters for getPipelineMovementStatistics operation in PipelinesApi.
 * @export
 * @interface PipelinesApiGetPipelineMovementStatisticsRequest
 */
export interface PipelinesApiGetPipelineMovementStatisticsRequest {
    /**
     * The ID of the pipeline
     * @type {number}
     * @memberof PipelinesApiGetPipelineMovementStatistics
     */
    readonly id: number

    /**
     * The start of the period. Date in format of YYYY-MM-DD.
     * @type {string}
     * @memberof PipelinesApiGetPipelineMovementStatistics
     */
    readonly start_date: string

    /**
     * The end of the period. Date in format of YYYY-MM-DD.
     * @type {string}
     * @memberof PipelinesApiGetPipelineMovementStatistics
     */
    readonly end_date: string

    /**
     * The ID of the user who\&#39;s pipeline statistics to fetch. If omitted, the authorized user will be used.
     * @type {number}
     * @memberof PipelinesApiGetPipelineMovementStatistics
     */
    readonly user_id?: number
}

/**
 * Request parameters for updatePipeline operation in PipelinesApi.
 * @export
 * @interface PipelinesApiUpdatePipelineRequest
 */
export interface PipelinesApiUpdatePipelineRequest {
    /**
     * The ID of the pipeline
     * @type {number}
     * @memberof PipelinesApiUpdatePipeline
     */
    readonly id: number

    /**
     *
     * @type {PipelineRequest1}
     * @memberof PipelinesApiUpdatePipeline
     */
    readonly PipelineRequest1?: PipelineRequest1
}

/**
 * PipelinesApi - object-oriented interface
 * @export
 * @class PipelinesApi
 * @extends {BaseAPI}
 */
export class PipelinesApi extends BaseAPI {
    /**
     * Adds a new pipeline.
     * @summary Add a new pipeline
     * @param {PipelinesApiAddPipelineRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public addPipeline(requestParameters: PipelinesApiAddPipelineRequest = {}, ) {
        return PipelinesApiFp(this.configuration).addPipeline(requestParameters.PipelineRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a pipeline as deleted.
     * @summary Delete a pipeline
     * @param {PipelinesApiDeletePipelineRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public deletePipeline(requestParameters: PipelinesApiDeletePipelineRequest, ) {
        return PipelinesApiFp(this.configuration).deletePipeline(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about a specific pipeline. Also returns the summary of the deals in this pipeline across its stages.
     * @summary Get one pipeline
     * @param {PipelinesApiGetPipelineRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipeline(requestParameters: PipelinesApiGetPipelineRequest, ) {
        return PipelinesApiFp(this.configuration).getPipeline(requestParameters.id, requestParameters.totals_convert_currency, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all stage-to-stage conversion and pipeline-to-close rates for the given time period.
     * @summary Get deals conversion rates in pipeline
     * @param {PipelinesApiGetPipelineConversionStatisticsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelineConversionStatistics(requestParameters: PipelinesApiGetPipelineConversionStatisticsRequest, ) {
        return PipelinesApiFp(this.configuration).getPipelineConversionStatistics(requestParameters.id, requestParameters.start_date, requestParameters.end_date, requestParameters.user_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists deals in a specific pipeline across all its stages.
     * @summary Get deals in a pipeline
     * @param {PipelinesApiGetPipelineDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelineDeals(requestParameters: PipelinesApiGetPipelineDealsRequest, ) {
        return PipelinesApiFp(this.configuration).getPipelineDeals(requestParameters.id, requestParameters.filter_id, requestParameters.user_id, requestParameters.everyone, requestParameters.stage_id, requestParameters.start, requestParameters.limit, requestParameters.get_summary, requestParameters.totals_convert_currency, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns statistics for deals movements for the given time period.
     * @summary Get deals movements in pipeline
     * @param {PipelinesApiGetPipelineMovementStatisticsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelineMovementStatistics(requestParameters: PipelinesApiGetPipelineMovementStatisticsRequest, ) {
        return PipelinesApiFp(this.configuration).getPipelineMovementStatistics(requestParameters.id, requestParameters.start_date, requestParameters.end_date, requestParameters.user_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all pipelines.
     * @summary Get all pipelines

     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelines() {
        return PipelinesApiFp(this.configuration).getPipelines().then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of a pipeline.
     * @summary Update a pipeline
     * @param {PipelinesApiUpdatePipelineRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public updatePipeline(requestParameters: PipelinesApiUpdatePipelineRequest, ) {
        return PipelinesApiFp(this.configuration).updatePipeline(requestParameters.id, requestParameters.PipelineRequest1, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductFieldsApi - axios parameter creator
 * @export
 */
export const ProductFieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new product field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new product field
         * @param {ProductFieldAllOf} [ProductFieldAllOf]

         * @throws {RequiredError}
         */
        addProductField: async (ProductFieldAllOf?: ProductFieldAllOf, ): Promise<RequestArgs> => {
            const localVarPath = `/productFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(ProductFieldAllOf, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a product field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a product field
         * @param {number} id The ID of the product field

         * @throws {RequiredError}
         */
        deleteProductField: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProductField', 'id', id)
            const localVarPath = `/productFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple product fields in bulk
         * @param {string} ids The comma-separated field IDs to delete

         * @throws {RequiredError}
         */
        deleteProductFields: async (ids: string, ): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteProductFields', 'ids', ids)
            const localVarPath = `/productFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:full"], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific product field.
         * @summary Get one product field
         * @param {number} id The ID of the product field

         * @throws {RequiredError}
         */
        getProductField: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductField', 'id', id)
            const localVarPath = `/productFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:read", "products:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all product fields.
         * @summary Get all product fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getProductFields: async (start?: number, limit?: number, ): Promise<RequestArgs> => {
            const localVarPath = `/productFields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:read", "products:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a product field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
         * @summary Update a product field
         * @param {number} id The ID of the product field
         * @param {UpdateProductFieldResponse200} [UpdateProductFieldResponse200]

         * @throws {RequiredError}
         */
        updateProductField: async (id: number, UpdateProductFieldResponse200?: UpdateProductFieldResponse200, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProductField', 'id', id)
            const localVarPath = `/productFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateProductFieldResponse200, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductFieldsApi - functional programming interface
 * @export
 */
export const ProductFieldsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = ProductFieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new product field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new product field
         * @param {ProductFieldAllOf} [ProductFieldAllOf]

         * @throws {RequiredError}
         */
        async addProductField(ProductFieldAllOf?: ProductFieldAllOf, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProductFieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProductField(ProductFieldAllOf, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a product field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a product field
         * @param {number} id The ID of the product field

         * @throws {RequiredError}
         */
        async deleteProductField(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteProductFieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductField(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple product fields in bulk
         * @param {string} ids The comma-separated field IDs to delete

         * @throws {RequiredError}
         */
        async deleteProductFields(ids: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteProductFieldsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductFields(ids, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about a specific product field.
         * @summary Get one product field
         * @param {number} id The ID of the product field

         * @throws {RequiredError}
         */
        async getProductField(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProductFieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductField(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all product fields.
         * @summary Get all product fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getProductFields(start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProductFieldsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductFields(start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a product field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
         * @summary Update a product field
         * @param {number} id The ID of the product field
         * @param {UpdateProductFieldResponse200} [UpdateProductFieldResponse200]

         * @throws {RequiredError}
         */
        async updateProductField(id: number, UpdateProductFieldResponse200?: UpdateProductFieldResponse200, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProductFieldResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductField(id, UpdateProductFieldResponse200, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductFieldsApi - factory interface
 * @export
 */
export const ProductFieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductFieldsApiFp(configuration)
    return {
        /**
         * Adds a new product field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new product field
         * @param {ProductFieldsApiAddProductFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addProductField(requestParameters: ProductFieldsApiAddProductFieldRequest = {}, ): Promise<GetProductFieldResponse200> {
            return localVarFp.addProductField(requestParameters.ProductFieldAllOf, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a product field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a product field
         * @param {ProductFieldsApiDeleteProductFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteProductField(requestParameters: ProductFieldsApiDeleteProductFieldRequest, ): Promise<DeleteProductFieldResponse200> {
            return localVarFp.deleteProductField(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple product fields in bulk
         * @param {ProductFieldsApiDeleteProductFieldsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteProductFields(requestParameters: ProductFieldsApiDeleteProductFieldsRequest, ): Promise<DeleteProductFieldsResponse200> {
            return localVarFp.deleteProductFields(requestParameters.ids, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about a specific product field.
         * @summary Get one product field
         * @param {ProductFieldsApiGetProductFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProductField(requestParameters: ProductFieldsApiGetProductFieldRequest, ): Promise<GetProductFieldResponse200> {
            return localVarFp.getProductField(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all product fields.
         * @summary Get all product fields
         * @param {ProductFieldsApiGetProductFieldsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProductFields(requestParameters: ProductFieldsApiGetProductFieldsRequest = {}, ): Promise<GetProductFieldsResponse200> {
            return localVarFp.getProductFields(requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates a product field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
         * @summary Update a product field
         * @param {ProductFieldsApiUpdateProductFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateProductField(requestParameters: ProductFieldsApiUpdateProductFieldRequest, ): Promise<GetProductFieldResponse200> {
            return localVarFp.updateProductField(requestParameters.id, requestParameters.UpdateProductFieldResponse200, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addProductField operation in ProductFieldsApi.
 * @export
 * @interface ProductFieldsApiAddProductFieldRequest
 */
export interface ProductFieldsApiAddProductFieldRequest {
    /**
     *
     * @type {ProductFieldAllOf}
     * @memberof ProductFieldsApiAddProductField
     */
    readonly ProductFieldAllOf?: ProductFieldAllOf
}

/**
 * Request parameters for deleteProductField operation in ProductFieldsApi.
 * @export
 * @interface ProductFieldsApiDeleteProductFieldRequest
 */
export interface ProductFieldsApiDeleteProductFieldRequest {
    /**
     * The ID of the product field
     * @type {number}
     * @memberof ProductFieldsApiDeleteProductField
     */
    readonly id: number
}

/**
 * Request parameters for deleteProductFields operation in ProductFieldsApi.
 * @export
 * @interface ProductFieldsApiDeleteProductFieldsRequest
 */
export interface ProductFieldsApiDeleteProductFieldsRequest {
    /**
     * The comma-separated field IDs to delete
     * @type {string}
     * @memberof ProductFieldsApiDeleteProductFields
     */
    readonly ids: string
}

/**
 * Request parameters for getProductField operation in ProductFieldsApi.
 * @export
 * @interface ProductFieldsApiGetProductFieldRequest
 */
export interface ProductFieldsApiGetProductFieldRequest {
    /**
     * The ID of the product field
     * @type {number}
     * @memberof ProductFieldsApiGetProductField
     */
    readonly id: number
}

/**
 * Request parameters for getProductFields operation in ProductFieldsApi.
 * @export
 * @interface ProductFieldsApiGetProductFieldsRequest
 */
export interface ProductFieldsApiGetProductFieldsRequest {
    /**
     * Pagination start
     * @type {number}
     * @memberof ProductFieldsApiGetProductFields
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof ProductFieldsApiGetProductFields
     */
    readonly limit?: number
}

/**
 * Request parameters for updateProductField operation in ProductFieldsApi.
 * @export
 * @interface ProductFieldsApiUpdateProductFieldRequest
 */
export interface ProductFieldsApiUpdateProductFieldRequest {
    /**
     * The ID of the product field
     * @type {number}
     * @memberof ProductFieldsApiUpdateProductField
     */
    readonly id: number

    /**
     *
     * @type {UpdateProductFieldResponse200}
     * @memberof ProductFieldsApiUpdateProductField
     */
    readonly UpdateProductFieldResponse200?: UpdateProductFieldResponse200
}

/**
 * ProductFieldsApi - object-oriented interface
 * @export
 * @class ProductFieldsApi
 * @extends {BaseAPI}
 */
export class ProductFieldsApi extends BaseAPI {
    /**
     * Adds a new product field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
     * @summary Add a new product field
     * @param {ProductFieldsApiAddProductFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductFieldsApi
     */
    public addProductField(requestParameters: ProductFieldsApiAddProductFieldRequest = {}, ) {
        return ProductFieldsApiFp(this.configuration).addProductField(requestParameters.ProductFieldAllOf, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a product field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
     * @summary Delete a product field
     * @param {ProductFieldsApiDeleteProductFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductFieldsApi
     */
    public deleteProductField(requestParameters: ProductFieldsApiDeleteProductFieldRequest, ) {
        return ProductFieldsApiFp(this.configuration).deleteProductField(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks multiple fields as deleted.
     * @summary Delete multiple product fields in bulk
     * @param {ProductFieldsApiDeleteProductFieldsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductFieldsApi
     */
    public deleteProductFields(requestParameters: ProductFieldsApiDeleteProductFieldsRequest, ) {
        return ProductFieldsApiFp(this.configuration).deleteProductFields(requestParameters.ids, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about a specific product field.
     * @summary Get one product field
     * @param {ProductFieldsApiGetProductFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductFieldsApi
     */
    public getProductField(requestParameters: ProductFieldsApiGetProductFieldRequest, ) {
        return ProductFieldsApiFp(this.configuration).getProductField(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all product fields.
     * @summary Get all product fields
     * @param {ProductFieldsApiGetProductFieldsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductFieldsApi
     */
    public getProductFields(requestParameters: ProductFieldsApiGetProductFieldsRequest = {}, ) {
        return ProductFieldsApiFp(this.configuration).getProductFields(requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a product field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields\' values</a>.
     * @summary Update a product field
     * @param {ProductFieldsApiUpdateProductFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductFieldsApi
     */
    public updateProductField(requestParameters: ProductFieldsApiUpdateProductFieldRequest, ) {
        return ProductFieldsApiFp(this.configuration).updateProductField(requestParameters.id, requestParameters.UpdateProductFieldResponse200, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new product to the Products inventory. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-product\" target=\"_blank\" rel=\"noopener noreferrer\">adding a product</a>.
         * @summary Add a product
         * @param {AddProductRequest} [AddProductRequest]

         * @throws {RequiredError}
         */
        addProduct: async (AddProductRequest?: AddProductRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a follower to a product.
         * @summary Add a follower to a product
         * @param {number} id The ID of the product
         * @param {AddProductFollowerRequest} [AddProductFollowerRequest]

         * @throws {RequiredError}
         */
        addProductFollower: async (id: number, AddProductFollowerRequest?: AddProductFollowerRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addProductFollower', 'id', id)
            const localVarPath = `/products/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddProductFollowerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a product as deleted. After 30 days, the product will be permanently deleted.
         * @summary Delete a product
         * @param {number} id The ID of the product

         * @throws {RequiredError}
         */
        deleteProduct: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProduct', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a follower from a product.
         * @summary Delete a follower from a product
         * @param {number} id The ID of the product
         * @param {number} follower_id The ID of the relationship between the follower and the product

         * @throws {RequiredError}
         */
        deleteProductFollower: async (id: number, follower_id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProductFollower', 'id', id)
            // verify required parameter 'follower_id' is not null or undefined
            assertParamExists('deleteProductFollower', 'follower_id', follower_id)
            const localVarPath = `/products/{id}/followers/{follower_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"follower_id"}}`, encodeURIComponent(String(follower_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific product.
         * @summary Get one product
         * @param {number} id The ID of the product

         * @throws {RequiredError}
         */
        getProduct: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProduct', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:read", "products:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about deals that have a product attached to it.
         * @summary Get deals where a product is attached to
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.

         * @throws {RequiredError}
         */
        getProductDeals: async (id: number, start?: number, limit?: number, status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted', ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductDeals', 'id', id)
            const localVarPath = `/products/{id}/deals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists files associated with a product.
         * @summary List files attached to a product
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field name and sorting mode (&#x60;field_name_1 ASC&#x60; or &#x60;field_name_1 DESC&#x60;). Supported fields: &#x60;update_time&#x60;, &#x60;id&#x60;

         * @throws {RequiredError}
         */
        getProductFiles: async (id: number, start?: number, limit?: number, sort?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductFiles', 'id', id)
            const localVarPath = `/products/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:read", "products:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the followers of a product.
         * @summary List followers of a product
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getProductFollowers: async (id: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductFollowers', 'id', id)
            const localVarPath = `/products/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:read", "products:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists users permitted to access a product.
         * @summary List permitted users
         * @param {number} id The ID of the product

         * @throws {RequiredError}
         */
        getProductUsers: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductUsers', 'id', id)
            const localVarPath = `/products/{id}/permittedUsers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:read", "products:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all products.
         * @summary Get all products
         * @param {number} [user_id] If supplied, only products owned by the given user will be returned
         * @param {number} [filter_id] The ID of the filter to use
         * @param {Array<number>} [ids] An array of integers with the IDs of the products that should be returned in the response
         * @param {string} [first_char] If supplied, only products whose name starts with the specified letter will be returned (case-insensitive)
         * @param {boolean} [get_summary] If supplied, the response will return the total numbers of products in the &#x60;additional_data.summary.total_count&#x60; property
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getProducts: async (user_id?: number, filter_id?: number, ids?: Array<number>, first_char?: string, get_summary?: boolean, start?: number, limit?: number, ): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:read", "products:full"], configuration)

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (first_char !== undefined) {
                localVarQueryParameter['first_char'] = first_char;
            }

            if (get_summary !== undefined) {
                localVarQueryParameter['get_summary'] = get_summary;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all products by name, code and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search products
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'code' | 'custom_fields' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {'product.price'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        searchProducts: async (term: string, fields?: 'code' | 'custom_fields' | 'name', exact_match?: boolean, include_fields?: 'product.price', start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchProducts', 'term', term)
            const localVarPath = `/products/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:read", "products:full", "search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates product data.
         * @summary Update a product
         * @param {number} id The ID of the product
         * @param {AddProductRequest1} [AddProductRequest1]

         * @throws {RequiredError}
         */
        updateProduct: async (id: number, AddProductRequest1?: AddProductRequest1, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProduct', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddProductRequest1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new product to the Products inventory. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-product\" target=\"_blank\" rel=\"noopener noreferrer\">adding a product</a>.
         * @summary Add a product
         * @param {AddProductRequest} [AddProductRequest]

         * @throws {RequiredError}
         */
        async addProduct(AddProductRequest?: AddProductRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetproductResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProduct(AddProductRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a follower to a product.
         * @summary Add a follower to a product
         * @param {number} id The ID of the product
         * @param {AddProductFollowerRequest} [AddProductFollowerRequest]

         * @throws {RequiredError}
         */
        async addProductFollower(id: number, AddProductFollowerRequest?: AddProductFollowerRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<NewFollowerResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProductFollower(id, AddProductFollowerRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a product as deleted. After 30 days, the product will be permanently deleted.
         * @summary Delete a product
         * @param {number} id The ID of the product

         * @throws {RequiredError}
         */
        async deleteProduct(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteProductResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a follower from a product.
         * @summary Delete a follower from a product
         * @param {number} id The ID of the product
         * @param {number} follower_id The ID of the relationship between the follower and the product

         * @throws {RequiredError}
         */
        async deleteProductFollower(id: number, follower_id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteProductFollowerResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductFollower(id, follower_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about a specific product.
         * @summary Get one product
         * @param {number} id The ID of the product

         * @throws {RequiredError}
         */
        async getProduct(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetproductResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about deals that have a product attached to it.
         * @summary Get deals where a product is attached to
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.

         * @throws {RequiredError}
         */
        async getProductDeals(id: number, start?: number, limit?: number, status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted', ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedDealsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductDeals(id, start, limit, status, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists files associated with a product.
         * @summary List files attached to a product
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field name and sorting mode (&#x60;field_name_1 ASC&#x60; or &#x60;field_name_1 DESC&#x60;). Supported fields: &#x60;update_time&#x60;, &#x60;id&#x60;

         * @throws {RequiredError}
         */
        async getProductFiles(id: number, start?: number, limit?: number, sort?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedFilesResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductFiles(id, start, limit, sort, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the followers of a product.
         * @summary List followers of a product
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getProductFollowers(id: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProductFollowersResponseSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductFollowers(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists users permitted to access a product.
         * @summary List permitted users
         * @param {number} id The ID of the product

         * @throws {RequiredError}
         */
        async getProductUsers(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UserIds>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductUsers(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all products.
         * @summary Get all products
         * @param {number} [user_id] If supplied, only products owned by the given user will be returned
         * @param {number} [filter_id] The ID of the filter to use
         * @param {Array<number>} [ids] An array of integers with the IDs of the products that should be returned in the response
         * @param {string} [first_char] If supplied, only products whose name starts with the specified letter will be returned (case-insensitive)
         * @param {boolean} [get_summary] If supplied, the response will return the total numbers of products in the &#x60;additional_data.summary.total_count&#x60; property
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getProducts(user_id?: number, filter_id?: number, ids?: Array<number>, first_char?: string, get_summary?: boolean, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProductsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProducts(user_id, filter_id, ids, first_char, get_summary, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches all products by name, code and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search products
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'code' | 'custom_fields' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {'product.price'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async searchProducts(term: string, fields?: 'code' | 'custom_fields' | 'name', exact_match?: boolean, include_fields?: 'product.price', start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SearchProductsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchProducts(term, fields, exact_match, include_fields, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates product data.
         * @summary Update a product
         * @param {number} id The ID of the product
         * @param {AddProductRequest1} [AddProductRequest1]

         * @throws {RequiredError}
         */
        async updateProduct(id: number, AddProductRequest1?: AddProductRequest1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdateProductResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(id, AddProductRequest1, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Adds a new product to the Products inventory. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-product\" target=\"_blank\" rel=\"noopener noreferrer\">adding a product</a>.
         * @summary Add a product
         * @param {ProductsApiAddProductRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addProduct(requestParameters: ProductsApiAddProductRequest = {}, ): Promise<GetproductResponse200> {
            return localVarFp.addProduct(requestParameters.AddProductRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a follower to a product.
         * @summary Add a follower to a product
         * @param {ProductsApiAddProductFollowerRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addProductFollower(requestParameters: ProductsApiAddProductFollowerRequest, ): Promise<NewFollowerResponse200> {
            return localVarFp.addProductFollower(requestParameters.id, requestParameters.AddProductFollowerRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a product as deleted. After 30 days, the product will be permanently deleted.
         * @summary Delete a product
         * @param {ProductsApiDeleteProductRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteProduct(requestParameters: ProductsApiDeleteProductRequest, ): Promise<DeleteProductResponse200> {
            return localVarFp.deleteProduct(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a follower from a product.
         * @summary Delete a follower from a product
         * @param {ProductsApiDeleteProductFollowerRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteProductFollower(requestParameters: ProductsApiDeleteProductFollowerRequest, ): Promise<DeleteProductFollowerResponse200> {
            return localVarFp.deleteProductFollower(requestParameters.id, requestParameters.follower_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about a specific product.
         * @summary Get one product
         * @param {ProductsApiGetProductRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProduct(requestParameters: ProductsApiGetProductRequest, ): Promise<GetproductResponse200> {
            return localVarFp.getProduct(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about deals that have a product attached to it.
         * @summary Get deals where a product is attached to
         * @param {ProductsApiGetProductDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProductDeals(requestParameters: ProductsApiGetProductDealsRequest, ): Promise<GetAssociatedDealsResponse200> {
            return localVarFp.getProductDeals(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.status, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists files associated with a product.
         * @summary List files attached to a product
         * @param {ProductsApiGetProductFilesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProductFiles(requestParameters: ProductsApiGetProductFilesRequest, ): Promise<GetAssociatedFilesResponse2001> {
            return localVarFp.getProductFiles(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists the followers of a product.
         * @summary List followers of a product
         * @param {ProductsApiGetProductFollowersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProductFollowers(requestParameters: ProductsApiGetProductFollowersRequest, ): Promise<GetProductFollowersResponseSuccess> {
            return localVarFp.getProductFollowers(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists users permitted to access a product.
         * @summary List permitted users
         * @param {ProductsApiGetProductUsersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProductUsers(requestParameters: ProductsApiGetProductUsersRequest, ): Promise<UserIds> {
            return localVarFp.getProductUsers(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all products.
         * @summary Get all products
         * @param {ProductsApiGetProductsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProducts(requestParameters: ProductsApiGetProductsRequest = {}, ): Promise<GetProductsResponse200> {
            return localVarFp.getProducts(requestParameters.user_id, requestParameters.filter_id, requestParameters.ids, requestParameters.first_char, requestParameters.get_summary, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Searches all products by name, code and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search products
         * @param {ProductsApiSearchProductsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchProducts(requestParameters: ProductsApiSearchProductsRequest, ): Promise<SearchProductsResponse200> {
            return localVarFp.searchProducts(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.include_fields, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates product data.
         * @summary Update a product
         * @param {ProductsApiUpdateProductRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateProduct(requestParameters: ProductsApiUpdateProductRequest, ): Promise<UpdateProductResponse200> {
            return localVarFp.updateProduct(requestParameters.id, requestParameters.AddProductRequest1, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addProduct operation in ProductsApi.
 * @export
 * @interface ProductsApiAddProductRequest
 */
export interface ProductsApiAddProductRequest {
    /**
     *
     * @type {AddProductRequest}
     * @memberof ProductsApiAddProduct
     */
    readonly AddProductRequest?: AddProductRequest
}

/**
 * Request parameters for addProductFollower operation in ProductsApi.
 * @export
 * @interface ProductsApiAddProductFollowerRequest
 */
export interface ProductsApiAddProductFollowerRequest {
    /**
     * The ID of the product
     * @type {number}
     * @memberof ProductsApiAddProductFollower
     */
    readonly id: number

    /**
     *
     * @type {AddProductFollowerRequest}
     * @memberof ProductsApiAddProductFollower
     */
    readonly AddProductFollowerRequest?: AddProductFollowerRequest
}

/**
 * Request parameters for deleteProduct operation in ProductsApi.
 * @export
 * @interface ProductsApiDeleteProductRequest
 */
export interface ProductsApiDeleteProductRequest {
    /**
     * The ID of the product
     * @type {number}
     * @memberof ProductsApiDeleteProduct
     */
    readonly id: number
}

/**
 * Request parameters for deleteProductFollower operation in ProductsApi.
 * @export
 * @interface ProductsApiDeleteProductFollowerRequest
 */
export interface ProductsApiDeleteProductFollowerRequest {
    /**
     * The ID of the product
     * @type {number}
     * @memberof ProductsApiDeleteProductFollower
     */
    readonly id: number

    /**
     * The ID of the relationship between the follower and the product
     * @type {number}
     * @memberof ProductsApiDeleteProductFollower
     */
    readonly follower_id: number
}

/**
 * Request parameters for getProduct operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductRequest
 */
export interface ProductsApiGetProductRequest {
    /**
     * The ID of the product
     * @type {number}
     * @memberof ProductsApiGetProduct
     */
    readonly id: number
}

/**
 * Request parameters for getProductDeals operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductDealsRequest
 */
export interface ProductsApiGetProductDealsRequest {
    /**
     * The ID of the product
     * @type {number}
     * @memberof ProductsApiGetProductDeals
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof ProductsApiGetProductDeals
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof ProductsApiGetProductDeals
     */
    readonly limit?: number

    /**
     * Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
     * @type {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'}
     * @memberof ProductsApiGetProductDeals
     */
    readonly status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'
}

/**
 * Request parameters for getProductFiles operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductFilesRequest
 */
export interface ProductsApiGetProductFilesRequest {
    /**
     * The ID of the product
     * @type {number}
     * @memberof ProductsApiGetProductFiles
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof ProductsApiGetProductFiles
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof ProductsApiGetProductFiles
     */
    readonly limit?: number

    /**
     * The field name and sorting mode (&#x60;field_name_1 ASC&#x60; or &#x60;field_name_1 DESC&#x60;). Supported fields: &#x60;update_time&#x60;, &#x60;id&#x60;
     * @type {string}
     * @memberof ProductsApiGetProductFiles
     */
    readonly sort?: string
}

/**
 * Request parameters for getProductFollowers operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductFollowersRequest
 */
export interface ProductsApiGetProductFollowersRequest {
    /**
     * The ID of the product
     * @type {number}
     * @memberof ProductsApiGetProductFollowers
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof ProductsApiGetProductFollowers
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof ProductsApiGetProductFollowers
     */
    readonly limit?: number
}

/**
 * Request parameters for getProductUsers operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductUsersRequest
 */
export interface ProductsApiGetProductUsersRequest {
    /**
     * The ID of the product
     * @type {number}
     * @memberof ProductsApiGetProductUsers
     */
    readonly id: number
}

/**
 * Request parameters for getProducts operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductsRequest
 */
export interface ProductsApiGetProductsRequest {
    /**
     * If supplied, only products owned by the given user will be returned
     * @type {number}
     * @memberof ProductsApiGetProducts
     */
    readonly user_id?: number

    /**
     * The ID of the filter to use
     * @type {number}
     * @memberof ProductsApiGetProducts
     */
    readonly filter_id?: number

    /**
     * An array of integers with the IDs of the products that should be returned in the response
     * @type {Array<number>}
     * @memberof ProductsApiGetProducts
     */
    readonly ids?: Array<number>

    /**
     * If supplied, only products whose name starts with the specified letter will be returned (case-insensitive)
     * @type {string}
     * @memberof ProductsApiGetProducts
     */
    readonly first_char?: string

    /**
     * If supplied, the response will return the total numbers of products in the &#x60;additional_data.summary.total_count&#x60; property
     * @type {boolean}
     * @memberof ProductsApiGetProducts
     */
    readonly get_summary?: boolean

    /**
     * Pagination start
     * @type {number}
     * @memberof ProductsApiGetProducts
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof ProductsApiGetProducts
     */
    readonly limit?: number
}

/**
 * Request parameters for searchProducts operation in ProductsApi.
 * @export
 * @interface ProductsApiSearchProductsRequest
 */
export interface ProductsApiSearchProductsRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof ProductsApiSearchProducts
     */
    readonly term: string

    /**
     * A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
     * @type {'code' | 'custom_fields' | 'name'}
     * @memberof ProductsApiSearchProducts
     */
    readonly fields?: 'code' | 'custom_fields' | 'name'

    /**
     * When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @type {boolean}
     * @memberof ProductsApiSearchProducts
     */
    readonly exact_match?: boolean

    /**
     * Supports including optional fields in the results which are not provided by default
     * @type {'product.price'}
     * @memberof ProductsApiSearchProducts
     */
    readonly include_fields?: 'product.price'

    /**
     * Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @type {number}
     * @memberof ProductsApiSearchProducts
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof ProductsApiSearchProducts
     */
    readonly limit?: number
}

/**
 * Request parameters for updateProduct operation in ProductsApi.
 * @export
 * @interface ProductsApiUpdateProductRequest
 */
export interface ProductsApiUpdateProductRequest {
    /**
     * The ID of the product
     * @type {number}
     * @memberof ProductsApiUpdateProduct
     */
    readonly id: number

    /**
     *
     * @type {AddProductRequest1}
     * @memberof ProductsApiUpdateProduct
     */
    readonly AddProductRequest1?: AddProductRequest1
}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Adds a new product to the Products inventory. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-product\" target=\"_blank\" rel=\"noopener noreferrer\">adding a product</a>.
     * @summary Add a product
     * @param {ProductsApiAddProductRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public addProduct(requestParameters: ProductsApiAddProductRequest = {}, ) {
        return ProductsApiFp(this.configuration).addProduct(requestParameters.AddProductRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a follower to a product.
     * @summary Add a follower to a product
     * @param {ProductsApiAddProductFollowerRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public addProductFollower(requestParameters: ProductsApiAddProductFollowerRequest, ) {
        return ProductsApiFp(this.configuration).addProductFollower(requestParameters.id, requestParameters.AddProductFollowerRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a product as deleted. After 30 days, the product will be permanently deleted.
     * @summary Delete a product
     * @param {ProductsApiDeleteProductRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProduct(requestParameters: ProductsApiDeleteProductRequest, ) {
        return ProductsApiFp(this.configuration).deleteProduct(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a follower from a product.
     * @summary Delete a follower from a product
     * @param {ProductsApiDeleteProductFollowerRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductFollower(requestParameters: ProductsApiDeleteProductFollowerRequest, ) {
        return ProductsApiFp(this.configuration).deleteProductFollower(requestParameters.id, requestParameters.follower_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about a specific product.
     * @summary Get one product
     * @param {ProductsApiGetProductRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProduct(requestParameters: ProductsApiGetProductRequest, ) {
        return ProductsApiFp(this.configuration).getProduct(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about deals that have a product attached to it.
     * @summary Get deals where a product is attached to
     * @param {ProductsApiGetProductDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductDeals(requestParameters: ProductsApiGetProductDealsRequest, ) {
        return ProductsApiFp(this.configuration).getProductDeals(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.status, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists files associated with a product.
     * @summary List files attached to a product
     * @param {ProductsApiGetProductFilesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductFiles(requestParameters: ProductsApiGetProductFilesRequest, ) {
        return ProductsApiFp(this.configuration).getProductFiles(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the followers of a product.
     * @summary List followers of a product
     * @param {ProductsApiGetProductFollowersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductFollowers(requestParameters: ProductsApiGetProductFollowersRequest, ) {
        return ProductsApiFp(this.configuration).getProductFollowers(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists users permitted to access a product.
     * @summary List permitted users
     * @param {ProductsApiGetProductUsersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductUsers(requestParameters: ProductsApiGetProductUsersRequest, ) {
        return ProductsApiFp(this.configuration).getProductUsers(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all products.
     * @summary Get all products
     * @param {ProductsApiGetProductsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProducts(requestParameters: ProductsApiGetProductsRequest = {}, ) {
        return ProductsApiFp(this.configuration).getProducts(requestParameters.user_id, requestParameters.filter_id, requestParameters.ids, requestParameters.first_char, requestParameters.get_summary, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches all products by name, code and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
     * @summary Search products
     * @param {ProductsApiSearchProductsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public searchProducts(requestParameters: ProductsApiSearchProductsRequest, ) {
        return ProductsApiFp(this.configuration).searchProducts(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.include_fields, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates product data.
     * @summary Update a product
     * @param {ProductsApiUpdateProductRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProduct(requestParameters: ProductsApiUpdateProductRequest, ) {
        return ProductsApiFp(this.configuration).updateProduct(requestParameters.id, requestParameters.AddProductRequest1, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectTemplatesApi - axios parameter creator
 * @export
 */
export const ProjectTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the details of a specific project template.
         * @summary Get details of a template
         * @param {number} id The ID of the project template

         * @throws {RequiredError}
         */
        getProjectTemplate: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProjectTemplate', 'id', id)
            const localVarPath = `/projectTemplates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read", "projects:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all not deleted project templates. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>.
         * @summary Get all project templates
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, up to 500 items will be returned.

         * @throws {RequiredError}
         */
        getProjectTemplates: async (cursor?: string, limit?: number, ): Promise<RequestArgs> => {
            const localVarPath = `/projectTemplates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read", "projects:full"], configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific project board.
         * @summary Get details of a board
         * @param {number} id The ID of the project board

         * @throws {RequiredError}
         */
        getProjectsBoard: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProjectsBoard', 'id', id)
            const localVarPath = `/projects/boards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read", "projects:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific project phase.
         * @summary Get details of a phase
         * @param {number} id The ID of the project phase

         * @throws {RequiredError}
         */
        getProjectsPhase: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProjectsPhase', 'id', id)
            const localVarPath = `/projects/phases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectTemplatesApi - functional programming interface
 * @export
 */
export const ProjectTemplatesApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = ProjectTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the details of a specific project template.
         * @summary Get details of a template
         * @param {number} id The ID of the project template

         * @throws {RequiredError}
         */
        async getProjectTemplate(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProjectTemplateResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectTemplate(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all not deleted project templates. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>.
         * @summary Get all project templates
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, up to 500 items will be returned.

         * @throws {RequiredError}
         */
        async getProjectTemplates(cursor?: string, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProjectTemplatesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectTemplates(cursor, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a specific project board.
         * @summary Get details of a board
         * @param {number} id The ID of the project board

         * @throws {RequiredError}
         */
        async getProjectsBoard(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProjectBoardResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectsBoard(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a specific project phase.
         * @summary Get details of a phase
         * @param {number} id The ID of the project phase

         * @throws {RequiredError}
         */
        async getProjectsPhase(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProjectPhaseResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectsPhase(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectTemplatesApi - factory interface
 * @export
 */
export const ProjectTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectTemplatesApiFp(configuration)
    return {
        /**
         * Returns the details of a specific project template.
         * @summary Get details of a template
         * @param {ProjectTemplatesApiGetProjectTemplateRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProjectTemplate(requestParameters: ProjectTemplatesApiGetProjectTemplateRequest, ): Promise<GetProjectTemplateResponse200> {
            return localVarFp.getProjectTemplate(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all not deleted project templates. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>.
         * @summary Get all project templates
         * @param {ProjectTemplatesApiGetProjectTemplatesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProjectTemplates(requestParameters: ProjectTemplatesApiGetProjectTemplatesRequest = {}, ): Promise<GetProjectTemplatesResponse200> {
            return localVarFp.getProjectTemplates(requestParameters.cursor, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific project board.
         * @summary Get details of a board
         * @param {ProjectTemplatesApiGetProjectsBoardRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProjectsBoard(requestParameters: ProjectTemplatesApiGetProjectsBoardRequest, ): Promise<GetProjectBoardResponse200> {
            return localVarFp.getProjectsBoard(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific project phase.
         * @summary Get details of a phase
         * @param {ProjectTemplatesApiGetProjectsPhaseRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProjectsPhase(requestParameters: ProjectTemplatesApiGetProjectsPhaseRequest, ): Promise<GetProjectPhaseResponse200> {
            return localVarFp.getProjectsPhase(requestParameters.id, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getProjectTemplate operation in ProjectTemplatesApi.
 * @export
 * @interface ProjectTemplatesApiGetProjectTemplateRequest
 */
export interface ProjectTemplatesApiGetProjectTemplateRequest {
    /**
     * The ID of the project template
     * @type {number}
     * @memberof ProjectTemplatesApiGetProjectTemplate
     */
    readonly id: number
}

/**
 * Request parameters for getProjectTemplates operation in ProjectTemplatesApi.
 * @export
 * @interface ProjectTemplatesApiGetProjectTemplatesRequest
 */
export interface ProjectTemplatesApiGetProjectTemplatesRequest {
    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof ProjectTemplatesApiGetProjectTemplates
     */
    readonly cursor?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, up to 500 items will be returned.
     * @type {number}
     * @memberof ProjectTemplatesApiGetProjectTemplates
     */
    readonly limit?: number
}

/**
 * Request parameters for getProjectsBoard operation in ProjectTemplatesApi.
 * @export
 * @interface ProjectTemplatesApiGetProjectsBoardRequest
 */
export interface ProjectTemplatesApiGetProjectsBoardRequest {
    /**
     * The ID of the project board
     * @type {number}
     * @memberof ProjectTemplatesApiGetProjectsBoard
     */
    readonly id: number
}

/**
 * Request parameters for getProjectsPhase operation in ProjectTemplatesApi.
 * @export
 * @interface ProjectTemplatesApiGetProjectsPhaseRequest
 */
export interface ProjectTemplatesApiGetProjectsPhaseRequest {
    /**
     * The ID of the project phase
     * @type {number}
     * @memberof ProjectTemplatesApiGetProjectsPhase
     */
    readonly id: number
}

/**
 * ProjectTemplatesApi - object-oriented interface
 * @export
 * @class ProjectTemplatesApi
 * @extends {BaseAPI}
 */
export class ProjectTemplatesApi extends BaseAPI {
    /**
     * Returns the details of a specific project template.
     * @summary Get details of a template
     * @param {ProjectTemplatesApiGetProjectTemplateRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectTemplatesApi
     */
    public getProjectTemplate(requestParameters: ProjectTemplatesApiGetProjectTemplateRequest, ) {
        return ProjectTemplatesApiFp(this.configuration).getProjectTemplate(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all not deleted project templates. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>.
     * @summary Get all project templates
     * @param {ProjectTemplatesApiGetProjectTemplatesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectTemplatesApi
     */
    public getProjectTemplates(requestParameters: ProjectTemplatesApiGetProjectTemplatesRequest = {}, ) {
        return ProjectTemplatesApiFp(this.configuration).getProjectTemplates(requestParameters.cursor, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a specific project board.
     * @summary Get details of a board
     * @param {ProjectTemplatesApiGetProjectsBoardRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectTemplatesApi
     */
    public getProjectsBoard(requestParameters: ProjectTemplatesApiGetProjectsBoardRequest, ) {
        return ProjectTemplatesApiFp(this.configuration).getProjectsBoard(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a specific project phase.
     * @summary Get details of a phase
     * @param {ProjectTemplatesApiGetProjectsPhaseRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectTemplatesApi
     */
    public getProjectsPhase(requestParameters: ProjectTemplatesApiGetProjectsPhaseRequest, ) {
        return ProjectTemplatesApiFp(this.configuration).getProjectsPhase(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new project. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys.
         * @summary Add a project
         * @param {AddProjectRequest} [AddProjectRequest]

         * @throws {RequiredError}
         */
        addProject: async (AddProjectRequest?: AddProjectRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archives a project.
         * @summary Archive a project
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        archiveProject: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('archiveProject', 'id', id)
            const localVarPath = `/projects/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a project as deleted.
         * @summary Delete a project
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        deleteProject: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProject', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific project. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of project fields.
         * @summary Get details of a project
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        getProject: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProject', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read", "projects:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns activities linked to a specific project.
         * @summary Returns project activities
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        getProjectActivities: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProjectActivities', 'id', id)
            const localVarPath = `/projects/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read", "projects:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all active groups under a specific project.
         * @summary Returns project groups
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        getProjectGroups: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProjectGroups', 'id', id)
            const localVarPath = `/projects/{id}/groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read", "projects:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about items in a project plan. Items consists of tasks and activities and are linked to specific project phase and group.
         * @summary Returns project plan
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        getProjectPlan: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProjectPlan', 'id', id)
            const localVarPath = `/projects/{id}/plan`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read", "projects:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns tasks linked to a specific project.
         * @summary Returns project tasks
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        getProjectTasks: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProjectTasks', 'id', id)
            const localVarPath = `/projects/{id}/tasks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read", "projects:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all projects. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>.
         * @summary Get all projects
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [status] If supplied, includes only projects with the specified statuses. Possible values are &#x60;open&#x60;, &#x60;completed&#x60;, &#x60;canceled&#x60; and &#x60;deleted&#x60;. By default &#x60;deleted&#x60; projects are not returned.
         * @param {number} [phase_id] If supplied, only projects in specified phase are returned
         * @param {boolean} [include_archived] If supplied with &#x60;true&#x60; then archived projects are also included in the response. By default only not archived projects are returned.

         * @throws {RequiredError}
         */
        getProjects: async (cursor?: string, limit?: number, filter_id?: number, status?: string, phase_id?: number, include_archived?: boolean, ): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read", "projects:full"], configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (phase_id !== undefined) {
                localVarQueryParameter['phase_id'] = phase_id;
            }

            if (include_archived !== undefined) {
                localVarQueryParameter['include_archived'] = include_archived;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all projects boards that are not deleted.
         * @summary Get all project boards

         * @throws {RequiredError}
         */
        getProjectsBoards: async (): Promise<RequestArgs> => {
            const localVarPath = `/projects/boards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read", "projects:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all active project phases under a specific board.
         * @summary Get project phases
         * @param {number} board_id ID of the board for which phases are requested

         * @throws {RequiredError}
         */
        getProjectsPhases: async (board_id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'board_id' is not null or undefined
            assertParamExists('getProjectsPhases', 'board_id', board_id)
            const localVarPath = `/projects/phases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read", "projects:full"], configuration)

            if (board_id !== undefined) {
                localVarQueryParameter['board_id'] = board_id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an activity phase or group in a project.
         * @summary Update activity in project plan
         * @param {number} id The ID of the project
         * @param {number} activityId The ID of the activity
         * @param {ProjectPutPlanItemBodyObject} [ProjectPutPlanItemBodyObject]

         * @throws {RequiredError}
         */
        putProjectPlanActivity: async (id: number, activityId: number, ProjectPutPlanItemBodyObject?: ProjectPutPlanItemBodyObject, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putProjectPlanActivity', 'id', id)
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists('putProjectPlanActivity', 'activityId', activityId)
            const localVarPath = `/projects/{id}/plan/activities/{activityId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(ProjectPutPlanItemBodyObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a task phase or group in a project.
         * @summary Update task in project plan
         * @param {number} id The ID of the project
         * @param {number} taskId The ID of the task
         * @param {ProjectPutPlanItemBodyObject} [ProjectPutPlanItemBodyObject]

         * @throws {RequiredError}
         */
        putProjectPlanTask: async (id: number, taskId: number, ProjectPutPlanItemBodyObject?: ProjectPutPlanItemBodyObject, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putProjectPlanTask', 'id', id)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('putProjectPlanTask', 'taskId', taskId)
            const localVarPath = `/projects/{id}/plan/tasks/{taskId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(ProjectPutPlanItemBodyObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a project.
         * @summary Update a project
         * @param {number} id The ID of the project
         * @param {UpdateProjectRequest} [UpdateProjectRequest]

         * @throws {RequiredError}
         */
        updateProject: async (id: number, UpdateProjectRequest?: UpdateProjectRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProject', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new project. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys.
         * @summary Add a project
         * @param {AddProjectRequest} [AddProjectRequest]

         * @throws {RequiredError}
         */
        async addProject(AddProjectRequest?: AddProjectRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddProjectResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProject(AddProjectRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Archives a project.
         * @summary Archive a project
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        async archiveProject(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdateProjectResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveProject(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a project as deleted.
         * @summary Delete a project
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        async deleteProject(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteProjectResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a specific project. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of project fields.
         * @summary Get details of a project
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        async getProject(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProjectResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns activities linked to a specific project.
         * @summary Returns project activities
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        async getProjectActivities(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetActivitiesCollectionResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectActivities(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all active groups under a specific project.
         * @summary Returns project groups
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        async getProjectGroups(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProjectGroupsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectGroups(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about items in a project plan. Items consists of tasks and activities and are linked to specific project phase and group.
         * @summary Returns project plan
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        async getProjectPlan(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProjectPlanResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectPlan(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns tasks linked to a specific project.
         * @summary Returns project tasks
         * @param {number} id The ID of the project

         * @throws {RequiredError}
         */
        async getProjectTasks(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetTasksResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectTasks(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all projects. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>.
         * @summary Get all projects
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [status] If supplied, includes only projects with the specified statuses. Possible values are &#x60;open&#x60;, &#x60;completed&#x60;, &#x60;canceled&#x60; and &#x60;deleted&#x60;. By default &#x60;deleted&#x60; projects are not returned.
         * @param {number} [phase_id] If supplied, only projects in specified phase are returned
         * @param {boolean} [include_archived] If supplied with &#x60;true&#x60; then archived projects are also included in the response. By default only not archived projects are returned.

         * @throws {RequiredError}
         */
        async getProjects(cursor?: string, limit?: number, filter_id?: number, status?: string, phase_id?: number, include_archived?: boolean, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProjectsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjects(cursor, limit, filter_id, status, phase_id, include_archived, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all projects boards that are not deleted.
         * @summary Get all project boards

         * @throws {RequiredError}
         */
        async getProjectsBoards(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProjectBoardsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectsBoards();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all active project phases under a specific board.
         * @summary Get project phases
         * @param {number} board_id ID of the board for which phases are requested

         * @throws {RequiredError}
         */
        async getProjectsPhases(board_id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetProjectPhasesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectsPhases(board_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an activity phase or group in a project.
         * @summary Update activity in project plan
         * @param {number} id The ID of the project
         * @param {number} activityId The ID of the activity
         * @param {ProjectPutPlanItemBodyObject} [ProjectPutPlanItemBodyObject]

         * @throws {RequiredError}
         */
        async putProjectPlanActivity(id: number, activityId: number, ProjectPutPlanItemBodyObject?: ProjectPutPlanItemBodyObject, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdatedActivityPlanItem200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProjectPlanActivity(id, activityId, ProjectPutPlanItemBodyObject, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a task phase or group in a project.
         * @summary Update task in project plan
         * @param {number} id The ID of the project
         * @param {number} taskId The ID of the task
         * @param {ProjectPutPlanItemBodyObject} [ProjectPutPlanItemBodyObject]

         * @throws {RequiredError}
         */
        async putProjectPlanTask(id: number, taskId: number, ProjectPutPlanItemBodyObject?: ProjectPutPlanItemBodyObject, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdatedTaskPlanItem200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProjectPlanTask(id, taskId, ProjectPutPlanItemBodyObject, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a project.
         * @summary Update a project
         * @param {number} id The ID of the project
         * @param {UpdateProjectRequest} [UpdateProjectRequest]

         * @throws {RequiredError}
         */
        async updateProject(id: number, UpdateProjectRequest?: UpdateProjectRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdateProjectResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(id, UpdateProjectRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Adds a new project. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys.
         * @summary Add a project
         * @param {ProjectsApiAddProjectRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addProject(requestParameters: ProjectsApiAddProjectRequest = {}, ): Promise<AddProjectResponse201> {
            return localVarFp.addProject(requestParameters.AddProjectRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Archives a project.
         * @summary Archive a project
         * @param {ProjectsApiArchiveProjectRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        archiveProject(requestParameters: ProjectsApiArchiveProjectRequest, ): Promise<UpdateProjectResponse200> {
            return localVarFp.archiveProject(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a project as deleted.
         * @summary Delete a project
         * @param {ProjectsApiDeleteProjectRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteProject(requestParameters: ProjectsApiDeleteProjectRequest, ): Promise<DeleteProjectResponse200> {
            return localVarFp.deleteProject(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific project. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of project fields.
         * @summary Get details of a project
         * @param {ProjectsApiGetProjectRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProject(requestParameters: ProjectsApiGetProjectRequest, ): Promise<GetProjectResponse200> {
            return localVarFp.getProject(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns activities linked to a specific project.
         * @summary Returns project activities
         * @param {ProjectsApiGetProjectActivitiesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProjectActivities(requestParameters: ProjectsApiGetProjectActivitiesRequest, ): Promise<GetActivitiesCollectionResponse200> {
            return localVarFp.getProjectActivities(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all active groups under a specific project.
         * @summary Returns project groups
         * @param {ProjectsApiGetProjectGroupsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProjectGroups(requestParameters: ProjectsApiGetProjectGroupsRequest, ): Promise<GetProjectGroupsResponse200> {
            return localVarFp.getProjectGroups(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about items in a project plan. Items consists of tasks and activities and are linked to specific project phase and group.
         * @summary Returns project plan
         * @param {ProjectsApiGetProjectPlanRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProjectPlan(requestParameters: ProjectsApiGetProjectPlanRequest, ): Promise<GetProjectPlanResponse200> {
            return localVarFp.getProjectPlan(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns tasks linked to a specific project.
         * @summary Returns project tasks
         * @param {ProjectsApiGetProjectTasksRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProjectTasks(requestParameters: ProjectsApiGetProjectTasksRequest, ): Promise<GetTasksResponse200> {
            return localVarFp.getProjectTasks(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all projects. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>.
         * @summary Get all projects
         * @param {ProjectsApiGetProjectsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProjects(requestParameters: ProjectsApiGetProjectsRequest = {}, ): Promise<GetProjectsResponse200> {
            return localVarFp.getProjects(requestParameters.cursor, requestParameters.limit, requestParameters.filter_id, requestParameters.status, requestParameters.phase_id, requestParameters.include_archived, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all projects boards that are not deleted.
         * @summary Get all project boards

         * @throws {RequiredError}
         */
        getProjectsBoards(): Promise<GetProjectBoardsResponse200> {
            return localVarFp.getProjectsBoards().then((request) => request(axios, basePath));
        },
        /**
         * Returns all active project phases under a specific board.
         * @summary Get project phases
         * @param {ProjectsApiGetProjectsPhasesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getProjectsPhases(requestParameters: ProjectsApiGetProjectsPhasesRequest, ): Promise<GetProjectPhasesResponse200> {
            return localVarFp.getProjectsPhases(requestParameters.board_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates an activity phase or group in a project.
         * @summary Update activity in project plan
         * @param {ProjectsApiPutProjectPlanActivityRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        putProjectPlanActivity(requestParameters: ProjectsApiPutProjectPlanActivityRequest, ): Promise<UpdatedActivityPlanItem200> {
            return localVarFp.putProjectPlanActivity(requestParameters.id, requestParameters.activityId, requestParameters.ProjectPutPlanItemBodyObject, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates a task phase or group in a project.
         * @summary Update task in project plan
         * @param {ProjectsApiPutProjectPlanTaskRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        putProjectPlanTask(requestParameters: ProjectsApiPutProjectPlanTaskRequest, ): Promise<UpdatedTaskPlanItem200> {
            return localVarFp.putProjectPlanTask(requestParameters.id, requestParameters.taskId, requestParameters.ProjectPutPlanItemBodyObject, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates a project.
         * @summary Update a project
         * @param {ProjectsApiUpdateProjectRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateProject(requestParameters: ProjectsApiUpdateProjectRequest, ): Promise<UpdateProjectResponse200> {
            return localVarFp.updateProject(requestParameters.id, requestParameters.UpdateProjectRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiAddProjectRequest
 */
export interface ProjectsApiAddProjectRequest {
    /**
     *
     * @type {AddProjectRequest}
     * @memberof ProjectsApiAddProject
     */
    readonly AddProjectRequest?: AddProjectRequest
}

/**
 * Request parameters for archiveProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiArchiveProjectRequest
 */
export interface ProjectsApiArchiveProjectRequest {
    /**
     * The ID of the project
     * @type {number}
     * @memberof ProjectsApiArchiveProject
     */
    readonly id: number
}

/**
 * Request parameters for deleteProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiDeleteProjectRequest
 */
export interface ProjectsApiDeleteProjectRequest {
    /**
     * The ID of the project
     * @type {number}
     * @memberof ProjectsApiDeleteProject
     */
    readonly id: number
}

/**
 * Request parameters for getProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetProjectRequest
 */
export interface ProjectsApiGetProjectRequest {
    /**
     * The ID of the project
     * @type {number}
     * @memberof ProjectsApiGetProject
     */
    readonly id: number
}

/**
 * Request parameters for getProjectActivities operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetProjectActivitiesRequest
 */
export interface ProjectsApiGetProjectActivitiesRequest {
    /**
     * The ID of the project
     * @type {number}
     * @memberof ProjectsApiGetProjectActivities
     */
    readonly id: number
}

/**
 * Request parameters for getProjectGroups operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetProjectGroupsRequest
 */
export interface ProjectsApiGetProjectGroupsRequest {
    /**
     * The ID of the project
     * @type {number}
     * @memberof ProjectsApiGetProjectGroups
     */
    readonly id: number
}

/**
 * Request parameters for getProjectPlan operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetProjectPlanRequest
 */
export interface ProjectsApiGetProjectPlanRequest {
    /**
     * The ID of the project
     * @type {number}
     * @memberof ProjectsApiGetProjectPlan
     */
    readonly id: number
}

/**
 * Request parameters for getProjectTasks operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetProjectTasksRequest
 */
export interface ProjectsApiGetProjectTasksRequest {
    /**
     * The ID of the project
     * @type {number}
     * @memberof ProjectsApiGetProjectTasks
     */
    readonly id: number
}

/**
 * Request parameters for getProjects operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetProjectsRequest
 */
export interface ProjectsApiGetProjectsRequest {
    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof ProjectsApiGetProjects
     */
    readonly cursor?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
     * @type {number}
     * @memberof ProjectsApiGetProjects
     */
    readonly limit?: number

    /**
     * The ID of the filter to use
     * @type {number}
     * @memberof ProjectsApiGetProjects
     */
    readonly filter_id?: number

    /**
     * If supplied, includes only projects with the specified statuses. Possible values are &#x60;open&#x60;, &#x60;completed&#x60;, &#x60;canceled&#x60; and &#x60;deleted&#x60;. By default &#x60;deleted&#x60; projects are not returned.
     * @type {string}
     * @memberof ProjectsApiGetProjects
     */
    readonly status?: string

    /**
     * If supplied, only projects in specified phase are returned
     * @type {number}
     * @memberof ProjectsApiGetProjects
     */
    readonly phase_id?: number

    /**
     * If supplied with &#x60;true&#x60; then archived projects are also included in the response. By default only not archived projects are returned.
     * @type {boolean}
     * @memberof ProjectsApiGetProjects
     */
    readonly include_archived?: boolean
}

/**
 * Request parameters for getProjectsPhases operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetProjectsPhasesRequest
 */
export interface ProjectsApiGetProjectsPhasesRequest {
    /**
     * ID of the board for which phases are requested
     * @type {number}
     * @memberof ProjectsApiGetProjectsPhases
     */
    readonly board_id: number
}

/**
 * Request parameters for putProjectPlanActivity operation in ProjectsApi.
 * @export
 * @interface ProjectsApiPutProjectPlanActivityRequest
 */
export interface ProjectsApiPutProjectPlanActivityRequest {
    /**
     * The ID of the project
     * @type {number}
     * @memberof ProjectsApiPutProjectPlanActivity
     */
    readonly id: number

    /**
     * The ID of the activity
     * @type {number}
     * @memberof ProjectsApiPutProjectPlanActivity
     */
    readonly activityId: number

    /**
     *
     * @type {ProjectPutPlanItemBodyObject}
     * @memberof ProjectsApiPutProjectPlanActivity
     */
    readonly ProjectPutPlanItemBodyObject?: ProjectPutPlanItemBodyObject
}

/**
 * Request parameters for putProjectPlanTask operation in ProjectsApi.
 * @export
 * @interface ProjectsApiPutProjectPlanTaskRequest
 */
export interface ProjectsApiPutProjectPlanTaskRequest {
    /**
     * The ID of the project
     * @type {number}
     * @memberof ProjectsApiPutProjectPlanTask
     */
    readonly id: number

    /**
     * The ID of the task
     * @type {number}
     * @memberof ProjectsApiPutProjectPlanTask
     */
    readonly taskId: number

    /**
     *
     * @type {ProjectPutPlanItemBodyObject}
     * @memberof ProjectsApiPutProjectPlanTask
     */
    readonly ProjectPutPlanItemBodyObject?: ProjectPutPlanItemBodyObject
}

/**
 * Request parameters for updateProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiUpdateProjectRequest
 */
export interface ProjectsApiUpdateProjectRequest {
    /**
     * The ID of the project
     * @type {number}
     * @memberof ProjectsApiUpdateProject
     */
    readonly id: number

    /**
     *
     * @type {UpdateProjectRequest}
     * @memberof ProjectsApiUpdateProject
     */
    readonly UpdateProjectRequest?: UpdateProjectRequest
}

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Adds a new project. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys.
     * @summary Add a project
     * @param {ProjectsApiAddProjectRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public addProject(requestParameters: ProjectsApiAddProjectRequest = {}, ) {
        return ProjectsApiFp(this.configuration).addProject(requestParameters.AddProjectRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archives a project.
     * @summary Archive a project
     * @param {ProjectsApiArchiveProjectRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public archiveProject(requestParameters: ProjectsApiArchiveProjectRequest, ) {
        return ProjectsApiFp(this.configuration).archiveProject(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a project as deleted.
     * @summary Delete a project
     * @param {ProjectsApiDeleteProjectRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(requestParameters: ProjectsApiDeleteProjectRequest, ) {
        return ProjectsApiFp(this.configuration).deleteProject(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a specific project. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of project fields.
     * @summary Get details of a project
     * @param {ProjectsApiGetProjectRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(requestParameters: ProjectsApiGetProjectRequest, ) {
        return ProjectsApiFp(this.configuration).getProject(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns activities linked to a specific project.
     * @summary Returns project activities
     * @param {ProjectsApiGetProjectActivitiesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectActivities(requestParameters: ProjectsApiGetProjectActivitiesRequest, ) {
        return ProjectsApiFp(this.configuration).getProjectActivities(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all active groups under a specific project.
     * @summary Returns project groups
     * @param {ProjectsApiGetProjectGroupsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectGroups(requestParameters: ProjectsApiGetProjectGroupsRequest, ) {
        return ProjectsApiFp(this.configuration).getProjectGroups(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about items in a project plan. Items consists of tasks and activities and are linked to specific project phase and group.
     * @summary Returns project plan
     * @param {ProjectsApiGetProjectPlanRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectPlan(requestParameters: ProjectsApiGetProjectPlanRequest, ) {
        return ProjectsApiFp(this.configuration).getProjectPlan(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns tasks linked to a specific project.
     * @summary Returns project tasks
     * @param {ProjectsApiGetProjectTasksRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectTasks(requestParameters: ProjectsApiGetProjectTasksRequest, ) {
        return ProjectsApiFp(this.configuration).getProjectTasks(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all projects. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>.
     * @summary Get all projects
     * @param {ProjectsApiGetProjectsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjects(requestParameters: ProjectsApiGetProjectsRequest = {}, ) {
        return ProjectsApiFp(this.configuration).getProjects(requestParameters.cursor, requestParameters.limit, requestParameters.filter_id, requestParameters.status, requestParameters.phase_id, requestParameters.include_archived, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all projects boards that are not deleted.
     * @summary Get all project boards

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectsBoards() {
        return ProjectsApiFp(this.configuration).getProjectsBoards().then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all active project phases under a specific board.
     * @summary Get project phases
     * @param {ProjectsApiGetProjectsPhasesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectsPhases(requestParameters: ProjectsApiGetProjectsPhasesRequest, ) {
        return ProjectsApiFp(this.configuration).getProjectsPhases(requestParameters.board_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an activity phase or group in a project.
     * @summary Update activity in project plan
     * @param {ProjectsApiPutProjectPlanActivityRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public putProjectPlanActivity(requestParameters: ProjectsApiPutProjectPlanActivityRequest, ) {
        return ProjectsApiFp(this.configuration).putProjectPlanActivity(requestParameters.id, requestParameters.activityId, requestParameters.ProjectPutPlanItemBodyObject, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a task phase or group in a project.
     * @summary Update task in project plan
     * @param {ProjectsApiPutProjectPlanTaskRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public putProjectPlanTask(requestParameters: ProjectsApiPutProjectPlanTaskRequest, ) {
        return ProjectsApiFp(this.configuration).putProjectPlanTask(requestParameters.id, requestParameters.taskId, requestParameters.ProjectPutPlanItemBodyObject, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a project.
     * @summary Update a project
     * @param {ProjectsApiUpdateProjectRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProject(requestParameters: ProjectsApiUpdateProjectRequest, ) {
        return ProjectsApiFp(this.configuration).updateProject(requestParameters.id, requestParameters.UpdateProjectRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RecentsApi - axios parameter creator
 * @export
 */
export const RecentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns data about all recent changes occurred after the given timestamp.
         * @summary Get recents
         * @param {string} since_timestamp The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
         * @param {'activity' | 'activityType' | 'deal' | 'file' | 'filter' | 'note' | 'person' | 'organization' | 'pipeline' | 'product' | 'stage' | 'user'} [items] Multiple selection of item types to include in the query (optional)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getRecents: async (since_timestamp: string, items?: 'activity' | 'activityType' | 'deal' | 'file' | 'filter' | 'note' | 'person' | 'organization' | 'pipeline' | 'product' | 'stage' | 'user', start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'since_timestamp' is not null or undefined
            assertParamExists('getRecents', 'since_timestamp', since_timestamp)
            const localVarPath = `/recents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["recents:read", "search:read"], configuration)

            if (since_timestamp !== undefined) {
                localVarQueryParameter['since_timestamp'] = since_timestamp;
            }

            if (items !== undefined) {
                localVarQueryParameter['items'] = items;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecentsApi - functional programming interface
 * @export
 */
export const RecentsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = RecentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns data about all recent changes occurred after the given timestamp.
         * @summary Get recents
         * @param {string} since_timestamp The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
         * @param {'activity' | 'activityType' | 'deal' | 'file' | 'filter' | 'note' | 'person' | 'organization' | 'pipeline' | 'product' | 'stage' | 'user'} [items] Multiple selection of item types to include in the query (optional)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getRecents(since_timestamp: string, items?: 'activity' | 'activityType' | 'deal' | 'file' | 'filter' | 'note' | 'person' | 'organization' | 'pipeline' | 'product' | 'stage' | 'user', start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetRecentsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecents(since_timestamp, items, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RecentsApi - factory interface
 * @export
 */
export const RecentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecentsApiFp(configuration)
    return {
        /**
         * Returns data about all recent changes occurred after the given timestamp.
         * @summary Get recents
         * @param {RecentsApiGetRecentsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getRecents(requestParameters: RecentsApiGetRecentsRequest, ): Promise<GetRecentsResponse200> {
            return localVarFp.getRecents(requestParameters.since_timestamp, requestParameters.items, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getRecents operation in RecentsApi.
 * @export
 * @interface RecentsApiGetRecentsRequest
 */
export interface RecentsApiGetRecentsRequest {
    /**
     * The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof RecentsApiGetRecents
     */
    readonly since_timestamp: string

    /**
     * Multiple selection of item types to include in the query (optional)
     * @type {'activity' | 'activityType' | 'deal' | 'file' | 'filter' | 'note' | 'person' | 'organization' | 'pipeline' | 'product' | 'stage' | 'user'}
     * @memberof RecentsApiGetRecents
     */
    readonly items?: 'activity' | 'activityType' | 'deal' | 'file' | 'filter' | 'note' | 'person' | 'organization' | 'pipeline' | 'product' | 'stage' | 'user'

    /**
     * Pagination start
     * @type {number}
     * @memberof RecentsApiGetRecents
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof RecentsApiGetRecents
     */
    readonly limit?: number
}

/**
 * RecentsApi - object-oriented interface
 * @export
 * @class RecentsApi
 * @extends {BaseAPI}
 */
export class RecentsApi extends BaseAPI {
    /**
     * Returns data about all recent changes occurred after the given timestamp.
     * @summary Get recents
     * @param {RecentsApiGetRecentsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof RecentsApi
     */
    public getRecents(requestParameters: RecentsApiGetRecentsRequest, ) {
        return RecentsApiFp(this.configuration).getRecents(requestParameters.since_timestamp, requestParameters.items, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds or updates the visibility setting for a role.
         * @summary Add or update role setting
         * @param {number} id The ID of the role
         * @param {AddOrUpdateRoleSettingRequest} [AddOrUpdateRoleSettingRequest]

         * @throws {RequiredError}
         */
        addOrUpdateRoleSetting: async (id: number, AddOrUpdateRoleSettingRequest?: AddOrUpdateRoleSettingRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addOrUpdateRoleSetting', 'id', id)
            const localVarPath = `/roles/{id}/settings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddOrUpdateRoleSettingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new role.
         * @summary Add a role
         * @param {AddRoleRequest} [AddRoleRequest]

         * @throws {RequiredError}
         */
        addRole: async (AddRoleRequest?: AddRoleRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns a user to a role.
         * @summary Add role assignment
         * @param {number} id The ID of the role
         * @param {AddRoleAssignmentRequest} [AddRoleAssignmentRequest]

         * @throws {RequiredError}
         */
        addRoleAssignment: async (id: number, AddRoleAssignmentRequest?: AddRoleAssignmentRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addRoleAssignment', 'id', id)
            const localVarPath = `/roles/{id}/assignments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddRoleAssignmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a role as deleted.
         * @summary Delete a role
         * @param {number} id The ID of the role

         * @throws {RequiredError}
         */
        deleteRole: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the assigned user from a role and adds to the default role.
         * @summary Delete a role assignment
         * @param {number} id The ID of the role
         * @param {DeleteRoleAssignmentRequest} [DeleteRoleAssignmentRequest]

         * @throws {RequiredError}
         */
        deleteRoleAssignment: async (id: number, DeleteRoleAssignmentRequest?: DeleteRoleAssignmentRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRoleAssignment', 'id', id)
            const localVarPath = `/roles/{id}/assignments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(DeleteRoleAssignmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific role.
         * @summary Get one role
         * @param {number} id The ID of the role

         * @throws {RequiredError}
         */
        getRole: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all users assigned to a role.
         * @summary List role assignments
         * @param {number} id The ID of the role
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getRoleAssignments: async (id: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoleAssignments', 'id', id)
            const localVarPath = `/roles/{id}/assignments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of either visible or hidden pipeline IDs for a specific role. For more information on pipeline visibility, please refer to the <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">Visibility groups article</a>.
         * @summary List pipeline visibility for a role
         * @param {number} id The ID of the role
         * @param {boolean} [visible] Whether to return the visible or hidden pipelines for the role

         * @throws {RequiredError}
         */
        getRolePipelines: async (id: number, visible?: boolean, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRolePipelines', 'id', id)
            const localVarPath = `/roles/{id}/pipelines`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)

            if (visible !== undefined) {
                localVarQueryParameter['visible'] = visible;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the visibility settings of a specific role.
         * @summary List role settings
         * @param {number} id The ID of the role

         * @throws {RequiredError}
         */
        getRoleSettings: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoleSettings', 'id', id)
            const localVarPath = `/roles/{id}/settings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the roles within the company.
         * @summary Get all roles
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getRoles: async (start?: number, limit?: number, ): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the parent role and/or the name of a specific role.
         * @summary Update role details
         * @param {number} id The ID of the role
         * @param {BaseRoleRequest} [BaseRoleRequest]

         * @throws {RequiredError}
         */
        updateRole: async (id: number, BaseRoleRequest?: BaseRoleRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(BaseRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified pipelines to be visible and/or hidden for a specific role. For more information on pipeline visibility, please refer to the <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">Visibility groups article</a>.
         * @summary Update pipeline visibility for a role
         * @param {number} id The ID of the role
         * @param {PutRolePipelinesBody} [PutRolePipelinesBody]

         * @throws {RequiredError}
         */
        updateRolePipelines: async (id: number, PutRolePipelinesBody?: PutRolePipelinesBody, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRolePipelines', 'id', id)
            const localVarPath = `/roles/{id}/pipelines`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(PutRolePipelinesBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds or updates the visibility setting for a role.
         * @summary Add or update role setting
         * @param {number} id The ID of the role
         * @param {AddOrUpdateRoleSettingRequest} [AddOrUpdateRoleSettingRequest]

         * @throws {RequiredError}
         */
        async addOrUpdateRoleSetting(id: number, AddOrUpdateRoleSettingRequest?: AddOrUpdateRoleSettingRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddOrUpdateRoleSettingResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrUpdateRoleSetting(id, AddOrUpdateRoleSettingRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new role.
         * @summary Add a role
         * @param {AddRoleRequest} [AddRoleRequest]

         * @throws {RequiredError}
         */
        async addRole(AddRoleRequest?: AddRoleRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddRoleResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRole(AddRoleRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Assigns a user to a role.
         * @summary Add role assignment
         * @param {number} id The ID of the role
         * @param {AddRoleAssignmentRequest} [AddRoleAssignmentRequest]

         * @throws {RequiredError}
         */
        async addRoleAssignment(id: number, AddRoleAssignmentRequest?: AddRoleAssignmentRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddRoleAssignmentResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRoleAssignment(id, AddRoleAssignmentRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a role as deleted.
         * @summary Delete a role
         * @param {number} id The ID of the role

         * @throws {RequiredError}
         */
        async deleteRole(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteRoleResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the assigned user from a role and adds to the default role.
         * @summary Delete a role assignment
         * @param {number} id The ID of the role
         * @param {DeleteRoleAssignmentRequest} [DeleteRoleAssignmentRequest]

         * @throws {RequiredError}
         */
        async deleteRoleAssignment(id: number, DeleteRoleAssignmentRequest?: DeleteRoleAssignmentRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteRoleAssignmentResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleAssignment(id, DeleteRoleAssignmentRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a specific role.
         * @summary Get one role
         * @param {number} id The ID of the role

         * @throws {RequiredError}
         */
        async getRole(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetRoleResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all users assigned to a role.
         * @summary List role assignments
         * @param {number} id The ID of the role
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getRoleAssignments(id: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetUserRoleAssignmentsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleAssignments(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of either visible or hidden pipeline IDs for a specific role. For more information on pipeline visibility, please refer to the <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">Visibility groups article</a>.
         * @summary List pipeline visibility for a role
         * @param {number} id The ID of the role
         * @param {boolean} [visible] Whether to return the visible or hidden pipelines for the role

         * @throws {RequiredError}
         */
        async getRolePipelines(id: number, visible?: boolean, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetRolePipelines200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRolePipelines(id, visible, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the visibility settings of a specific role.
         * @summary List role settings
         * @param {number} id The ID of the role

         * @throws {RequiredError}
         */
        async getRoleSettings(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetRoleSettingsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleSettings(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all the roles within the company.
         * @summary Get all roles
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getRoles(start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetRolesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoles(start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the parent role and/or the name of a specific role.
         * @summary Update role details
         * @param {number} id The ID of the role
         * @param {BaseRoleRequest} [BaseRoleRequest]

         * @throws {RequiredError}
         */
        async updateRole(id: number, BaseRoleRequest?: BaseRoleRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdateRoleResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(id, BaseRoleRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the specified pipelines to be visible and/or hidden for a specific role. For more information on pipeline visibility, please refer to the <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">Visibility groups article</a>.
         * @summary Update pipeline visibility for a role
         * @param {number} id The ID of the role
         * @param {PutRolePipelinesBody} [PutRolePipelinesBody]

         * @throws {RequiredError}
         */
        async updateRolePipelines(id: number, PutRolePipelinesBody?: PutRolePipelinesBody, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetRolePipelines200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRolePipelines(id, PutRolePipelinesBody, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * Adds or updates the visibility setting for a role.
         * @summary Add or update role setting
         * @param {RolesApiAddOrUpdateRoleSettingRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addOrUpdateRoleSetting(requestParameters: RolesApiAddOrUpdateRoleSettingRequest, ): Promise<AddOrUpdateRoleSettingResponse200> {
            return localVarFp.addOrUpdateRoleSetting(requestParameters.id, requestParameters.AddOrUpdateRoleSettingRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new role.
         * @summary Add a role
         * @param {RolesApiAddRoleRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addRole(requestParameters: RolesApiAddRoleRequest = {}, ): Promise<AddRoleResponse200> {
            return localVarFp.addRole(requestParameters.AddRoleRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Assigns a user to a role.
         * @summary Add role assignment
         * @param {RolesApiAddRoleAssignmentRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addRoleAssignment(requestParameters: RolesApiAddRoleAssignmentRequest, ): Promise<AddRoleAssignmentResponse200> {
            return localVarFp.addRoleAssignment(requestParameters.id, requestParameters.AddRoleAssignmentRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a role as deleted.
         * @summary Delete a role
         * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteRole(requestParameters: RolesApiDeleteRoleRequest, ): Promise<DeleteRoleResponse200> {
            return localVarFp.deleteRole(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Removes the assigned user from a role and adds to the default role.
         * @summary Delete a role assignment
         * @param {RolesApiDeleteRoleAssignmentRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteRoleAssignment(requestParameters: RolesApiDeleteRoleAssignmentRequest, ): Promise<DeleteRoleAssignmentResponse200> {
            return localVarFp.deleteRoleAssignment(requestParameters.id, requestParameters.DeleteRoleAssignmentRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific role.
         * @summary Get one role
         * @param {RolesApiGetRoleRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getRole(requestParameters: RolesApiGetRoleRequest, ): Promise<GetRoleResponse200> {
            return localVarFp.getRole(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all users assigned to a role.
         * @summary List role assignments
         * @param {RolesApiGetRoleAssignmentsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getRoleAssignments(requestParameters: RolesApiGetRoleAssignmentsRequest, ): Promise<GetUserRoleAssignmentsResponse200> {
            return localVarFp.getRoleAssignments(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of either visible or hidden pipeline IDs for a specific role. For more information on pipeline visibility, please refer to the <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">Visibility groups article</a>.
         * @summary List pipeline visibility for a role
         * @param {RolesApiGetRolePipelinesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getRolePipelines(requestParameters: RolesApiGetRolePipelinesRequest, ): Promise<GetRolePipelines200> {
            return localVarFp.getRolePipelines(requestParameters.id, requestParameters.visible, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the visibility settings of a specific role.
         * @summary List role settings
         * @param {RolesApiGetRoleSettingsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getRoleSettings(requestParameters: RolesApiGetRoleSettingsRequest, ): Promise<GetRoleSettingsResponse200> {
            return localVarFp.getRoleSettings(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the roles within the company.
         * @summary Get all roles
         * @param {RolesApiGetRolesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getRoles(requestParameters: RolesApiGetRolesRequest = {}, ): Promise<GetRolesResponse200> {
            return localVarFp.getRoles(requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the parent role and/or the name of a specific role.
         * @summary Update role details
         * @param {RolesApiUpdateRoleRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateRole(requestParameters: RolesApiUpdateRoleRequest, ): Promise<UpdateRoleResponse200> {
            return localVarFp.updateRole(requestParameters.id, requestParameters.BaseRoleRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified pipelines to be visible and/or hidden for a specific role. For more information on pipeline visibility, please refer to the <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">Visibility groups article</a>.
         * @summary Update pipeline visibility for a role
         * @param {RolesApiUpdateRolePipelinesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateRolePipelines(requestParameters: RolesApiUpdateRolePipelinesRequest, ): Promise<GetRolePipelines200> {
            return localVarFp.updateRolePipelines(requestParameters.id, requestParameters.PutRolePipelinesBody, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addOrUpdateRoleSetting operation in RolesApi.
 * @export
 * @interface RolesApiAddOrUpdateRoleSettingRequest
 */
export interface RolesApiAddOrUpdateRoleSettingRequest {
    /**
     * The ID of the role
     * @type {number}
     * @memberof RolesApiAddOrUpdateRoleSetting
     */
    readonly id: number

    /**
     *
     * @type {AddOrUpdateRoleSettingRequest}
     * @memberof RolesApiAddOrUpdateRoleSetting
     */
    readonly AddOrUpdateRoleSettingRequest?: AddOrUpdateRoleSettingRequest
}

/**
 * Request parameters for addRole operation in RolesApi.
 * @export
 * @interface RolesApiAddRoleRequest
 */
export interface RolesApiAddRoleRequest {
    /**
     *
     * @type {AddRoleRequest}
     * @memberof RolesApiAddRole
     */
    readonly AddRoleRequest?: AddRoleRequest
}

/**
 * Request parameters for addRoleAssignment operation in RolesApi.
 * @export
 * @interface RolesApiAddRoleAssignmentRequest
 */
export interface RolesApiAddRoleAssignmentRequest {
    /**
     * The ID of the role
     * @type {number}
     * @memberof RolesApiAddRoleAssignment
     */
    readonly id: number

    /**
     *
     * @type {AddRoleAssignmentRequest}
     * @memberof RolesApiAddRoleAssignment
     */
    readonly AddRoleAssignmentRequest?: AddRoleAssignmentRequest
}

/**
 * Request parameters for deleteRole operation in RolesApi.
 * @export
 * @interface RolesApiDeleteRoleRequest
 */
export interface RolesApiDeleteRoleRequest {
    /**
     * The ID of the role
     * @type {number}
     * @memberof RolesApiDeleteRole
     */
    readonly id: number
}

/**
 * Request parameters for deleteRoleAssignment operation in RolesApi.
 * @export
 * @interface RolesApiDeleteRoleAssignmentRequest
 */
export interface RolesApiDeleteRoleAssignmentRequest {
    /**
     * The ID of the role
     * @type {number}
     * @memberof RolesApiDeleteRoleAssignment
     */
    readonly id: number

    /**
     *
     * @type {DeleteRoleAssignmentRequest}
     * @memberof RolesApiDeleteRoleAssignment
     */
    readonly DeleteRoleAssignmentRequest?: DeleteRoleAssignmentRequest
}

/**
 * Request parameters for getRole operation in RolesApi.
 * @export
 * @interface RolesApiGetRoleRequest
 */
export interface RolesApiGetRoleRequest {
    /**
     * The ID of the role
     * @type {number}
     * @memberof RolesApiGetRole
     */
    readonly id: number
}

/**
 * Request parameters for getRoleAssignments operation in RolesApi.
 * @export
 * @interface RolesApiGetRoleAssignmentsRequest
 */
export interface RolesApiGetRoleAssignmentsRequest {
    /**
     * The ID of the role
     * @type {number}
     * @memberof RolesApiGetRoleAssignments
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof RolesApiGetRoleAssignments
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof RolesApiGetRoleAssignments
     */
    readonly limit?: number
}

/**
 * Request parameters for getRolePipelines operation in RolesApi.
 * @export
 * @interface RolesApiGetRolePipelinesRequest
 */
export interface RolesApiGetRolePipelinesRequest {
    /**
     * The ID of the role
     * @type {number}
     * @memberof RolesApiGetRolePipelines
     */
    readonly id: number

    /**
     * Whether to return the visible or hidden pipelines for the role
     * @type {boolean}
     * @memberof RolesApiGetRolePipelines
     */
    readonly visible?: boolean
}

/**
 * Request parameters for getRoleSettings operation in RolesApi.
 * @export
 * @interface RolesApiGetRoleSettingsRequest
 */
export interface RolesApiGetRoleSettingsRequest {
    /**
     * The ID of the role
     * @type {number}
     * @memberof RolesApiGetRoleSettings
     */
    readonly id: number
}

/**
 * Request parameters for getRoles operation in RolesApi.
 * @export
 * @interface RolesApiGetRolesRequest
 */
export interface RolesApiGetRolesRequest {
    /**
     * Pagination start
     * @type {number}
     * @memberof RolesApiGetRoles
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof RolesApiGetRoles
     */
    readonly limit?: number
}

/**
 * Request parameters for updateRole operation in RolesApi.
 * @export
 * @interface RolesApiUpdateRoleRequest
 */
export interface RolesApiUpdateRoleRequest {
    /**
     * The ID of the role
     * @type {number}
     * @memberof RolesApiUpdateRole
     */
    readonly id: number

    /**
     *
     * @type {BaseRoleRequest}
     * @memberof RolesApiUpdateRole
     */
    readonly BaseRoleRequest?: BaseRoleRequest
}

/**
 * Request parameters for updateRolePipelines operation in RolesApi.
 * @export
 * @interface RolesApiUpdateRolePipelinesRequest
 */
export interface RolesApiUpdateRolePipelinesRequest {
    /**
     * The ID of the role
     * @type {number}
     * @memberof RolesApiUpdateRolePipelines
     */
    readonly id: number

    /**
     *
     * @type {PutRolePipelinesBody}
     * @memberof RolesApiUpdateRolePipelines
     */
    readonly PutRolePipelinesBody?: PutRolePipelinesBody
}

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * Adds or updates the visibility setting for a role.
     * @summary Add or update role setting
     * @param {RolesApiAddOrUpdateRoleSettingRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public addOrUpdateRoleSetting(requestParameters: RolesApiAddOrUpdateRoleSettingRequest, ) {
        return RolesApiFp(this.configuration).addOrUpdateRoleSetting(requestParameters.id, requestParameters.AddOrUpdateRoleSettingRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new role.
     * @summary Add a role
     * @param {RolesApiAddRoleRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public addRole(requestParameters: RolesApiAddRoleRequest = {}, ) {
        return RolesApiFp(this.configuration).addRole(requestParameters.AddRoleRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assigns a user to a role.
     * @summary Add role assignment
     * @param {RolesApiAddRoleAssignmentRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public addRoleAssignment(requestParameters: RolesApiAddRoleAssignmentRequest, ) {
        return RolesApiFp(this.configuration).addRoleAssignment(requestParameters.id, requestParameters.AddRoleAssignmentRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a role as deleted.
     * @summary Delete a role
     * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRole(requestParameters: RolesApiDeleteRoleRequest, ) {
        return RolesApiFp(this.configuration).deleteRole(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the assigned user from a role and adds to the default role.
     * @summary Delete a role assignment
     * @param {RolesApiDeleteRoleAssignmentRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRoleAssignment(requestParameters: RolesApiDeleteRoleAssignmentRequest, ) {
        return RolesApiFp(this.configuration).deleteRoleAssignment(requestParameters.id, requestParameters.DeleteRoleAssignmentRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a specific role.
     * @summary Get one role
     * @param {RolesApiGetRoleRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRole(requestParameters: RolesApiGetRoleRequest, ) {
        return RolesApiFp(this.configuration).getRole(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all users assigned to a role.
     * @summary List role assignments
     * @param {RolesApiGetRoleAssignmentsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleAssignments(requestParameters: RolesApiGetRoleAssignmentsRequest, ) {
        return RolesApiFp(this.configuration).getRoleAssignments(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of either visible or hidden pipeline IDs for a specific role. For more information on pipeline visibility, please refer to the <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">Visibility groups article</a>.
     * @summary List pipeline visibility for a role
     * @param {RolesApiGetRolePipelinesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRolePipelines(requestParameters: RolesApiGetRolePipelinesRequest, ) {
        return RolesApiFp(this.configuration).getRolePipelines(requestParameters.id, requestParameters.visible, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the visibility settings of a specific role.
     * @summary List role settings
     * @param {RolesApiGetRoleSettingsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleSettings(requestParameters: RolesApiGetRoleSettingsRequest, ) {
        return RolesApiFp(this.configuration).getRoleSettings(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the roles within the company.
     * @summary Get all roles
     * @param {RolesApiGetRolesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoles(requestParameters: RolesApiGetRolesRequest = {}, ) {
        return RolesApiFp(this.configuration).getRoles(requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the parent role and/or the name of a specific role.
     * @summary Update role details
     * @param {RolesApiUpdateRoleRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public updateRole(requestParameters: RolesApiUpdateRoleRequest, ) {
        return RolesApiFp(this.configuration).updateRole(requestParameters.id, requestParameters.BaseRoleRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified pipelines to be visible and/or hidden for a specific role. For more information on pipeline visibility, please refer to the <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">Visibility groups article</a>.
     * @summary Update pipeline visibility for a role
     * @param {RolesApiUpdateRolePipelinesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public updateRolePipelines(requestParameters: RolesApiUpdateRolePipelinesRequest, ) {
        return RolesApiFp(this.configuration).updateRolePipelines(requestParameters.id, requestParameters.PutRolePipelinesBody, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StagesApi - axios parameter creator
 * @export
 */
export const StagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new stage, returns the ID upon success.
         * @summary Add a new stage
         * @param {AddStageRequest} [AddStageRequest]

         * @throws {RequiredError}
         */
        addStage: async (AddStageRequest?: AddStageRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/stages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddStageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a stage as deleted.
         * @summary Delete a stage
         * @param {number} id The ID of the stage

         * @throws {RequiredError}
         */
        deleteStage: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteStage', 'id', id)
            const localVarPath = `/stages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple stages as deleted.
         * @summary Delete multiple stages in bulk
         * @param {string} ids The comma-separated stage IDs to delete

         * @throws {RequiredError}
         */
        deleteStages: async (ids: string, ): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteStages', 'ids', ids)
            const localVarPath = `/stages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific stage.
         * @summary Get one stage
         * @param {number} id The ID of the stage
         * @param {0 | 1} [everyone] If &#x60;everyone&#x3D;1&#x60; is provided, deals summary will return deals owned by every user

         * @throws {RequiredError}
         */
        getStage: async (id: number, everyone?: 0 | 1, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStage', 'id', id)
            const localVarPath = `/stages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "admin"], configuration)

            if (everyone !== undefined) {
                localVarQueryParameter['everyone'] = everyone;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists deals in a specific stage.
         * @summary Get deals in a stage
         * @param {number} id The ID of the stage
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
         * @param {0 | 1} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered – instead, deals owned by everyone will be returned
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getStageDeals: async (id: number, filter_id?: number, user_id?: number, everyone?: 0 | 1, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStageDeals', 'id', id)
            const localVarPath = `/stages/{id}/deals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (everyone !== undefined) {
                localVarQueryParameter['everyone'] = everyone;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all stages.
         * @summary Get all stages
         * @param {number} [pipeline_id] The ID of the pipeline to fetch stages for. If omitted, stages for all pipelines will be fetched.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getStages: async (pipeline_id?: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            const localVarPath = `/stages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "admin"], configuration)

            if (pipeline_id !== undefined) {
                localVarQueryParameter['pipeline_id'] = pipeline_id;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a stage.
         * @summary Update stage details
         * @param {number} id The ID of the stage
         * @param {UpdateStageRequest} [UpdateStageRequest]

         * @throws {RequiredError}
         */
        updateStage: async (id: number, UpdateStageRequest?: UpdateStageRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStage', 'id', id)
            const localVarPath = `/stages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateStageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StagesApi - functional programming interface
 * @export
 */
export const StagesApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = StagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new stage, returns the ID upon success.
         * @summary Add a new stage
         * @param {AddStageRequest} [AddStageRequest]

         * @throws {RequiredError}
         */
        async addStage(AddStageRequest?: AddStageRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<StageResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addStage(AddStageRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a stage as deleted.
         * @summary Delete a stage
         * @param {number} id The ID of the stage

         * @throws {RequiredError}
         */
        async deleteStage(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteStageResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStage(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks multiple stages as deleted.
         * @summary Delete multiple stages in bulk
         * @param {string} ids The comma-separated stage IDs to delete

         * @throws {RequiredError}
         */
        async deleteStages(ids: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteStagesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStages(ids, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about a specific stage.
         * @summary Get one stage
         * @param {number} id The ID of the stage
         * @param {0 | 1} [everyone] If &#x60;everyone&#x3D;1&#x60; is provided, deals summary will return deals owned by every user

         * @throws {RequiredError}
         */
        async getStage(id: number, everyone?: 0 | 1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStageResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStage(id, everyone, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists deals in a specific stage.
         * @summary Get deals in a stage
         * @param {number} id The ID of the stage
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
         * @param {0 | 1} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered – instead, deals owned by everyone will be returned
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getStageDeals(id: number, filter_id?: number, user_id?: number, everyone?: 0 | 1, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStageDealsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStageDeals(id, filter_id, user_id, everyone, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all stages.
         * @summary Get all stages
         * @param {number} [pipeline_id] The ID of the pipeline to fetch stages for. If omitted, stages for all pipelines will be fetched.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getStages(pipeline_id?: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStagesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStages(pipeline_id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of a stage.
         * @summary Update stage details
         * @param {number} id The ID of the stage
         * @param {UpdateStageRequest} [UpdateStageRequest]

         * @throws {RequiredError}
         */
        async updateStage(id: number, UpdateStageRequest?: UpdateStageRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<StageResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStage(id, UpdateStageRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StagesApi - factory interface
 * @export
 */
export const StagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StagesApiFp(configuration)
    return {
        /**
         * Adds a new stage, returns the ID upon success.
         * @summary Add a new stage
         * @param {StagesApiAddStageRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addStage(requestParameters: StagesApiAddStageRequest = {}, ): Promise<StageResponse200> {
            return localVarFp.addStage(requestParameters.AddStageRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a stage as deleted.
         * @summary Delete a stage
         * @param {StagesApiDeleteStageRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteStage(requestParameters: StagesApiDeleteStageRequest, ): Promise<DeleteStageResponse200> {
            return localVarFp.deleteStage(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks multiple stages as deleted.
         * @summary Delete multiple stages in bulk
         * @param {StagesApiDeleteStagesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteStages(requestParameters: StagesApiDeleteStagesRequest, ): Promise<DeleteStagesResponse200> {
            return localVarFp.deleteStages(requestParameters.ids, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about a specific stage.
         * @summary Get one stage
         * @param {StagesApiGetStageRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getStage(requestParameters: StagesApiGetStageRequest, ): Promise<GetStageResponse200> {
            return localVarFp.getStage(requestParameters.id, requestParameters.everyone, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists deals in a specific stage.
         * @summary Get deals in a stage
         * @param {StagesApiGetStageDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getStageDeals(requestParameters: StagesApiGetStageDealsRequest, ): Promise<GetStageDealsResponse200> {
            return localVarFp.getStageDeals(requestParameters.id, requestParameters.filter_id, requestParameters.user_id, requestParameters.everyone, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all stages.
         * @summary Get all stages
         * @param {StagesApiGetStagesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getStages(requestParameters: StagesApiGetStagesRequest = {}, ): Promise<GetStagesResponse200> {
            return localVarFp.getStages(requestParameters.pipeline_id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a stage.
         * @summary Update stage details
         * @param {StagesApiUpdateStageRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateStage(requestParameters: StagesApiUpdateStageRequest, ): Promise<StageResponse200> {
            return localVarFp.updateStage(requestParameters.id, requestParameters.UpdateStageRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addStage operation in StagesApi.
 * @export
 * @interface StagesApiAddStageRequest
 */
export interface StagesApiAddStageRequest {
    /**
     *
     * @type {AddStageRequest}
     * @memberof StagesApiAddStage
     */
    readonly AddStageRequest?: AddStageRequest
}

/**
 * Request parameters for deleteStage operation in StagesApi.
 * @export
 * @interface StagesApiDeleteStageRequest
 */
export interface StagesApiDeleteStageRequest {
    /**
     * The ID of the stage
     * @type {number}
     * @memberof StagesApiDeleteStage
     */
    readonly id: number
}

/**
 * Request parameters for deleteStages operation in StagesApi.
 * @export
 * @interface StagesApiDeleteStagesRequest
 */
export interface StagesApiDeleteStagesRequest {
    /**
     * The comma-separated stage IDs to delete
     * @type {string}
     * @memberof StagesApiDeleteStages
     */
    readonly ids: string
}

/**
 * Request parameters for getStage operation in StagesApi.
 * @export
 * @interface StagesApiGetStageRequest
 */
export interface StagesApiGetStageRequest {
    /**
     * The ID of the stage
     * @type {number}
     * @memberof StagesApiGetStage
     */
    readonly id: number

    /**
     * If &#x60;everyone&#x3D;1&#x60; is provided, deals summary will return deals owned by every user
     * @type {0 | 1}
     * @memberof StagesApiGetStage
     */
    readonly everyone?: 0 | 1
}

/**
 * Request parameters for getStageDeals operation in StagesApi.
 * @export
 * @interface StagesApiGetStageDealsRequest
 */
export interface StagesApiGetStageDealsRequest {
    /**
     * The ID of the stage
     * @type {number}
     * @memberof StagesApiGetStageDeals
     */
    readonly id: number

    /**
     * If supplied, only deals matching the given filter will be returned
     * @type {number}
     * @memberof StagesApiGetStageDeals
     */
    readonly filter_id?: number

    /**
     * If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
     * @type {number}
     * @memberof StagesApiGetStageDeals
     */
    readonly user_id?: number

    /**
     * If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered – instead, deals owned by everyone will be returned
     * @type {0 | 1}
     * @memberof StagesApiGetStageDeals
     */
    readonly everyone?: 0 | 1

    /**
     * Pagination start
     * @type {number}
     * @memberof StagesApiGetStageDeals
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof StagesApiGetStageDeals
     */
    readonly limit?: number
}

/**
 * Request parameters for getStages operation in StagesApi.
 * @export
 * @interface StagesApiGetStagesRequest
 */
export interface StagesApiGetStagesRequest {
    /**
     * The ID of the pipeline to fetch stages for. If omitted, stages for all pipelines will be fetched.
     * @type {number}
     * @memberof StagesApiGetStages
     */
    readonly pipeline_id?: number

    /**
     * Pagination start
     * @type {number}
     * @memberof StagesApiGetStages
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof StagesApiGetStages
     */
    readonly limit?: number
}

/**
 * Request parameters for updateStage operation in StagesApi.
 * @export
 * @interface StagesApiUpdateStageRequest
 */
export interface StagesApiUpdateStageRequest {
    /**
     * The ID of the stage
     * @type {number}
     * @memberof StagesApiUpdateStage
     */
    readonly id: number

    /**
     *
     * @type {UpdateStageRequest}
     * @memberof StagesApiUpdateStage
     */
    readonly UpdateStageRequest?: UpdateStageRequest
}

/**
 * StagesApi - object-oriented interface
 * @export
 * @class StagesApi
 * @extends {BaseAPI}
 */
export class StagesApi extends BaseAPI {
    /**
     * Adds a new stage, returns the ID upon success.
     * @summary Add a new stage
     * @param {StagesApiAddStageRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public addStage(requestParameters: StagesApiAddStageRequest = {}, ) {
        return StagesApiFp(this.configuration).addStage(requestParameters.AddStageRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a stage as deleted.
     * @summary Delete a stage
     * @param {StagesApiDeleteStageRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public deleteStage(requestParameters: StagesApiDeleteStageRequest, ) {
        return StagesApiFp(this.configuration).deleteStage(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks multiple stages as deleted.
     * @summary Delete multiple stages in bulk
     * @param {StagesApiDeleteStagesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public deleteStages(requestParameters: StagesApiDeleteStagesRequest, ) {
        return StagesApiFp(this.configuration).deleteStages(requestParameters.ids, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about a specific stage.
     * @summary Get one stage
     * @param {StagesApiGetStageRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public getStage(requestParameters: StagesApiGetStageRequest, ) {
        return StagesApiFp(this.configuration).getStage(requestParameters.id, requestParameters.everyone, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists deals in a specific stage.
     * @summary Get deals in a stage
     * @param {StagesApiGetStageDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public getStageDeals(requestParameters: StagesApiGetStageDealsRequest, ) {
        return StagesApiFp(this.configuration).getStageDeals(requestParameters.id, requestParameters.filter_id, requestParameters.user_id, requestParameters.everyone, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all stages.
     * @summary Get all stages
     * @param {StagesApiGetStagesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public getStages(requestParameters: StagesApiGetStagesRequest = {}, ) {
        return StagesApiFp(this.configuration).getStages(requestParameters.pipeline_id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of a stage.
     * @summary Update stage details
     * @param {StagesApiUpdateStageRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public updateStage(requestParameters: StagesApiUpdateStageRequest, ) {
        return StagesApiFp(this.configuration).updateStage(requestParameters.id, requestParameters.UpdateStageRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new recurring subscription.
         * @summary Add a recurring subscription
         * @param {AddRecurringSubscriptionRequest} [AddRecurringSubscriptionRequest]

         * @throws {RequiredError}
         */
        addRecurringSubscription: async (AddRecurringSubscriptionRequest?: AddRecurringSubscriptionRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions/recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddRecurringSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new installment subscription.
         * @summary Add an installment subscription
         * @param {AddSubscriptionInstallmentRequest} [AddSubscriptionInstallmentRequest]

         * @throws {RequiredError}
         */
        addSubscriptionInstallment: async (AddSubscriptionInstallmentRequest?: AddSubscriptionInstallmentRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions/installment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddSubscriptionInstallmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a recurring subscription.
         * @summary Cancel a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {CancelRecurringSubscriptionRequest} [CancelRecurringSubscriptionRequest]

         * @throws {RequiredError}
         */
        cancelRecurringSubscription: async (id: number, CancelRecurringSubscriptionRequest?: CancelRecurringSubscriptionRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelRecurringSubscription', 'id', id)
            const localVarPath = `/subscriptions/recurring/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(CancelRecurringSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an installment or a recurring subscription as deleted.
         * @summary Delete a subscription
         * @param {number} id The ID of the subscription

         * @throws {RequiredError}
         */
        deleteSubscription: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSubscription', 'id', id)
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of an installment or a recurring subscription by the deal ID.
         * @summary Find subscription by deal
         * @param {number} dealId The ID of the deal

         * @throws {RequiredError}
         */
        findSubscriptionByDeal: async (dealId: number, ): Promise<RequestArgs> => {
            // verify required parameter 'dealId' is not null or undefined
            assertParamExists('findSubscriptionByDeal', 'dealId', dealId)
            const localVarPath = `/subscriptions/find/{dealId}`
                .replace(`{${"dealId"}}`, encodeURIComponent(String(dealId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of an installment or a recurring subscription.
         * @summary Get details of a subscription
         * @param {number} id The ID of the subscription

         * @throws {RequiredError}
         */
        getSubscription: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubscription', 'id', id)
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payments of an installment or recurring subscription.
         * @summary Get all payments of a subscription
         * @param {number} id The ID of the subscription

         * @throws {RequiredError}
         */
        getSubscriptionPayments: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubscriptionPayments', 'id', id)
            const localVarPath = `/subscriptions/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a recurring subscription.
         * @summary Update a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateRecurringSubscriptionRequest} [UpdateRecurringSubscriptionRequest]

         * @throws {RequiredError}
         */
        updateRecurringSubscription: async (id: number, UpdateRecurringSubscriptionRequest?: UpdateRecurringSubscriptionRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecurringSubscription', 'id', id)
            const localVarPath = `/subscriptions/recurring/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateRecurringSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an installment subscription.
         * @summary Update an installment subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateSubscriptionInstallmentRequest} [UpdateSubscriptionInstallmentRequest]

         * @throws {RequiredError}
         */
        updateSubscriptionInstallment: async (id: number, UpdateSubscriptionInstallmentRequest?: UpdateSubscriptionInstallmentRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSubscriptionInstallment', 'id', id)
            const localVarPath = `/subscriptions/installment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateSubscriptionInstallmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new recurring subscription.
         * @summary Add a recurring subscription
         * @param {AddRecurringSubscriptionRequest} [AddRecurringSubscriptionRequest]

         * @throws {RequiredError}
         */
        async addRecurringSubscription(AddRecurringSubscriptionRequest?: AddRecurringSubscriptionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SubscriptionsIdResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRecurringSubscription(AddRecurringSubscriptionRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new installment subscription.
         * @summary Add an installment subscription
         * @param {AddSubscriptionInstallmentRequest} [AddSubscriptionInstallmentRequest]

         * @throws {RequiredError}
         */
        async addSubscriptionInstallment(AddSubscriptionInstallmentRequest?: AddSubscriptionInstallmentRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SubscriptionsIdResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSubscriptionInstallment(AddSubscriptionInstallmentRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels a recurring subscription.
         * @summary Cancel a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {CancelRecurringSubscriptionRequest} [CancelRecurringSubscriptionRequest]

         * @throws {RequiredError}
         */
        async cancelRecurringSubscription(id: number, CancelRecurringSubscriptionRequest?: CancelRecurringSubscriptionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SubscriptionsIdResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelRecurringSubscription(id, CancelRecurringSubscriptionRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks an installment or a recurring subscription as deleted.
         * @summary Delete a subscription
         * @param {number} id The ID of the subscription

         * @throws {RequiredError}
         */
        async deleteSubscription(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SubscriptionsIdResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscription(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns details of an installment or a recurring subscription by the deal ID.
         * @summary Find subscription by deal
         * @param {number} dealId The ID of the deal

         * @throws {RequiredError}
         */
        async findSubscriptionByDeal(dealId: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SubscriptionsIdResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSubscriptionByDeal(dealId, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns details of an installment or a recurring subscription.
         * @summary Get details of a subscription
         * @param {number} id The ID of the subscription

         * @throws {RequiredError}
         */
        async getSubscription(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SubscriptionsIdResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all payments of an installment or recurring subscription.
         * @summary Get all payments of a subscription
         * @param {number} id The ID of the subscription

         * @throws {RequiredError}
         */
        async getSubscriptionPayments(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<PaymentResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionPayments(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a recurring subscription.
         * @summary Update a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateRecurringSubscriptionRequest} [UpdateRecurringSubscriptionRequest]

         * @throws {RequiredError}
         */
        async updateRecurringSubscription(id: number, UpdateRecurringSubscriptionRequest?: UpdateRecurringSubscriptionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SubscriptionsIdResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecurringSubscription(id, UpdateRecurringSubscriptionRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an installment subscription.
         * @summary Update an installment subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateSubscriptionInstallmentRequest} [UpdateSubscriptionInstallmentRequest]

         * @throws {RequiredError}
         */
        async updateSubscriptionInstallment(id: number, UpdateSubscriptionInstallmentRequest?: UpdateSubscriptionInstallmentRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SubscriptionsIdResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionInstallment(id, UpdateSubscriptionInstallmentRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * Adds a new recurring subscription.
         * @summary Add a recurring subscription
         * @param {SubscriptionsApiAddRecurringSubscriptionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addRecurringSubscription(requestParameters: SubscriptionsApiAddRecurringSubscriptionRequest = {}, ): Promise<SubscriptionsIdResponse200> {
            return localVarFp.addRecurringSubscription(requestParameters.AddRecurringSubscriptionRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new installment subscription.
         * @summary Add an installment subscription
         * @param {SubscriptionsApiAddSubscriptionInstallmentRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addSubscriptionInstallment(requestParameters: SubscriptionsApiAddSubscriptionInstallmentRequest = {}, ): Promise<SubscriptionsIdResponse200> {
            return localVarFp.addSubscriptionInstallment(requestParameters.AddSubscriptionInstallmentRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a recurring subscription.
         * @summary Cancel a recurring subscription
         * @param {SubscriptionsApiCancelRecurringSubscriptionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        cancelRecurringSubscription(requestParameters: SubscriptionsApiCancelRecurringSubscriptionRequest, ): Promise<SubscriptionsIdResponse200> {
            return localVarFp.cancelRecurringSubscription(requestParameters.id, requestParameters.CancelRecurringSubscriptionRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks an installment or a recurring subscription as deleted.
         * @summary Delete a subscription
         * @param {SubscriptionsApiDeleteSubscriptionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteSubscription(requestParameters: SubscriptionsApiDeleteSubscriptionRequest, ): Promise<SubscriptionsIdResponse200> {
            return localVarFp.deleteSubscription(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of an installment or a recurring subscription by the deal ID.
         * @summary Find subscription by deal
         * @param {SubscriptionsApiFindSubscriptionByDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        findSubscriptionByDeal(requestParameters: SubscriptionsApiFindSubscriptionByDealRequest, ): Promise<SubscriptionsIdResponse200> {
            return localVarFp.findSubscriptionByDeal(requestParameters.dealId, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of an installment or a recurring subscription.
         * @summary Get details of a subscription
         * @param {SubscriptionsApiGetSubscriptionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getSubscription(requestParameters: SubscriptionsApiGetSubscriptionRequest, ): Promise<SubscriptionsIdResponse200> {
            return localVarFp.getSubscription(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all payments of an installment or recurring subscription.
         * @summary Get all payments of a subscription
         * @param {SubscriptionsApiGetSubscriptionPaymentsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getSubscriptionPayments(requestParameters: SubscriptionsApiGetSubscriptionPaymentsRequest, ): Promise<PaymentResponse200> {
            return localVarFp.getSubscriptionPayments(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates a recurring subscription.
         * @summary Update a recurring subscription
         * @param {SubscriptionsApiUpdateRecurringSubscriptionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateRecurringSubscription(requestParameters: SubscriptionsApiUpdateRecurringSubscriptionRequest, ): Promise<SubscriptionsIdResponse200> {
            return localVarFp.updateRecurringSubscription(requestParameters.id, requestParameters.UpdateRecurringSubscriptionRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates an installment subscription.
         * @summary Update an installment subscription
         * @param {SubscriptionsApiUpdateSubscriptionInstallmentRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateSubscriptionInstallment(requestParameters: SubscriptionsApiUpdateSubscriptionInstallmentRequest, ): Promise<SubscriptionsIdResponse200> {
            return localVarFp.updateSubscriptionInstallment(requestParameters.id, requestParameters.UpdateSubscriptionInstallmentRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addRecurringSubscription operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiAddRecurringSubscriptionRequest
 */
export interface SubscriptionsApiAddRecurringSubscriptionRequest {
    /**
     *
     * @type {AddRecurringSubscriptionRequest}
     * @memberof SubscriptionsApiAddRecurringSubscription
     */
    readonly AddRecurringSubscriptionRequest?: AddRecurringSubscriptionRequest
}

/**
 * Request parameters for addSubscriptionInstallment operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiAddSubscriptionInstallmentRequest
 */
export interface SubscriptionsApiAddSubscriptionInstallmentRequest {
    /**
     *
     * @type {AddSubscriptionInstallmentRequest}
     * @memberof SubscriptionsApiAddSubscriptionInstallment
     */
    readonly AddSubscriptionInstallmentRequest?: AddSubscriptionInstallmentRequest
}

/**
 * Request parameters for cancelRecurringSubscription operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiCancelRecurringSubscriptionRequest
 */
export interface SubscriptionsApiCancelRecurringSubscriptionRequest {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsApiCancelRecurringSubscription
     */
    readonly id: number

    /**
     *
     * @type {CancelRecurringSubscriptionRequest}
     * @memberof SubscriptionsApiCancelRecurringSubscription
     */
    readonly CancelRecurringSubscriptionRequest?: CancelRecurringSubscriptionRequest
}

/**
 * Request parameters for deleteSubscription operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiDeleteSubscriptionRequest
 */
export interface SubscriptionsApiDeleteSubscriptionRequest {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsApiDeleteSubscription
     */
    readonly id: number
}

/**
 * Request parameters for findSubscriptionByDeal operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiFindSubscriptionByDealRequest
 */
export interface SubscriptionsApiFindSubscriptionByDealRequest {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof SubscriptionsApiFindSubscriptionByDeal
     */
    readonly dealId: number
}

/**
 * Request parameters for getSubscription operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiGetSubscriptionRequest
 */
export interface SubscriptionsApiGetSubscriptionRequest {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsApiGetSubscription
     */
    readonly id: number
}

/**
 * Request parameters for getSubscriptionPayments operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiGetSubscriptionPaymentsRequest
 */
export interface SubscriptionsApiGetSubscriptionPaymentsRequest {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsApiGetSubscriptionPayments
     */
    readonly id: number
}

/**
 * Request parameters for updateRecurringSubscription operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiUpdateRecurringSubscriptionRequest
 */
export interface SubscriptionsApiUpdateRecurringSubscriptionRequest {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsApiUpdateRecurringSubscription
     */
    readonly id: number

    /**
     *
     * @type {UpdateRecurringSubscriptionRequest}
     * @memberof SubscriptionsApiUpdateRecurringSubscription
     */
    readonly UpdateRecurringSubscriptionRequest?: UpdateRecurringSubscriptionRequest
}

/**
 * Request parameters for updateSubscriptionInstallment operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiUpdateSubscriptionInstallmentRequest
 */
export interface SubscriptionsApiUpdateSubscriptionInstallmentRequest {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsApiUpdateSubscriptionInstallment
     */
    readonly id: number

    /**
     *
     * @type {UpdateSubscriptionInstallmentRequest}
     * @memberof SubscriptionsApiUpdateSubscriptionInstallment
     */
    readonly UpdateSubscriptionInstallmentRequest?: UpdateSubscriptionInstallmentRequest
}

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * Adds a new recurring subscription.
     * @summary Add a recurring subscription
     * @param {SubscriptionsApiAddRecurringSubscriptionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public addRecurringSubscription(requestParameters: SubscriptionsApiAddRecurringSubscriptionRequest = {}, ) {
        return SubscriptionsApiFp(this.configuration).addRecurringSubscription(requestParameters.AddRecurringSubscriptionRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new installment subscription.
     * @summary Add an installment subscription
     * @param {SubscriptionsApiAddSubscriptionInstallmentRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public addSubscriptionInstallment(requestParameters: SubscriptionsApiAddSubscriptionInstallmentRequest = {}, ) {
        return SubscriptionsApiFp(this.configuration).addSubscriptionInstallment(requestParameters.AddSubscriptionInstallmentRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a recurring subscription.
     * @summary Cancel a recurring subscription
     * @param {SubscriptionsApiCancelRecurringSubscriptionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public cancelRecurringSubscription(requestParameters: SubscriptionsApiCancelRecurringSubscriptionRequest, ) {
        return SubscriptionsApiFp(this.configuration).cancelRecurringSubscription(requestParameters.id, requestParameters.CancelRecurringSubscriptionRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks an installment or a recurring subscription as deleted.
     * @summary Delete a subscription
     * @param {SubscriptionsApiDeleteSubscriptionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public deleteSubscription(requestParameters: SubscriptionsApiDeleteSubscriptionRequest, ) {
        return SubscriptionsApiFp(this.configuration).deleteSubscription(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details of an installment or a recurring subscription by the deal ID.
     * @summary Find subscription by deal
     * @param {SubscriptionsApiFindSubscriptionByDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public findSubscriptionByDeal(requestParameters: SubscriptionsApiFindSubscriptionByDealRequest, ) {
        return SubscriptionsApiFp(this.configuration).findSubscriptionByDeal(requestParameters.dealId, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details of an installment or a recurring subscription.
     * @summary Get details of a subscription
     * @param {SubscriptionsApiGetSubscriptionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscription(requestParameters: SubscriptionsApiGetSubscriptionRequest, ) {
        return SubscriptionsApiFp(this.configuration).getSubscription(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all payments of an installment or recurring subscription.
     * @summary Get all payments of a subscription
     * @param {SubscriptionsApiGetSubscriptionPaymentsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscriptionPayments(requestParameters: SubscriptionsApiGetSubscriptionPaymentsRequest, ) {
        return SubscriptionsApiFp(this.configuration).getSubscriptionPayments(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a recurring subscription.
     * @summary Update a recurring subscription
     * @param {SubscriptionsApiUpdateRecurringSubscriptionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public updateRecurringSubscription(requestParameters: SubscriptionsApiUpdateRecurringSubscriptionRequest, ) {
        return SubscriptionsApiFp(this.configuration).updateRecurringSubscription(requestParameters.id, requestParameters.UpdateRecurringSubscriptionRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an installment subscription.
     * @summary Update an installment subscription
     * @param {SubscriptionsApiUpdateSubscriptionInstallmentRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public updateSubscriptionInstallment(requestParameters: SubscriptionsApiUpdateSubscriptionInstallmentRequest, ) {
        return SubscriptionsApiFp(this.configuration).updateSubscriptionInstallment(requestParameters.id, requestParameters.UpdateSubscriptionInstallmentRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new task.
         * @summary Add a task
         * @param {AddTaskRequest} [AddTaskRequest]

         * @throws {RequiredError}
         */
        addTask: async (AddTaskRequest?: AddTaskRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a task as deleted. If the task has subtasks then those will also be deleted.
         * @summary Delete a task
         * @param {number} id The ID of the task

         * @throws {RequiredError}
         */
        deleteTask: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTask', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific task.
         * @summary Get details of a task
         * @param {number} id The ID of the task

         * @throws {RequiredError}
         */
        getTask: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTask', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read", "projects:full"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all tasks. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>.
         * @summary Get all tasks
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, up to 500 items will be returned.
         * @param {number} [assignee_id] If supplied, only tasks that are assigned to this user are returned
         * @param {number} [project_id] If supplied, only tasks that are assigned to this project are returned
         * @param {number} [parent_task_id] If &#x60;null&#x60; is supplied then only parent tasks are returned. If integer is supplied then only subtasks of a specific task are returned. By default all tasks are returned.
         * @param {0 | 1} [done] Whether the task is done or not. &#x60;0&#x60; &#x3D; Not done, &#x60;1&#x60; &#x3D; Done. If not omitted then returns both done and not done tasks.

         * @throws {RequiredError}
         */
        getTasks: async (cursor?: string, limit?: number, assignee_id?: number, project_id?: number, parent_task_id?: number, done?: 0 | 1, ): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:read", "projects:full"], configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (assignee_id !== undefined) {
                localVarQueryParameter['assignee_id'] = assignee_id;
            }

            if (project_id !== undefined) {
                localVarQueryParameter['project_id'] = project_id;
            }

            if (parent_task_id !== undefined) {
                localVarQueryParameter['parent_task_id'] = parent_task_id;
            }

            if (done !== undefined) {
                localVarQueryParameter['done'] = done;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a task.
         * @summary Update a task
         * @param {number} id The ID of the task
         * @param {UpdateProjectRequest2} [UpdateProjectRequest2]

         * @throws {RequiredError}
         */
        updateTask: async (id: number, UpdateProjectRequest2?: UpdateProjectRequest2, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTask', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["projects:full"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateProjectRequest2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new task.
         * @summary Add a task
         * @param {AddTaskRequest} [AddTaskRequest]

         * @throws {RequiredError}
         */
        async addTask(AddTaskRequest?: AddTaskRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddTaskResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTask(AddTaskRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a task as deleted. If the task has subtasks then those will also be deleted.
         * @summary Delete a task
         * @param {number} id The ID of the task

         * @throws {RequiredError}
         */
        async deleteTask(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeleteTaskResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTask(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a specific task.
         * @summary Get details of a task
         * @param {number} id The ID of the task

         * @throws {RequiredError}
         */
        async getTask(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetTaskResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTask(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all tasks. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>.
         * @summary Get all tasks
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, up to 500 items will be returned.
         * @param {number} [assignee_id] If supplied, only tasks that are assigned to this user are returned
         * @param {number} [project_id] If supplied, only tasks that are assigned to this project are returned
         * @param {number} [parent_task_id] If &#x60;null&#x60; is supplied then only parent tasks are returned. If integer is supplied then only subtasks of a specific task are returned. By default all tasks are returned.
         * @param {0 | 1} [done] Whether the task is done or not. &#x60;0&#x60; &#x3D; Not done, &#x60;1&#x60; &#x3D; Done. If not omitted then returns both done and not done tasks.

         * @throws {RequiredError}
         */
        async getTasks(cursor?: string, limit?: number, assignee_id?: number, project_id?: number, parent_task_id?: number, done?: 0 | 1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetTasksResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(cursor, limit, assignee_id, project_id, parent_task_id, done, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a task.
         * @summary Update a task
         * @param {number} id The ID of the task
         * @param {UpdateProjectRequest2} [UpdateProjectRequest2]

         * @throws {RequiredError}
         */
        async updateTask(id: number, UpdateProjectRequest2?: UpdateProjectRequest2, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdateTaskResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTask(id, UpdateProjectRequest2, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * Adds a new task.
         * @summary Add a task
         * @param {TasksApiAddTaskRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addTask(requestParameters: TasksApiAddTaskRequest = {}, ): Promise<AddTaskResponse201> {
            return localVarFp.addTask(requestParameters.AddTaskRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a task as deleted. If the task has subtasks then those will also be deleted.
         * @summary Delete a task
         * @param {TasksApiDeleteTaskRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteTask(requestParameters: TasksApiDeleteTaskRequest, ): Promise<DeleteTaskResponse200> {
            return localVarFp.deleteTask(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific task.
         * @summary Get details of a task
         * @param {TasksApiGetTaskRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getTask(requestParameters: TasksApiGetTaskRequest, ): Promise<GetTaskResponse200> {
            return localVarFp.getTask(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all tasks. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>.
         * @summary Get all tasks
         * @param {TasksApiGetTasksRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getTasks(requestParameters: TasksApiGetTasksRequest = {}, ): Promise<GetTasksResponse200> {
            return localVarFp.getTasks(requestParameters.cursor, requestParameters.limit, requestParameters.assignee_id, requestParameters.project_id, requestParameters.parent_task_id, requestParameters.done, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates a task.
         * @summary Update a task
         * @param {TasksApiUpdateTaskRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateTask(requestParameters: TasksApiUpdateTaskRequest, ): Promise<UpdateTaskResponse200> {
            return localVarFp.updateTask(requestParameters.id, requestParameters.UpdateProjectRequest2, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addTask operation in TasksApi.
 * @export
 * @interface TasksApiAddTaskRequest
 */
export interface TasksApiAddTaskRequest {
    /**
     *
     * @type {AddTaskRequest}
     * @memberof TasksApiAddTask
     */
    readonly AddTaskRequest?: AddTaskRequest
}

/**
 * Request parameters for deleteTask operation in TasksApi.
 * @export
 * @interface TasksApiDeleteTaskRequest
 */
export interface TasksApiDeleteTaskRequest {
    /**
     * The ID of the task
     * @type {number}
     * @memberof TasksApiDeleteTask
     */
    readonly id: number
}

/**
 * Request parameters for getTask operation in TasksApi.
 * @export
 * @interface TasksApiGetTaskRequest
 */
export interface TasksApiGetTaskRequest {
    /**
     * The ID of the task
     * @type {number}
     * @memberof TasksApiGetTask
     */
    readonly id: number
}

/**
 * Request parameters for getTasks operation in TasksApi.
 * @export
 * @interface TasksApiGetTasksRequest
 */
export interface TasksApiGetTasksRequest {
    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof TasksApiGetTasks
     */
    readonly cursor?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, up to 500 items will be returned.
     * @type {number}
     * @memberof TasksApiGetTasks
     */
    readonly limit?: number

    /**
     * If supplied, only tasks that are assigned to this user are returned
     * @type {number}
     * @memberof TasksApiGetTasks
     */
    readonly assignee_id?: number

    /**
     * If supplied, only tasks that are assigned to this project are returned
     * @type {number}
     * @memberof TasksApiGetTasks
     */
    readonly project_id?: number

    /**
     * If &#x60;null&#x60; is supplied then only parent tasks are returned. If integer is supplied then only subtasks of a specific task are returned. By default all tasks are returned.
     * @type {number}
     * @memberof TasksApiGetTasks
     */
    readonly parent_task_id?: number

    /**
     * Whether the task is done or not. &#x60;0&#x60; &#x3D; Not done, &#x60;1&#x60; &#x3D; Done. If not omitted then returns both done and not done tasks.
     * @type {0 | 1}
     * @memberof TasksApiGetTasks
     */
    readonly done?: 0 | 1
}

/**
 * Request parameters for updateTask operation in TasksApi.
 * @export
 * @interface TasksApiUpdateTaskRequest
 */
export interface TasksApiUpdateTaskRequest {
    /**
     * The ID of the task
     * @type {number}
     * @memberof TasksApiUpdateTask
     */
    readonly id: number

    /**
     *
     * @type {UpdateProjectRequest2}
     * @memberof TasksApiUpdateTask
     */
    readonly UpdateProjectRequest2?: UpdateProjectRequest2
}

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Adds a new task.
     * @summary Add a task
     * @param {TasksApiAddTaskRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public addTask(requestParameters: TasksApiAddTaskRequest = {}, ) {
        return TasksApiFp(this.configuration).addTask(requestParameters.AddTaskRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a task as deleted. If the task has subtasks then those will also be deleted.
     * @summary Delete a task
     * @param {TasksApiDeleteTaskRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public deleteTask(requestParameters: TasksApiDeleteTaskRequest, ) {
        return TasksApiFp(this.configuration).deleteTask(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a specific task.
     * @summary Get details of a task
     * @param {TasksApiGetTaskRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTask(requestParameters: TasksApiGetTaskRequest, ) {
        return TasksApiFp(this.configuration).getTask(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all tasks. This is a cursor-paginated endpoint. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>.
     * @summary Get all tasks
     * @param {TasksApiGetTasksRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasks(requestParameters: TasksApiGetTasksRequest = {}, ) {
        return TasksApiFp(this.configuration).getTasks(requestParameters.cursor, requestParameters.limit, requestParameters.assignee_id, requestParameters.project_id, requestParameters.parent_task_id, requestParameters.done, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a task.
     * @summary Update a task
     * @param {TasksApiUpdateTaskRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public updateTask(requestParameters: TasksApiUpdateTaskRequest, ) {
        return TasksApiFp(this.configuration).updateTask(requestParameters.id, requestParameters.UpdateProjectRequest2, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserConnectionsApi - axios parameter creator
 * @export
 */
export const UserConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns data about all connections for the authorized user.
         * @summary Get all user connections

         * @throws {RequiredError}
         */
        getUserConnections: async (): Promise<RequestArgs> => {
            const localVarPath = `/userConnections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["base"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserConnectionsApi - functional programming interface
 * @export
 */
export const UserConnectionsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = UserConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns data about all connections for the authorized user.
         * @summary Get all user connections

         * @throws {RequiredError}
         */
        async getUserConnections(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UserConnectionsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserConnections();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserConnectionsApi - factory interface
 * @export
 */
export const UserConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserConnectionsApiFp(configuration)
    return {
        /**
         * Returns data about all connections for the authorized user.
         * @summary Get all user connections

         * @throws {RequiredError}
         */
        getUserConnections(): Promise<UserConnectionsResponse200> {
            return localVarFp.getUserConnections().then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserConnectionsApi - object-oriented interface
 * @export
 * @class UserConnectionsApi
 * @extends {BaseAPI}
 */
export class UserConnectionsApi extends BaseAPI {
    /**
     * Returns data about all connections for the authorized user.
     * @summary Get all user connections

     * @throws {RequiredError}
     * @memberof UserConnectionsApi
     */
    public getUserConnections() {
        return UserConnectionsApiFp(this.configuration).getUserConnections().then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserSettingsApi - axios parameter creator
 * @export
 */
export const UserSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists the settings of an authorized user. Example response contains a shortened list of settings.
         * @summary List settings of an authorized user

         * @throws {RequiredError}
         */
        getUserSettings: async (): Promise<RequestArgs> => {
            const localVarPath = `/userSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["base"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSettingsApi - functional programming interface
 * @export
 */
export const UserSettingsApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = UserSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists the settings of an authorized user. Example response contains a shortened list of settings.
         * @summary List settings of an authorized user

         * @throws {RequiredError}
         */
        async getUserSettings(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetUserSettingsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSettings();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserSettingsApi - factory interface
 * @export
 */
export const UserSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSettingsApiFp(configuration)
    return {
        /**
         * Lists the settings of an authorized user. Example response contains a shortened list of settings.
         * @summary List settings of an authorized user

         * @throws {RequiredError}
         */
        getUserSettings(): Promise<GetUserSettingsResponse200> {
            return localVarFp.getUserSettings().then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSettingsApi - object-oriented interface
 * @export
 * @class UserSettingsApi
 * @extends {BaseAPI}
 */
export class UserSettingsApi extends BaseAPI {
    /**
     * Lists the settings of an authorized user. Example response contains a shortened list of settings.
     * @summary List settings of an authorized user

     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public getUserSettings() {
        return UserSettingsApiFp(this.configuration).getUserSettings().then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new user to the company, returns the ID upon success.
         * @summary Add a new user
         * @param {AddUserRequest} [AddUserRequest]

         * @throws {RequiredError}
         */
        addUser: async (AddUserRequest?: AddUserRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds users by their name.
         * @summary Find users by name
         * @param {string} term The search term to look for
         * @param {0 | 1} [search_by_email] When enabled, the term will only be matched against email addresses of users. Default: &#x60;false&#x60;

         * @throws {RequiredError}
         */
        findUsersByName: async (term: string, search_by_email?: 0 | 1, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('findUsersByName', 'term', term)
            const localVarPath = `/users/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["users:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (search_by_email !== undefined) {
                localVarQueryParameter['search_by_email'] = search_by_email;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about an authorized user within the company with bound company data: company ID, company name, and domain. Note that the `locale` property means \'Date/number format\' in the Pipedrive account settings, not the chosen language.
         * @summary Get current user data

         * @throws {RequiredError}
         */
        getCurrentUser: async (): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["base"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific user within the company.
         * @summary Get one user
         * @param {number} id The ID of the user

         * @throws {RequiredError}
         */
        getUser: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["users:read"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the followers of a specific user.
         * @summary List followers of a user
         * @param {number} id The ID of the user

         * @throws {RequiredError}
         */
        getUserFollowers: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserFollowers', 'id', id)
            const localVarPath = `/users/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["users:read"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists aggregated permissions over all assigned permission sets for a user.
         * @summary List user permissions
         * @param {number} id The ID of the user

         * @throws {RequiredError}
         */
        getUserPermissions: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserPermissions', 'id', id)
            const localVarPath = `/users/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["users:read"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists role assignments for a user.
         * @summary List role assignments
         * @param {number} id The ID of the user
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getUserRoleAssignments: async (id: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserRoleAssignments', 'id', id)
            const localVarPath = `/users/{id}/roleAssignments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["users:read"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the settings of user\'s assigned role.
         * @summary List user role settings
         * @param {number} id The ID of the user

         * @throws {RequiredError}
         */
        getUserRoleSettings: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserRoleSettings', 'id', id)
            const localVarPath = `/users/{id}/roleSettings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["users:read"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all users within the company.
         * @summary Get all users

         * @throws {RequiredError}
         */
        getUsers: async (): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["users:read"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a user. Currently, only `active_flag` can be updated.
         * @summary Update user details
         * @param {number} id The ID of the user
         * @param {UpdateUserRequest} [UpdateUserRequest]

         * @throws {RequiredError}
         */
        updateUser: async (id: number, UpdateUserRequest?: UpdateUserRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {


	/**
	 * Axios interceptor to add the SDK version as a User-Agent header
	 * */
	globalAxios.interceptors.request.use(function (config) {
		const version = require("../package.json").version;
		config.headers['User-Agent'] = `Pipedrive-SDK-Javascript-${version}`;
		return config;
	});

    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new user to the company, returns the ID upon success.
         * @summary Add a new user
         * @param {AddUserRequest} [AddUserRequest]

         * @throws {RequiredError}
         */
        async addUser(AddUserRequest?: AddUserRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UserResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUser(AddUserRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finds users by their name.
         * @summary Find users by name
         * @param {string} term The search term to look for
         * @param {0 | 1} [search_by_email] When enabled, the term will only be matched against email addresses of users. Default: &#x60;false&#x60;

         * @throws {RequiredError}
         */
        async findUsersByName(term: string, search_by_email?: 0 | 1, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UsersResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUsersByName(term, search_by_email, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about an authorized user within the company with bound company data: company ID, company name, and domain. Note that the `locale` property means \'Date/number format\' in the Pipedrive account settings, not the chosen language.
         * @summary Get current user data

         * @throws {RequiredError}
         */
        async getCurrentUser(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCurrentUserResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about a specific user within the company.
         * @summary Get one user
         * @param {number} id The ID of the user

         * @throws {RequiredError}
         */
        async getUser(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UserResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the followers of a specific user.
         * @summary List followers of a user
         * @param {number} id The ID of the user

         * @throws {RequiredError}
         */
        async getUserFollowers(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UserIds>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFollowers(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists aggregated permissions over all assigned permission sets for a user.
         * @summary List user permissions
         * @param {number} id The ID of the user

         * @throws {RequiredError}
         */
        async getUserPermissions(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetUserPermissionsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPermissions(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists role assignments for a user.
         * @summary List role assignments
         * @param {number} id The ID of the user
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getUserRoleAssignments(id: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetUserRoleAssignmentsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoleAssignments(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the settings of user\'s assigned role.
         * @summary List user role settings
         * @param {number} id The ID of the user

         * @throws {RequiredError}
         */
        async getUserRoleSettings(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetRoleSettingsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoleSettings(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all users within the company.
         * @summary Get all users

         * @throws {RequiredError}
         */
        async getUsers(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UsersResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of a user. Currently, only `active_flag` can be updated.
         * @summary Update user details
         * @param {number} id The ID of the user
         * @param {UpdateUserRequest} [UpdateUserRequest]

         * @throws {RequiredError}
         */
        async updateUser(id: number, UpdateUserRequest?: UpdateUserRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UserResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, UpdateUserRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Adds a new user to the company, returns the ID upon success.
         * @summary Add a new user
         * @param {UsersApiAddUserRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addUser(requestParameters: UsersApiAddUserRequest = {}, ): Promise<UserResponse200> {
            return localVarFp.addUser(requestParameters.AddUserRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Finds users by their name.
         * @summary Find users by name
         * @param {UsersApiFindUsersByNameRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        findUsersByName(requestParameters: UsersApiFindUsersByNameRequest, ): Promise<UsersResponse200> {
            return localVarFp.findUsersByName(requestParameters.term, requestParameters.search_by_email, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about an authorized user within the company with bound company data: company ID, company name, and domain. Note that the `locale` property means \'Date/number format\' in the Pipedrive account settings, not the chosen language.
         * @summary Get current user data

         * @throws {RequiredError}
         */
        getCurrentUser(): Promise<GetCurrentUserResponse200> {
            return localVarFp.getCurrentUser().then((request) => request(axios, basePath));
        },
        /**
         * Returns data about a specific user within the company.
         * @summary Get one user
         * @param {UsersApiGetUserRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getUser(requestParameters: UsersApiGetUserRequest, ): Promise<UserResponse200> {
            return localVarFp.getUser(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists the followers of a specific user.
         * @summary List followers of a user
         * @param {UsersApiGetUserFollowersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getUserFollowers(requestParameters: UsersApiGetUserFollowersRequest, ): Promise<UserIds> {
            return localVarFp.getUserFollowers(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists aggregated permissions over all assigned permission sets for a user.
         * @summary List user permissions
         * @param {UsersApiGetUserPermissionsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getUserPermissions(requestParameters: UsersApiGetUserPermissionsRequest, ): Promise<GetUserPermissionsResponse200> {
            return localVarFp.getUserPermissions(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists role assignments for a user.
         * @summary List role assignments
         * @param {UsersApiGetUserRoleAssignmentsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getUserRoleAssignments(requestParameters: UsersApiGetUserRoleAssignmentsRequest, ): Promise<GetUserRoleAssignmentsResponse200> {
            return localVarFp.getUserRoleAssignments(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists the settings of user\'s assigned role.
         * @summary List user role settings
         * @param {UsersApiGetUserRoleSettingsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getUserRoleSettings(requestParameters: UsersApiGetUserRoleSettingsRequest, ): Promise<GetRoleSettingsResponse200> {
            return localVarFp.getUserRoleSettings(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all users within the company.
         * @summary Get all users

         * @throws {RequiredError}
         */
        getUsers(): Promise<UsersResponse200> {
            return localVarFp.getUsers().then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a user. Currently, only `active_flag` can be updated.
         * @summary Update user details
         * @param {UsersApiUpdateUserRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateUser(requestParameters: UsersApiUpdateUserRequest, ): Promise<UserResponse200> {
            return localVarFp.updateUser(requestParameters.id, requestParameters.UpdateUserRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addUser operation in UsersApi.
 * @export
 * @interface UsersApiAddUserRequest
 */
export interface UsersApiAddUserRequest {
    /**
     *
     * @type {AddUserRequest}
     * @memberof UsersApiAddUser
     */
    readonly AddUserRequest?: AddUserRequest
}

/**
 * Request parameters for findUsersByName operation in UsersApi.
 * @export
 * @interface UsersApiFindUsersByNameRequest
 */
export interface UsersApiFindUsersByNameRequest {
    /**
     * The search term to look for
     * @type {string}
     * @memberof UsersApiFindUsersByName
     */
    readonly term: string

    /**
     * When enabled, the term will only be matched against email addresses of users. Default: &#x60;false&#x60;
     * @type {0 | 1}
     * @memberof UsersApiFindUsersByName
     */
    readonly search_by_email?: 0 | 1
}

/**
 * Request parameters for getUser operation in UsersApi.
 * @export
 * @interface UsersApiGetUserRequest
 */
export interface UsersApiGetUserRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof UsersApiGetUser
     */
    readonly id: number
}

/**
 * Request parameters for getUserFollowers operation in UsersApi.
 * @export
 * @interface UsersApiGetUserFollowersRequest
 */
export interface UsersApiGetUserFollowersRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof UsersApiGetUserFollowers
     */
    readonly id: number
}

/**
 * Request parameters for getUserPermissions operation in UsersApi.
 * @export
 * @interface UsersApiGetUserPermissionsRequest
 */
export interface UsersApiGetUserPermissionsRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof UsersApiGetUserPermissions
     */
    readonly id: number
}

/**
 * Request parameters for getUserRoleAssignments operation in UsersApi.
 * @export
 * @interface UsersApiGetUserRoleAssignmentsRequest
 */
export interface UsersApiGetUserRoleAssignmentsRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof UsersApiGetUserRoleAssignments
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof UsersApiGetUserRoleAssignments
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof UsersApiGetUserRoleAssignments
     */
    readonly limit?: number
}

/**
 * Request parameters for getUserRoleSettings operation in UsersApi.
 * @export
 * @interface UsersApiGetUserRoleSettingsRequest
 */
export interface UsersApiGetUserRoleSettingsRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof UsersApiGetUserRoleSettings
     */
    readonly id: number
}

/**
 * Request parameters for updateUser operation in UsersApi.
 * @export
 * @interface UsersApiUpdateUserRequest
 */
export interface UsersApiUpdateUserRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof UsersApiUpdateUser
     */
    readonly id: number

    /**
     *
     * @type {UpdateUserRequest}
     * @memberof UsersApiUpdateUser
     */
    readonly UpdateUserRequest?: UpdateUserRequest
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Adds a new user to the company, returns the ID upon success.
     * @summary Add a new user
     * @param {UsersApiAddUserRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUser(requestParameters: UsersApiAddUserRequest = {}, ) {
        return UsersApiFp(this.configuration).addUser(requestParameters.AddUserRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finds users by their name.
     * @summary Find users by name
     * @param {UsersApiFindUsersByNameRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUsersByName(requestParameters: UsersApiFindUsersByNameRequest, ) {
        return UsersApiFp(this.configuration).findUsersByName(requestParameters.term, requestParameters.search_by_email, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about an authorized user within the company with bound company data: company ID, company name, and domain. Note that the `locale` property means \'Date/number format\' in the Pipedrive account settings, not the chosen language.
     * @summary Get current user data

     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUser() {
        return UsersApiFp(this.configuration).getCurrentUser().then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about a specific user within the company.
     * @summary Get one user
     * @param {UsersApiGetUserRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(requestParameters: UsersApiGetUserRequest, ) {
        return UsersApiFp(this.configuration).getUser(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the followers of a specific user.
     * @summary List followers of a user
     * @param {UsersApiGetUserFollowersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserFollowers(requestParameters: UsersApiGetUserFollowersRequest, ) {
        return UsersApiFp(this.configuration).getUserFollowers(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists aggregated permissions over all assigned permission sets for a user.
     * @summary List user permissions
     * @param {UsersApiGetUserPermissionsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserPermissions(requestParameters: UsersApiGetUserPermissionsRequest, ) {
        return UsersApiFp(this.configuration).getUserPermissions(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists role assignments for a user.
     * @summary List role assignments
     * @param {UsersApiGetUserRoleAssignmentsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserRoleAssignments(requestParameters: UsersApiGetUserRoleAssignmentsRequest, ) {
        return UsersApiFp(this.configuration).getUserRoleAssignments(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the settings of user\'s assigned role.
     * @summary List user role settings
     * @param {UsersApiGetUserRoleSettingsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserRoleSettings(requestParameters: UsersApiGetUserRoleSettingsRequest, ) {
        return UsersApiFp(this.configuration).getUserRoleSettings(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all users within the company.
     * @summary Get all users

     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers() {
        return UsersApiFp(this.configuration).getUsers().then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of a user. Currently, only `active_flag` can be updated.
     * @summary Update user details
     * @param {UsersApiUpdateUserRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(requestParameters: UsersApiUpdateUserRequest, ) {
        return UsersApiFp(this.configuration).updateUser(requestParameters.id, requestParameters.UpdateUserRequest, ).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Webhook and returns its details. Note that specifying an event which triggers the Webhook combines 2 parameters - `event_action` and `event_object`. E.g., use `*.*` for getting notifications about all events, `added.deal` for any newly added deals, `deleted.persons` for any deleted persons, etc. See <a href=\"https://pipedrive.readme.io/docs/guide-for-webhooks?ref=api_reference\" target=\"_blank\" rel=\"noopener noreferrer\">the guide for Webhooks</a> for more details.
         * @summary Create a new Webhook
         * @param {AddWebhookRequest} [AddWebhookRequest]

         * @throws {RequiredError}
         */
        addWebhook: async (AddWebhookRequest?: AddWebhookRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified Webhook.
         * @summary Delete existing Webhook
         * @param {number} id The ID of the Webhook to delete

         * @throws {RequiredError}
         */
        deleteWebhook: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhook', 'id', id)
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all the Webhooks of a company.
         * @summary Get all Webhooks

         * @throws {RequiredError}
         */
        getWebhooks: async (): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["admin"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Webhook and returns its details. Note that specifying an event which triggers the Webhook combines 2 parameters - `event_action` and `event_object`. E.g., use `*.*` for getting notifications about all events, `added.deal` for any newly added deals, `deleted.persons` for any deleted persons, etc. See <a href=\"https://pipedrive.readme.io/docs/guide-for-webhooks?ref=api_reference\" target=\"_blank\" rel=\"noopener noreferrer\">the guide for Webhooks</a> for more details.
         * @summary Create a new Webhook
         * @param {AddWebhookRequest} [AddWebhookRequest]

         * @throws {RequiredError}
         */
        async addWebhook(AddWebhookRequest?: AddWebhookRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<WebhookResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWebhook(AddWebhookRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the specified Webhook.
         * @summary Delete existing Webhook
         * @param {number} id The ID of the Webhook to delete

         * @throws {RequiredError}
         */
        async deleteWebhook(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<BaseResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns data about all the Webhooks of a company.
         * @summary Get all Webhooks

         * @throws {RequiredError}
         */
        async getWebhooks(): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetWebhooksResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooks();
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Creates a new Webhook and returns its details. Note that specifying an event which triggers the Webhook combines 2 parameters - `event_action` and `event_object`. E.g., use `*.*` for getting notifications about all events, `added.deal` for any newly added deals, `deleted.persons` for any deleted persons, etc. See <a href=\"https://pipedrive.readme.io/docs/guide-for-webhooks?ref=api_reference\" target=\"_blank\" rel=\"noopener noreferrer\">the guide for Webhooks</a> for more details.
         * @summary Create a new Webhook
         * @param {WebhooksApiAddWebhookRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addWebhook(requestParameters: WebhooksApiAddWebhookRequest = {}, ): Promise<WebhookResponse200> {
            return localVarFp.addWebhook(requestParameters.AddWebhookRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified Webhook.
         * @summary Delete existing Webhook
         * @param {WebhooksApiDeleteWebhookRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteWebhook(requestParameters: WebhooksApiDeleteWebhookRequest, ): Promise<BaseResponse200> {
            return localVarFp.deleteWebhook(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all the Webhooks of a company.
         * @summary Get all Webhooks

         * @throws {RequiredError}
         */
        getWebhooks(): Promise<GetWebhooksResponse200> {
            return localVarFp.getWebhooks().then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addWebhook operation in WebhooksApi.
 * @export
 * @interface WebhooksApiAddWebhookRequest
 */
export interface WebhooksApiAddWebhookRequest {
    /**
     *
     * @type {AddWebhookRequest}
     * @memberof WebhooksApiAddWebhook
     */
    readonly AddWebhookRequest?: AddWebhookRequest
}

/**
 * Request parameters for deleteWebhook operation in WebhooksApi.
 * @export
 * @interface WebhooksApiDeleteWebhookRequest
 */
export interface WebhooksApiDeleteWebhookRequest {
    /**
     * The ID of the Webhook to delete
     * @type {number}
     * @memberof WebhooksApiDeleteWebhook
     */
    readonly id: number
}

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Creates a new Webhook and returns its details. Note that specifying an event which triggers the Webhook combines 2 parameters - `event_action` and `event_object`. E.g., use `*.*` for getting notifications about all events, `added.deal` for any newly added deals, `deleted.persons` for any deleted persons, etc. See <a href=\"https://pipedrive.readme.io/docs/guide-for-webhooks?ref=api_reference\" target=\"_blank\" rel=\"noopener noreferrer\">the guide for Webhooks</a> for more details.
     * @summary Create a new Webhook
     * @param {WebhooksApiAddWebhookRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public addWebhook(requestParameters: WebhooksApiAddWebhookRequest = {}, ) {
        return WebhooksApiFp(this.configuration).addWebhook(requestParameters.AddWebhookRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified Webhook.
     * @summary Delete existing Webhook
     * @param {WebhooksApiDeleteWebhookRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(requestParameters: WebhooksApiDeleteWebhookRequest, ) {
        return WebhooksApiFp(this.configuration).deleteWebhook(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns data about all the Webhooks of a company.
     * @summary Get all Webhooks

     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhooks() {
        return WebhooksApiFp(this.configuration).getWebhooks().then((request) => request(this.axios, this.basePath));
    }
}


