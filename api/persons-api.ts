/* tslint:disable */
/* eslint-disable */
/**
 * Pipedrive API v1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AddPersonFollowerRequest } from '../models';
// @ts-ignore
import { AddPersonFollowerResponse200 } from '../models';
// @ts-ignore
import { AddPersonPictureResponse200 } from '../models';
// @ts-ignore
import { AddPersonRequest } from '../models';
// @ts-ignore
import { AddPersonResponse200 } from '../models';
// @ts-ignore
import { DeletePersonResponse200 } from '../models';
// @ts-ignore
import { DeletePersonsResponse200 } from '../models';
// @ts-ignore
import { FailResponse } from '../models';
// @ts-ignore
import { GetAssociatedActivitiesResponse200 } from '../models';
// @ts-ignore
import { GetAssociatedDealsResponse200 } from '../models';
// @ts-ignore
import { GetAssociatedFilesResponse200 } from '../models';
// @ts-ignore
import { GetAssociatedFollowersResponse200 } from '../models';
// @ts-ignore
import { GetAssociatedMailMessagesResponse200 } from '../models';
// @ts-ignore
import { GetAssociatedPersonUpdatesResponse200 } from '../models';
// @ts-ignore
import { GetPersonProductsResponse200 } from '../models';
// @ts-ignore
import { GetPersonResponse200 } from '../models';
// @ts-ignore
import { GetPersonsCollection200Response } from '../models';
// @ts-ignore
import { GetPersonsResponse200 } from '../models';
// @ts-ignore
import { ListPermittedUsersResponse2001 } from '../models';
// @ts-ignore
import { MergePersonsRequest } from '../models';
// @ts-ignore
import { MergePersonsResponse200 } from '../models';
// @ts-ignore
import { SearchPersonsResponse200 } from '../models';
// @ts-ignore
import { UpdatePersonRequest } from '../models';
// @ts-ignore
import { UpdatePersonResponse200 } from '../models';
/**
 * PersonsApi - axios parameter creator
 * @export
 */
export const PersonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Add a person
         * @param {AddPersonRequest} [AddPersonRequest] 

         * @throws {RequiredError}
         */
        addPerson: async (AddPersonRequest?: AddPersonRequest, ): Promise<RequestArgs> => {
            const localVarPath = `/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddPersonRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a follower to a person.
         * @summary Add a follower to a person
         * @param {number} id The ID of the person
         * @param {AddPersonFollowerRequest} [AddPersonFollowerRequest] 

         * @throws {RequiredError}
         */
        addPersonFollower: async (id: number, AddPersonFollowerRequest?: AddPersonFollowerRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addPersonFollower', 'id', id)
            const localVarPath = `/persons/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(AddPersonFollowerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
         * @summary Add person picture
         * @param {number} id The ID of the person
         * @param {File} file One image supplied in the multipart/form-data encoding
         * @param {number} [crop_x] X coordinate to where start cropping form (in pixels)
         * @param {number} [crop_y] Y coordinate to where start cropping form (in pixels)
         * @param {number} [crop_width] The width of the cropping area (in pixels)
         * @param {number} [crop_height] The height of the cropping area (in pixels)

         * @throws {RequiredError}
         */
        addPersonPicture: async (id: number, file: File, crop_x?: number, crop_y?: number, crop_width?: number, crop_height?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addPersonPicture', 'id', id)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('addPersonPicture', 'file', file)
            const localVarPath = `/persons/{id}/picture`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (crop_x !== undefined) { 
                localVarFormParams.append('crop_x', crop_x as any);
            }
    
            if (crop_y !== undefined) { 
                localVarFormParams.append('crop_y', crop_y as any);
            }
    
            if (crop_width !== undefined) { 
                localVarFormParams.append('crop_width', crop_width as any);
            }
    
            if (crop_height !== undefined) { 
                localVarFormParams.append('crop_height', crop_height as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a person as deleted. After 30 days, the person will be permanently deleted.
         * @summary Delete a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        deletePerson: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePerson', 'id', id)
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a follower from a person.
         * @summary Delete a follower from a person
         * @param {number} id The ID of the person
         * @param {number} follower_id The ID of the follower

         * @throws {RequiredError}
         */
        deletePersonFollower: async (id: number, follower_id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePersonFollower', 'id', id)
            // verify required parameter 'follower_id' is not null or undefined
            assertParamExists('deletePersonFollower', 'follower_id', follower_id)
            const localVarPath = `/persons/{id}/followers/{follower_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"follower_id"}}`, encodeURIComponent(String(follower_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a personâ€™s picture.
         * @summary Delete person picture
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        deletePersonPicture: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePersonPicture', 'id', id)
            const localVarPath = `/persons/{id}/picture`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple persons as deleted. After 30 days, the persons will be permanently deleted.
         * @summary Delete multiple persons in bulk
         * @param {string} ids The comma-separated IDs that will be deleted

         * @throws {RequiredError}
         */
        deletePersons: async (ids: string, ): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deletePersons', 'ids', ids)
            const localVarPath = `/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get details of a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        getPerson: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPerson', 'id', id)
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists activities associated with a person.
         * @summary List activities associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {0 | 1} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result

         * @throws {RequiredError}
         */
        getPersonActivities: async (id: number, start?: number, limit?: number, done?: 0 | 1, exclude?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonActivities', 'id', id)
            const localVarPath = `/persons/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:read", "activities:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (done !== undefined) {
                localVarQueryParameter['done'] = done;
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists deals associated with a person.
         * @summary List deals associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).

         * @throws {RequiredError}
         */
        getPersonDeals: async (id: number, start?: number, limit?: number, status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted', sort?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonDeals', 'id', id)
            const localVarPath = `/persons/{id}/deals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists files associated with a person.
         * @summary List files attached to a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.

         * @throws {RequiredError}
         */
        getPersonFiles: async (id: number, start?: number, limit?: number, sort?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonFiles', 'id', id)
            const localVarPath = `/persons/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the followers of a person.
         * @summary List followers of a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        getPersonFollowers: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonFollowers', 'id', id)
            const localVarPath = `/persons/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists mail messages associated with a person.
         * @summary List mail messages associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getPersonMailMessages: async (id: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonMailMessages', 'id', id)
            const localVarPath = `/persons/{id}/mailMessages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["mail:read", "mail:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists products associated with a person.
         * @summary List products associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        getPersonProducts: async (id: number, start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonProducts', 'id', id)
            const localVarPath = `/persons/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint\'s response will also include updates for the `marketing_status` field.
         * @summary List updates about a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change).

         * @throws {RequiredError}
         */
        getPersonUpdates: async (id: number, start?: number, limit?: number, all_changes?: string, items?: string, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonUpdates', 'id', id)
            const localVarPath = `/persons/{id}/flow`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["recents:read"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (all_changes !== undefined) {
                localVarQueryParameter['all_changes'] = all_changes;
            }

            if (items !== undefined) {
                localVarQueryParameter['items'] = items;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List users permitted to access a person.
         * @summary List permitted users
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        getPersonUsers: async (id: number, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonUsers', 'id', id)
            const localVarPath = `/persons/{id}/permittedUsers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all persons.
         * @summary Get all persons
         * @param {number} [user_id] If supplied, only persons owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [first_char] If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).

         * @throws {RequiredError}
         */
        getPersons: async (user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (first_char !== undefined) {
                localVarQueryParameter['first_char'] = first_char;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all persons. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all persons (BETA)
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [since] The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {string} [until] The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {number} [owner_id] If supplied, only persons owned by the given user will be returned
         * @param {string} [first_char] If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive)

         * @throws {RequiredError}
         */
        getPersonsCollection: async (cursor?: string, limit?: number, since?: string, until?: string, owner_id?: number, first_char?: string, ): Promise<RequestArgs> => {
            const localVarPath = `/persons/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }

            if (owner_id !== undefined) {
                localVarQueryParameter['owner_id'] = owner_id;
            }

            if (first_char !== undefined) {
                localVarQueryParameter['first_char'] = first_char;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merges a person with another person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-persons\" target=\"_blank\" rel=\"noopener noreferrer\">merging two persons</a>.
         * @summary Merge two persons
         * @param {number} id The ID of the person
         * @param {MergePersonsRequest} [MergePersonsRequest] 

         * @throws {RequiredError}
         */
        mergePersons: async (id: number, MergePersonsRequest?: MergePersonsRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergePersons', 'id', id)
            const localVarPath = `/persons/{id}/merge`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(MergePersonsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'email' | 'notes' | 'phone' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [organization_id] Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
         * @param {'person.picture'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        searchPersons: async (term: string, fields?: 'custom_fields' | 'email' | 'notes' | 'phone' | 'name', exact_match?: boolean, organization_id?: number, include_fields?: 'person.picture', start?: number, limit?: number, ): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchPersons', 'term', term)
            const localVarPath = `/persons/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full", "search:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-person\" target=\"_blank\" rel=\"noopener noreferrer\">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Update a person
         * @param {number} id The ID of the person
         * @param {UpdatePersonRequest} [UpdatePersonRequest] 

         * @throws {RequiredError}
         */
        updatePerson: async (id: number, UpdatePersonRequest?: UpdatePersonRequest, ): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePerson', 'id', id)
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarQueryParameter, "api_token", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, };
            localVarRequestOptions.data = serializeDataIfNeeded(UpdatePersonRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonsApi - functional programming interface
 * @export
 */
export const PersonsApiFp = function(configuration?: Configuration) {

    /**
    * Axios interceptor to add the SDK version as a User-Agent header
    * */
    globalAxios.interceptors.request.use(function (config) {
        const version = require("../../package.json").version;
        config.headers['User-Agent'] = `Pipedrive-SDK-Javascript-${version}`;
        return config;
    });

    /**
    * Axios response interceptor to modify response structure
    */
    globalAxios.interceptors.response.use(function (response) {
        return response.hasOwnProperty('success') ? response : response.data;
    }, function (error) {
        if(error?.response?.data) {
            return Promise.reject(error.response.data);
        }
        return Promise.reject(error);
    });
    const localVarAxiosParamCreator = PersonsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Add a person
         * @param {AddPersonRequest} [AddPersonRequest] 

         * @throws {RequiredError}
         */
        async addPerson(AddPersonRequest?: AddPersonRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddPersonResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPerson(AddPersonRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a follower to a person.
         * @summary Add a follower to a person
         * @param {number} id The ID of the person
         * @param {AddPersonFollowerRequest} [AddPersonFollowerRequest] 

         * @throws {RequiredError}
         */
        async addPersonFollower(id: number, AddPersonFollowerRequest?: AddPersonFollowerRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddPersonFollowerResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPersonFollower(id, AddPersonFollowerRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
         * @summary Add person picture
         * @param {number} id The ID of the person
         * @param {File} file One image supplied in the multipart/form-data encoding
         * @param {number} [crop_x] X coordinate to where start cropping form (in pixels)
         * @param {number} [crop_y] Y coordinate to where start cropping form (in pixels)
         * @param {number} [crop_width] The width of the cropping area (in pixels)
         * @param {number} [crop_height] The height of the cropping area (in pixels)

         * @throws {RequiredError}
         */
        async addPersonPicture(id: number, file: File, crop_x?: number, crop_y?: number, crop_width?: number, crop_height?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AddPersonPictureResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPersonPicture(id, file, crop_x, crop_y, crop_width, crop_height, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks a person as deleted. After 30 days, the person will be permanently deleted.
         * @summary Delete a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        async deletePerson(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeletePersonResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePerson(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a follower from a person.
         * @summary Delete a follower from a person
         * @param {number} id The ID of the person
         * @param {number} follower_id The ID of the follower

         * @throws {RequiredError}
         */
        async deletePersonFollower(id: number, follower_id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeletePersonResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonFollower(id, follower_id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a personâ€™s picture.
         * @summary Delete person picture
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        async deletePersonPicture(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeletePersonResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonPicture(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks multiple persons as deleted. After 30 days, the persons will be permanently deleted.
         * @summary Delete multiple persons in bulk
         * @param {string} ids The comma-separated IDs that will be deleted

         * @throws {RequiredError}
         */
        async deletePersons(ids: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeletePersonsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersons(ids, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get details of a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        async getPerson(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPersonResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPerson(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists activities associated with a person.
         * @summary List activities associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {0 | 1} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result

         * @throws {RequiredError}
         */
        async getPersonActivities(id: number, start?: number, limit?: number, done?: 0 | 1, exclude?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedActivitiesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonActivities(id, start, limit, done, exclude, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists deals associated with a person.
         * @summary List deals associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).

         * @throws {RequiredError}
         */
        async getPersonDeals(id: number, start?: number, limit?: number, status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted', sort?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedDealsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonDeals(id, start, limit, status, sort, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists files associated with a person.
         * @summary List files attached to a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.

         * @throws {RequiredError}
         */
        async getPersonFiles(id: number, start?: number, limit?: number, sort?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedFilesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonFiles(id, start, limit, sort, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the followers of a person.
         * @summary List followers of a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        async getPersonFollowers(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedFollowersResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonFollowers(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists mail messages associated with a person.
         * @summary List mail messages associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getPersonMailMessages(id: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedMailMessagesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonMailMessages(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists products associated with a person.
         * @summary List products associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async getPersonProducts(id: number, start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPersonProductsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonProducts(id, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint\'s response will also include updates for the `marketing_status` field.
         * @summary List updates about a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change).

         * @throws {RequiredError}
         */
        async getPersonUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetAssociatedPersonUpdatesResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonUpdates(id, start, limit, all_changes, items, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List users permitted to access a person.
         * @summary List permitted users
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        async getPersonUsers(id: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListPermittedUsersResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonUsers(id, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all persons.
         * @summary Get all persons
         * @param {number} [user_id] If supplied, only persons owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [first_char] If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).

         * @throws {RequiredError}
         */
        async getPersons(user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPersonsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersons(user_id, filter_id, first_char, start, limit, sort, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all persons. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all persons (BETA)
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [since] The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {string} [until] The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
         * @param {number} [owner_id] If supplied, only persons owned by the given user will be returned
         * @param {string} [first_char] If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive)

         * @throws {RequiredError}
         */
        async getPersonsCollection(cursor?: string, limit?: number, since?: string, until?: string, owner_id?: number, first_char?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPersonsCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonsCollection(cursor, limit, since, until, owner_id, first_char, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Merges a person with another person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-persons\" target=\"_blank\" rel=\"noopener noreferrer\">merging two persons</a>.
         * @summary Merge two persons
         * @param {number} id The ID of the person
         * @param {MergePersonsRequest} [MergePersonsRequest] 

         * @throws {RequiredError}
         */
        async mergePersons(id: number, MergePersonsRequest?: MergePersonsRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<MergePersonsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergePersons(id, MergePersonsRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'email' | 'notes' | 'phone' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [organization_id] Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
         * @param {'person.picture'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page

         * @throws {RequiredError}
         */
        async searchPersons(term: string, fields?: 'custom_fields' | 'email' | 'notes' | 'phone' | 'name', exact_match?: boolean, organization_id?: number, include_fields?: 'person.picture', start?: number, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<SearchPersonsResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPersons(term, fields, exact_match, organization_id, include_fields, start, limit, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of a person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-person\" target=\"_blank\" rel=\"noopener noreferrer\">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Update a person
         * @param {number} id The ID of the person
         * @param {UpdatePersonRequest} [UpdatePersonRequest] 

         * @throws {RequiredError}
         */
        async updatePerson(id: number, UpdatePersonRequest?: UpdatePersonRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<UpdatePersonResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePerson(id, UpdatePersonRequest, );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonsApi - factory interface
 * @export
 */
export const PersonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonsApiFp(configuration)
    return {
        /**
         * Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Add a person
         * @param {PersonsApiAddPersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addPerson(requestParameters: PersonsApiAddPersonRequest = {}, ): Promise<AddPersonResponse200> {
            return localVarFp.addPerson(requestParameters.AddPersonRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a follower to a person.
         * @summary Add a follower to a person
         * @param {PersonsApiAddPersonFollowerRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addPersonFollower(requestParameters: PersonsApiAddPersonFollowerRequest, ): Promise<AddPersonFollowerResponse200> {
            return localVarFp.addPersonFollower(requestParameters.id, requestParameters.AddPersonFollowerRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
         * @summary Add person picture
         * @param {PersonsApiAddPersonPictureRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addPersonPicture(requestParameters: PersonsApiAddPersonPictureRequest, ): Promise<AddPersonPictureResponse200> {
            return localVarFp.addPersonPicture(requestParameters.id, requestParameters.file, requestParameters.crop_x, requestParameters.crop_y, requestParameters.crop_width, requestParameters.crop_height, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks a person as deleted. After 30 days, the person will be permanently deleted.
         * @summary Delete a person
         * @param {PersonsApiDeletePersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deletePerson(requestParameters: PersonsApiDeletePersonRequest, ): Promise<DeletePersonResponse200> {
            return localVarFp.deletePerson(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a follower from a person.
         * @summary Delete a follower from a person
         * @param {PersonsApiDeletePersonFollowerRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deletePersonFollower(requestParameters: PersonsApiDeletePersonFollowerRequest, ): Promise<DeletePersonResponse200> {
            return localVarFp.deletePersonFollower(requestParameters.id, requestParameters.follower_id, ).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a personâ€™s picture.
         * @summary Delete person picture
         * @param {PersonsApiDeletePersonPictureRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deletePersonPicture(requestParameters: PersonsApiDeletePersonPictureRequest, ): Promise<DeletePersonResponse200> {
            return localVarFp.deletePersonPicture(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Marks multiple persons as deleted. After 30 days, the persons will be permanently deleted.
         * @summary Delete multiple persons in bulk
         * @param {PersonsApiDeletePersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deletePersons(requestParameters: PersonsApiDeletePersonsRequest, ): Promise<DeletePersonsResponse200> {
            return localVarFp.deletePersons(requestParameters.ids, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get details of a person
         * @param {PersonsApiGetPersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPerson(requestParameters: PersonsApiGetPersonRequest, ): Promise<GetPersonResponse200> {
            return localVarFp.getPerson(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists activities associated with a person.
         * @summary List activities associated with a person
         * @param {PersonsApiGetPersonActivitiesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonActivities(requestParameters: PersonsApiGetPersonActivitiesRequest, ): Promise<GetAssociatedActivitiesResponse200> {
            return localVarFp.getPersonActivities(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.done, requestParameters.exclude, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists deals associated with a person.
         * @summary List deals associated with a person
         * @param {PersonsApiGetPersonDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonDeals(requestParameters: PersonsApiGetPersonDealsRequest, ): Promise<GetAssociatedDealsResponse200> {
            return localVarFp.getPersonDeals(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.status, requestParameters.sort, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists files associated with a person.
         * @summary List files attached to a person
         * @param {PersonsApiGetPersonFilesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonFiles(requestParameters: PersonsApiGetPersonFilesRequest, ): Promise<GetAssociatedFilesResponse200> {
            return localVarFp.getPersonFiles(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists the followers of a person.
         * @summary List followers of a person
         * @param {PersonsApiGetPersonFollowersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonFollowers(requestParameters: PersonsApiGetPersonFollowersRequest, ): Promise<GetAssociatedFollowersResponse200> {
            return localVarFp.getPersonFollowers(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists mail messages associated with a person.
         * @summary List mail messages associated with a person
         * @param {PersonsApiGetPersonMailMessagesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonMailMessages(requestParameters: PersonsApiGetPersonMailMessagesRequest, ): Promise<GetAssociatedMailMessagesResponse200> {
            return localVarFp.getPersonMailMessages(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists products associated with a person.
         * @summary List products associated with a person
         * @param {PersonsApiGetPersonProductsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonProducts(requestParameters: PersonsApiGetPersonProductsRequest, ): Promise<GetPersonProductsResponse200> {
            return localVarFp.getPersonProducts(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint\'s response will also include updates for the `marketing_status` field.
         * @summary List updates about a person
         * @param {PersonsApiGetPersonUpdatesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonUpdates(requestParameters: PersonsApiGetPersonUpdatesRequest, ): Promise<GetAssociatedPersonUpdatesResponse200> {
            return localVarFp.getPersonUpdates(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.all_changes, requestParameters.items, ).then((request) => request(axios, basePath));
        },
        /**
         * List users permitted to access a person.
         * @summary List permitted users
         * @param {PersonsApiGetPersonUsersRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonUsers(requestParameters: PersonsApiGetPersonUsersRequest, ): Promise<ListPermittedUsersResponse2001> {
            return localVarFp.getPersonUsers(requestParameters.id, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all persons.
         * @summary Get all persons
         * @param {PersonsApiGetPersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersons(requestParameters: PersonsApiGetPersonsRequest = {}, ): Promise<GetPersonsResponse200> {
            return localVarFp.getPersons(requestParameters.user_id, requestParameters.filter_id, requestParameters.first_char, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(axios, basePath));
        },
        /**
         * Returns all persons. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
         * @summary Get all persons (BETA)
         * @param {PersonsApiGetPersonsCollectionRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersonsCollection(requestParameters: PersonsApiGetPersonsCollectionRequest = {}, ): Promise<GetPersonsCollection200Response> {
            return localVarFp.getPersonsCollection(requestParameters.cursor, requestParameters.limit, requestParameters.since, requestParameters.until, requestParameters.owner_id, requestParameters.first_char, ).then((request) => request(axios, basePath));
        },
        /**
         * Merges a person with another person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-persons\" target=\"_blank\" rel=\"noopener noreferrer\">merging two persons</a>.
         * @summary Merge two persons
         * @param {PersonsApiMergePersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        mergePersons(requestParameters: PersonsApiMergePersonsRequest, ): Promise<MergePersonsResponse200> {
            return localVarFp.mergePersons(requestParameters.id, requestParameters.MergePersonsRequest, ).then((request) => request(axios, basePath));
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {PersonsApiSearchPersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchPersons(requestParameters: PersonsApiSearchPersonsRequest, ): Promise<SearchPersonsResponse200> {
            return localVarFp.searchPersons(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.organization_id, requestParameters.include_fields, requestParameters.start, requestParameters.limit, ).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-person\" target=\"_blank\" rel=\"noopener noreferrer\">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Update a person
         * @param {PersonsApiUpdatePersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updatePerson(requestParameters: PersonsApiUpdatePersonRequest, ): Promise<UpdatePersonResponse200> {
            return localVarFp.updatePerson(requestParameters.id, requestParameters.UpdatePersonRequest, ).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addPerson operation in PersonsApi.
 * @export
 * @interface PersonsApiAddPersonRequest
 */
export interface PersonsApiAddPersonRequest {
    /**
     * 
     * @type {AddPersonRequest}
     * @memberof PersonsApiAddPerson
     */
    readonly AddPersonRequest?: AddPersonRequest
}

/**
 * Request parameters for addPersonFollower operation in PersonsApi.
 * @export
 * @interface PersonsApiAddPersonFollowerRequest
 */
export interface PersonsApiAddPersonFollowerRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiAddPersonFollower
     */
    readonly id: number

    /**
     * 
     * @type {AddPersonFollowerRequest}
     * @memberof PersonsApiAddPersonFollower
     */
    readonly AddPersonFollowerRequest?: AddPersonFollowerRequest
}

/**
 * Request parameters for addPersonPicture operation in PersonsApi.
 * @export
 * @interface PersonsApiAddPersonPictureRequest
 */
export interface PersonsApiAddPersonPictureRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiAddPersonPicture
     */
    readonly id: number

    /**
     * One image supplied in the multipart/form-data encoding
     * @type {File}
     * @memberof PersonsApiAddPersonPicture
     */
    readonly file: File

    /**
     * X coordinate to where start cropping form (in pixels)
     * @type {number}
     * @memberof PersonsApiAddPersonPicture
     */
    readonly crop_x?: number

    /**
     * Y coordinate to where start cropping form (in pixels)
     * @type {number}
     * @memberof PersonsApiAddPersonPicture
     */
    readonly crop_y?: number

    /**
     * The width of the cropping area (in pixels)
     * @type {number}
     * @memberof PersonsApiAddPersonPicture
     */
    readonly crop_width?: number

    /**
     * The height of the cropping area (in pixels)
     * @type {number}
     * @memberof PersonsApiAddPersonPicture
     */
    readonly crop_height?: number
}

/**
 * Request parameters for deletePerson operation in PersonsApi.
 * @export
 * @interface PersonsApiDeletePersonRequest
 */
export interface PersonsApiDeletePersonRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiDeletePerson
     */
    readonly id: number
}

/**
 * Request parameters for deletePersonFollower operation in PersonsApi.
 * @export
 * @interface PersonsApiDeletePersonFollowerRequest
 */
export interface PersonsApiDeletePersonFollowerRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiDeletePersonFollower
     */
    readonly id: number

    /**
     * The ID of the follower
     * @type {number}
     * @memberof PersonsApiDeletePersonFollower
     */
    readonly follower_id: number
}

/**
 * Request parameters for deletePersonPicture operation in PersonsApi.
 * @export
 * @interface PersonsApiDeletePersonPictureRequest
 */
export interface PersonsApiDeletePersonPictureRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiDeletePersonPicture
     */
    readonly id: number
}

/**
 * Request parameters for deletePersons operation in PersonsApi.
 * @export
 * @interface PersonsApiDeletePersonsRequest
 */
export interface PersonsApiDeletePersonsRequest {
    /**
     * The comma-separated IDs that will be deleted
     * @type {string}
     * @memberof PersonsApiDeletePersons
     */
    readonly ids: string
}

/**
 * Request parameters for getPerson operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonRequest
 */
export interface PersonsApiGetPersonRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPerson
     */
    readonly id: number
}

/**
 * Request parameters for getPersonActivities operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonActivitiesRequest
 */
export interface PersonsApiGetPersonActivitiesRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonActivities
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersonActivities
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersonActivities
     */
    readonly limit?: number

    /**
     * Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
     * @type {0 | 1}
     * @memberof PersonsApiGetPersonActivities
     */
    readonly done?: 0 | 1

    /**
     * A comma-separated string of activity IDs to exclude from result
     * @type {string}
     * @memberof PersonsApiGetPersonActivities
     */
    readonly exclude?: string
}

/**
 * Request parameters for getPersonDeals operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonDealsRequest
 */
export interface PersonsApiGetPersonDealsRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonDeals
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersonDeals
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersonDeals
     */
    readonly limit?: number

    /**
     * Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included.
     * @type {'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'}
     * @memberof PersonsApiGetPersonDeals
     */
    readonly status?: 'open' | 'won' | 'lost' | 'deleted' | 'all_not_deleted'

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @type {string}
     * @memberof PersonsApiGetPersonDeals
     */
    readonly sort?: string
}

/**
 * Request parameters for getPersonFiles operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonFilesRequest
 */
export interface PersonsApiGetPersonFilesRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonFiles
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersonFiles
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersonFiles
     */
    readonly limit?: number

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @type {string}
     * @memberof PersonsApiGetPersonFiles
     */
    readonly sort?: string
}

/**
 * Request parameters for getPersonFollowers operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonFollowersRequest
 */
export interface PersonsApiGetPersonFollowersRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonFollowers
     */
    readonly id: number
}

/**
 * Request parameters for getPersonMailMessages operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonMailMessagesRequest
 */
export interface PersonsApiGetPersonMailMessagesRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonMailMessages
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersonMailMessages
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersonMailMessages
     */
    readonly limit?: number
}

/**
 * Request parameters for getPersonProducts operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonProductsRequest
 */
export interface PersonsApiGetPersonProductsRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonProducts
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersonProducts
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersonProducts
     */
    readonly limit?: number
}

/**
 * Request parameters for getPersonUpdates operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonUpdatesRequest
 */
export interface PersonsApiGetPersonUpdatesRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonUpdates
     */
    readonly id: number

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersonUpdates
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersonUpdates
     */
    readonly limit?: number

    /**
     * Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
     * @type {string}
     * @memberof PersonsApiGetPersonUpdates
     */
    readonly all_changes?: string

    /**
     * A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change).
     * @type {string}
     * @memberof PersonsApiGetPersonUpdates
     */
    readonly items?: string
}

/**
 * Request parameters for getPersonUsers operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonUsersRequest
 */
export interface PersonsApiGetPersonUsersRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiGetPersonUsers
     */
    readonly id: number
}

/**
 * Request parameters for getPersons operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonsRequest
 */
export interface PersonsApiGetPersonsRequest {
    /**
     * If supplied, only persons owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly user_id?: number

    /**
     * The ID of the filter to use
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly filter_id?: number

    /**
     * If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive)
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly first_char?: string

    /**
     * Pagination start
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly limit?: number

    /**
     * The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly sort?: string
}

/**
 * Request parameters for getPersonsCollection operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonsCollectionRequest
 */
export interface PersonsApiGetPersonsCollectionRequest {
    /**
     * For pagination, the marker (an opaque string value) representing the first item on the next page
     * @type {string}
     * @memberof PersonsApiGetPersonsCollection
     */
    readonly cursor?: string

    /**
     * For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
     * @type {number}
     * @memberof PersonsApiGetPersonsCollection
     */
    readonly limit?: number

    /**
     * The time boundary that points to the start of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
     * @type {string}
     * @memberof PersonsApiGetPersonsCollection
     */
    readonly since?: string

    /**
     * The time boundary that points to the end of the range of data. Datetime in ISO 8601 format. E.g. 2022-11-01 08:55:59. Operates on the &#x60;update_time&#x60; field.
     * @type {string}
     * @memberof PersonsApiGetPersonsCollection
     */
    readonly until?: string

    /**
     * If supplied, only persons owned by the given user will be returned
     * @type {number}
     * @memberof PersonsApiGetPersonsCollection
     */
    readonly owner_id?: number

    /**
     * If supplied, only persons whose name starts with the specified letter will be returned (case-insensitive)
     * @type {string}
     * @memberof PersonsApiGetPersonsCollection
     */
    readonly first_char?: string
}

/**
 * Request parameters for mergePersons operation in PersonsApi.
 * @export
 * @interface PersonsApiMergePersonsRequest
 */
export interface PersonsApiMergePersonsRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiMergePersons
     */
    readonly id: number

    /**
     * 
     * @type {MergePersonsRequest}
     * @memberof PersonsApiMergePersons
     */
    readonly MergePersonsRequest?: MergePersonsRequest
}

/**
 * Request parameters for searchPersons operation in PersonsApi.
 * @export
 * @interface PersonsApiSearchPersonsRequest
 */
export interface PersonsApiSearchPersonsRequest {
    /**
     * The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
     * @type {string}
     * @memberof PersonsApiSearchPersons
     */
    readonly term: string

    /**
     * A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
     * @type {'custom_fields' | 'email' | 'notes' | 'phone' | 'name'}
     * @memberof PersonsApiSearchPersons
     */
    readonly fields?: 'custom_fields' | 'email' | 'notes' | 'phone' | 'name'

    /**
     * When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @type {boolean}
     * @memberof PersonsApiSearchPersons
     */
    readonly exact_match?: boolean

    /**
     * Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
     * @type {number}
     * @memberof PersonsApiSearchPersons
     */
    readonly organization_id?: number

    /**
     * Supports including optional fields in the results which are not provided by default
     * @type {'person.picture'}
     * @memberof PersonsApiSearchPersons
     */
    readonly include_fields?: 'person.picture'

    /**
     * Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @type {number}
     * @memberof PersonsApiSearchPersons
     */
    readonly start?: number

    /**
     * Items shown per page
     * @type {number}
     * @memberof PersonsApiSearchPersons
     */
    readonly limit?: number
}

/**
 * Request parameters for updatePerson operation in PersonsApi.
 * @export
 * @interface PersonsApiUpdatePersonRequest
 */
export interface PersonsApiUpdatePersonRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof PersonsApiUpdatePerson
     */
    readonly id: number

    /**
     * 
     * @type {UpdatePersonRequest}
     * @memberof PersonsApiUpdatePerson
     */
    readonly UpdatePersonRequest?: UpdatePersonRequest
}

/**
 * PersonsApi - object-oriented interface
 * @export
 * @class PersonsApi
 * @extends {BaseAPI}
 */
export class PersonsApi extends BaseAPI {
    /**
     * Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
     * @summary Add a person
     * @param {PersonsApiAddPersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public addPerson(requestParameters: PersonsApiAddPersonRequest = {}, ) {
        return PersonsApiFp(this.configuration).addPerson(requestParameters.AddPersonRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a follower to a person.
     * @summary Add a follower to a person
     * @param {PersonsApiAddPersonFollowerRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public addPersonFollower(requestParameters: PersonsApiAddPersonFollowerRequest, ) {
        return PersonsApiFp(this.configuration).addPersonFollower(requestParameters.id, requestParameters.AddPersonFollowerRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
     * @summary Add person picture
     * @param {PersonsApiAddPersonPictureRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public addPersonPicture(requestParameters: PersonsApiAddPersonPictureRequest, ) {
        return PersonsApiFp(this.configuration).addPersonPicture(requestParameters.id, requestParameters.file, requestParameters.crop_x, requestParameters.crop_y, requestParameters.crop_width, requestParameters.crop_height, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a person as deleted. After 30 days, the person will be permanently deleted.
     * @summary Delete a person
     * @param {PersonsApiDeletePersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public deletePerson(requestParameters: PersonsApiDeletePersonRequest, ) {
        return PersonsApiFp(this.configuration).deletePerson(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a follower from a person.
     * @summary Delete a follower from a person
     * @param {PersonsApiDeletePersonFollowerRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public deletePersonFollower(requestParameters: PersonsApiDeletePersonFollowerRequest, ) {
        return PersonsApiFp(this.configuration).deletePersonFollower(requestParameters.id, requestParameters.follower_id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a personâ€™s picture.
     * @summary Delete person picture
     * @param {PersonsApiDeletePersonPictureRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public deletePersonPicture(requestParameters: PersonsApiDeletePersonPictureRequest, ) {
        return PersonsApiFp(this.configuration).deletePersonPicture(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks multiple persons as deleted. After 30 days, the persons will be permanently deleted.
     * @summary Delete multiple persons in bulk
     * @param {PersonsApiDeletePersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public deletePersons(requestParameters: PersonsApiDeletePersonsRequest, ) {
        return PersonsApiFp(this.configuration).deletePersons(requestParameters.ids, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary Get details of a person
     * @param {PersonsApiGetPersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPerson(requestParameters: PersonsApiGetPersonRequest, ) {
        return PersonsApiFp(this.configuration).getPerson(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists activities associated with a person.
     * @summary List activities associated with a person
     * @param {PersonsApiGetPersonActivitiesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonActivities(requestParameters: PersonsApiGetPersonActivitiesRequest, ) {
        return PersonsApiFp(this.configuration).getPersonActivities(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.done, requestParameters.exclude, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists deals associated with a person.
     * @summary List deals associated with a person
     * @param {PersonsApiGetPersonDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonDeals(requestParameters: PersonsApiGetPersonDealsRequest, ) {
        return PersonsApiFp(this.configuration).getPersonDeals(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.status, requestParameters.sort, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists files associated with a person.
     * @summary List files attached to a person
     * @param {PersonsApiGetPersonFilesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonFiles(requestParameters: PersonsApiGetPersonFilesRequest, ) {
        return PersonsApiFp(this.configuration).getPersonFiles(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the followers of a person.
     * @summary List followers of a person
     * @param {PersonsApiGetPersonFollowersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonFollowers(requestParameters: PersonsApiGetPersonFollowersRequest, ) {
        return PersonsApiFp(this.configuration).getPersonFollowers(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists mail messages associated with a person.
     * @summary List mail messages associated with a person
     * @param {PersonsApiGetPersonMailMessagesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonMailMessages(requestParameters: PersonsApiGetPersonMailMessagesRequest, ) {
        return PersonsApiFp(this.configuration).getPersonMailMessages(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists products associated with a person.
     * @summary List products associated with a person
     * @param {PersonsApiGetPersonProductsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonProducts(requestParameters: PersonsApiGetPersonProductsRequest, ) {
        return PersonsApiFp(this.configuration).getPersonProducts(requestParameters.id, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint\'s response will also include updates for the `marketing_status` field.
     * @summary List updates about a person
     * @param {PersonsApiGetPersonUpdatesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonUpdates(requestParameters: PersonsApiGetPersonUpdatesRequest, ) {
        return PersonsApiFp(this.configuration).getPersonUpdates(requestParameters.id, requestParameters.start, requestParameters.limit, requestParameters.all_changes, requestParameters.items, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List users permitted to access a person.
     * @summary List permitted users
     * @param {PersonsApiGetPersonUsersRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonUsers(requestParameters: PersonsApiGetPersonUsersRequest, ) {
        return PersonsApiFp(this.configuration).getPersonUsers(requestParameters.id, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all persons.
     * @summary Get all persons
     * @param {PersonsApiGetPersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersons(requestParameters: PersonsApiGetPersonsRequest = {}, ) {
        return PersonsApiFp(this.configuration).getPersons(requestParameters.user_id, requestParameters.filter_id, requestParameters.first_char, requestParameters.start, requestParameters.limit, requestParameters.sort, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all persons. This is a cursor-paginated endpoint that is currently in BETA. For more information, please refer to our documentation on <a href=\"https://pipedrive.readme.io/docs/core-api-concepts-pagination\" target=\"_blank\" rel=\"noopener noreferrer\">pagination</a>. Please note that only global admins (those with global permissions) can access these endpoints. Users with regular permissions will receive a 403 response. Read more about global permissions <a href=\"https://support.pipedrive.com/en/article/global-user-management\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.
     * @summary Get all persons (BETA)
     * @param {PersonsApiGetPersonsCollectionRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonsCollection(requestParameters: PersonsApiGetPersonsCollectionRequest = {}, ) {
        return PersonsApiFp(this.configuration).getPersonsCollection(requestParameters.cursor, requestParameters.limit, requestParameters.since, requestParameters.until, requestParameters.owner_id, requestParameters.first_char, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Merges a person with another person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-persons\" target=\"_blank\" rel=\"noopener noreferrer\">merging two persons</a>.
     * @summary Merge two persons
     * @param {PersonsApiMergePersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public mergePersons(requestParameters: PersonsApiMergePersonsRequest, ) {
        return PersonsApiFp(this.configuration).mergePersons(requestParameters.id, requestParameters.MergePersonsRequest, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
     * @summary Search persons
     * @param {PersonsApiSearchPersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public searchPersons(requestParameters: PersonsApiSearchPersonsRequest, ) {
        return PersonsApiFp(this.configuration).searchPersons(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.organization_id, requestParameters.include_fields, requestParameters.start, requestParameters.limit, ).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of a person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-person\" target=\"_blank\" rel=\"noopener noreferrer\">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
     * @summary Update a person
     * @param {PersonsApiUpdatePersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public updatePerson(requestParameters: PersonsApiUpdatePersonRequest, ) {
        return PersonsApiFp(this.configuration).updatePerson(requestParameters.id, requestParameters.UpdatePersonRequest, ).then((request) => request(this.axios, this.basePath));
    }
}
